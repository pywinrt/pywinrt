// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Automation.Peers.h"

namespace py::cpp::Windows::UI::Xaml::Automation::Peers
{
    // ----- AppBarAutomationPeer class --------------------

    struct PyWinrtAppBarAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeerT<PyWinrtAppBarAutomationPeer>
    {
        PyWinrtAppBarAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::AppBar owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeerT<PyWinrtAppBarAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtAppBarAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_AppBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBar>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtAppBarAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarAutomationPeer_Close(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_SetVisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"SetVisualState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_WaitForInputIdle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"WaitForInputIdle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_InteractionState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"InteractionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_IsModal(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"IsModal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_IsTopmost(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"IsTopmost");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_Maximizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Maximizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_Minimizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Minimizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_VisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"VisualState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>().VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarAutomationPeer[] = {
        { "close", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Close), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_SetVisualState), METH_VARARGS, nullptr },
        { "toggle", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "toggle_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { "interaction_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(AppBarAutomationPeer_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(AppBarAutomationPeer_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(AppBarAutomationPeer_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(AppBarAutomationPeer_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AppBarAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AppBarAutomationPeer};

    static PyGetSetDef getset_AppBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AppBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AppBarAutomationPeer_Static
    };

    // ----- AppBarButtonAutomationPeer class --------------------

    struct PyWinrtAppBarButtonAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeerT<PyWinrtAppBarButtonAutomationPeer>
    {
        PyWinrtAppBarButtonAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::AppBarButton owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeerT<PyWinrtAppBarButtonAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtAppBarButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_AppBarButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBarButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtAppBarButtonAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButtonAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>().Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarButtonAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>().Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarButtonAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>().ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(AppBarButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(AppBarButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBarButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(AppBarButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AppBarButtonAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AppBarButtonAutomationPeer};

    static PyGetSetDef getset_AppBarButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AppBarButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarButtonAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AppBarButtonAutomationPeer_Static
    };

    // ----- AppBarToggleButtonAutomationPeer class --------------------

    struct PyWinrtAppBarToggleButtonAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeerT<PyWinrtAppBarToggleButtonAutomationPeer>
    {
        PyWinrtAppBarToggleButtonAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::AppBarToggleButton owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeerT<PyWinrtAppBarToggleButtonAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtAppBarToggleButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_AppBarToggleButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtAppBarToggleButtonAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarToggleButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AppBarToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButtonAutomationPeer[] = {
        { "_assign_array_", _assign_array_AppBarToggleButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButtonAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarToggleButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AppBarToggleButtonAutomationPeer};

    static PyGetSetDef getset_AppBarToggleButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AppBarToggleButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarToggleButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarToggleButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarToggleButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButtonAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarToggleButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AppBarToggleButtonAutomationPeer_Static
    };

    // ----- AutoSuggestBoxAutomationPeer class --------------------

    static PyObject* _new_AutoSuggestBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AutoSuggestBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutoSuggestBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoSuggestBoxAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutoSuggestBoxAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoSuggestBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoSuggestBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoSuggestBoxAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(AutoSuggestBoxAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutoSuggestBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoSuggestBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoSuggestBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AutoSuggestBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoSuggestBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoSuggestBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoSuggestBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoSuggestBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AutoSuggestBoxAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutoSuggestBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoSuggestBoxAutomationPeer};

    // ----- AutomationPeer class --------------------

    struct PyWinrtAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerT<PyWinrtAutomationPeer>
    {

        static void toggle_reference(PyWinrtAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_AutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_AutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationPeer_GenerateRawElementProviderRuntimeId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GenerateRawElementProviderRuntimeId", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer::GenerateRawElementProviderRuntimeId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAcceleratorKey(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAcceleratorKey", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetAcceleratorKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAccessKey(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAccessKey", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetAccessKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAnnotations(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAnnotations", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetAnnotations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationControlType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationControlType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetAutomationControlType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationId(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationId", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetAutomationId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetBoundingRectangle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetBoundingRectangle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetBoundingRectangle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetChildren(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetChildren", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetChildren());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClassName(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClassName", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetClassName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClickablePoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClickablePoint", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetClickablePoint());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetControlledPeers(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetControlledPeers", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetControlledPeers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetCulture(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetCulture", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetCulture());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetElementFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetElementFromPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetElementFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFocusedElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFocusedElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetFocusedElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFullDescription(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFullDescription", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetFullDescription());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHeadingLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHeadingLevel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetHeadingLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHelpText(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHelpText", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetHelpText());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemStatus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemStatus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetItemStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetItemType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLabeledBy(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLabeledBy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetLabeledBy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLandmarkType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLandmarkType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetLandmarkType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLevel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLiveSetting(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLiveSetting", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetLiveSetting());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedControlType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedControlType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetLocalizedControlType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedLandmarkType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedLandmarkType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetLocalizedLandmarkType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetName(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetName", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetOrientation(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetOrientation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetOrientation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetParent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetParent", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetParent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPattern(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPattern", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::PatternInterface>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetPattern(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPeerFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPeerFromPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetPeerFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPositionInSet(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPositionInSet", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetPositionInSet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetSizeOfSet(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetSizeOfSet", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().GetSizeOfSet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_HasKeyboardFocus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"HasKeyboardFocus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().HasKeyboardFocus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_InvalidatePeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"InvalidatePeer", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().InvalidatePeer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsContentElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsContentElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsContentElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsControlElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsControlElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsControlElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDataValidForForm(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDataValidForForm", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsDataValidForForm());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDialog(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDialog", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsDialog());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsEnabled(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsEnabled", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsKeyboardFocusable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsKeyboardFocusable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsKeyboardFocusable());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsOffscreen(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsOffscreen", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsOffscreen());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPassword(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPassword", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsPassword());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPeripheral(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPeripheral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsPeripheral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsRequiredForForm(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsRequiredForForm", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().IsRequiredForForm());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ListenerExists(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"ListenerExists", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationEvents>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer::ListenerExists(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_Navigate(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"Navigate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNavigationDirection>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().Navigate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseAutomationEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseAutomationEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationEvents>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().RaiseAutomationEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseNotificationEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseNotificationEvent", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNotificationKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNotificationProcessing>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().RaiseNotificationEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaisePropertyChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaisePropertyChangedEvent", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().RaisePropertyChangedEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseStructureChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseStructureChangedEvent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationStructureChangeType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().RaiseStructureChangedEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseTextEditTextChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseTextEditTextChangedEvent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationTextEditChangeType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().RaiseTextEditTextChangedEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetFocus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"SetFocus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().SetFocus();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetParent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"SetParent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().SetParent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ShowContextMenu(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"ShowContextMenu", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().ShowContextMenu();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_get_EventsSource(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"EventsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().EventsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeer_put_EventsSource(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"EventsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>().EventsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationPeer[] = {
        { "get_accelerator_key", reinterpret_cast<PyCFunction>(AutomationPeer_GetAcceleratorKey), METH_VARARGS, nullptr },
        { "get_access_key", reinterpret_cast<PyCFunction>(AutomationPeer_GetAccessKey), METH_VARARGS, nullptr },
        { "get_annotations", reinterpret_cast<PyCFunction>(AutomationPeer_GetAnnotations), METH_VARARGS, nullptr },
        { "get_automation_control_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationControlType), METH_VARARGS, nullptr },
        { "get_automation_id", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationId), METH_VARARGS, nullptr },
        { "get_bounding_rectangle", reinterpret_cast<PyCFunction>(AutomationPeer_GetBoundingRectangle), METH_VARARGS, nullptr },
        { "get_children", reinterpret_cast<PyCFunction>(AutomationPeer_GetChildren), METH_VARARGS, nullptr },
        { "get_class_name", reinterpret_cast<PyCFunction>(AutomationPeer_GetClassName), METH_VARARGS, nullptr },
        { "get_clickable_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetClickablePoint), METH_VARARGS, nullptr },
        { "get_controlled_peers", reinterpret_cast<PyCFunction>(AutomationPeer_GetControlledPeers), METH_VARARGS, nullptr },
        { "get_culture", reinterpret_cast<PyCFunction>(AutomationPeer_GetCulture), METH_VARARGS, nullptr },
        { "get_element_from_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetElementFromPoint), METH_VARARGS, nullptr },
        { "get_focused_element", reinterpret_cast<PyCFunction>(AutomationPeer_GetFocusedElement), METH_VARARGS, nullptr },
        { "get_full_description", reinterpret_cast<PyCFunction>(AutomationPeer_GetFullDescription), METH_VARARGS, nullptr },
        { "get_heading_level", reinterpret_cast<PyCFunction>(AutomationPeer_GetHeadingLevel), METH_VARARGS, nullptr },
        { "get_help_text", reinterpret_cast<PyCFunction>(AutomationPeer_GetHelpText), METH_VARARGS, nullptr },
        { "get_item_status", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemStatus), METH_VARARGS, nullptr },
        { "get_item_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemType), METH_VARARGS, nullptr },
        { "get_labeled_by", reinterpret_cast<PyCFunction>(AutomationPeer_GetLabeledBy), METH_VARARGS, nullptr },
        { "get_landmark_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLandmarkType), METH_VARARGS, nullptr },
        { "get_level", reinterpret_cast<PyCFunction>(AutomationPeer_GetLevel), METH_VARARGS, nullptr },
        { "get_live_setting", reinterpret_cast<PyCFunction>(AutomationPeer_GetLiveSetting), METH_VARARGS, nullptr },
        { "get_localized_control_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedControlType), METH_VARARGS, nullptr },
        { "get_localized_landmark_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedLandmarkType), METH_VARARGS, nullptr },
        { "get_name", reinterpret_cast<PyCFunction>(AutomationPeer_GetName), METH_VARARGS, nullptr },
        { "get_orientation", reinterpret_cast<PyCFunction>(AutomationPeer_GetOrientation), METH_VARARGS, nullptr },
        { "get_parent", reinterpret_cast<PyCFunction>(AutomationPeer_GetParent), METH_VARARGS, nullptr },
        { "get_pattern", reinterpret_cast<PyCFunction>(AutomationPeer_GetPattern), METH_VARARGS, nullptr },
        { "get_peer_from_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetPeerFromPoint), METH_VARARGS, nullptr },
        { "get_position_in_set", reinterpret_cast<PyCFunction>(AutomationPeer_GetPositionInSet), METH_VARARGS, nullptr },
        { "get_size_of_set", reinterpret_cast<PyCFunction>(AutomationPeer_GetSizeOfSet), METH_VARARGS, nullptr },
        { "has_keyboard_focus", reinterpret_cast<PyCFunction>(AutomationPeer_HasKeyboardFocus), METH_VARARGS, nullptr },
        { "invalidate_peer", reinterpret_cast<PyCFunction>(AutomationPeer_InvalidatePeer), METH_VARARGS, nullptr },
        { "is_content_element", reinterpret_cast<PyCFunction>(AutomationPeer_IsContentElement), METH_VARARGS, nullptr },
        { "is_control_element", reinterpret_cast<PyCFunction>(AutomationPeer_IsControlElement), METH_VARARGS, nullptr },
        { "is_data_valid_for_form", reinterpret_cast<PyCFunction>(AutomationPeer_IsDataValidForForm), METH_VARARGS, nullptr },
        { "is_dialog", reinterpret_cast<PyCFunction>(AutomationPeer_IsDialog), METH_VARARGS, nullptr },
        { "is_enabled", reinterpret_cast<PyCFunction>(AutomationPeer_IsEnabled), METH_VARARGS, nullptr },
        { "is_keyboard_focusable", reinterpret_cast<PyCFunction>(AutomationPeer_IsKeyboardFocusable), METH_VARARGS, nullptr },
        { "is_offscreen", reinterpret_cast<PyCFunction>(AutomationPeer_IsOffscreen), METH_VARARGS, nullptr },
        { "is_password", reinterpret_cast<PyCFunction>(AutomationPeer_IsPassword), METH_VARARGS, nullptr },
        { "is_peripheral", reinterpret_cast<PyCFunction>(AutomationPeer_IsPeripheral), METH_VARARGS, nullptr },
        { "is_required_for_form", reinterpret_cast<PyCFunction>(AutomationPeer_IsRequiredForForm), METH_VARARGS, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(AutomationPeer_Navigate), METH_VARARGS, nullptr },
        { "raise_automation_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseAutomationEvent), METH_VARARGS, nullptr },
        { "raise_notification_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseNotificationEvent), METH_VARARGS, nullptr },
        { "raise_property_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaisePropertyChangedEvent), METH_VARARGS, nullptr },
        { "raise_structure_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseStructureChangedEvent), METH_VARARGS, nullptr },
        { "raise_text_edit_text_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseTextEditTextChangedEvent), METH_VARARGS, nullptr },
        { "set_focus", reinterpret_cast<PyCFunction>(AutomationPeer_SetFocus), METH_VARARGS, nullptr },
        { "set_parent", reinterpret_cast<PyCFunction>(AutomationPeer_SetParent), METH_VARARGS, nullptr },
        { "show_context_menu", reinterpret_cast<PyCFunction>(AutomationPeer_ShowContextMenu), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationPeer[] = {
        { "events_source", reinterpret_cast<getter>(AutomationPeer_get_EventsSource), reinterpret_cast<setter>(AutomationPeer_put_EventsSource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AutomationPeer};

    static PyGetSetDef getset_AutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AutomationPeer_Static[] = {
        { "generate_raw_element_provider_runtime_id", reinterpret_cast<PyCFunction>(AutomationPeer_GenerateRawElementProviderRuntimeId), METH_VARARGS, nullptr },
        { "listener_exists", reinterpret_cast<PyCFunction>(AutomationPeer_ListenerExists), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AutomationPeer_Static
    };

    // ----- AutomationPeerAnnotation class --------------------

    static PyObject* _new_AutomationPeerAnnotation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutomationPeerAnnotation(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationPeerAnnotation_get_Type(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeerAnnotation_put_Type(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_Peer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Peer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Peer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeerAnnotation_put_Peer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Peer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(arg);

            self->obj.Peer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_PeerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"PeerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation::PeerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_TypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"TypeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation::TypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationPeerAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationPeerAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationPeerAnnotation[] = {
        { "_assign_array_", _assign_array_AutomationPeerAnnotation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationPeerAnnotation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationPeerAnnotation[] = {
        { "type", reinterpret_cast<getter>(AutomationPeerAnnotation_get_Type), reinterpret_cast<setter>(AutomationPeerAnnotation_put_Type), nullptr, nullptr },
        { "peer", reinterpret_cast<getter>(AutomationPeerAnnotation_get_Peer), reinterpret_cast<setter>(AutomationPeerAnnotation_put_Peer), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationPeerAnnotation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationPeerAnnotation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationPeerAnnotation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationPeerAnnotation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationPeerAnnotation) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeerAnnotation = {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutomationPeerAnnotation",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationPeerAnnotation};

    static PyGetSetDef getset_AutomationPeerAnnotation_Static[] = {
        { "peer_property", reinterpret_cast<getter>(AutomationPeerAnnotation_get_PeerProperty), nullptr, nullptr, nullptr },
        { "type_property", reinterpret_cast<getter>(AutomationPeerAnnotation_get_TypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AutomationPeerAnnotation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AutomationPeerAnnotation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationPeerAnnotation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationPeerAnnotation_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeerAnnotation_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutomationPeerAnnotation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationPeerAnnotation_Static
    };

    // ----- ButtonAutomationPeer class --------------------

    struct PyWinrtButtonAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeerT<PyWinrtButtonAutomationPeer>
    {
        PyWinrtButtonAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Button owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeerT<PyWinrtButtonAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Button>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtButtonAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ButtonAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer>().Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(ButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ButtonAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ButtonAutomationPeer};

    static PyGetSetDef getset_ButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ButtonAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ButtonAutomationPeer_Static
    };

    // ----- ButtonBaseAutomationPeer class --------------------

    struct PyWinrtButtonBaseAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeerT<PyWinrtButtonBaseAutomationPeer>
    {

        static void toggle_reference(PyWinrtButtonBaseAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ButtonBaseAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ButtonBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ButtonBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonBaseAutomationPeer[] = {
        { "_assign_array_", _assign_array_ButtonBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonBaseAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ButtonBaseAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonBaseAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ButtonBaseAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ButtonBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ButtonBaseAutomationPeer};

    static PyGetSetDef getset_ButtonBaseAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ButtonBaseAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ButtonBaseAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ButtonBaseAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ButtonBaseAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ButtonBaseAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ButtonBaseAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ButtonBaseAutomationPeer_Static
    };

    // ----- CalendarDatePickerAutomationPeer class --------------------

    struct PyWinrtCalendarDatePickerAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeerT<PyWinrtCalendarDatePickerAutomationPeer>
    {
        PyWinrtCalendarDatePickerAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::CalendarDatePicker owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeerT<PyWinrtCalendarDatePickerAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtCalendarDatePickerAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_CalendarDatePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CalendarDatePicker>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtCalendarDatePickerAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CalendarDatePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarDatePickerAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>().Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>().SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>().IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>().Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarDatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarDatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarDatePickerAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(CalendarDatePickerAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(CalendarDatePickerAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CalendarDatePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarDatePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarDatePickerAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(CalendarDatePickerAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(CalendarDatePickerAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarDatePickerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarDatePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarDatePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarDatePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarDatePickerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_CalendarDatePickerAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.CalendarDatePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CalendarDatePickerAutomationPeer};

    static PyGetSetDef getset_CalendarDatePickerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_CalendarDatePickerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CalendarDatePickerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CalendarDatePickerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CalendarDatePickerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_CalendarDatePickerAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.CalendarDatePickerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CalendarDatePickerAutomationPeer_Static
    };

    // ----- CaptureElementAutomationPeer class --------------------

    struct PyWinrtCaptureElementAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeerT<PyWinrtCaptureElementAutomationPeer>
    {
        PyWinrtCaptureElementAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::CaptureElement owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeerT<PyWinrtCaptureElementAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtCaptureElementAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_CaptureElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CaptureElement>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtCaptureElementAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CaptureElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CaptureElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CaptureElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CaptureElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_CaptureElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CaptureElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CaptureElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_CaptureElementAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CaptureElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CaptureElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CaptureElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CaptureElementAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_CaptureElementAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.CaptureElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CaptureElementAutomationPeer};

    static PyGetSetDef getset_CaptureElementAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_CaptureElementAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CaptureElementAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CaptureElementAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CaptureElementAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_CaptureElementAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.CaptureElementAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CaptureElementAutomationPeer_Static
    };

    // ----- CheckBoxAutomationPeer class --------------------

    struct PyWinrtCheckBoxAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeerT<PyWinrtCheckBoxAutomationPeer>
    {
        PyWinrtCheckBoxAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::CheckBox owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeerT<PyWinrtCheckBoxAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtCheckBoxAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_CheckBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CheckBox>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtCheckBoxAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CheckBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CheckBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CheckBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CheckBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_CheckBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CheckBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CheckBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_CheckBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CheckBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CheckBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CheckBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CheckBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_CheckBoxAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.CheckBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CheckBoxAutomationPeer};

    static PyGetSetDef getset_CheckBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_CheckBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CheckBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CheckBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CheckBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_CheckBoxAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.CheckBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CheckBoxAutomationPeer_Static
    };

    // ----- ColorPickerSliderAutomationPeer class --------------------

    struct PyWinrtColorPickerSliderAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeerT<PyWinrtColorPickerSliderAutomationPeer>
    {
        PyWinrtColorPickerSliderAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Primitives::ColorPickerSlider owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeerT<PyWinrtColorPickerSliderAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtColorPickerSliderAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ColorPickerSliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ColorPickerSlider>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtColorPickerSliderAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPickerSliderAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPickerSliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorPickerSliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPickerSliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorPickerSliderAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ColorPickerSliderAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPickerSliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPickerSliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPickerSliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPickerSliderAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ColorPickerSliderAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ColorPickerSliderAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorPickerSliderAutomationPeer};

    static PyGetSetDef getset_ColorPickerSliderAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ColorPickerSliderAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColorPickerSliderAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorPickerSliderAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorPickerSliderAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorPickerSliderAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ColorPickerSliderAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorPickerSliderAutomationPeer_Static
    };

    // ----- ColorSpectrumAutomationPeer class --------------------

    struct PyWinrtColorSpectrumAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeerT<PyWinrtColorSpectrumAutomationPeer>
    {
        PyWinrtColorSpectrumAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeerT<PyWinrtColorSpectrumAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtColorSpectrumAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ColorSpectrumAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtColorSpectrumAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrumAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrumAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorSpectrumAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrumAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorSpectrumAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ColorSpectrumAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrumAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrumAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrumAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrumAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrumAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ColorSpectrumAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorSpectrumAutomationPeer};

    static PyGetSetDef getset_ColorSpectrumAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ColorSpectrumAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColorSpectrumAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorSpectrumAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorSpectrumAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrumAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ColorSpectrumAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorSpectrumAutomationPeer_Static
    };

    // ----- ComboBoxAutomationPeer class --------------------

    struct PyWinrtComboBoxAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeerT<PyWinrtComboBoxAutomationPeer>
    {
        PyWinrtComboBoxAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ComboBox owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeerT<PyWinrtComboBoxAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtComboBoxAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ComboBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBox>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtComboBoxAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxAutomationPeer_Close(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_SetVisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"SetVisualState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_WaitForInputIdle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"WaitForInputIdle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_InteractionState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"InteractionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsModal(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsModal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsTopmost(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsTopmost");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Maximizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Maximizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Minimizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Minimizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_VisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"VisualState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>().VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxAutomationPeer[] = {
        { "close", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Close), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_SetVisualState), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ComboBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { "interaction_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ComboBoxAutomationPeer};

    static PyGetSetDef getset_ComboBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ComboBoxAutomationPeer_Static
    };

    // ----- ComboBoxItemAutomationPeer class --------------------

    struct PyWinrtComboBoxItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeerT<PyWinrtComboBoxItemAutomationPeer>
    {
        PyWinrtComboBoxItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ComboBoxItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeerT<PyWinrtComboBoxItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtComboBoxItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ComboBoxItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtComboBoxItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ComboBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ComboBoxItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ComboBoxItemAutomationPeer};

    static PyGetSetDef getset_ComboBoxItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ComboBoxItemAutomationPeer_Static
    };

    // ----- ComboBoxItemDataAutomationPeer class --------------------

    struct PyWinrtComboBoxItemDataAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeerT<PyWinrtComboBoxItemDataAutomationPeer>
    {
        PyWinrtComboBoxItemDataAutomationPeer(PyObject* py_obj, winrt::Windows::Foundation::IInspectable item, winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer parent) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeerT<PyWinrtComboBoxItemDataAutomationPeer>(item, parent) {}

        static void toggle_reference(PyWinrtComboBoxItemDataAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ComboBoxItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtComboBoxItemDataAutomationPeer>(self.get(), param0, param1);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>().ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ComboBoxItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ComboBoxItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItemDataAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ComboBoxItemDataAutomationPeer};

    static PyGetSetDef getset_ComboBoxItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItemDataAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ComboBoxItemDataAutomationPeer_Static
    };

    // ----- DatePickerAutomationPeer class --------------------

    struct PyWinrtDatePickerAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeerT<PyWinrtDatePickerAutomationPeer>
    {
        PyWinrtDatePickerAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::DatePicker owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeerT<PyWinrtDatePickerAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtDatePickerAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_DatePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DatePicker>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtDatePickerAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerAutomationPeer[] = {
        { "_assign_array_", _assign_array_DatePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_DatePickerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_DatePickerAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.DatePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DatePickerAutomationPeer};

    static PyGetSetDef getset_DatePickerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_DatePickerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DatePickerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DatePickerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DatePickerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_DatePickerAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.DatePickerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DatePickerAutomationPeer_Static
    };

    // ----- DatePickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_DatePickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_DatePickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DatePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_DatePickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_DatePickerFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_DatePickerFlyoutPresenterAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.DatePickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerFlyoutPresenterAutomationPeer};

    // ----- FlipViewAutomationPeer class --------------------

    struct PyWinrtFlipViewAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeerT<PyWinrtFlipViewAutomationPeer>
    {
        PyWinrtFlipViewAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::FlipView owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeerT<PyWinrtFlipViewAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtFlipViewAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_FlipViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlipView>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtFlipViewAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlipViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FlipViewAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlipViewAutomationPeer};

    static PyGetSetDef getset_FlipViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlipViewAutomationPeer_Static
    };

    // ----- FlipViewItemAutomationPeer class --------------------

    struct PyWinrtFlipViewItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeerT<PyWinrtFlipViewItemAutomationPeer>
    {
        PyWinrtFlipViewItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::FlipViewItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeerT<PyWinrtFlipViewItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtFlipViewItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_FlipViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlipViewItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtFlipViewItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlipViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlipViewItemAutomationPeer};

    static PyGetSetDef getset_FlipViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlipViewItemAutomationPeer_Static
    };

    // ----- FlipViewItemDataAutomationPeer class --------------------

    struct PyWinrtFlipViewItemDataAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeerT<PyWinrtFlipViewItemDataAutomationPeer>
    {
        PyWinrtFlipViewItemDataAutomationPeer(PyObject* py_obj, winrt::Windows::Foundation::IInspectable item, winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer parent) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeerT<PyWinrtFlipViewItemDataAutomationPeer>(item, parent) {}

        static void toggle_reference(PyWinrtFlipViewItemDataAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_FlipViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtFlipViewItemDataAutomationPeer>(self.get(), param0, param1);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlipViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FlipViewItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>().ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlipViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(FlipViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FlipViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItemDataAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlipViewItemDataAutomationPeer};

    static PyGetSetDef getset_FlipViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItemDataAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlipViewItemDataAutomationPeer_Static
    };

    // ----- FlyoutPresenterAutomationPeer class --------------------

    struct PyWinrtFlyoutPresenterAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeerT<PyWinrtFlyoutPresenterAutomationPeer>
    {
        PyWinrtFlyoutPresenterAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::FlyoutPresenter owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeerT<PyWinrtFlyoutPresenterAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtFlyoutPresenterAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_FlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlyoutPresenter>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtFlyoutPresenterAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FlyoutPresenterAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlyoutPresenterAutomationPeer};

    static PyGetSetDef getset_FlyoutPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FlyoutPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlyoutPresenterAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlyoutPresenterAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlyoutPresenterAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FlyoutPresenterAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlyoutPresenterAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlyoutPresenterAutomationPeer_Static
    };

    // ----- FrameworkElementAutomationPeer class --------------------

    struct PyWinrtFrameworkElementAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeerT<PyWinrtFrameworkElementAutomationPeer>
    {
        PyWinrtFrameworkElementAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::FrameworkElement owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeerT<PyWinrtFrameworkElementAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtFrameworkElementAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_FrameworkElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtFrameworkElementAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameworkElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameworkElementAutomationPeer_CreatePeerForElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"CreatePeerForElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer::CreatePeerForElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElementAutomationPeer_FromElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"FromElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer::FromElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElementAutomationPeer_get_Owner(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"Owner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>().Owner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameworkElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameworkElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameworkElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_FrameworkElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameworkElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameworkElementAutomationPeer[] = {
        { "owner", reinterpret_cast<getter>(FrameworkElementAutomationPeer_get_Owner), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameworkElementAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameworkElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameworkElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameworkElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameworkElementAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FrameworkElementAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.FrameworkElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FrameworkElementAutomationPeer};

    static PyGetSetDef getset_FrameworkElementAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FrameworkElementAutomationPeer_Static[] = {
        { "create_peer_for_element", reinterpret_cast<PyCFunction>(FrameworkElementAutomationPeer_CreatePeerForElement), METH_VARARGS, nullptr },
        { "from_element", reinterpret_cast<PyCFunction>(FrameworkElementAutomationPeer_FromElement), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FrameworkElementAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FrameworkElementAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FrameworkElementAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FrameworkElementAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FrameworkElementAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FrameworkElementAutomationPeer_Static
    };

    // ----- GridViewAutomationPeer class --------------------

    struct PyWinrtGridViewAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeerT<PyWinrtGridViewAutomationPeer>
    {
        PyWinrtGridViewAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::GridView owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeerT<PyWinrtGridViewAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtGridViewAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GridViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridView>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtGridViewAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GridViewAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GridViewAutomationPeer};

    static PyGetSetDef getset_GridViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GridViewAutomationPeer_Static
    };

    // ----- GridViewHeaderItemAutomationPeer class --------------------

    struct PyWinrtGridViewHeaderItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeerT<PyWinrtGridViewHeaderItemAutomationPeer>
    {
        PyWinrtGridViewHeaderItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::GridViewHeaderItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeerT<PyWinrtGridViewHeaderItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtGridViewHeaderItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GridViewHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridViewHeaderItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtGridViewHeaderItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewHeaderItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewHeaderItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GridViewHeaderItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GridViewHeaderItemAutomationPeer};

    static PyGetSetDef getset_GridViewHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewHeaderItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewHeaderItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewHeaderItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewHeaderItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewHeaderItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GridViewHeaderItemAutomationPeer_Static
    };

    // ----- GridViewItemAutomationPeer class --------------------

    struct PyWinrtGridViewItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeerT<PyWinrtGridViewItemAutomationPeer>
    {
        PyWinrtGridViewItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::GridViewItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeerT<PyWinrtGridViewItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtGridViewItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GridViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridViewItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtGridViewItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GridViewItemAutomationPeer};

    static PyGetSetDef getset_GridViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GridViewItemAutomationPeer_Static
    };

    // ----- GridViewItemDataAutomationPeer class --------------------

    struct PyWinrtGridViewItemDataAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeerT<PyWinrtGridViewItemDataAutomationPeer>
    {
        PyWinrtGridViewItemDataAutomationPeer(PyObject* py_obj, winrt::Windows::Foundation::IInspectable item, winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer parent) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeerT<PyWinrtGridViewItemDataAutomationPeer>(item, parent) {}

        static void toggle_reference(PyWinrtGridViewItemDataAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GridViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtGridViewItemDataAutomationPeer>(self.get(), param0, param1);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.GridViewItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>().ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(GridViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GridViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemDataAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GridViewItemDataAutomationPeer};

    static PyGetSetDef getset_GridViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemDataAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GridViewItemDataAutomationPeer_Static
    };

    // ----- GroupItemAutomationPeer class --------------------

    struct PyWinrtGroupItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeerT<PyWinrtGroupItemAutomationPeer>
    {
        PyWinrtGroupItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::GroupItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeerT<PyWinrtGroupItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtGroupItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GroupItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GroupItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtGroupItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GroupItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GroupItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GroupItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GroupItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GroupItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GroupItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GroupItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GroupItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GroupItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GroupItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GroupItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GroupItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GroupItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.GroupItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GroupItemAutomationPeer};

    static PyGetSetDef getset_GroupItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GroupItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GroupItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GroupItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GroupItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GroupItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GroupItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GroupItemAutomationPeer_Static
    };

    // ----- HubAutomationPeer class --------------------

    struct PyWinrtHubAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeerT<PyWinrtHubAutomationPeer>
    {
        PyWinrtHubAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Hub owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeerT<PyWinrtHubAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtHubAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_HubAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Hub>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtHubAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HubAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HubAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HubAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HubAutomationPeer[] = {
        { "_assign_array_", _assign_array_HubAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HubAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HubAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HubAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HubAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HubAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HubAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HubAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_HubAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.HubAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_HubAutomationPeer};

    static PyGetSetDef getset_HubAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_HubAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HubAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HubAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HubAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_HubAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.HubAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_HubAutomationPeer_Static
    };

    // ----- HubSectionAutomationPeer class --------------------

    struct PyWinrtHubSectionAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeerT<PyWinrtHubSectionAutomationPeer>
    {
        PyWinrtHubSectionAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::HubSection owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeerT<PyWinrtHubSectionAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtHubSectionAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_HubSectionAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::HubSection>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtHubSectionAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HubSectionAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HubSectionAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.HubSectionAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>().ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HubSectionAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HubSectionAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HubSectionAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(HubSectionAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HubSectionAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HubSectionAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HubSectionAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HubSectionAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HubSectionAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HubSectionAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HubSectionAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HubSectionAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_HubSectionAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.HubSectionAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_HubSectionAutomationPeer};

    static PyGetSetDef getset_HubSectionAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_HubSectionAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HubSectionAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HubSectionAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HubSectionAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_HubSectionAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.HubSectionAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_HubSectionAutomationPeer_Static
    };

    // ----- HyperlinkButtonAutomationPeer class --------------------

    struct PyWinrtHyperlinkButtonAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeerT<PyWinrtHyperlinkButtonAutomationPeer>
    {
        PyWinrtHyperlinkButtonAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::HyperlinkButton owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeerT<PyWinrtHyperlinkButtonAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtHyperlinkButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_HyperlinkButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtHyperlinkButtonAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HyperlinkButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HyperlinkButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.HyperlinkButtonAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>().Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HyperlinkButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(HyperlinkButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HyperlinkButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HyperlinkButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButtonAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.HyperlinkButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_HyperlinkButtonAutomationPeer};

    static PyGetSetDef getset_HyperlinkButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_HyperlinkButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HyperlinkButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HyperlinkButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HyperlinkButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButtonAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.HyperlinkButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_HyperlinkButtonAutomationPeer_Static
    };

    // ----- ImageAutomationPeer class --------------------

    struct PyWinrtImageAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeerT<PyWinrtImageAutomationPeer>
    {
        PyWinrtImageAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Image owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeerT<PyWinrtImageAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtImageAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ImageAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Image>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtImageAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ImageAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageAutomationPeer[] = {
        { "_assign_array_", _assign_array_ImageAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ImageAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ImageAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ImageAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ImageAutomationPeer};

    static PyGetSetDef getset_ImageAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ImageAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ImageAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ImageAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImageAutomationPeer_Static
    };

    // ----- InkToolbarAutomationPeer class --------------------

    static PyObject* _new_InkToolbarAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarAutomationPeer[] = {
        { "_assign_array_", _assign_array_InkToolbarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.InkToolbarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarAutomationPeer};

    // ----- ItemAutomationPeer class --------------------

    struct PyWinrtItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeerT<PyWinrtItemAutomationPeer>
    {
        PyWinrtItemAutomationPeer(PyObject* py_obj, winrt::Windows::Foundation::IInspectable item, winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer parent) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeerT<PyWinrtItemAutomationPeer>(item, parent) {}

        static void toggle_reference(PyWinrtItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtItemAutomationPeer>(self.get(), param0, param1);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"Realize", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>().Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemAutomationPeer_get_Item(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>().Item());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemAutomationPeer_get_ItemsControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"ItemsControlAutomationPeer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>().ItemsControlAutomationPeer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemAutomationPeer[] = {
        { "realize", reinterpret_cast<PyCFunction>(ItemAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemAutomationPeer[] = {
        { "item", reinterpret_cast<getter>(ItemAutomationPeer_get_Item), nullptr, nullptr, nullptr },
        { "items_control_automation_peer", reinterpret_cast<getter>(ItemAutomationPeer_get_ItemsControlAutomationPeer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ItemAutomationPeer};

    static PyGetSetDef getset_ItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ItemAutomationPeer_Static
    };

    // ----- ItemsControlAutomationPeer class --------------------

    struct PyWinrtItemsControlAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeerT<PyWinrtItemsControlAutomationPeer>
    {
        PyWinrtItemsControlAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ItemsControl owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeerT<PyWinrtItemsControlAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtItemsControlAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ItemsControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ItemsControl>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtItemsControlAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemsControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsControlAutomationPeer_CreateItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"CreateItemAutomationPeer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>().CreateItemAutomationPeer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsControlAutomationPeer_FindItemByProperty(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"FindItemByProperty", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>().FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsControlAutomationPeer[] = {
        { "create_item_automation_peer", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_CreateItemAutomationPeer), METH_VARARGS, nullptr },
        { "find_item_by_property", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_FindItemByProperty), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemsControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemsControlAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ItemsControlAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsControlAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ItemsControlAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ItemsControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ItemsControlAutomationPeer};

    static PyGetSetDef getset_ItemsControlAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ItemsControlAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ItemsControlAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemsControlAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemsControlAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemsControlAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ItemsControlAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ItemsControlAutomationPeer_Static
    };

    // ----- ListBoxAutomationPeer class --------------------

    struct PyWinrtListBoxAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeerT<PyWinrtListBoxAutomationPeer>
    {
        PyWinrtListBoxAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ListBox owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeerT<PyWinrtListBoxAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtListBoxAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListBox>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtListBoxAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListBoxAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListBoxAutomationPeer};

    static PyGetSetDef getset_ListBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListBoxAutomationPeer_Static
    };

    // ----- ListBoxItemAutomationPeer class --------------------

    struct PyWinrtListBoxItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeerT<PyWinrtListBoxItemAutomationPeer>
    {
        PyWinrtListBoxItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ListBoxItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeerT<PyWinrtListBoxItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtListBoxItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListBoxItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListBoxItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtListBoxItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListBoxItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListBoxItemAutomationPeer};

    static PyGetSetDef getset_ListBoxItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListBoxItemAutomationPeer_Static
    };

    // ----- ListBoxItemDataAutomationPeer class --------------------

    struct PyWinrtListBoxItemDataAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeerT<PyWinrtListBoxItemDataAutomationPeer>
    {
        PyWinrtListBoxItemDataAutomationPeer(PyObject* py_obj, winrt::Windows::Foundation::IInspectable item, winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer parent) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeerT<PyWinrtListBoxItemDataAutomationPeer>(item, parent) {}

        static void toggle_reference(PyWinrtListBoxItemDataAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListBoxItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtListBoxItemDataAutomationPeer>(self.get(), param0, param1);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListBoxItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ListBoxItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>().ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListBoxItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListBoxItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItemDataAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListBoxItemDataAutomationPeer};

    static PyGetSetDef getset_ListBoxItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItemDataAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListBoxItemDataAutomationPeer_Static
    };

    // ----- ListPickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_ListPickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ListPickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListPickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListPickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListPickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListPickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListPickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListPickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListPickerFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListPickerFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListPickerFlyoutPresenterAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListPickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListPickerFlyoutPresenterAutomationPeer};

    // ----- ListViewAutomationPeer class --------------------

    struct PyWinrtListViewAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeerT<PyWinrtListViewAutomationPeer>
    {
        PyWinrtListViewAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ListView owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeerT<PyWinrtListViewAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtListViewAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListView>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtListViewAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewAutomationPeer};

    static PyGetSetDef getset_ListViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewAutomationPeer_Static
    };

    // ----- ListViewBaseAutomationPeer class --------------------

    struct PyWinrtListViewBaseAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeerT<PyWinrtListViewBaseAutomationPeer>
    {
        PyWinrtListViewBaseAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ListViewBase owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeerT<PyWinrtListViewBaseAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtListViewBaseAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListViewBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewBase>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtListViewBaseAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewBaseAutomationPeer_get_DropEffect(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer", L"DropEffect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>().DropEffect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBaseAutomationPeer_get_DropEffects(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer", L"DropEffects");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>().DropEffects());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBaseAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBaseAutomationPeer[] = {
        { "drop_effect", reinterpret_cast<getter>(ListViewBaseAutomationPeer_get_DropEffect), nullptr, nullptr, nullptr },
        { "drop_effects", reinterpret_cast<getter>(ListViewBaseAutomationPeer_get_DropEffects), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewBaseAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBaseAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewBaseAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewBaseAutomationPeer};

    static PyGetSetDef getset_ListViewBaseAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewBaseAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewBaseAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewBaseAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewBaseAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewBaseAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewBaseAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewBaseAutomationPeer_Static
    };

    // ----- ListViewBaseHeaderItemAutomationPeer class --------------------

    struct PyWinrtListViewBaseHeaderItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeerT<PyWinrtListViewBaseHeaderItemAutomationPeer>
    {

        static void toggle_reference(PyWinrtListViewBaseHeaderItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListViewBaseHeaderItemAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewBaseHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewBaseHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBaseHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBaseHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewBaseHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBaseHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBaseHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewBaseHeaderItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBaseHeaderItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewBaseHeaderItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewBaseHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewBaseHeaderItemAutomationPeer};

    static PyGetSetDef getset_ListViewBaseHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewBaseHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewBaseHeaderItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewBaseHeaderItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewBaseHeaderItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewBaseHeaderItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewBaseHeaderItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewBaseHeaderItemAutomationPeer_Static
    };

    // ----- ListViewHeaderItemAutomationPeer class --------------------

    struct PyWinrtListViewHeaderItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeerT<PyWinrtListViewHeaderItemAutomationPeer>
    {
        PyWinrtListViewHeaderItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ListViewHeaderItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeerT<PyWinrtListViewHeaderItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtListViewHeaderItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListViewHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewHeaderItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtListViewHeaderItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewHeaderItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewHeaderItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewHeaderItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewHeaderItemAutomationPeer};

    static PyGetSetDef getset_ListViewHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewHeaderItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewHeaderItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewHeaderItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewHeaderItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewHeaderItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewHeaderItemAutomationPeer_Static
    };

    // ----- ListViewItemAutomationPeer class --------------------

    struct PyWinrtListViewItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeerT<PyWinrtListViewItemAutomationPeer>
    {
        PyWinrtListViewItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ListViewItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeerT<PyWinrtListViewItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtListViewItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtListViewItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewItemAutomationPeer};

    static PyGetSetDef getset_ListViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewItemAutomationPeer_Static
    };

    // ----- ListViewItemDataAutomationPeer class --------------------

    struct PyWinrtListViewItemDataAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeerT<PyWinrtListViewItemDataAutomationPeer>
    {
        PyWinrtListViewItemDataAutomationPeer(PyObject* py_obj, winrt::Windows::Foundation::IInspectable item, winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer parent) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeerT<PyWinrtListViewItemDataAutomationPeer>(item, parent) {}

        static void toggle_reference(PyWinrtListViewItemDataAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ListViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtListViewItemDataAutomationPeer>(self.get(), param0, param1);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>().ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemDataAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewItemDataAutomationPeer};

    static PyGetSetDef getset_ListViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemDataAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewItemDataAutomationPeer_Static
    };

    // ----- LoopingSelectorAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_FindItemByProperty(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"FindItemByProperty", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"SetScrollPercent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"CanSelectMultiple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"IsSelectionRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "find_item_by_property", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_FindItemByProperty), METH_VARARGS, nullptr },
        { "get_selection", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "horizontal_scroll_percent", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_select_multiple", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.LoopingSelectorAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorAutomationPeer};

    // ----- LoopingSelectorItemAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorItemAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorItemAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItemAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItemAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(LoopingSelectorItemAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(LoopingSelectorItemAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.LoopingSelectorItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItemAutomationPeer};

    // ----- LoopingSelectorItemDataAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorItemDataAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorItemDataAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemDataAutomationPeer", L"Realize", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItemDataAutomationPeer[] = {
        { "realize", reinterpret_cast<PyCFunction>(LoopingSelectorItemDataAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorItemDataAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.LoopingSelectorItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItemDataAutomationPeer};

    // ----- MapControlAutomationPeer class --------------------

    static PyObject* _new_MapControlAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_MapControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlAutomationPeer_Move(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Move", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Move(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Resize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Resize", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Resize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Rotate(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Rotate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Rotate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"SetScrollPercent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Zoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Zoom", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Zoom(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_ZoomByUnit(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"ZoomByUnit", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ZoomUnit>(args, 0);

                self->obj.ZoomByUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanMove(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanMove");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanMove());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanResize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanResize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanResize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanRotate(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanRotate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanRotate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanZoom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_MaxZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"MaxZoom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_MinZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"MinZoom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"ZoomLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlAutomationPeer[] = {
        { "move", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Move), METH_VARARGS, nullptr },
        { "resize", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Resize), METH_VARARGS, nullptr },
        { "rotate", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Rotate), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "zoom", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Zoom), METH_VARARGS, nullptr },
        { "zoom_by_unit", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_ZoomByUnit), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_move", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanMove), nullptr, nullptr, nullptr },
        { "can_resize", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanResize), nullptr, nullptr, nullptr },
        { "can_rotate", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanRotate), nullptr, nullptr, nullptr },
        { "can_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanZoom), nullptr, nullptr, nullptr },
        { "max_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_MaxZoom), nullptr, nullptr, nullptr },
        { "min_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_MinZoom), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(MapControlAutomationPeer_get_ZoomLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MapControlAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.MapControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlAutomationPeer};

    // ----- MediaElementAutomationPeer class --------------------

    struct PyWinrtMediaElementAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeerT<PyWinrtMediaElementAutomationPeer>
    {
        PyWinrtMediaElementAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::MediaElement owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeerT<PyWinrtMediaElementAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtMediaElementAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MediaElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaElement>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtMediaElementAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaElementAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaElementAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MediaElementAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MediaElementAutomationPeer};

    static PyGetSetDef getset_MediaElementAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaElementAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MediaElementAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaElementAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaElementAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaElementAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaElementAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MediaElementAutomationPeer_Static
    };

    // ----- MediaPlayerElementAutomationPeer class --------------------

    struct PyWinrtMediaPlayerElementAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeerT<PyWinrtMediaPlayerElementAutomationPeer>
    {
        PyWinrtMediaPlayerElementAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::MediaPlayerElement owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeerT<PyWinrtMediaPlayerElementAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtMediaPlayerElementAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MediaPlayerElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaPlayerElement>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtMediaPlayerElementAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlayerElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaPlayerElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayerElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaPlayerElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayerElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayerElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaPlayerElementAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayerElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayerElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayerElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayerElementAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MediaPlayerElementAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaPlayerElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MediaPlayerElementAutomationPeer};

    static PyGetSetDef getset_MediaPlayerElementAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaPlayerElementAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MediaPlayerElementAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaPlayerElementAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaPlayerElementAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaPlayerElementAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaPlayerElementAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MediaPlayerElementAutomationPeer_Static
    };

    // ----- MediaTransportControlsAutomationPeer class --------------------

    struct PyWinrtMediaTransportControlsAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeerT<PyWinrtMediaTransportControlsAutomationPeer>
    {
        PyWinrtMediaTransportControlsAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::MediaTransportControls owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeerT<PyWinrtMediaTransportControlsAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtMediaTransportControlsAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MediaTransportControlsAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaTransportControls>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtMediaTransportControlsAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaTransportControlsAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaTransportControlsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaTransportControlsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTransportControlsAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaTransportControlsAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaTransportControlsAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaTransportControlsAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaTransportControlsAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTransportControlsAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTransportControlsAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaTransportControlsAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTransportControlsAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MediaTransportControlsAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaTransportControlsAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MediaTransportControlsAutomationPeer};

    static PyGetSetDef getset_MediaTransportControlsAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaTransportControlsAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MediaTransportControlsAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaTransportControlsAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaTransportControlsAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaTransportControlsAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaTransportControlsAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MediaTransportControlsAutomationPeer_Static
    };

    // ----- MenuBarAutomationPeer class --------------------

    struct PyWinrtMenuBarAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeerT<PyWinrtMenuBarAutomationPeer>
    {
        PyWinrtMenuBarAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::MenuBar owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeerT<PyWinrtMenuBarAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtMenuBarAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MenuBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuBar>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtMenuBarAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MenuBarAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuBarAutomationPeer};

    static PyGetSetDef getset_MenuBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuBarAutomationPeer_Static
    };

    // ----- MenuBarItemAutomationPeer class --------------------

    struct PyWinrtMenuBarItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeerT<PyWinrtMenuBarItemAutomationPeer>
    {
        PyWinrtMenuBarItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::MenuBarItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeerT<PyWinrtMenuBarItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtMenuBarItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MenuBarItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuBarItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtMenuBarItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuBarItemAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>().Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>().Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>().Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>().ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "invoke", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuBarItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(MenuBarItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuBarItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuBarItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuBarItemAutomationPeer};

    static PyGetSetDef getset_MenuBarItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuBarItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuBarItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuBarItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuBarItemAutomationPeer_Static
    };

    // ----- MenuFlyoutItemAutomationPeer class --------------------

    struct PyWinrtMenuFlyoutItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeerT<PyWinrtMenuFlyoutItemAutomationPeer>
    {
        PyWinrtMenuFlyoutItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::MenuFlyoutItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeerT<PyWinrtMenuFlyoutItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtMenuFlyoutItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MenuFlyoutItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuFlyoutItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtMenuFlyoutItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyoutItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutItemAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuFlyoutItemAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>().Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutItemAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(MenuFlyoutItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuFlyoutItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuFlyoutItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuFlyoutItemAutomationPeer};

    static PyGetSetDef getset_MenuFlyoutItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuFlyoutItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuFlyoutItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuFlyoutItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuFlyoutItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuFlyoutItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuFlyoutItemAutomationPeer_Static
    };

    // ----- MenuFlyoutPresenterAutomationPeer class --------------------

    struct PyWinrtMenuFlyoutPresenterAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeerT<PyWinrtMenuFlyoutPresenterAutomationPeer>
    {
        PyWinrtMenuFlyoutPresenterAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::MenuFlyoutPresenter owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeerT<PyWinrtMenuFlyoutPresenterAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtMenuFlyoutPresenterAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_MenuFlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuFlyoutPresenter>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtMenuFlyoutPresenterAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MenuFlyoutPresenterAutomationPeer};

    static PyGetSetDef getset_MenuFlyoutPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuFlyoutPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuFlyoutPresenterAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuFlyoutPresenterAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuFlyoutPresenterAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuFlyoutPresenterAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MenuFlyoutPresenterAutomationPeer_Static
    };

    // ----- NavigationViewItemAutomationPeer class --------------------

    struct PyWinrtNavigationViewItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeerT<PyWinrtNavigationViewItemAutomationPeer>
    {
        PyWinrtNavigationViewItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::NavigationViewItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeerT<PyWinrtNavigationViewItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtNavigationViewItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_NavigationViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtNavigationViewItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_NavigationViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.NavigationViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemAutomationPeer};

    static PyGetSetDef getset_NavigationViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.NavigationViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemAutomationPeer_Static
    };

    // ----- PasswordBoxAutomationPeer class --------------------

    struct PyWinrtPasswordBoxAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeerT<PyWinrtPasswordBoxAutomationPeer>
    {
        PyWinrtPasswordBoxAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::PasswordBox owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeerT<PyWinrtPasswordBoxAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtPasswordBoxAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_PasswordBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PasswordBox>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtPasswordBoxAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PasswordBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PasswordBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PasswordBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PasswordBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_PasswordBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PasswordBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PasswordBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PasswordBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PasswordBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PasswordBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PasswordBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PasswordBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PasswordBoxAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.PasswordBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PasswordBoxAutomationPeer};

    static PyGetSetDef getset_PasswordBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_PasswordBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PasswordBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PasswordBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PasswordBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_PasswordBoxAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.PasswordBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PasswordBoxAutomationPeer_Static
    };

    // ----- PersonPictureAutomationPeer class --------------------

    struct PyWinrtPersonPictureAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeerT<PyWinrtPersonPictureAutomationPeer>
    {
        PyWinrtPersonPictureAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::PersonPicture owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeerT<PyWinrtPersonPictureAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtPersonPictureAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_PersonPictureAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PersonPicture>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtPersonPictureAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PersonPictureAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersonPictureAutomationPeer[] = {
        { "_assign_array_", _assign_array_PersonPictureAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PersonPictureAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PersonPictureAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PersonPictureAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersonPictureAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PersonPictureAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersonPictureAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersonPictureAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PersonPictureAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.PersonPictureAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PersonPictureAutomationPeer};

    static PyGetSetDef getset_PersonPictureAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_PersonPictureAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PersonPictureAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PersonPictureAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PersonPictureAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_PersonPictureAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.PersonPictureAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PersonPictureAutomationPeer_Static
    };

    // ----- PickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_PickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_PickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_PickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PickerFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyoutPresenterAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.PickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerFlyoutPresenterAutomationPeer};

    // ----- PivotAutomationPeer class --------------------

    static PyObject* _new_PivotAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Pivot>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"SetScrollPercent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"CanSelectMultiple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"IsSelectionRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(PivotAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(PivotAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(PivotAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PivotAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_select_multiple", reinterpret_cast<getter>(PivotAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(PivotAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PivotAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.PivotAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotAutomationPeer};

    // ----- PivotItemAutomationPeer class --------------------

    static PyObject* _new_PivotItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PivotItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_PivotItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PivotItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.PivotItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotItemAutomationPeer};

    // ----- PivotItemDataAutomationPeer class --------------------

    static PyObject* _new_PivotItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotItemDataAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"Realize", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotItemDataAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "realize", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PivotItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotItemDataAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(PivotItemDataAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(PivotItemDataAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PivotItemDataAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.PivotItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotItemDataAutomationPeer};

    // ----- ProgressBarAutomationPeer class --------------------

    struct PyWinrtProgressBarAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeerT<PyWinrtProgressBarAutomationPeer>
    {
        PyWinrtProgressBarAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ProgressBar owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeerT<PyWinrtProgressBarAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtProgressBarAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ProgressBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ProgressBar>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtProgressBarAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ProgressBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ProgressBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ProgressBarAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ProgressBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ProgressBarAutomationPeer};

    static PyGetSetDef getset_ProgressBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ProgressBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ProgressBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressBarAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ProgressBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ProgressBarAutomationPeer_Static
    };

    // ----- ProgressRingAutomationPeer class --------------------

    struct PyWinrtProgressRingAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeerT<PyWinrtProgressRingAutomationPeer>
    {
        PyWinrtProgressRingAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ProgressRing owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeerT<PyWinrtProgressRingAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtProgressRingAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ProgressRingAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ProgressRing>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtProgressRingAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressRingAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressRingAutomationPeer[] = {
        { "_assign_array_", _assign_array_ProgressRingAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressRingAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressRingAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ProgressRingAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressRingAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressRingAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressRingAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressRingAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ProgressRingAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ProgressRingAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ProgressRingAutomationPeer};

    static PyGetSetDef getset_ProgressRingAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ProgressRingAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ProgressRingAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressRingAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressRingAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressRingAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ProgressRingAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ProgressRingAutomationPeer_Static
    };

    // ----- RadioButtonAutomationPeer class --------------------

    struct PyWinrtRadioButtonAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeerT<PyWinrtRadioButtonAutomationPeer>
    {
        PyWinrtRadioButtonAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::RadioButton owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeerT<PyWinrtRadioButtonAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtRadioButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RadioButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RadioButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtRadioButtonAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButtonAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>().AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>().RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>().Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>().IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>().SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButtonAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RadioButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButtonAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(RadioButtonAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(RadioButtonAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadioButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RadioButtonAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.RadioButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RadioButtonAutomationPeer};

    static PyGetSetDef getset_RadioButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RadioButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RadioButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButtonAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RadioButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RadioButtonAutomationPeer_Static
    };

    // ----- RangeBaseAutomationPeer class --------------------

    struct PyWinrtRangeBaseAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeerT<PyWinrtRangeBaseAutomationPeer>
    {
        PyWinrtRangeBaseAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeerT<PyWinrtRangeBaseAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtRangeBaseAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RangeBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtRangeBaseAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RangeBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBaseAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>().SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>().IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_LargeChange(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>().LargeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Maximum(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>().Maximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Minimum(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>().Minimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_SmallChange(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>().SmallChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>().Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBaseAutomationPeer[] = {
        { "set_value", reinterpret_cast<PyCFunction>(RangeBaseAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RangeBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBaseAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_LargeChange), nullptr, nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Maximum), nullptr, nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Minimum), nullptr, nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_SmallChange), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBaseAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBaseAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RangeBaseAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.RangeBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RangeBaseAutomationPeer};

    static PyGetSetDef getset_RangeBaseAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RangeBaseAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RangeBaseAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RangeBaseAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RangeBaseAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RangeBaseAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RangeBaseAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RangeBaseAutomationPeer_Static
    };

    // ----- RatingControlAutomationPeer class --------------------

    struct PyWinrtRatingControlAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeerT<PyWinrtRatingControlAutomationPeer>
    {
        PyWinrtRatingControlAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::RatingControl owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeerT<PyWinrtRatingControlAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtRatingControlAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RatingControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RatingControl>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtRatingControlAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingControlAutomationPeer[] = {
        { "_assign_array_", _assign_array_RatingControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RatingControlAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RatingControlAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingControlAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RatingControlAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.RatingControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RatingControlAutomationPeer};

    static PyGetSetDef getset_RatingControlAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RatingControlAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RatingControlAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RatingControlAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RatingControlAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RatingControlAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RatingControlAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RatingControlAutomationPeer_Static
    };

    // ----- RepeatButtonAutomationPeer class --------------------

    struct PyWinrtRepeatButtonAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeerT<PyWinrtRepeatButtonAutomationPeer>
    {
        PyWinrtRepeatButtonAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeerT<PyWinrtRepeatButtonAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtRepeatButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RepeatButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtRepeatButtonAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RepeatButtonAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>().Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(RepeatButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RepeatButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RepeatButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RepeatButtonAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.RepeatButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RepeatButtonAutomationPeer};

    static PyGetSetDef getset_RepeatButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RepeatButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RepeatButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeatButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeatButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeatButtonAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RepeatButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RepeatButtonAutomationPeer_Static
    };

    // ----- RichEditBoxAutomationPeer class --------------------

    struct PyWinrtRichEditBoxAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeerT<PyWinrtRichEditBoxAutomationPeer>
    {
        PyWinrtRichEditBoxAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::RichEditBox owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeerT<PyWinrtRichEditBoxAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtRichEditBoxAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RichEditBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichEditBox>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtRichEditBoxAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichEditBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichEditBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichEditBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichEditBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichEditBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichEditBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichEditBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichEditBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichEditBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichEditBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichEditBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichEditBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RichEditBoxAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichEditBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RichEditBoxAutomationPeer};

    static PyGetSetDef getset_RichEditBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RichEditBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RichEditBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RichEditBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RichEditBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RichEditBoxAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichEditBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RichEditBoxAutomationPeer_Static
    };

    // ----- RichTextBlockAutomationPeer class --------------------

    struct PyWinrtRichTextBlockAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeerT<PyWinrtRichTextBlockAutomationPeer>
    {
        PyWinrtRichTextBlockAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::RichTextBlock owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeerT<PyWinrtRichTextBlockAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtRichTextBlockAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RichTextBlockAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichTextBlock>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtRichTextBlockAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichTextBlockAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichTextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichTextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichTextBlockAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichTextBlockAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichTextBlockAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichTextBlockAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichTextBlockAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichTextBlockAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichTextBlockAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichTextBlockAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichTextBlockAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RichTextBlockAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichTextBlockAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RichTextBlockAutomationPeer};

    static PyGetSetDef getset_RichTextBlockAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RichTextBlockAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RichTextBlockAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RichTextBlockAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RichTextBlockAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RichTextBlockAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichTextBlockAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RichTextBlockAutomationPeer_Static
    };

    // ----- RichTextBlockOverflowAutomationPeer class --------------------

    struct PyWinrtRichTextBlockOverflowAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeerT<PyWinrtRichTextBlockOverflowAutomationPeer>
    {
        PyWinrtRichTextBlockOverflowAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::RichTextBlockOverflow owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeerT<PyWinrtRichTextBlockOverflowAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtRichTextBlockOverflowAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RichTextBlockOverflowAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichTextBlockOverflow>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtRichTextBlockOverflowAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichTextBlockOverflowAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichTextBlockOverflowAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichTextBlockOverflowAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichTextBlockOverflowAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichTextBlockOverflowAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichTextBlockOverflowAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichTextBlockOverflowAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichTextBlockOverflowAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichTextBlockOverflowAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RichTextBlockOverflowAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichTextBlockOverflowAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RichTextBlockOverflowAutomationPeer};

    static PyGetSetDef getset_RichTextBlockOverflowAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RichTextBlockOverflowAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RichTextBlockOverflowAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RichTextBlockOverflowAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RichTextBlockOverflowAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RichTextBlockOverflowAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichTextBlockOverflowAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RichTextBlockOverflowAutomationPeer_Static
    };

    // ----- ScrollBarAutomationPeer class --------------------

    struct PyWinrtScrollBarAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeerT<PyWinrtScrollBarAutomationPeer>
    {
        PyWinrtScrollBarAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeerT<PyWinrtScrollBarAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtScrollBarAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ScrollBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtScrollBarAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ScrollBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ScrollBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ScrollBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ScrollBarAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ScrollBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ScrollBarAutomationPeer};

    static PyGetSetDef getset_ScrollBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ScrollBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollBarAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ScrollBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ScrollBarAutomationPeer_Static
    };

    // ----- ScrollViewerAutomationPeer class --------------------

    struct PyWinrtScrollViewerAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeerT<PyWinrtScrollViewerAutomationPeer>
    {
        PyWinrtScrollViewerAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ScrollViewer owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeerT<PyWinrtScrollViewerAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtScrollViewerAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ScrollViewerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ScrollViewer>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtScrollViewerAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollViewerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollViewerAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>().Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"SetScrollPercent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>().SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>().HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>().HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>().HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>().VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>().VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>().VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollViewerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollViewerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollViewerAutomationPeer[] = {
        { "scroll", reinterpret_cast<PyCFunction>(ScrollViewerAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(ScrollViewerAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ScrollViewerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollViewerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollViewerAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollViewerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollViewerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollViewerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollViewerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollViewerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ScrollViewerAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ScrollViewerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ScrollViewerAutomationPeer};

    static PyGetSetDef getset_ScrollViewerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ScrollViewerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollViewerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollViewerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollViewerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollViewerAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ScrollViewerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ScrollViewerAutomationPeer_Static
    };

    // ----- SearchBoxAutomationPeer class --------------------

    struct PyWinrtSearchBoxAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeerT<PyWinrtSearchBoxAutomationPeer>
    {
        PyWinrtSearchBoxAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::SearchBox owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeerT<PyWinrtSearchBoxAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtSearchBoxAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_SearchBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SearchBox>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtSearchBoxAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SearchBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SearchBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_SearchBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SearchBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SearchBoxAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.SearchBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SearchBoxAutomationPeer};

    static PyGetSetDef getset_SearchBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SearchBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SearchBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SearchBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SearchBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SearchBoxAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SearchBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SearchBoxAutomationPeer_Static
    };

    // ----- SelectorAutomationPeer class --------------------

    struct PyWinrtSelectorAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeerT<PyWinrtSelectorAutomationPeer>
    {
        PyWinrtSelectorAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Primitives::Selector owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeerT<PyWinrtSelectorAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtSelectorAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_SelectorAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtSelectorAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>().GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"CanSelectMultiple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>().CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectorAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"IsSelectionRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>().IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(SelectorAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SelectorAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorAutomationPeer[] = {
        { "can_select_multiple", reinterpret_cast<getter>(SelectorAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(SelectorAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SelectorAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.SelectorAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SelectorAutomationPeer};

    static PyGetSetDef getset_SelectorAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SelectorAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectorAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectorAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectorAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectorAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SelectorAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SelectorAutomationPeer_Static
    };

    // ----- SelectorItemAutomationPeer class --------------------

    struct PyWinrtSelectorItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeerT<PyWinrtSelectorItemAutomationPeer>
    {
        PyWinrtSelectorItemAutomationPeer(PyObject* py_obj, winrt::Windows::Foundation::IInspectable item, winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer parent) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeerT<PyWinrtSelectorItemAutomationPeer>(item, parent) {}

        static void toggle_reference(PyWinrtSelectorItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_SelectorItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtSelectorItemAutomationPeer>(self.get(), param0, param1);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorItemAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>().AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>().RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>().Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>().IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>().SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorItemAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SelectorItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorItemAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(SelectorItemAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(SelectorItemAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SelectorItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.SelectorItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SelectorItemAutomationPeer};

    static PyGetSetDef getset_SelectorItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SelectorItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectorItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectorItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectorItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectorItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SelectorItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SelectorItemAutomationPeer_Static
    };

    // ----- SemanticZoomAutomationPeer class --------------------

    struct PyWinrtSemanticZoomAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeerT<PyWinrtSemanticZoomAutomationPeer>
    {
        PyWinrtSemanticZoomAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::SemanticZoom owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeerT<PyWinrtSemanticZoomAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtSemanticZoomAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_SemanticZoomAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoom>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtSemanticZoomAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SemanticZoomAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SemanticZoomAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SemanticZoomAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>().Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SemanticZoomAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SemanticZoomAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>().ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SemanticZoomAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SemanticZoomAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SemanticZoomAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(SemanticZoomAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SemanticZoomAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SemanticZoomAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SemanticZoomAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(SemanticZoomAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SemanticZoomAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SemanticZoomAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SemanticZoomAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SemanticZoomAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SemanticZoomAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SemanticZoomAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.SemanticZoomAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SemanticZoomAutomationPeer};

    static PyGetSetDef getset_SemanticZoomAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SemanticZoomAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SemanticZoomAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SemanticZoomAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SemanticZoomAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SemanticZoomAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SemanticZoomAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SemanticZoomAutomationPeer_Static
    };

    // ----- SettingsFlyoutAutomationPeer class --------------------

    struct PyWinrtSettingsFlyoutAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeerT<PyWinrtSettingsFlyoutAutomationPeer>
    {
        PyWinrtSettingsFlyoutAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::SettingsFlyout owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeerT<PyWinrtSettingsFlyoutAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtSettingsFlyoutAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_SettingsFlyoutAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SettingsFlyout>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtSettingsFlyoutAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SettingsFlyoutAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SettingsFlyoutAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SettingsFlyoutAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SettingsFlyoutAutomationPeer[] = {
        { "_assign_array_", _assign_array_SettingsFlyoutAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SettingsFlyoutAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SettingsFlyoutAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SettingsFlyoutAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SettingsFlyoutAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SettingsFlyoutAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SettingsFlyoutAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SettingsFlyoutAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SettingsFlyoutAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.SettingsFlyoutAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SettingsFlyoutAutomationPeer};

    static PyGetSetDef getset_SettingsFlyoutAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SettingsFlyoutAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SettingsFlyoutAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SettingsFlyoutAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SettingsFlyoutAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SettingsFlyoutAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SettingsFlyoutAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SettingsFlyoutAutomationPeer_Static
    };

    // ----- SliderAutomationPeer class --------------------

    struct PyWinrtSliderAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeerT<PyWinrtSliderAutomationPeer>
    {
        PyWinrtSliderAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Slider owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeerT<PyWinrtSliderAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtSliderAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_SliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Slider>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtSliderAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SliderAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_SliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SliderAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SliderAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SliderAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SliderAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.SliderAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SliderAutomationPeer};

    static PyGetSetDef getset_SliderAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SliderAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SliderAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SliderAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SliderAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SliderAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SliderAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SliderAutomationPeer_Static
    };

    // ----- TextBlockAutomationPeer class --------------------

    struct PyWinrtTextBlockAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeerT<PyWinrtTextBlockAutomationPeer>
    {
        PyWinrtTextBlockAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::TextBlock owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeerT<PyWinrtTextBlockAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtTextBlockAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TextBlockAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TextBlock>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtTextBlockAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextBlockAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextBlockAutomationPeer[] = {
        { "_assign_array_", _assign_array_TextBlockAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextBlockAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextBlockAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TextBlockAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextBlockAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextBlockAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextBlockAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextBlockAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TextBlockAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.TextBlockAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TextBlockAutomationPeer};

    static PyGetSetDef getset_TextBlockAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TextBlockAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TextBlockAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextBlockAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextBlockAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TextBlockAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TextBlockAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TextBlockAutomationPeer_Static
    };

    // ----- TextBoxAutomationPeer class --------------------

    struct PyWinrtTextBoxAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeerT<PyWinrtTextBoxAutomationPeer>
    {
        PyWinrtTextBoxAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::TextBox owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeerT<PyWinrtTextBoxAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtTextBoxAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TextBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TextBox>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtTextBoxAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_TextBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TextBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TextBoxAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.TextBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TextBoxAutomationPeer};

    static PyGetSetDef getset_TextBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TextBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TextBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TextBoxAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TextBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TextBoxAutomationPeer_Static
    };

    // ----- ThumbAutomationPeer class --------------------

    struct PyWinrtThumbAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeerT<PyWinrtThumbAutomationPeer>
    {
        PyWinrtThumbAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Primitives::Thumb owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeerT<PyWinrtThumbAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtThumbAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ThumbAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::Thumb>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtThumbAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ThumbAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ThumbAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ThumbAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ThumbAutomationPeer[] = {
        { "_assign_array_", _assign_array_ThumbAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ThumbAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ThumbAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ThumbAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ThumbAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ThumbAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ThumbAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ThumbAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ThumbAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ThumbAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ThumbAutomationPeer};

    static PyGetSetDef getset_ThumbAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ThumbAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ThumbAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ThumbAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ThumbAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ThumbAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ThumbAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ThumbAutomationPeer_Static
    };

    // ----- TimePickerAutomationPeer class --------------------

    struct PyWinrtTimePickerAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeerT<PyWinrtTimePickerAutomationPeer>
    {
        PyWinrtTimePickerAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::TimePicker owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeerT<PyWinrtTimePickerAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtTimePickerAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TimePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TimePicker>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtTimePickerAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerAutomationPeer[] = {
        { "_assign_array_", _assign_array_TimePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TimePickerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TimePickerAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.TimePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TimePickerAutomationPeer};

    static PyGetSetDef getset_TimePickerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TimePickerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TimePickerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimePickerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TimePickerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TimePickerAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TimePickerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TimePickerAutomationPeer_Static
    };

    // ----- TimePickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_TimePickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_TimePickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_TimePickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TimePickerFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TimePickerFlyoutPresenterAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.TimePickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerFlyoutPresenterAutomationPeer};

    // ----- ToggleButtonAutomationPeer class --------------------

    struct PyWinrtToggleButtonAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeerT<PyWinrtToggleButtonAutomationPeer>
    {
        PyWinrtToggleButtonAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeerT<PyWinrtToggleButtonAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtToggleButtonAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ToggleButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtToggleButtonAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleButtonAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>().Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleButtonAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>().ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleButtonAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleButtonAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleButtonAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleButtonAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ToggleButtonAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ToggleButtonAutomationPeer};

    static PyGetSetDef getset_ToggleButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ToggleButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleButtonAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ToggleButtonAutomationPeer_Static
    };

    // ----- ToggleMenuFlyoutItemAutomationPeer class --------------------

    struct PyWinrtToggleMenuFlyoutItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeerT<PyWinrtToggleMenuFlyoutItemAutomationPeer>
    {
        PyWinrtToggleMenuFlyoutItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ToggleMenuFlyoutItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeerT<PyWinrtToggleMenuFlyoutItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtToggleMenuFlyoutItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ToggleMenuFlyoutItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ToggleMenuFlyoutItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtToggleMenuFlyoutItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleMenuFlyoutItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleMenuFlyoutItemAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleMenuFlyoutItemAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>().Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleMenuFlyoutItemAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleMenuFlyoutItemAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>().ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleMenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleMenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleMenuFlyoutItemAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleMenuFlyoutItemAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleMenuFlyoutItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleMenuFlyoutItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleMenuFlyoutItemAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleMenuFlyoutItemAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleMenuFlyoutItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleMenuFlyoutItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ToggleMenuFlyoutItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleMenuFlyoutItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ToggleMenuFlyoutItemAutomationPeer};

    static PyGetSetDef getset_ToggleMenuFlyoutItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ToggleMenuFlyoutItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleMenuFlyoutItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleMenuFlyoutItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleMenuFlyoutItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleMenuFlyoutItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleMenuFlyoutItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ToggleMenuFlyoutItemAutomationPeer_Static
    };

    // ----- ToggleSwitchAutomationPeer class --------------------

    struct PyWinrtToggleSwitchAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeerT<PyWinrtToggleSwitchAutomationPeer>
    {
        PyWinrtToggleSwitchAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::ToggleSwitch owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeerT<PyWinrtToggleSwitchAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtToggleSwitchAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ToggleSwitchAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ToggleSwitch>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtToggleSwitchAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleSwitchAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSwitchAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleSwitchAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>().Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleSwitchAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>().ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSwitchAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSwitchAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSwitchAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleSwitchAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleSwitchAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSwitchAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleSwitchAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleSwitchAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleSwitchAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSwitchAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSwitchAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSwitchAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSwitchAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ToggleSwitchAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleSwitchAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ToggleSwitchAutomationPeer};

    static PyGetSetDef getset_ToggleSwitchAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ToggleSwitchAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleSwitchAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleSwitchAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleSwitchAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleSwitchAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleSwitchAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ToggleSwitchAutomationPeer_Static
    };

    // ----- TreeViewItemAutomationPeer class --------------------

    struct PyWinrtTreeViewItemAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeerT<PyWinrtTreeViewItemAutomationPeer>
    {
        PyWinrtTreeViewItemAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::TreeViewItem owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeerT<PyWinrtTreeViewItemAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtTreeViewItemAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TreeViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TreeViewItem>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtTreeViewItemAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>().Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>().Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>().ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TreeViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(TreeViewItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.TreeViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewItemAutomationPeer};

    static PyGetSetDef getset_TreeViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TreeViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TreeViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewItemAutomationPeer_Static
    };

    // ----- TreeViewListAutomationPeer class --------------------

    struct PyWinrtTreeViewListAutomationPeer : py::py_obj_ref, winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeerT<PyWinrtTreeViewListAutomationPeer>
    {
        PyWinrtTreeViewListAutomationPeer(PyObject* py_obj, winrt::Windows::UI::Xaml::Controls::TreeViewList owner) : py::py_obj_ref(py_obj), winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeerT<PyWinrtTreeViewListAutomationPeer>(owner) {}

        static void toggle_reference(PyWinrtTreeViewListAutomationPeer* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TreeViewListAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TreeViewList>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer*>(self.get())->obj = winrt::make<PyWinrtTreeViewListAutomationPeer>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewListAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewListAutomationPeer[] = {
        { "_assign_array_", _assign_array_TreeViewListAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewListAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewListAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TreeViewListAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewListAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewListAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewListAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewListAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TreeViewListAutomationPeer = {
        "winrt._winrt_windows_ui_xaml_automation_peers.TreeViewListAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TreeViewListAutomationPeer};

    static PyGetSetDef getset_TreeViewListAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TreeViewListAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewListAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewListAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewListAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewListAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TreeViewListAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TreeViewListAutomationPeer_Static
    };

    // ----- RawElementProviderRuntimeId struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>* _new_RawElementProviderRuntimeId(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_RawElementProviderRuntimeId(winrt_struct_wrapper<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _Part1{};
        uint32_t _Part2{};

        static const char* kwlist[] = {"part1", "part2", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Part1, &_Part2))
        {
            return -1;
        }

        try
        {
            self->obj.Part1 = _Part1;
            self->obj.Part2 = _Part2;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_RawElementProviderRuntimeId(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RawElementProviderRuntimeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_RawElementProviderRuntimeId[] = {
        { "_assign_array_", _assign_array_RawElementProviderRuntimeId, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* RawElementProviderRuntimeId_get_Part1(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Part1);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RawElementProviderRuntimeId_set_Part1(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Part1 = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RawElementProviderRuntimeId_get_Part2(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Part2);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RawElementProviderRuntimeId_set_Part2(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Part2 = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RawElementProviderRuntimeId[] = {
        { "part1", reinterpret_cast<getter>(RawElementProviderRuntimeId_get_Part1), reinterpret_cast<setter>(RawElementProviderRuntimeId_set_Part1), nullptr, nullptr },
        { "part2", reinterpret_cast<getter>(RawElementProviderRuntimeId_get_Part2), reinterpret_cast<setter>(RawElementProviderRuntimeId_set_Part2), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_RawElementProviderRuntimeId(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_RawElementProviderRuntimeId(PyObject* self) noexcept
    {
        py::pyobj_handle Part1{PyObject_GetAttrString(self, "part1")};
        if (!Part1)
        {
            return nullptr;
        }

        py::pyobj_handle Part2{PyObject_GetAttrString(self, "part2")};
        if (!Part2)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("RawElementProviderRuntimeId(part1=%R, part2=%R)", Part1.get(), Part2.get());
    }

    static PyType_Slot _type_slots_RawElementProviderRuntimeId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RawElementProviderRuntimeId) },
        { Py_tp_init, reinterpret_cast<void*>(_init_RawElementProviderRuntimeId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RawElementProviderRuntimeId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RawElementProviderRuntimeId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RawElementProviderRuntimeId) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_RawElementProviderRuntimeId) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_RawElementProviderRuntimeId) },
        { }
    };

    static PyType_Spec type_spec_RawElementProviderRuntimeId = {
        "winrt._winrt_windows_ui_xaml_automation_peers.RawElementProviderRuntimeId",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RawElementProviderRuntimeId};

    // ----- Windows.UI.Xaml.Automation.Peers Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Automation.Peers");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_automation_peers",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Automation::Peers

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_automation_peers(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Automation::Peers;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml")};
    if (!windows_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_DependencyObject_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "DependencyObject")};
    if (!windows_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle AutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!AutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_AutomationPeer_Static, AutomationPeer_Static_bases.get())};
    if (!type_AutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AutomationPeer_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!AutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle AutomationPeer_type{py::register_python_type(module.get(), &type_spec_AutomationPeer, AutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationPeer_Static.get()))};
    if (!AutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FrameworkElementAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(AutomationPeer_type.get())))};
    if (!FrameworkElementAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FrameworkElementAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_FrameworkElementAutomationPeer_Static, FrameworkElementAutomationPeer_Static_bases.get())};
    if (!type_FrameworkElementAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FrameworkElementAutomationPeer_bases{PyTuple_Pack(1, AutomationPeer_type.get())};
    if (!FrameworkElementAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle FrameworkElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FrameworkElementAutomationPeer, FrameworkElementAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_FrameworkElementAutomationPeer_Static.get()))};
    if (!FrameworkElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!AppBarAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_AppBarAutomationPeer_Static, AppBarAutomationPeer_Static_bases.get())};
    if (!type_AppBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!AppBarAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarAutomationPeer, AppBarAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarAutomationPeer_Static.get()))};
    if (!AppBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonBaseAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ButtonBaseAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ButtonBaseAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ButtonBaseAutomationPeer_Static, ButtonBaseAutomationPeer_Static_bases.get())};
    if (!type_ButtonBaseAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonBaseAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ButtonBaseAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ButtonBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ButtonBaseAutomationPeer, ButtonBaseAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ButtonBaseAutomationPeer_Static.get()))};
    if (!ButtonBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonBaseAutomationPeer_type.get())))};
    if (!ButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ButtonAutomationPeer_Static, ButtonAutomationPeer_Static_bases.get())};
    if (!type_ButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonAutomationPeer_bases{PyTuple_Pack(1, ButtonBaseAutomationPeer_type.get())};
    if (!ButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ButtonAutomationPeer, ButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ButtonAutomationPeer_Static.get()))};
    if (!ButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonAutomationPeer_type.get())))};
    if (!AppBarButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_AppBarButtonAutomationPeer_Static, AppBarButtonAutomationPeer_Static_bases.get())};
    if (!type_AppBarButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarButtonAutomationPeer_bases{PyTuple_Pack(1, ButtonAutomationPeer_type.get())};
    if (!AppBarButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarButtonAutomationPeer, AppBarButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarButtonAutomationPeer_Static.get()))};
    if (!AppBarButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonBaseAutomationPeer_type.get())))};
    if (!ToggleButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ToggleButtonAutomationPeer_Static, ToggleButtonAutomationPeer_Static_bases.get())};
    if (!type_ToggleButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleButtonAutomationPeer_bases{PyTuple_Pack(1, ButtonBaseAutomationPeer_type.get())};
    if (!ToggleButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleButtonAutomationPeer, ToggleButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleButtonAutomationPeer_Static.get()))};
    if (!ToggleButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarToggleButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ToggleButtonAutomationPeer_type.get())))};
    if (!AppBarToggleButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarToggleButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_AppBarToggleButtonAutomationPeer_Static, AppBarToggleButtonAutomationPeer_Static_bases.get())};
    if (!type_AppBarToggleButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarToggleButtonAutomationPeer_bases{PyTuple_Pack(1, ToggleButtonAutomationPeer_type.get())};
    if (!AppBarToggleButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarToggleButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButtonAutomationPeer, AppBarToggleButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarToggleButtonAutomationPeer_Static.get()))};
    if (!AppBarToggleButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AutoSuggestBoxAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!AutoSuggestBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle AutoSuggestBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AutoSuggestBoxAutomationPeer, AutoSuggestBoxAutomationPeer_bases.get(), nullptr)};
    if (!AutoSuggestBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AutomationPeerAnnotation_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!AutomationPeerAnnotation_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationPeerAnnotation_Static{PyType_FromSpecWithBases(&type_spec_AutomationPeerAnnotation_Static, AutomationPeerAnnotation_Static_bases.get())};
    if (!type_AutomationPeerAnnotation_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AutomationPeerAnnotation_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!AutomationPeerAnnotation_bases)
    {
        return nullptr;
    }

    py::pytype_handle AutomationPeerAnnotation_type{py::register_python_type(module.get(), &type_spec_AutomationPeerAnnotation, AutomationPeerAnnotation_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationPeerAnnotation_Static.get()))};
    if (!AutomationPeerAnnotation_type)
    {
        return nullptr;
    }

    py::pyobj_handle CalendarDatePickerAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!CalendarDatePickerAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CalendarDatePickerAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_CalendarDatePickerAutomationPeer_Static, CalendarDatePickerAutomationPeer_Static_bases.get())};
    if (!type_CalendarDatePickerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CalendarDatePickerAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!CalendarDatePickerAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle CalendarDatePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_CalendarDatePickerAutomationPeer, CalendarDatePickerAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_CalendarDatePickerAutomationPeer_Static.get()))};
    if (!CalendarDatePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle CaptureElementAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!CaptureElementAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CaptureElementAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_CaptureElementAutomationPeer_Static, CaptureElementAutomationPeer_Static_bases.get())};
    if (!type_CaptureElementAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CaptureElementAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!CaptureElementAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle CaptureElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_CaptureElementAutomationPeer, CaptureElementAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_CaptureElementAutomationPeer_Static.get()))};
    if (!CaptureElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle CheckBoxAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ToggleButtonAutomationPeer_type.get())))};
    if (!CheckBoxAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CheckBoxAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_CheckBoxAutomationPeer_Static, CheckBoxAutomationPeer_Static_bases.get())};
    if (!type_CheckBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CheckBoxAutomationPeer_bases{PyTuple_Pack(1, ToggleButtonAutomationPeer_type.get())};
    if (!CheckBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle CheckBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_CheckBoxAutomationPeer, CheckBoxAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_CheckBoxAutomationPeer_Static.get()))};
    if (!CheckBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBaseAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!RangeBaseAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RangeBaseAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RangeBaseAutomationPeer_Static, RangeBaseAutomationPeer_Static_bases.get())};
    if (!type_RangeBaseAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBaseAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!RangeBaseAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RangeBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RangeBaseAutomationPeer, RangeBaseAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RangeBaseAutomationPeer_Static.get()))};
    if (!RangeBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SliderAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RangeBaseAutomationPeer_type.get())))};
    if (!SliderAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SliderAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_SliderAutomationPeer_Static, SliderAutomationPeer_Static_bases.get())};
    if (!type_SliderAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SliderAutomationPeer_bases{PyTuple_Pack(1, RangeBaseAutomationPeer_type.get())};
    if (!SliderAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle SliderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SliderAutomationPeer, SliderAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_SliderAutomationPeer_Static.get()))};
    if (!SliderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPickerSliderAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SliderAutomationPeer_type.get())))};
    if (!ColorPickerSliderAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorPickerSliderAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ColorPickerSliderAutomationPeer_Static, ColorPickerSliderAutomationPeer_Static_bases.get())};
    if (!type_ColorPickerSliderAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPickerSliderAutomationPeer_bases{PyTuple_Pack(1, SliderAutomationPeer_type.get())};
    if (!ColorPickerSliderAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorPickerSliderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ColorPickerSliderAutomationPeer, ColorPickerSliderAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorPickerSliderAutomationPeer_Static.get()))};
    if (!ColorPickerSliderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrumAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ColorSpectrumAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorSpectrumAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ColorSpectrumAutomationPeer_Static, ColorSpectrumAutomationPeer_Static_bases.get())};
    if (!type_ColorSpectrumAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrumAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ColorSpectrumAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorSpectrumAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ColorSpectrumAutomationPeer, ColorSpectrumAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorSpectrumAutomationPeer_Static.get()))};
    if (!ColorSpectrumAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ItemsControlAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ItemsControlAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemsControlAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ItemsControlAutomationPeer_Static, ItemsControlAutomationPeer_Static_bases.get())};
    if (!type_ItemsControlAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ItemsControlAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ItemsControlAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ItemsControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ItemsControlAutomationPeer, ItemsControlAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemsControlAutomationPeer_Static.get()))};
    if (!ItemsControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ItemsControlAutomationPeer_type.get())))};
    if (!SelectorAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectorAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_SelectorAutomationPeer_Static, SelectorAutomationPeer_Static_bases.get())};
    if (!type_SelectorAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorAutomationPeer_bases{PyTuple_Pack(1, ItemsControlAutomationPeer_type.get())};
    if (!SelectorAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle SelectorAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SelectorAutomationPeer, SelectorAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectorAutomationPeer_Static.get()))};
    if (!SelectorAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorAutomationPeer_type.get())))};
    if (!ComboBoxAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ComboBoxAutomationPeer_Static, ComboBoxAutomationPeer_Static_bases.get())};
    if (!type_ComboBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxAutomationPeer_bases{PyTuple_Pack(1, SelectorAutomationPeer_type.get())};
    if (!ComboBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxAutomationPeer, ComboBoxAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxAutomationPeer_Static.get()))};
    if (!ComboBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ComboBoxItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ComboBoxItemAutomationPeer_Static, ComboBoxItemAutomationPeer_Static_bases.get())};
    if (!type_ComboBoxItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ComboBoxItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxItemAutomationPeer, ComboBoxItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxItemAutomationPeer_Static.get()))};
    if (!ComboBoxItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(AutomationPeer_type.get())))};
    if (!ItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ItemAutomationPeer_Static, ItemAutomationPeer_Static_bases.get())};
    if (!type_ItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ItemAutomationPeer_bases{PyTuple_Pack(1, AutomationPeer_type.get())};
    if (!ItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ItemAutomationPeer, ItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemAutomationPeer_Static.get()))};
    if (!ItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ItemAutomationPeer_type.get())))};
    if (!SelectorItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectorItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_SelectorItemAutomationPeer_Static, SelectorItemAutomationPeer_Static_bases.get())};
    if (!type_SelectorItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorItemAutomationPeer_bases{PyTuple_Pack(1, ItemAutomationPeer_type.get())};
    if (!SelectorItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle SelectorItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SelectorItemAutomationPeer, SelectorItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectorItemAutomationPeer_Static.get()))};
    if (!SelectorItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItemDataAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorItemAutomationPeer_type.get())))};
    if (!ComboBoxItemDataAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxItemDataAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ComboBoxItemDataAutomationPeer_Static, ComboBoxItemDataAutomationPeer_Static_bases.get())};
    if (!type_ComboBoxItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItemDataAutomationPeer_bases{PyTuple_Pack(1, SelectorItemAutomationPeer_type.get())};
    if (!ComboBoxItemDataAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxItemDataAutomationPeer, ComboBoxItemDataAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxItemDataAutomationPeer_Static.get()))};
    if (!ComboBoxItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle DatePickerAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!DatePickerAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DatePickerAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_DatePickerAutomationPeer_Static, DatePickerAutomationPeer_Static_bases.get())};
    if (!type_DatePickerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DatePickerAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!DatePickerAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle DatePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_DatePickerAutomationPeer, DatePickerAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_DatePickerAutomationPeer_Static.get()))};
    if (!DatePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle DatePickerFlyoutPresenterAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!DatePickerFlyoutPresenterAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle DatePickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_DatePickerFlyoutPresenterAutomationPeer, DatePickerFlyoutPresenterAutomationPeer_bases.get(), nullptr)};
    if (!DatePickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorAutomationPeer_type.get())))};
    if (!FlipViewAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_FlipViewAutomationPeer_Static, FlipViewAutomationPeer_Static_bases.get())};
    if (!type_FlipViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewAutomationPeer_bases{PyTuple_Pack(1, SelectorAutomationPeer_type.get())};
    if (!FlipViewAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewAutomationPeer, FlipViewAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewAutomationPeer_Static.get()))};
    if (!FlipViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!FlipViewItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_FlipViewItemAutomationPeer_Static, FlipViewItemAutomationPeer_Static_bases.get())};
    if (!type_FlipViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!FlipViewItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewItemAutomationPeer, FlipViewItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewItemAutomationPeer_Static.get()))};
    if (!FlipViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItemDataAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorItemAutomationPeer_type.get())))};
    if (!FlipViewItemDataAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewItemDataAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_FlipViewItemDataAutomationPeer_Static, FlipViewItemDataAutomationPeer_Static_bases.get())};
    if (!type_FlipViewItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItemDataAutomationPeer_bases{PyTuple_Pack(1, SelectorItemAutomationPeer_type.get())};
    if (!FlipViewItemDataAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewItemDataAutomationPeer, FlipViewItemDataAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewItemDataAutomationPeer_Static.get()))};
    if (!FlipViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlyoutPresenterAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!FlyoutPresenterAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlyoutPresenterAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_FlyoutPresenterAutomationPeer_Static, FlyoutPresenterAutomationPeer_Static_bases.get())};
    if (!type_FlyoutPresenterAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlyoutPresenterAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!FlyoutPresenterAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle FlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlyoutPresenterAutomationPeer, FlyoutPresenterAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlyoutPresenterAutomationPeer_Static.get()))};
    if (!FlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBaseAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorAutomationPeer_type.get())))};
    if (!ListViewBaseAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewBaseAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListViewBaseAutomationPeer_Static, ListViewBaseAutomationPeer_Static_bases.get())};
    if (!type_ListViewBaseAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBaseAutomationPeer_bases{PyTuple_Pack(1, SelectorAutomationPeer_type.get())};
    if (!ListViewBaseAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewBaseAutomationPeer, ListViewBaseAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewBaseAutomationPeer_Static.get()))};
    if (!ListViewBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewBaseAutomationPeer_type.get())))};
    if (!GridViewAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_GridViewAutomationPeer_Static, GridViewAutomationPeer_Static_bases.get())};
    if (!type_GridViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewAutomationPeer_bases{PyTuple_Pack(1, ListViewBaseAutomationPeer_type.get())};
    if (!GridViewAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewAutomationPeer, GridViewAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewAutomationPeer_Static.get()))};
    if (!GridViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBaseHeaderItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ListViewBaseHeaderItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewBaseHeaderItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListViewBaseHeaderItemAutomationPeer_Static, ListViewBaseHeaderItemAutomationPeer_Static_bases.get())};
    if (!type_ListViewBaseHeaderItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBaseHeaderItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ListViewBaseHeaderItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewBaseHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewBaseHeaderItemAutomationPeer, ListViewBaseHeaderItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewBaseHeaderItemAutomationPeer_Static.get()))};
    if (!ListViewBaseHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewHeaderItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewBaseHeaderItemAutomationPeer_type.get())))};
    if (!GridViewHeaderItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewHeaderItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_GridViewHeaderItemAutomationPeer_Static, GridViewHeaderItemAutomationPeer_Static_bases.get())};
    if (!type_GridViewHeaderItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewHeaderItemAutomationPeer_bases{PyTuple_Pack(1, ListViewBaseHeaderItemAutomationPeer_type.get())};
    if (!GridViewHeaderItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewHeaderItemAutomationPeer, GridViewHeaderItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewHeaderItemAutomationPeer_Static.get()))};
    if (!GridViewHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!GridViewItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_GridViewItemAutomationPeer_Static, GridViewItemAutomationPeer_Static_bases.get())};
    if (!type_GridViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!GridViewItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewItemAutomationPeer, GridViewItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItemAutomationPeer_Static.get()))};
    if (!GridViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemDataAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorItemAutomationPeer_type.get())))};
    if (!GridViewItemDataAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItemDataAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_GridViewItemDataAutomationPeer_Static, GridViewItemDataAutomationPeer_Static_bases.get())};
    if (!type_GridViewItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemDataAutomationPeer_bases{PyTuple_Pack(1, SelectorItemAutomationPeer_type.get())};
    if (!GridViewItemDataAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewItemDataAutomationPeer, GridViewItemDataAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItemDataAutomationPeer_Static.get()))};
    if (!GridViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GroupItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!GroupItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GroupItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_GroupItemAutomationPeer_Static, GroupItemAutomationPeer_Static_bases.get())};
    if (!type_GroupItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GroupItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!GroupItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle GroupItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GroupItemAutomationPeer, GroupItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_GroupItemAutomationPeer_Static.get()))};
    if (!GroupItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle HubAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!HubAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_HubAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_HubAutomationPeer_Static, HubAutomationPeer_Static_bases.get())};
    if (!type_HubAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle HubAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!HubAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle HubAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HubAutomationPeer, HubAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_HubAutomationPeer_Static.get()))};
    if (!HubAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle HubSectionAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!HubSectionAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_HubSectionAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_HubSectionAutomationPeer_Static, HubSectionAutomationPeer_Static_bases.get())};
    if (!type_HubSectionAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle HubSectionAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!HubSectionAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle HubSectionAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HubSectionAutomationPeer, HubSectionAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_HubSectionAutomationPeer_Static.get()))};
    if (!HubSectionAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle HyperlinkButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonBaseAutomationPeer_type.get())))};
    if (!HyperlinkButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_HyperlinkButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_HyperlinkButtonAutomationPeer_Static, HyperlinkButtonAutomationPeer_Static_bases.get())};
    if (!type_HyperlinkButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle HyperlinkButtonAutomationPeer_bases{PyTuple_Pack(1, ButtonBaseAutomationPeer_type.get())};
    if (!HyperlinkButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle HyperlinkButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HyperlinkButtonAutomationPeer, HyperlinkButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_HyperlinkButtonAutomationPeer_Static.get()))};
    if (!HyperlinkButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ImageAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ImageAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ImageAutomationPeer_Static, ImageAutomationPeer_Static_bases.get())};
    if (!type_ImageAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ImageAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ImageAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ImageAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ImageAutomationPeer, ImageAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageAutomationPeer_Static.get()))};
    if (!ImageAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!InkToolbarAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle InkToolbarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_InkToolbarAutomationPeer, InkToolbarAutomationPeer_bases.get(), nullptr)};
    if (!InkToolbarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorAutomationPeer_type.get())))};
    if (!ListBoxAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListBoxAutomationPeer_Static, ListBoxAutomationPeer_Static_bases.get())};
    if (!type_ListBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxAutomationPeer_bases{PyTuple_Pack(1, SelectorAutomationPeer_type.get())};
    if (!ListBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxAutomationPeer, ListBoxAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxAutomationPeer_Static.get()))};
    if (!ListBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ListBoxItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListBoxItemAutomationPeer_Static, ListBoxItemAutomationPeer_Static_bases.get())};
    if (!type_ListBoxItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ListBoxItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxItemAutomationPeer, ListBoxItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxItemAutomationPeer_Static.get()))};
    if (!ListBoxItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItemDataAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorItemAutomationPeer_type.get())))};
    if (!ListBoxItemDataAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxItemDataAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListBoxItemDataAutomationPeer_Static, ListBoxItemDataAutomationPeer_Static_bases.get())};
    if (!type_ListBoxItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItemDataAutomationPeer_bases{PyTuple_Pack(1, SelectorItemAutomationPeer_type.get())};
    if (!ListBoxItemDataAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxItemDataAutomationPeer, ListBoxItemDataAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxItemDataAutomationPeer_Static.get()))};
    if (!ListBoxItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListPickerFlyoutPresenterAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ListPickerFlyoutPresenterAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListPickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListPickerFlyoutPresenterAutomationPeer, ListPickerFlyoutPresenterAutomationPeer_bases.get(), nullptr)};
    if (!ListPickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewBaseAutomationPeer_type.get())))};
    if (!ListViewAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListViewAutomationPeer_Static, ListViewAutomationPeer_Static_bases.get())};
    if (!type_ListViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewAutomationPeer_bases{PyTuple_Pack(1, ListViewBaseAutomationPeer_type.get())};
    if (!ListViewAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewAutomationPeer, ListViewAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewAutomationPeer_Static.get()))};
    if (!ListViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewHeaderItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewBaseHeaderItemAutomationPeer_type.get())))};
    if (!ListViewHeaderItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewHeaderItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListViewHeaderItemAutomationPeer_Static, ListViewHeaderItemAutomationPeer_Static_bases.get())};
    if (!type_ListViewHeaderItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewHeaderItemAutomationPeer_bases{PyTuple_Pack(1, ListViewBaseHeaderItemAutomationPeer_type.get())};
    if (!ListViewHeaderItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewHeaderItemAutomationPeer, ListViewHeaderItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewHeaderItemAutomationPeer_Static.get()))};
    if (!ListViewHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ListViewItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListViewItemAutomationPeer_Static, ListViewItemAutomationPeer_Static_bases.get())};
    if (!type_ListViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ListViewItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewItemAutomationPeer, ListViewItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItemAutomationPeer_Static.get()))};
    if (!ListViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemDataAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorItemAutomationPeer_type.get())))};
    if (!ListViewItemDataAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItemDataAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ListViewItemDataAutomationPeer_Static, ListViewItemDataAutomationPeer_Static_bases.get())};
    if (!type_ListViewItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemDataAutomationPeer_bases{PyTuple_Pack(1, SelectorItemAutomationPeer_type.get())};
    if (!ListViewItemDataAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewItemDataAutomationPeer, ListViewItemDataAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItemDataAutomationPeer_Static.get()))};
    if (!ListViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!LoopingSelectorAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorAutomationPeer, LoopingSelectorAutomationPeer_bases.get(), nullptr)};
    if (!LoopingSelectorAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!LoopingSelectorItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorItemAutomationPeer, LoopingSelectorItemAutomationPeer_bases.get(), nullptr)};
    if (!LoopingSelectorItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorItemDataAutomationPeer_bases{PyTuple_Pack(1, AutomationPeer_type.get())};
    if (!LoopingSelectorItemDataAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorItemDataAutomationPeer, LoopingSelectorItemDataAutomationPeer_bases.get(), nullptr)};
    if (!LoopingSelectorItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MapControlAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!MapControlAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MapControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MapControlAutomationPeer, MapControlAutomationPeer_bases.get(), nullptr)};
    if (!MapControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MediaElementAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!MediaElementAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaElementAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MediaElementAutomationPeer_Static, MediaElementAutomationPeer_Static_bases.get())};
    if (!type_MediaElementAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MediaElementAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!MediaElementAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MediaElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MediaElementAutomationPeer, MediaElementAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaElementAutomationPeer_Static.get()))};
    if (!MediaElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MediaPlayerElementAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!MediaPlayerElementAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaPlayerElementAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MediaPlayerElementAutomationPeer_Static, MediaPlayerElementAutomationPeer_Static_bases.get())};
    if (!type_MediaPlayerElementAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MediaPlayerElementAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!MediaPlayerElementAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MediaPlayerElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MediaPlayerElementAutomationPeer, MediaPlayerElementAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaPlayerElementAutomationPeer_Static.get()))};
    if (!MediaPlayerElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MediaTransportControlsAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!MediaTransportControlsAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaTransportControlsAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MediaTransportControlsAutomationPeer_Static, MediaTransportControlsAutomationPeer_Static_bases.get())};
    if (!type_MediaTransportControlsAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MediaTransportControlsAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!MediaTransportControlsAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MediaTransportControlsAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MediaTransportControlsAutomationPeer, MediaTransportControlsAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaTransportControlsAutomationPeer_Static.get()))};
    if (!MediaTransportControlsAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!MenuBarAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MenuBarAutomationPeer_Static, MenuBarAutomationPeer_Static_bases.get())};
    if (!type_MenuBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!MenuBarAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuBarAutomationPeer, MenuBarAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarAutomationPeer_Static.get()))};
    if (!MenuBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!MenuBarItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MenuBarItemAutomationPeer_Static, MenuBarItemAutomationPeer_Static_bases.get())};
    if (!type_MenuBarItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!MenuBarItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuBarItemAutomationPeer, MenuBarItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarItemAutomationPeer_Static.get()))};
    if (!MenuBarItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!MenuFlyoutItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuFlyoutItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MenuFlyoutItemAutomationPeer_Static, MenuFlyoutItemAutomationPeer_Static_bases.get())};
    if (!type_MenuFlyoutItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!MenuFlyoutItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyoutItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutItemAutomationPeer, MenuFlyoutItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuFlyoutItemAutomationPeer_Static.get()))};
    if (!MenuFlyoutItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutPresenterAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ItemsControlAutomationPeer_type.get())))};
    if (!MenuFlyoutPresenterAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuFlyoutPresenterAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_MenuFlyoutPresenterAutomationPeer_Static, MenuFlyoutPresenterAutomationPeer_Static_bases.get())};
    if (!type_MenuFlyoutPresenterAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutPresenterAutomationPeer_bases{PyTuple_Pack(1, ItemsControlAutomationPeer_type.get())};
    if (!MenuFlyoutPresenterAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutPresenterAutomationPeer, MenuFlyoutPresenterAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuFlyoutPresenterAutomationPeer_Static.get()))};
    if (!MenuFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewItemAutomationPeer_type.get())))};
    if (!NavigationViewItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemAutomationPeer_Static, NavigationViewItemAutomationPeer_Static_bases.get())};
    if (!type_NavigationViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemAutomationPeer_bases{PyTuple_Pack(1, ListViewItemAutomationPeer_type.get())};
    if (!NavigationViewItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemAutomationPeer, NavigationViewItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemAutomationPeer_Static.get()))};
    if (!NavigationViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PasswordBoxAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!PasswordBoxAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PasswordBoxAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_PasswordBoxAutomationPeer_Static, PasswordBoxAutomationPeer_Static_bases.get())};
    if (!type_PasswordBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PasswordBoxAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!PasswordBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle PasswordBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PasswordBoxAutomationPeer, PasswordBoxAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_PasswordBoxAutomationPeer_Static.get()))};
    if (!PasswordBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PersonPictureAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!PersonPictureAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PersonPictureAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_PersonPictureAutomationPeer_Static, PersonPictureAutomationPeer_Static_bases.get())};
    if (!type_PersonPictureAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PersonPictureAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!PersonPictureAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle PersonPictureAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PersonPictureAutomationPeer, PersonPictureAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_PersonPictureAutomationPeer_Static.get()))};
    if (!PersonPictureAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyoutPresenterAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!PickerFlyoutPresenterAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle PickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PickerFlyoutPresenterAutomationPeer, PickerFlyoutPresenterAutomationPeer_bases.get(), nullptr)};
    if (!PickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotAutomationPeer_bases{PyTuple_Pack(1, ItemsControlAutomationPeer_type.get())};
    if (!PivotAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotAutomationPeer, PivotAutomationPeer_bases.get(), nullptr)};
    if (!PivotAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!PivotItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotItemAutomationPeer, PivotItemAutomationPeer_bases.get(), nullptr)};
    if (!PivotItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotItemDataAutomationPeer_bases{PyTuple_Pack(1, ItemAutomationPeer_type.get())};
    if (!PivotItemDataAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotItemDataAutomationPeer, PivotItemDataAutomationPeer_bases.get(), nullptr)};
    if (!PivotItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBarAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RangeBaseAutomationPeer_type.get())))};
    if (!ProgressBarAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressBarAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ProgressBarAutomationPeer_Static, ProgressBarAutomationPeer_Static_bases.get())};
    if (!type_ProgressBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBarAutomationPeer_bases{PyTuple_Pack(1, RangeBaseAutomationPeer_type.get())};
    if (!ProgressBarAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ProgressBarAutomationPeer, ProgressBarAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressBarAutomationPeer_Static.get()))};
    if (!ProgressBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRingAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ProgressRingAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressRingAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ProgressRingAutomationPeer_Static, ProgressRingAutomationPeer_Static_bases.get())};
    if (!type_ProgressRingAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRingAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ProgressRingAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressRingAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ProgressRingAutomationPeer, ProgressRingAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressRingAutomationPeer_Static.get()))};
    if (!ProgressRingAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ToggleButtonAutomationPeer_type.get())))};
    if (!RadioButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RadioButtonAutomationPeer_Static, RadioButtonAutomationPeer_Static_bases.get())};
    if (!type_RadioButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButtonAutomationPeer_bases{PyTuple_Pack(1, ToggleButtonAutomationPeer_type.get())};
    if (!RadioButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RadioButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RadioButtonAutomationPeer, RadioButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButtonAutomationPeer_Static.get()))};
    if (!RadioButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RatingControlAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!RatingControlAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RatingControlAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RatingControlAutomationPeer_Static, RatingControlAutomationPeer_Static_bases.get())};
    if (!type_RatingControlAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RatingControlAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!RatingControlAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RatingControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RatingControlAutomationPeer, RatingControlAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RatingControlAutomationPeer_Static.get()))};
    if (!RatingControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatButtonAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonBaseAutomationPeer_type.get())))};
    if (!RepeatButtonAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeatButtonAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RepeatButtonAutomationPeer_Static, RepeatButtonAutomationPeer_Static_bases.get())};
    if (!type_RepeatButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatButtonAutomationPeer_bases{PyTuple_Pack(1, ButtonBaseAutomationPeer_type.get())};
    if (!RepeatButtonAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RepeatButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RepeatButtonAutomationPeer, RepeatButtonAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatButtonAutomationPeer_Static.get()))};
    if (!RepeatButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RichEditBoxAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!RichEditBoxAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RichEditBoxAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RichEditBoxAutomationPeer_Static, RichEditBoxAutomationPeer_Static_bases.get())};
    if (!type_RichEditBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RichEditBoxAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!RichEditBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RichEditBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichEditBoxAutomationPeer, RichEditBoxAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RichEditBoxAutomationPeer_Static.get()))};
    if (!RichEditBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RichTextBlockAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!RichTextBlockAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RichTextBlockAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RichTextBlockAutomationPeer_Static, RichTextBlockAutomationPeer_Static_bases.get())};
    if (!type_RichTextBlockAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RichTextBlockAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!RichTextBlockAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RichTextBlockAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichTextBlockAutomationPeer, RichTextBlockAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RichTextBlockAutomationPeer_Static.get()))};
    if (!RichTextBlockAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RichTextBlockOverflowAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!RichTextBlockOverflowAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RichTextBlockOverflowAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_RichTextBlockOverflowAutomationPeer_Static, RichTextBlockOverflowAutomationPeer_Static_bases.get())};
    if (!type_RichTextBlockOverflowAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RichTextBlockOverflowAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!RichTextBlockOverflowAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle RichTextBlockOverflowAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichTextBlockOverflowAutomationPeer, RichTextBlockOverflowAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_RichTextBlockOverflowAutomationPeer_Static.get()))};
    if (!RichTextBlockOverflowAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollBarAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RangeBaseAutomationPeer_type.get())))};
    if (!ScrollBarAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollBarAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ScrollBarAutomationPeer_Static, ScrollBarAutomationPeer_Static_bases.get())};
    if (!type_ScrollBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollBarAutomationPeer_bases{PyTuple_Pack(1, RangeBaseAutomationPeer_type.get())};
    if (!ScrollBarAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ScrollBarAutomationPeer, ScrollBarAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollBarAutomationPeer_Static.get()))};
    if (!ScrollBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollViewerAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ScrollViewerAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollViewerAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ScrollViewerAutomationPeer_Static, ScrollViewerAutomationPeer_Static_bases.get())};
    if (!type_ScrollViewerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollViewerAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ScrollViewerAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollViewerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ScrollViewerAutomationPeer, ScrollViewerAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollViewerAutomationPeer_Static.get()))};
    if (!ScrollViewerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SearchBoxAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!SearchBoxAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SearchBoxAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_SearchBoxAutomationPeer_Static, SearchBoxAutomationPeer_Static_bases.get())};
    if (!type_SearchBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SearchBoxAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!SearchBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle SearchBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SearchBoxAutomationPeer, SearchBoxAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_SearchBoxAutomationPeer_Static.get()))};
    if (!SearchBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SemanticZoomAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!SemanticZoomAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SemanticZoomAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_SemanticZoomAutomationPeer_Static, SemanticZoomAutomationPeer_Static_bases.get())};
    if (!type_SemanticZoomAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SemanticZoomAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!SemanticZoomAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle SemanticZoomAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SemanticZoomAutomationPeer, SemanticZoomAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_SemanticZoomAutomationPeer_Static.get()))};
    if (!SemanticZoomAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SettingsFlyoutAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!SettingsFlyoutAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SettingsFlyoutAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_SettingsFlyoutAutomationPeer_Static, SettingsFlyoutAutomationPeer_Static_bases.get())};
    if (!type_SettingsFlyoutAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SettingsFlyoutAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!SettingsFlyoutAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle SettingsFlyoutAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SettingsFlyoutAutomationPeer, SettingsFlyoutAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_SettingsFlyoutAutomationPeer_Static.get()))};
    if (!SettingsFlyoutAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextBlockAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!TextBlockAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextBlockAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TextBlockAutomationPeer_Static, TextBlockAutomationPeer_Static_bases.get())};
    if (!type_TextBlockAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TextBlockAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!TextBlockAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TextBlockAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TextBlockAutomationPeer, TextBlockAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextBlockAutomationPeer_Static.get()))};
    if (!TextBlockAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextBoxAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!TextBoxAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextBoxAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TextBoxAutomationPeer_Static, TextBoxAutomationPeer_Static_bases.get())};
    if (!type_TextBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TextBoxAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!TextBoxAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TextBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TextBoxAutomationPeer, TextBoxAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextBoxAutomationPeer_Static.get()))};
    if (!TextBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ThumbAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ThumbAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ThumbAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ThumbAutomationPeer_Static, ThumbAutomationPeer_Static_bases.get())};
    if (!type_ThumbAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ThumbAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ThumbAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ThumbAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ThumbAutomationPeer, ThumbAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ThumbAutomationPeer_Static.get()))};
    if (!ThumbAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TimePickerAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!TimePickerAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimePickerAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TimePickerAutomationPeer_Static, TimePickerAutomationPeer_Static_bases.get())};
    if (!type_TimePickerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TimePickerAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!TimePickerAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TimePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TimePickerAutomationPeer, TimePickerAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimePickerAutomationPeer_Static.get()))};
    if (!TimePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TimePickerFlyoutPresenterAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!TimePickerFlyoutPresenterAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TimePickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TimePickerFlyoutPresenterAutomationPeer, TimePickerFlyoutPresenterAutomationPeer_bases.get(), nullptr)};
    if (!TimePickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleMenuFlyoutItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ToggleMenuFlyoutItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleMenuFlyoutItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ToggleMenuFlyoutItemAutomationPeer_Static, ToggleMenuFlyoutItemAutomationPeer_Static_bases.get())};
    if (!type_ToggleMenuFlyoutItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleMenuFlyoutItemAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ToggleMenuFlyoutItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleMenuFlyoutItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleMenuFlyoutItemAutomationPeer, ToggleMenuFlyoutItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleMenuFlyoutItemAutomationPeer_Static.get()))};
    if (!ToggleMenuFlyoutItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSwitchAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FrameworkElementAutomationPeer_type.get())))};
    if (!ToggleSwitchAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleSwitchAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_ToggleSwitchAutomationPeer_Static, ToggleSwitchAutomationPeer_Static_bases.get())};
    if (!type_ToggleSwitchAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSwitchAutomationPeer_bases{PyTuple_Pack(1, FrameworkElementAutomationPeer_type.get())};
    if (!ToggleSwitchAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleSwitchAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleSwitchAutomationPeer, ToggleSwitchAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleSwitchAutomationPeer_Static.get()))};
    if (!ToggleSwitchAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ListViewItemAutomationPeer_type.get())))};
    if (!TreeViewItemAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItemAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TreeViewItemAutomationPeer_Static, TreeViewItemAutomationPeer_Static_bases.get())};
    if (!type_TreeViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemAutomationPeer_bases{PyTuple_Pack(1, ListViewItemAutomationPeer_type.get())};
    if (!TreeViewItemAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewItemAutomationPeer, TreeViewItemAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItemAutomationPeer_Static.get()))};
    if (!TreeViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewListAutomationPeer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SelectorAutomationPeer_type.get())))};
    if (!TreeViewListAutomationPeer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewListAutomationPeer_Static{PyType_FromSpecWithBases(&type_spec_TreeViewListAutomationPeer_Static, TreeViewListAutomationPeer_Static_bases.get())};
    if (!type_TreeViewListAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewListAutomationPeer_bases{PyTuple_Pack(1, SelectorAutomationPeer_type.get())};
    if (!TreeViewListAutomationPeer_bases)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewListAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewListAutomationPeer, TreeViewListAutomationPeer_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewListAutomationPeer_Static.get()))};
    if (!TreeViewListAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle RawElementProviderRuntimeId_type{py::register_python_type(module.get(), &type_spec_RawElementProviderRuntimeId, nullptr, nullptr)};
    if (!RawElementProviderRuntimeId_type)
    {
        return nullptr;
    }


    return module.detach();
}
