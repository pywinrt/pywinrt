// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Automation.Peers.h"


namespace py::cpp::Windows::UI::Xaml::Automation::Peers
{
    // ----- AppBarAutomationPeer class --------------------

    static PyObject* _new_AppBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBar>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarAutomationPeer_Close(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Collapse", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Expand", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_SetVisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"SetVisualState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Toggle", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_WaitForInputIdle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"WaitForInputIdle", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"ExpandCollapseState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"ToggleState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_InteractionState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"InteractionState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_IsModal(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"IsModal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_IsTopmost(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"IsTopmost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_Maximizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Maximizable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_Minimizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Minimizable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_VisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"VisualState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarAutomationPeer[] = {
        { "close", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Close), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_SetVisualState), METH_VARARGS, nullptr },
        { "toggle", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "toggle_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { "interaction_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(AppBarAutomationPeer_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(AppBarAutomationPeer_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(AppBarAutomationPeer_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(AppBarAutomationPeer_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AppBarAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarAutomationPeer
    };

    // ----- AppBarButtonAutomationPeer class --------------------

    static PyObject* _new_AppBarButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBarButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButtonAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"Collapse", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarButtonAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"Expand", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarButtonAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"ExpandCollapseState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(AppBarButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(AppBarButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBarButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(AppBarButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AppBarButtonAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButtonAutomationPeer
    };

    // ----- AppBarToggleButtonAutomationPeer class --------------------

    static PyObject* _new_AppBarToggleButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarToggleButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AppBarToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButtonAutomationPeer[] = {
        { "_assign_array_", _assign_array_AppBarToggleButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AppBarToggleButtonAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AppBarToggleButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButtonAutomationPeer
    };

    // ----- AutoSuggestBoxAutomationPeer class --------------------

    static PyObject* _new_AutoSuggestBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AutoSuggestBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutoSuggestBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoSuggestBoxAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutoSuggestBoxAutomationPeer", L"Invoke", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoSuggestBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoSuggestBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoSuggestBoxAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(AutoSuggestBoxAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutoSuggestBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoSuggestBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoSuggestBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AutoSuggestBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoSuggestBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoSuggestBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoSuggestBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoSuggestBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AutoSuggestBoxAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutoSuggestBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoSuggestBoxAutomationPeer
    };

    // ----- AutomationPeer class --------------------

    static PyObject* _new_AutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_AutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationPeer_GenerateRawElementProviderRuntimeId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GenerateRawElementProviderRuntimeId", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer::GenerateRawElementProviderRuntimeId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAcceleratorKey(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAcceleratorKey", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAcceleratorKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAccessKey(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAccessKey", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAccessKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAnnotations(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAnnotations", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAnnotations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationControlType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationControlType", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAutomationControlType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationId(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationId", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAutomationId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetBoundingRectangle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetBoundingRectangle", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBoundingRectangle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetChildren(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetChildren", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetChildren());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClassName(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClassName", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClassName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClickablePoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClickablePoint", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClickablePoint());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetControlledPeers(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetControlledPeers", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetControlledPeers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetCulture(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetCulture", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCulture());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetElementFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetElementFromPoint", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.GetElementFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFocusedElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFocusedElement", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetFocusedElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFullDescription(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFullDescription", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetFullDescription());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHeadingLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHeadingLevel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetHeadingLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHelpText(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHelpText", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetHelpText());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemStatus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemStatus", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetItemStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemType", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetItemType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLabeledBy(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLabeledBy", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLabeledBy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLandmarkType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLandmarkType", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLandmarkType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLevel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLiveSetting(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLiveSetting", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLiveSetting());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedControlType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedControlType", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLocalizedControlType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedLandmarkType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedLandmarkType", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLocalizedLandmarkType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetName(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetName", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetOrientation(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetOrientation", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetOrientation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetParent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetParent", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetParent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPattern(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPattern", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::PatternInterface>(args, 0);

                return py::convert(self->obj.GetPattern(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPeerFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPeerFromPoint", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.GetPeerFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPositionInSet(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPositionInSet", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPositionInSet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetSizeOfSet(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetSizeOfSet", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSizeOfSet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_HasKeyboardFocus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"HasKeyboardFocus", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.HasKeyboardFocus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_InvalidatePeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"InvalidatePeer", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.InvalidatePeer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsContentElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsContentElement", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsContentElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsControlElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsControlElement", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsControlElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDataValidForForm(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDataValidForForm", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsDataValidForForm());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDialog(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDialog", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsDialog());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsEnabled(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsEnabled", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsKeyboardFocusable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsKeyboardFocusable", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsKeyboardFocusable());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsOffscreen(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsOffscreen", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsOffscreen());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPassword(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPassword", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsPassword());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPeripheral(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPeripheral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsPeripheral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsRequiredForForm(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsRequiredForForm", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsRequiredForForm());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ListenerExists(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"ListenerExists", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationEvents>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer::ListenerExists(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_Navigate(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"Navigate", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNavigationDirection>(args, 0);

                return py::convert(self->obj.Navigate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseAutomationEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseAutomationEvent", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationEvents>(args, 0);

                self->obj.RaiseAutomationEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseNotificationEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseNotificationEvent", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNotificationKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNotificationProcessing>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                self->obj.RaiseNotificationEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaisePropertyChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaisePropertyChangedEvent", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.RaisePropertyChangedEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseStructureChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseStructureChangedEvent", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationStructureChangeType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 1);

                self->obj.RaiseStructureChangedEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseTextEditTextChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseTextEditTextChangedEvent", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationTextEditChangeType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 1);

                self->obj.RaiseTextEditTextChangedEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetFocus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"SetFocus", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetFocus();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetParent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"SetParent", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 0);

                self->obj.SetParent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ShowContextMenu(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"ShowContextMenu", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ShowContextMenu();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_get_EventsSource(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"EventsSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EventsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeer_put_EventsSource(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"EventsSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(arg);

            self->obj.EventsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationPeer[] = {
        { "get_accelerator_key", reinterpret_cast<PyCFunction>(AutomationPeer_GetAcceleratorKey), METH_VARARGS, nullptr },
        { "get_access_key", reinterpret_cast<PyCFunction>(AutomationPeer_GetAccessKey), METH_VARARGS, nullptr },
        { "get_annotations", reinterpret_cast<PyCFunction>(AutomationPeer_GetAnnotations), METH_VARARGS, nullptr },
        { "get_automation_control_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationControlType), METH_VARARGS, nullptr },
        { "get_automation_id", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationId), METH_VARARGS, nullptr },
        { "get_bounding_rectangle", reinterpret_cast<PyCFunction>(AutomationPeer_GetBoundingRectangle), METH_VARARGS, nullptr },
        { "get_children", reinterpret_cast<PyCFunction>(AutomationPeer_GetChildren), METH_VARARGS, nullptr },
        { "get_class_name", reinterpret_cast<PyCFunction>(AutomationPeer_GetClassName), METH_VARARGS, nullptr },
        { "get_clickable_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetClickablePoint), METH_VARARGS, nullptr },
        { "get_controlled_peers", reinterpret_cast<PyCFunction>(AutomationPeer_GetControlledPeers), METH_VARARGS, nullptr },
        { "get_culture", reinterpret_cast<PyCFunction>(AutomationPeer_GetCulture), METH_VARARGS, nullptr },
        { "get_element_from_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetElementFromPoint), METH_VARARGS, nullptr },
        { "get_focused_element", reinterpret_cast<PyCFunction>(AutomationPeer_GetFocusedElement), METH_VARARGS, nullptr },
        { "get_full_description", reinterpret_cast<PyCFunction>(AutomationPeer_GetFullDescription), METH_VARARGS, nullptr },
        { "get_heading_level", reinterpret_cast<PyCFunction>(AutomationPeer_GetHeadingLevel), METH_VARARGS, nullptr },
        { "get_help_text", reinterpret_cast<PyCFunction>(AutomationPeer_GetHelpText), METH_VARARGS, nullptr },
        { "get_item_status", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemStatus), METH_VARARGS, nullptr },
        { "get_item_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemType), METH_VARARGS, nullptr },
        { "get_labeled_by", reinterpret_cast<PyCFunction>(AutomationPeer_GetLabeledBy), METH_VARARGS, nullptr },
        { "get_landmark_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLandmarkType), METH_VARARGS, nullptr },
        { "get_level", reinterpret_cast<PyCFunction>(AutomationPeer_GetLevel), METH_VARARGS, nullptr },
        { "get_live_setting", reinterpret_cast<PyCFunction>(AutomationPeer_GetLiveSetting), METH_VARARGS, nullptr },
        { "get_localized_control_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedControlType), METH_VARARGS, nullptr },
        { "get_localized_landmark_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedLandmarkType), METH_VARARGS, nullptr },
        { "get_name", reinterpret_cast<PyCFunction>(AutomationPeer_GetName), METH_VARARGS, nullptr },
        { "get_orientation", reinterpret_cast<PyCFunction>(AutomationPeer_GetOrientation), METH_VARARGS, nullptr },
        { "get_parent", reinterpret_cast<PyCFunction>(AutomationPeer_GetParent), METH_VARARGS, nullptr },
        { "get_pattern", reinterpret_cast<PyCFunction>(AutomationPeer_GetPattern), METH_VARARGS, nullptr },
        { "get_peer_from_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetPeerFromPoint), METH_VARARGS, nullptr },
        { "get_position_in_set", reinterpret_cast<PyCFunction>(AutomationPeer_GetPositionInSet), METH_VARARGS, nullptr },
        { "get_size_of_set", reinterpret_cast<PyCFunction>(AutomationPeer_GetSizeOfSet), METH_VARARGS, nullptr },
        { "has_keyboard_focus", reinterpret_cast<PyCFunction>(AutomationPeer_HasKeyboardFocus), METH_VARARGS, nullptr },
        { "invalidate_peer", reinterpret_cast<PyCFunction>(AutomationPeer_InvalidatePeer), METH_VARARGS, nullptr },
        { "is_content_element", reinterpret_cast<PyCFunction>(AutomationPeer_IsContentElement), METH_VARARGS, nullptr },
        { "is_control_element", reinterpret_cast<PyCFunction>(AutomationPeer_IsControlElement), METH_VARARGS, nullptr },
        { "is_data_valid_for_form", reinterpret_cast<PyCFunction>(AutomationPeer_IsDataValidForForm), METH_VARARGS, nullptr },
        { "is_dialog", reinterpret_cast<PyCFunction>(AutomationPeer_IsDialog), METH_VARARGS, nullptr },
        { "is_enabled", reinterpret_cast<PyCFunction>(AutomationPeer_IsEnabled), METH_VARARGS, nullptr },
        { "is_keyboard_focusable", reinterpret_cast<PyCFunction>(AutomationPeer_IsKeyboardFocusable), METH_VARARGS, nullptr },
        { "is_offscreen", reinterpret_cast<PyCFunction>(AutomationPeer_IsOffscreen), METH_VARARGS, nullptr },
        { "is_password", reinterpret_cast<PyCFunction>(AutomationPeer_IsPassword), METH_VARARGS, nullptr },
        { "is_peripheral", reinterpret_cast<PyCFunction>(AutomationPeer_IsPeripheral), METH_VARARGS, nullptr },
        { "is_required_for_form", reinterpret_cast<PyCFunction>(AutomationPeer_IsRequiredForForm), METH_VARARGS, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(AutomationPeer_Navigate), METH_VARARGS, nullptr },
        { "raise_automation_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseAutomationEvent), METH_VARARGS, nullptr },
        { "raise_notification_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseNotificationEvent), METH_VARARGS, nullptr },
        { "raise_property_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaisePropertyChangedEvent), METH_VARARGS, nullptr },
        { "raise_structure_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseStructureChangedEvent), METH_VARARGS, nullptr },
        { "raise_text_edit_text_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseTextEditTextChangedEvent), METH_VARARGS, nullptr },
        { "set_focus", reinterpret_cast<PyCFunction>(AutomationPeer_SetFocus), METH_VARARGS, nullptr },
        { "set_parent", reinterpret_cast<PyCFunction>(AutomationPeer_SetParent), METH_VARARGS, nullptr },
        { "show_context_menu", reinterpret_cast<PyCFunction>(AutomationPeer_ShowContextMenu), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationPeer[] = {
        { "events_source", reinterpret_cast<getter>(AutomationPeer_get_EventsSource), reinterpret_cast<setter>(AutomationPeer_put_EventsSource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationPeer
    };

    static PyGetSetDef getset_AutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AutomationPeer_Static[] = {
        { "generate_raw_element_provider_runtime_id", reinterpret_cast<PyCFunction>(AutomationPeer_GenerateRawElementProviderRuntimeId), METH_VARARGS, nullptr },
        { "listener_exists", reinterpret_cast<PyCFunction>(AutomationPeer_ListenerExists), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationPeer_Static
    };

    // ----- AutomationPeerAnnotation class --------------------

    static PyObject* _new_AutomationPeerAnnotation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutomationPeerAnnotation(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationPeerAnnotation_get_Type(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeerAnnotation_put_Type(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_Peer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Peer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Peer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeerAnnotation_put_Peer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Peer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(arg);

            self->obj.Peer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_PeerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"PeerProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation::PeerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_TypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"TypeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation::TypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationPeerAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationPeerAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationPeerAnnotation[] = {
        { "_assign_array_", _assign_array_AutomationPeerAnnotation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationPeerAnnotation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationPeerAnnotation[] = {
        { "type", reinterpret_cast<getter>(AutomationPeerAnnotation_get_Type), reinterpret_cast<setter>(AutomationPeerAnnotation_put_Type), nullptr, nullptr },
        { "peer", reinterpret_cast<getter>(AutomationPeerAnnotation_get_Peer), reinterpret_cast<setter>(AutomationPeerAnnotation_put_Peer), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationPeerAnnotation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationPeerAnnotation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationPeerAnnotation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationPeerAnnotation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationPeerAnnotation) },
        { },
    };

    static PyType_Spec type_spec_AutomationPeerAnnotation =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutomationPeerAnnotation",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationPeerAnnotation
    };

    static PyGetSetDef getset_AutomationPeerAnnotation_Static[] = {
        { "peer_property", reinterpret_cast<getter>(AutomationPeerAnnotation_get_PeerProperty), nullptr, nullptr, nullptr },
        { "type_property", reinterpret_cast<getter>(AutomationPeerAnnotation_get_TypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AutomationPeerAnnotation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AutomationPeerAnnotation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationPeerAnnotation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationPeerAnnotation_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeerAnnotation_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.AutomationPeerAnnotation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationPeerAnnotation_Static
    };

    // ----- ButtonAutomationPeer class --------------------

    static PyObject* _new_ButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Button>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ButtonAutomationPeer", L"Invoke", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(ButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ButtonAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ButtonAutomationPeer
    };

    // ----- ButtonBaseAutomationPeer class --------------------

    static PyObject* _new_ButtonBaseAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ButtonBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ButtonBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonBaseAutomationPeer[] = {
        { "_assign_array_", _assign_array_ButtonBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonBaseAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ButtonBaseAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonBaseAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ButtonBaseAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ButtonBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ButtonBaseAutomationPeer
    };

    // ----- CalendarDatePickerAutomationPeer class --------------------

    static PyObject* _new_CalendarDatePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CalendarDatePicker>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CalendarDatePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarDatePickerAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"Invoke", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"SetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"IsReadOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarDatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarDatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarDatePickerAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(CalendarDatePickerAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(CalendarDatePickerAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CalendarDatePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarDatePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarDatePickerAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(CalendarDatePickerAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(CalendarDatePickerAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarDatePickerAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarDatePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarDatePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarDatePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarDatePickerAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_CalendarDatePickerAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.CalendarDatePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarDatePickerAutomationPeer
    };

    // ----- CaptureElementAutomationPeer class --------------------

    static PyObject* _new_CaptureElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CaptureElement>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CaptureElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CaptureElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CaptureElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CaptureElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_CaptureElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CaptureElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CaptureElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_CaptureElementAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CaptureElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CaptureElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CaptureElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CaptureElementAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_CaptureElementAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.CaptureElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CaptureElementAutomationPeer
    };

    // ----- CheckBoxAutomationPeer class --------------------

    static PyObject* _new_CheckBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CheckBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CheckBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CheckBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CheckBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CheckBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_CheckBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CheckBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CheckBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_CheckBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CheckBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CheckBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CheckBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CheckBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_CheckBoxAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.CheckBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CheckBoxAutomationPeer
    };

    // ----- ColorPickerSliderAutomationPeer class --------------------

    static PyObject* _new_ColorPickerSliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ColorPickerSlider>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPickerSliderAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPickerSliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorPickerSliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPickerSliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorPickerSliderAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ColorPickerSliderAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPickerSliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPickerSliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPickerSliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPickerSliderAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ColorPickerSliderAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ColorPickerSliderAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorPickerSliderAutomationPeer
    };

    // ----- ColorSpectrumAutomationPeer class --------------------

    static PyObject* _new_ColorSpectrumAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrumAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrumAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorSpectrumAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrumAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorSpectrumAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ColorSpectrumAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrumAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrumAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrumAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrumAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ColorSpectrumAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ColorSpectrumAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorSpectrumAutomationPeer
    };

    // ----- ComboBoxAutomationPeer class --------------------

    static PyObject* _new_ComboBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxAutomationPeer_Close(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Collapse", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Expand", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"SetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_SetVisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"SetVisualState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_WaitForInputIdle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"WaitForInputIdle", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"ExpandCollapseState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsReadOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_InteractionState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"InteractionState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsModal(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsModal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsTopmost(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsTopmost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Maximizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Maximizable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Minimizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Minimizable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_VisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"VisualState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxAutomationPeer[] = {
        { "close", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Close), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_SetVisualState), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ComboBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { "interaction_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxAutomationPeer
    };

    // ----- ComboBoxItemAutomationPeer class --------------------

    static PyObject* _new_ComboBoxItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ComboBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ComboBoxItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItemAutomationPeer
    };

    // ----- ComboBoxItemDataAutomationPeer class --------------------

    static PyObject* _new_ComboBoxItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxItemDataAutomationPeer", L"ScrollIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ComboBoxItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ComboBoxItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxItemDataAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ComboBoxItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItemDataAutomationPeer
    };

    // ----- DatePickerAutomationPeer class --------------------

    static PyObject* _new_DatePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DatePicker>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerAutomationPeer[] = {
        { "_assign_array_", _assign_array_DatePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_DatePickerAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_DatePickerAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.DatePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerAutomationPeer
    };

    // ----- DatePickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_DatePickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_DatePickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DatePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_DatePickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_DatePickerFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_DatePickerFlyoutPresenterAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.DatePickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerFlyoutPresenterAutomationPeer
    };

    // ----- FlipViewAutomationPeer class --------------------

    static PyObject* _new_FlipViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlipView>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlipViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FlipViewAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewAutomationPeer
    };

    // ----- FlipViewItemAutomationPeer class --------------------

    static PyObject* _new_FlipViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlipViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlipViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FlipViewItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItemAutomationPeer
    };

    // ----- FlipViewItemDataAutomationPeer class --------------------

    static PyObject* _new_FlipViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlipViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FlipViewItemDataAutomationPeer", L"ScrollIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlipViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(FlipViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FlipViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FlipViewItemDataAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlipViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItemDataAutomationPeer
    };

    // ----- FlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_FlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlyoutPresenter>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FlyoutPresenterAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlyoutPresenterAutomationPeer
    };

    // ----- FrameworkElementAutomationPeer class --------------------

    static PyObject* _new_FrameworkElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameworkElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameworkElementAutomationPeer_CreatePeerForElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"CreatePeerForElement", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer::CreatePeerForElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElementAutomationPeer_FromElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"FromElement", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer::FromElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElementAutomationPeer_get_Owner(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"Owner"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Owner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameworkElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameworkElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameworkElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_FrameworkElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameworkElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameworkElementAutomationPeer[] = {
        { "owner", reinterpret_cast<getter>(FrameworkElementAutomationPeer_get_Owner), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameworkElementAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameworkElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameworkElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameworkElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameworkElementAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FrameworkElementAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FrameworkElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameworkElementAutomationPeer
    };

    static PyGetSetDef getset_FrameworkElementAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FrameworkElementAutomationPeer_Static[] = {
        { "create_peer_for_element", reinterpret_cast<PyCFunction>(FrameworkElementAutomationPeer_CreatePeerForElement), METH_VARARGS, nullptr },
        { "from_element", reinterpret_cast<PyCFunction>(FrameworkElementAutomationPeer_FromElement), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FrameworkElementAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FrameworkElementAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FrameworkElementAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FrameworkElementAutomationPeer_Static =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.FrameworkElementAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FrameworkElementAutomationPeer_Static
    };

    // ----- GridViewAutomationPeer class --------------------

    static PyObject* _new_GridViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridView>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GridViewAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewAutomationPeer
    };

    // ----- GridViewHeaderItemAutomationPeer class --------------------

    static PyObject* _new_GridViewHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridViewHeaderItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewHeaderItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewHeaderItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GridViewHeaderItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewHeaderItemAutomationPeer
    };

    // ----- GridViewItemAutomationPeer class --------------------

    static PyObject* _new_GridViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GridViewItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemAutomationPeer
    };

    // ----- GridViewItemDataAutomationPeer class --------------------

    static PyObject* _new_GridViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.GridViewItemDataAutomationPeer", L"ScrollIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(GridViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GridViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GridViewItemDataAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GridViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemDataAutomationPeer
    };

    // ----- GroupItemAutomationPeer class --------------------

    static PyObject* _new_GroupItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GroupItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GroupItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GroupItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GroupItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GroupItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GroupItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GroupItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GroupItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GroupItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GroupItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GroupItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GroupItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GroupItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GroupItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.GroupItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GroupItemAutomationPeer
    };

    // ----- HubAutomationPeer class --------------------

    static PyObject* _new_HubAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Hub>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HubAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HubAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HubAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HubAutomationPeer[] = {
        { "_assign_array_", _assign_array_HubAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HubAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HubAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HubAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HubAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HubAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HubAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HubAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_HubAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.HubAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HubAutomationPeer
    };

    // ----- HubSectionAutomationPeer class --------------------

    static PyObject* _new_HubSectionAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::HubSection>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HubSectionAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HubSectionAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.HubSectionAutomationPeer", L"ScrollIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HubSectionAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HubSectionAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HubSectionAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(HubSectionAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HubSectionAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HubSectionAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HubSectionAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HubSectionAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HubSectionAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HubSectionAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HubSectionAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HubSectionAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_HubSectionAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.HubSectionAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HubSectionAutomationPeer
    };

    // ----- HyperlinkButtonAutomationPeer class --------------------

    static PyObject* _new_HyperlinkButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HyperlinkButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HyperlinkButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.HyperlinkButtonAutomationPeer", L"Invoke", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HyperlinkButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(HyperlinkButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HyperlinkButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HyperlinkButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_HyperlinkButtonAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.HyperlinkButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HyperlinkButtonAutomationPeer
    };

    // ----- ImageAutomationPeer class --------------------

    static PyObject* _new_ImageAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Image>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ImageAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageAutomationPeer[] = {
        { "_assign_array_", _assign_array_ImageAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ImageAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ImageAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ImageAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageAutomationPeer
    };

    // ----- InkToolbarAutomationPeer class --------------------

    static PyObject* _new_InkToolbarAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarAutomationPeer[] = {
        { "_assign_array_", _assign_array_InkToolbarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.InkToolbarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarAutomationPeer
    };

    // ----- ItemAutomationPeer class --------------------

    static PyObject* _new_ItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"Realize", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemAutomationPeer_get_Item(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"Item"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Item());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemAutomationPeer_get_ItemsControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"ItemsControlAutomationPeer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemsControlAutomationPeer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemAutomationPeer[] = {
        { "realize", reinterpret_cast<PyCFunction>(ItemAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemAutomationPeer[] = {
        { "item", reinterpret_cast<getter>(ItemAutomationPeer_get_Item), nullptr, nullptr, nullptr },
        { "items_control_automation_peer", reinterpret_cast<getter>(ItemAutomationPeer_get_ItemsControlAutomationPeer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemAutomationPeer
    };

    // ----- ItemsControlAutomationPeer class --------------------

    static PyObject* _new_ItemsControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ItemsControl>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemsControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsControlAutomationPeer_CreateItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"CreateItemAutomationPeer", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CreateItemAutomationPeer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsControlAutomationPeer_FindItemByProperty(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"FindItemByProperty", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsControlAutomationPeer[] = {
        { "create_item_automation_peer", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_CreateItemAutomationPeer), METH_VARARGS, nullptr },
        { "find_item_by_property", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_FindItemByProperty), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemsControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemsControlAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ItemsControlAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsControlAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ItemsControlAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ItemsControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsControlAutomationPeer
    };

    // ----- ListBoxAutomationPeer class --------------------

    static PyObject* _new_ListBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListBoxAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxAutomationPeer
    };

    // ----- ListBoxItemAutomationPeer class --------------------

    static PyObject* _new_ListBoxItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListBoxItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListBoxItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListBoxItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItemAutomationPeer
    };

    // ----- ListBoxItemDataAutomationPeer class --------------------

    static PyObject* _new_ListBoxItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListBoxItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ListBoxItemDataAutomationPeer", L"ScrollIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListBoxItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListBoxItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListBoxItemDataAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListBoxItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItemDataAutomationPeer
    };

    // ----- ListPickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_ListPickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ListPickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListPickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListPickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListPickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListPickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListPickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListPickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListPickerFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListPickerFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListPickerFlyoutPresenterAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListPickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListPickerFlyoutPresenterAutomationPeer
    };

    // ----- ListViewAutomationPeer class --------------------

    static PyObject* _new_ListViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListView>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewAutomationPeer
    };

    // ----- ListViewBaseAutomationPeer class --------------------

    static PyObject* _new_ListViewBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewBase>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewBaseAutomationPeer_get_DropEffect(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer", L"DropEffect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DropEffect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBaseAutomationPeer_get_DropEffects(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer", L"DropEffects"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DropEffects());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBaseAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBaseAutomationPeer[] = {
        { "drop_effect", reinterpret_cast<getter>(ListViewBaseAutomationPeer_get_DropEffect), nullptr, nullptr, nullptr },
        { "drop_effects", reinterpret_cast<getter>(ListViewBaseAutomationPeer_get_DropEffects), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewBaseAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBaseAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewBaseAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBaseAutomationPeer
    };

    // ----- ListViewBaseHeaderItemAutomationPeer class --------------------

    static PyObject* _new_ListViewBaseHeaderItemAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewBaseHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewBaseHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBaseHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBaseHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewBaseHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBaseHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBaseHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewBaseHeaderItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBaseHeaderItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewBaseHeaderItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewBaseHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBaseHeaderItemAutomationPeer
    };

    // ----- ListViewHeaderItemAutomationPeer class --------------------

    static PyObject* _new_ListViewHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewHeaderItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewHeaderItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewHeaderItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewHeaderItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewHeaderItemAutomationPeer
    };

    // ----- ListViewItemAutomationPeer class --------------------

    static PyObject* _new_ListViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemAutomationPeer
    };

    // ----- ListViewItemDataAutomationPeer class --------------------

    static PyObject* _new_ListViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewItemDataAutomationPeer", L"ScrollIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewItemDataAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ListViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemDataAutomationPeer
    };

    // ----- LoopingSelectorAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Collapse", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Expand", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_FindItemByProperty(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"FindItemByProperty", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"GetSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Scroll", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"SetScrollPercent", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"ExpandCollapseState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontalScrollPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontalViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontallyScrollable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticalScrollPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticalViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticallyScrollable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"CanSelectMultiple"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"IsSelectionRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "find_item_by_property", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_FindItemByProperty), METH_VARARGS, nullptr },
        { "get_selection", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "horizontal_scroll_percent", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_select_multiple", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelectorAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.LoopingSelectorAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorAutomationPeer
    };

    // ----- LoopingSelectorItemAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorItemAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorItemAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"AddToSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"RemoveFromSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"ScrollIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"Select", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"IsSelected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"SelectionContainer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItemAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItemAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(LoopingSelectorItemAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(LoopingSelectorItemAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelectorItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.LoopingSelectorItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItemAutomationPeer
    };

    // ----- LoopingSelectorItemDataAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorItemDataAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorItemDataAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemDataAutomationPeer", L"Realize", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItemDataAutomationPeer[] = {
        { "realize", reinterpret_cast<PyCFunction>(LoopingSelectorItemDataAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelectorItemDataAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.LoopingSelectorItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItemDataAutomationPeer
    };

    // ----- MapControlAutomationPeer class --------------------

    static PyObject* _new_MapControlAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_MapControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlAutomationPeer_Move(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Move", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Move(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Resize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Resize", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Resize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Rotate(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Rotate", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Rotate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Scroll", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"SetScrollPercent", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Zoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Zoom", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Zoom(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_ZoomByUnit(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"ZoomByUnit", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ZoomUnit>(args, 0);

                self->obj.ZoomByUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontalScrollPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontalViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontallyScrollable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticalScrollPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticalViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticallyScrollable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanMove(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanMove"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanMove());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanResize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanResize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanResize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanRotate(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanRotate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanRotate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanZoom"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_MaxZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"MaxZoom"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_MinZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"MinZoom"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"ZoomLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlAutomationPeer[] = {
        { "move", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Move), METH_VARARGS, nullptr },
        { "resize", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Resize), METH_VARARGS, nullptr },
        { "rotate", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Rotate), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "zoom", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Zoom), METH_VARARGS, nullptr },
        { "zoom_by_unit", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_ZoomByUnit), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_move", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanMove), nullptr, nullptr, nullptr },
        { "can_resize", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanResize), nullptr, nullptr, nullptr },
        { "can_rotate", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanRotate), nullptr, nullptr, nullptr },
        { "can_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanZoom), nullptr, nullptr, nullptr },
        { "max_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_MaxZoom), nullptr, nullptr, nullptr },
        { "min_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_MinZoom), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(MapControlAutomationPeer_get_ZoomLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MapControlAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MapControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlAutomationPeer
    };

    // ----- MediaElementAutomationPeer class --------------------

    static PyObject* _new_MediaElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaElement>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaElementAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaElementAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MediaElementAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaElementAutomationPeer
    };

    // ----- MediaPlayerElementAutomationPeer class --------------------

    static PyObject* _new_MediaPlayerElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaPlayerElement>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlayerElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaPlayerElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayerElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaPlayerElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayerElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayerElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaPlayerElementAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayerElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayerElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayerElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayerElementAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MediaPlayerElementAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaPlayerElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerElementAutomationPeer
    };

    // ----- MediaTransportControlsAutomationPeer class --------------------

    static PyObject* _new_MediaTransportControlsAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaTransportControls>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaTransportControlsAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaTransportControlsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaTransportControlsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTransportControlsAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaTransportControlsAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaTransportControlsAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaTransportControlsAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaTransportControlsAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTransportControlsAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTransportControlsAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaTransportControlsAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTransportControlsAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MediaTransportControlsAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MediaTransportControlsAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTransportControlsAutomationPeer
    };

    // ----- MenuBarAutomationPeer class --------------------

    static PyObject* _new_MenuBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuBar>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuBarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MenuBarAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuBarAutomationPeer
    };

    // ----- MenuBarItemAutomationPeer class --------------------

    static PyObject* _new_MenuBarItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuBarItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuBarItemAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Collapse", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Expand", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Invoke", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"ExpandCollapseState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "invoke", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuBarItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(MenuBarItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuBarItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MenuBarItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuBarItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuBarItemAutomationPeer
    };

    // ----- MenuFlyoutItemAutomationPeer class --------------------

    static PyObject* _new_MenuFlyoutItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuFlyoutItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyoutItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutItemAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuFlyoutItemAutomationPeer", L"Invoke", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutItemAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(MenuFlyoutItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuFlyoutItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MenuFlyoutItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuFlyoutItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutItemAutomationPeer
    };

    // ----- MenuFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_MenuFlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuFlyoutPresenter>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.MenuFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutPresenterAutomationPeer
    };

    // ----- NavigationViewItemAutomationPeer class --------------------

    static PyObject* _new_NavigationViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_NavigationViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.NavigationViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemAutomationPeer
    };

    // ----- PasswordBoxAutomationPeer class --------------------

    static PyObject* _new_PasswordBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PasswordBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PasswordBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PasswordBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PasswordBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PasswordBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_PasswordBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PasswordBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PasswordBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PasswordBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PasswordBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PasswordBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PasswordBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PasswordBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PasswordBoxAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.PasswordBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PasswordBoxAutomationPeer
    };

    // ----- PersonPictureAutomationPeer class --------------------

    static PyObject* _new_PersonPictureAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PersonPicture>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PersonPictureAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersonPictureAutomationPeer[] = {
        { "_assign_array_", _assign_array_PersonPictureAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PersonPictureAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PersonPictureAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PersonPictureAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersonPictureAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PersonPictureAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersonPictureAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersonPictureAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PersonPictureAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.PersonPictureAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PersonPictureAutomationPeer
    };

    // ----- PickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_PickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_PickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_PickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PickerFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PickerFlyoutPresenterAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.PickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerFlyoutPresenterAutomationPeer
    };

    // ----- PivotAutomationPeer class --------------------

    static PyObject* _new_PivotAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Pivot>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"GetSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"Scroll", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"SetScrollPercent", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontalScrollPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontalViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontallyScrollable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticalScrollPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticalViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticallyScrollable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"CanSelectMultiple"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"IsSelectionRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(PivotAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(PivotAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(PivotAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PivotAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_select_multiple", reinterpret_cast<getter>(PivotAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(PivotAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PivotAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.PivotAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotAutomationPeer
    };

    // ----- PivotItemAutomationPeer class --------------------

    static PyObject* _new_PivotItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PivotItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_PivotItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PivotItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.PivotItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotItemAutomationPeer
    };

    // ----- PivotItemDataAutomationPeer class --------------------

    static PyObject* _new_PivotItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotItemDataAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"AddToSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"Realize", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"RemoveFromSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"ScrollIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"Select", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"IsSelected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"SelectionContainer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotItemDataAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "realize", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PivotItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotItemDataAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(PivotItemDataAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(PivotItemDataAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PivotItemDataAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.PivotItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotItemDataAutomationPeer
    };

    // ----- ProgressBarAutomationPeer class --------------------

    static PyObject* _new_ProgressBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ProgressBar>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ProgressBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ProgressBarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ProgressBarAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ProgressBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressBarAutomationPeer
    };

    // ----- ProgressRingAutomationPeer class --------------------

    static PyObject* _new_ProgressRingAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ProgressRing>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressRingAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressRingAutomationPeer[] = {
        { "_assign_array_", _assign_array_ProgressRingAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressRingAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressRingAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ProgressRingAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressRingAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressRingAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressRingAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressRingAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ProgressRingAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ProgressRingAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressRingAutomationPeer
    };

    // ----- RadioButtonAutomationPeer class --------------------

    static PyObject* _new_RadioButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RadioButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButtonAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"AddToSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"RemoveFromSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"Select", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"IsSelected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"SelectionContainer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButtonAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RadioButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButtonAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(RadioButtonAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(RadioButtonAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadioButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RadioButtonAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RadioButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadioButtonAutomationPeer
    };

    // ----- RangeBaseAutomationPeer class --------------------

    static PyObject* _new_RangeBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RangeBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBaseAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"SetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"IsReadOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_LargeChange(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"LargeChange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LargeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Maximum(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Maximum"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Maximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Minimum(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Minimum"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Minimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_SmallChange(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"SmallChange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmallChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBaseAutomationPeer[] = {
        { "set_value", reinterpret_cast<PyCFunction>(RangeBaseAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RangeBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBaseAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_LargeChange), nullptr, nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Maximum), nullptr, nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Minimum), nullptr, nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_SmallChange), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBaseAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBaseAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RangeBaseAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RangeBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RangeBaseAutomationPeer
    };

    // ----- RatingControlAutomationPeer class --------------------

    static PyObject* _new_RatingControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RatingControl>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingControlAutomationPeer[] = {
        { "_assign_array_", _assign_array_RatingControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RatingControlAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RatingControlAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingControlAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RatingControlAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RatingControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RatingControlAutomationPeer
    };

    // ----- RepeatButtonAutomationPeer class --------------------

    static PyObject* _new_RepeatButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RepeatButtonAutomationPeer", L"Invoke", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(RepeatButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RepeatButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RepeatButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RepeatButtonAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RepeatButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatButtonAutomationPeer
    };

    // ----- RichEditBoxAutomationPeer class --------------------

    static PyObject* _new_RichEditBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichEditBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichEditBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichEditBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichEditBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichEditBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichEditBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichEditBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichEditBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichEditBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichEditBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichEditBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichEditBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichEditBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RichEditBoxAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichEditBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichEditBoxAutomationPeer
    };

    // ----- RichTextBlockAutomationPeer class --------------------

    static PyObject* _new_RichTextBlockAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichTextBlock>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichTextBlockAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichTextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichTextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichTextBlockAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichTextBlockAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichTextBlockAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichTextBlockAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichTextBlockAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichTextBlockAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichTextBlockAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichTextBlockAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichTextBlockAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RichTextBlockAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichTextBlockAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichTextBlockAutomationPeer
    };

    // ----- RichTextBlockOverflowAutomationPeer class --------------------

    static PyObject* _new_RichTextBlockOverflowAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichTextBlockOverflow>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichTextBlockOverflowAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichTextBlockOverflowAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichTextBlockOverflowAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichTextBlockOverflowAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichTextBlockOverflowAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichTextBlockOverflowAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichTextBlockOverflowAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichTextBlockOverflowAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichTextBlockOverflowAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RichTextBlockOverflowAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RichTextBlockOverflowAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichTextBlockOverflowAutomationPeer
    };

    // ----- ScrollBarAutomationPeer class --------------------

    static PyObject* _new_ScrollBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ScrollBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ScrollBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ScrollBarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollBarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ScrollBarAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ScrollBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollBarAutomationPeer
    };

    // ----- ScrollViewerAutomationPeer class --------------------

    static PyObject* _new_ScrollViewerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ScrollViewer>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollViewerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollViewerAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"Scroll", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"SetScrollPercent", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontalScrollPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontalViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontallyScrollable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticalScrollPercent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticalViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticallyScrollable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollViewerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollViewerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollViewerAutomationPeer[] = {
        { "scroll", reinterpret_cast<PyCFunction>(ScrollViewerAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(ScrollViewerAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ScrollViewerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollViewerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollViewerAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollViewerAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollViewerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollViewerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollViewerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollViewerAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ScrollViewerAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ScrollViewerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollViewerAutomationPeer
    };

    // ----- SearchBoxAutomationPeer class --------------------

    static PyObject* _new_SearchBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SearchBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SearchBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SearchBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_SearchBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SearchBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SearchBoxAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SearchBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchBoxAutomationPeer
    };

    // ----- SelectorAutomationPeer class --------------------

    static PyObject* _new_SelectorAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"GetSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"CanSelectMultiple"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectorAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"IsSelectionRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(SelectorAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SelectorAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorAutomationPeer[] = {
        { "can_select_multiple", reinterpret_cast<getter>(SelectorAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(SelectorAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SelectorAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SelectorAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectorAutomationPeer
    };

    // ----- SelectorItemAutomationPeer class --------------------

    static PyObject* _new_SelectorItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorItemAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"AddToSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"RemoveFromSelection", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"Select", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"IsSelected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"SelectionContainer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorItemAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SelectorItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorItemAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(SelectorItemAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(SelectorItemAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SelectorItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SelectorItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectorItemAutomationPeer
    };

    // ----- SemanticZoomAutomationPeer class --------------------

    static PyObject* _new_SemanticZoomAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoom>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SemanticZoomAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SemanticZoomAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SemanticZoomAutomationPeer", L"Toggle", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SemanticZoomAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SemanticZoomAutomationPeer", L"ToggleState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SemanticZoomAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SemanticZoomAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SemanticZoomAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(SemanticZoomAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SemanticZoomAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SemanticZoomAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SemanticZoomAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(SemanticZoomAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SemanticZoomAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SemanticZoomAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SemanticZoomAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SemanticZoomAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SemanticZoomAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SemanticZoomAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SemanticZoomAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SemanticZoomAutomationPeer
    };

    // ----- SettingsFlyoutAutomationPeer class --------------------

    static PyObject* _new_SettingsFlyoutAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SettingsFlyout>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SettingsFlyoutAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SettingsFlyoutAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SettingsFlyoutAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SettingsFlyoutAutomationPeer[] = {
        { "_assign_array_", _assign_array_SettingsFlyoutAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SettingsFlyoutAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SettingsFlyoutAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SettingsFlyoutAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SettingsFlyoutAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SettingsFlyoutAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SettingsFlyoutAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SettingsFlyoutAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SettingsFlyoutAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SettingsFlyoutAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SettingsFlyoutAutomationPeer
    };

    // ----- SliderAutomationPeer class --------------------

    static PyObject* _new_SliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Slider>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SliderAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_SliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SliderAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SliderAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SliderAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SliderAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.SliderAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SliderAutomationPeer
    };

    // ----- TextBlockAutomationPeer class --------------------

    static PyObject* _new_TextBlockAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TextBlock>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextBlockAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextBlockAutomationPeer[] = {
        { "_assign_array_", _assign_array_TextBlockAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextBlockAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextBlockAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TextBlockAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextBlockAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextBlockAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextBlockAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextBlockAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TextBlockAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TextBlockAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextBlockAutomationPeer
    };

    // ----- TextBoxAutomationPeer class --------------------

    static PyObject* _new_TextBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TextBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_TextBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TextBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TextBoxAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TextBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextBoxAutomationPeer
    };

    // ----- ThumbAutomationPeer class --------------------

    static PyObject* _new_ThumbAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::Thumb>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ThumbAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ThumbAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ThumbAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ThumbAutomationPeer[] = {
        { "_assign_array_", _assign_array_ThumbAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ThumbAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ThumbAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ThumbAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ThumbAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ThumbAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ThumbAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ThumbAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ThumbAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ThumbAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ThumbAutomationPeer
    };

    // ----- TimePickerAutomationPeer class --------------------

    static PyObject* _new_TimePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TimePicker>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerAutomationPeer[] = {
        { "_assign_array_", _assign_array_TimePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TimePickerAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TimePickerAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TimePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerAutomationPeer
    };

    // ----- TimePickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_TimePickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_TimePickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_TimePickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TimePickerFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TimePickerFlyoutPresenterAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TimePickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerFlyoutPresenterAutomationPeer
    };

    // ----- ToggleButtonAutomationPeer class --------------------

    static PyObject* _new_ToggleButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleButtonAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer", L"Toggle", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleButtonAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer", L"ToggleState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleButtonAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleButtonAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleButtonAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleButtonAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ToggleButtonAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleButtonAutomationPeer
    };

    // ----- ToggleMenuFlyoutItemAutomationPeer class --------------------

    static PyObject* _new_ToggleMenuFlyoutItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ToggleMenuFlyoutItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleMenuFlyoutItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleMenuFlyoutItemAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleMenuFlyoutItemAutomationPeer", L"Toggle", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleMenuFlyoutItemAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleMenuFlyoutItemAutomationPeer", L"ToggleState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleMenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleMenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleMenuFlyoutItemAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleMenuFlyoutItemAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleMenuFlyoutItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleMenuFlyoutItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleMenuFlyoutItemAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleMenuFlyoutItemAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleMenuFlyoutItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleMenuFlyoutItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ToggleMenuFlyoutItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleMenuFlyoutItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleMenuFlyoutItemAutomationPeer
    };

    // ----- ToggleSwitchAutomationPeer class --------------------

    static PyObject* _new_ToggleSwitchAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ToggleSwitch>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleSwitchAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSwitchAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleSwitchAutomationPeer", L"Toggle", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleSwitchAutomationPeer", L"ToggleState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSwitchAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSwitchAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSwitchAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleSwitchAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleSwitchAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSwitchAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleSwitchAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleSwitchAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleSwitchAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSwitchAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSwitchAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSwitchAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSwitchAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ToggleSwitchAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.ToggleSwitchAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleSwitchAutomationPeer
    };

    // ----- TreeViewItemAutomationPeer class --------------------

    static PyObject* _new_TreeViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TreeViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Collapse", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Expand", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"ExpandCollapseState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TreeViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(TreeViewItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TreeViewItemAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TreeViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewItemAutomationPeer
    };

    // ----- TreeViewListAutomationPeer class --------------------

    static PyObject* _new_TreeViewListAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TreeViewList>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewListAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewListAutomationPeer[] = {
        { "_assign_array_", _assign_array_TreeViewListAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewListAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewListAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TreeViewListAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewListAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewListAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewListAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewListAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TreeViewListAutomationPeer =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.TreeViewListAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewListAutomationPeer
    };

    // ----- RawElementProviderRuntimeId struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>* _new_RawElementProviderRuntimeId(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_RawElementProviderRuntimeId(winrt_struct_wrapper<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _Part1{};
        uint32_t _Part2{};

        static const char* kwlist[] = {"part1", "part2", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Part1, &_Part2))
        {
            return -1;
        }

        try
        {
            self->obj = {_Part1, _Part2};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_RawElementProviderRuntimeId(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RawElementProviderRuntimeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_RawElementProviderRuntimeId[] = {
        { "_assign_array_", _assign_array_RawElementProviderRuntimeId, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* RawElementProviderRuntimeId_get_Part1(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Part1);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RawElementProviderRuntimeId_set_Part1(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Part1 = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RawElementProviderRuntimeId_get_Part2(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Part2);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RawElementProviderRuntimeId_set_Part2(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Part2 = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RawElementProviderRuntimeId[] = {
        { "part1", reinterpret_cast<getter>(RawElementProviderRuntimeId_get_Part1), reinterpret_cast<setter>(RawElementProviderRuntimeId_set_Part1), nullptr, nullptr },
        { "part2", reinterpret_cast<getter>(RawElementProviderRuntimeId_get_Part2), reinterpret_cast<setter>(RawElementProviderRuntimeId_set_Part2), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RawElementProviderRuntimeId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RawElementProviderRuntimeId) },
        { Py_tp_init, reinterpret_cast<void*>(_init_RawElementProviderRuntimeId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RawElementProviderRuntimeId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RawElementProviderRuntimeId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RawElementProviderRuntimeId) },
        { },
    };

    static PyType_Spec type_spec_RawElementProviderRuntimeId =
    {
        "winrt._winrt_windows_ui_xaml_automation_peers.RawElementProviderRuntimeId",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RawElementProviderRuntimeId
    };

    // ----- Windows.UI.Xaml.Automation.Peers Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml::Automation::Peers");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_xaml_automation_peers",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Xaml::Automation::Peers

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_automation_peers(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Automation::Peers;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationPeer_Static{PyType_FromSpec(&type_spec_AutomationPeer_Static)};
    if (!type_AutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AutomationPeer_type{py::register_python_type(module.get(), &type_spec_AutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationPeer_Static.get()))};
    if (!AutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ItemAutomationPeer, object_bases.get(), nullptr)};
    if (!ItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SelectorItemAutomationPeer, object_bases.get(), nullptr)};
    if (!SelectorItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!ListViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!ListBoxItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!GridViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!FlipViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!ComboBoxItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FrameworkElementAutomationPeer_Static{PyType_FromSpec(&type_spec_FrameworkElementAutomationPeer_Static)};
    if (!type_FrameworkElementAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FrameworkElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FrameworkElementAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FrameworkElementAutomationPeer_Static.get()))};
    if (!FrameworkElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSwitchAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleSwitchAutomationPeer, object_bases.get(), nullptr)};
    if (!ToggleSwitchAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleMenuFlyoutItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleMenuFlyoutItemAutomationPeer, object_bases.get(), nullptr)};
    if (!ToggleMenuFlyoutItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TimePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TimePickerAutomationPeer, object_bases.get(), nullptr)};
    if (!TimePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ThumbAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ThumbAutomationPeer, object_bases.get(), nullptr)};
    if (!ThumbAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TextBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!TextBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextBlockAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TextBlockAutomationPeer, object_bases.get(), nullptr)};
    if (!TextBlockAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SettingsFlyoutAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SettingsFlyoutAutomationPeer, object_bases.get(), nullptr)};
    if (!SettingsFlyoutAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SemanticZoomAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SemanticZoomAutomationPeer, object_bases.get(), nullptr)};
    if (!SemanticZoomAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SearchBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SearchBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!SearchBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollViewerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ScrollViewerAutomationPeer, object_bases.get(), nullptr)};
    if (!ScrollViewerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RichTextBlockOverflowAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichTextBlockOverflowAutomationPeer, object_bases.get(), nullptr)};
    if (!RichTextBlockOverflowAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RichTextBlockAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichTextBlockAutomationPeer, object_bases.get(), nullptr)};
    if (!RichTextBlockAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RichEditBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichEditBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!RichEditBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RatingControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RatingControlAutomationPeer, object_bases.get(), nullptr)};
    if (!RatingControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RangeBaseAutomationPeer, object_bases.get(), nullptr)};
    if (!RangeBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SliderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SliderAutomationPeer, object_bases.get(), nullptr)};
    if (!SliderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorPickerSliderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ColorPickerSliderAutomationPeer, object_bases.get(), nullptr)};
    if (!ColorPickerSliderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ScrollBarAutomationPeer, object_bases.get(), nullptr)};
    if (!ScrollBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ProgressBarAutomationPeer, object_bases.get(), nullptr)};
    if (!ProgressBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRingAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ProgressRingAutomationPeer, object_bases.get(), nullptr)};
    if (!ProgressRingAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PersonPictureAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PersonPictureAutomationPeer, object_bases.get(), nullptr)};
    if (!PersonPictureAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PasswordBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PasswordBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!PasswordBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutItemAutomationPeer, object_bases.get(), nullptr)};
    if (!MenuFlyoutItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuBarItemAutomationPeer, object_bases.get(), nullptr)};
    if (!MenuBarItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuBarAutomationPeer, object_bases.get(), nullptr)};
    if (!MenuBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MediaTransportControlsAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MediaTransportControlsAutomationPeer, object_bases.get(), nullptr)};
    if (!MediaTransportControlsAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MediaPlayerElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MediaPlayerElementAutomationPeer, object_bases.get(), nullptr)};
    if (!MediaPlayerElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MediaElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MediaElementAutomationPeer, object_bases.get(), nullptr)};
    if (!MediaElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewItemAutomationPeer, object_bases.get(), nullptr)};
    if (!ListViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewItemAutomationPeer, object_bases.get(), nullptr)};
    if (!TreeViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemAutomationPeer, object_bases.get(), nullptr)};
    if (!NavigationViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBaseHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewBaseHeaderItemAutomationPeer, object_bases.get(), nullptr)};
    if (!ListViewBaseHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewHeaderItemAutomationPeer, object_bases.get(), nullptr)};
    if (!ListViewHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewHeaderItemAutomationPeer, object_bases.get(), nullptr)};
    if (!GridViewHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxItemAutomationPeer, object_bases.get(), nullptr)};
    if (!ListBoxItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ItemsControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ItemsControlAutomationPeer, object_bases.get(), nullptr)};
    if (!ItemsControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SelectorAutomationPeer, object_bases.get(), nullptr)};
    if (!SelectorAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewListAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewListAutomationPeer, object_bases.get(), nullptr)};
    if (!TreeViewListAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewBaseAutomationPeer, object_bases.get(), nullptr)};
    if (!ListViewBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewAutomationPeer, object_bases.get(), nullptr)};
    if (!ListViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewAutomationPeer, object_bases.get(), nullptr)};
    if (!GridViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!ListBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewAutomationPeer, object_bases.get(), nullptr)};
    if (!FlipViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!ComboBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!MenuFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ImageAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ImageAutomationPeer, object_bases.get(), nullptr)};
    if (!ImageAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle HubSectionAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HubSectionAutomationPeer, object_bases.get(), nullptr)};
    if (!HubSectionAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle HubAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HubAutomationPeer, object_bases.get(), nullptr)};
    if (!HubAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GroupItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GroupItemAutomationPeer, object_bases.get(), nullptr)};
    if (!GroupItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewItemAutomationPeer, object_bases.get(), nullptr)};
    if (!GridViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!FlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewItemAutomationPeer, object_bases.get(), nullptr)};
    if (!FlipViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle DatePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_DatePickerAutomationPeer, object_bases.get(), nullptr)};
    if (!DatePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxItemAutomationPeer, object_bases.get(), nullptr)};
    if (!ComboBoxItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrumAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ColorSpectrumAutomationPeer, object_bases.get(), nullptr)};
    if (!ColorSpectrumAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle CaptureElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_CaptureElementAutomationPeer, object_bases.get(), nullptr)};
    if (!CaptureElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle CalendarDatePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_CalendarDatePickerAutomationPeer, object_bases.get(), nullptr)};
    if (!CalendarDatePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ButtonBaseAutomationPeer, object_bases.get(), nullptr)};
    if (!ButtonBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleButtonAutomationPeer, object_bases.get(), nullptr)};
    if (!ToggleButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RadioButtonAutomationPeer, object_bases.get(), nullptr)};
    if (!RadioButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle CheckBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_CheckBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!CheckBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarToggleButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButtonAutomationPeer, object_bases.get(), nullptr)};
    if (!AppBarToggleButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RepeatButtonAutomationPeer, object_bases.get(), nullptr)};
    if (!RepeatButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle HyperlinkButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HyperlinkButtonAutomationPeer, object_bases.get(), nullptr)};
    if (!HyperlinkButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ButtonAutomationPeer, object_bases.get(), nullptr)};
    if (!ButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarButtonAutomationPeer, object_bases.get(), nullptr)};
    if (!AppBarButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarAutomationPeer, object_bases.get(), nullptr)};
    if (!AppBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle AutoSuggestBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AutoSuggestBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!AutoSuggestBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationPeerAnnotation_Static{PyType_FromSpec(&type_spec_AutomationPeerAnnotation_Static)};
    if (!type_AutomationPeerAnnotation_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AutomationPeerAnnotation_type{py::register_python_type(module.get(), &type_spec_AutomationPeerAnnotation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationPeerAnnotation_Static.get()))};
    if (!AutomationPeerAnnotation_type)
    {
        return nullptr;
    }

    py::pyobj_handle DatePickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_DatePickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!DatePickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_InkToolbarAutomationPeer, object_bases.get(), nullptr)};
    if (!InkToolbarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListPickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListPickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!ListPickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorAutomationPeer, object_bases.get(), nullptr)};
    if (!LoopingSelectorAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorItemAutomationPeer, object_bases.get(), nullptr)};
    if (!LoopingSelectorItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!LoopingSelectorItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle MapControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MapControlAutomationPeer, object_bases.get(), nullptr)};
    if (!MapControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!PickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotAutomationPeer, object_bases.get(), nullptr)};
    if (!PivotAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotItemAutomationPeer, object_bases.get(), nullptr)};
    if (!PivotItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!PivotItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle TimePickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TimePickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!TimePickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle RawElementProviderRuntimeId_type{py::register_python_type(module.get(), &type_spec_RawElementProviderRuntimeId, nullptr, nullptr)};
    if (!RawElementProviderRuntimeId_type)
    {
        return nullptr;
    }


    return module.detach();
}
