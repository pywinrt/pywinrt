# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.devices.geolocation
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.services.maps
import winrt.windows.ui

from winrt.windows.services.maps.guidance import GuidanceAudioMeasurementSystem, GuidanceAudioNotificationKind, GuidanceAudioNotifications, GuidanceLaneMarkers, GuidanceManeuverKind, GuidanceMode

Self = typing.TypeVar('Self')

@typing.final
class GuidanceAudioNotificationRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceAudioNotificationRequestedEventArgs: ...
    @_property
    def audio_file_paths(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @_property
    def audio_notification(self) -> GuidanceAudioNotificationKind: ...
    @_property
    def audio_text(self) -> str: ...

@typing.final
class GuidanceLaneInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceLaneInfo: ...
    @_property
    def is_on_route(self) -> bool: ...
    @_property
    def lane_markers(self) -> GuidanceLaneMarkers: ...

@typing.final
class GuidanceManeuver(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceManeuver: ...
    @_property
    def departure_road_name(self) -> str: ...
    @_property
    def departure_short_road_name(self) -> str: ...
    @_property
    def distance_from_previous_maneuver(self) -> winrt.system.Int32: ...
    @_property
    def distance_from_route_start(self) -> winrt.system.Int32: ...
    @_property
    def end_angle(self) -> winrt.system.Int32: ...
    @_property
    def instruction_text(self) -> str: ...
    @_property
    def kind(self) -> GuidanceManeuverKind: ...
    @_property
    def next_road_name(self) -> str: ...
    @_property
    def next_short_road_name(self) -> str: ...
    @_property
    def road_signpost(self) -> typing.Optional[GuidanceRoadSignpost]: ...
    @_property
    def start_angle(self) -> winrt.system.Int32: ...
    @_property
    def start_location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...

@typing.final
class GuidanceMapMatchedCoordinate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceMapMatchedCoordinate: ...
    @_property
    def current_heading(self) -> winrt.system.Double: ...
    @_property
    def current_speed(self) -> winrt.system.Double: ...
    @_property
    def is_on_street(self) -> bool: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def road(self) -> typing.Optional[GuidanceRoadSegment]: ...

@typing.final
class GuidanceNavigator_Static(type):
    def get_current(cls) -> typing.Optional[GuidanceNavigator]: ...
    @_property
    def use_app_provided_voice(cls) -> bool: ...

@typing.final
class GuidanceNavigator(winrt.system.Object, metaclass=GuidanceNavigator_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceNavigator: ...
    def pause(self) -> None: ...
    def repeat_last_audio_notification(self) -> None: ...
    def resume(self) -> None: ...
    def set_guidance_voice(self, voice_id: winrt.system.Int32, voice_folder: str, /) -> None: ...
    def start_navigating(self, route: typing.Optional[GuidanceRoute], /) -> None: ...
    def start_simulating(self, route: typing.Optional[GuidanceRoute], speed_in_meters_per_second: winrt.system.Int32, /) -> None: ...
    def start_tracking(self) -> None: ...
    def stop(self) -> None: ...
    @typing.overload
    def update_user_location(self, user_location: typing.Optional[winrt.windows.devices.geolocation.Geocoordinate], /) -> None: ...
    @typing.overload
    def update_user_location(self, user_location: typing.Optional[winrt.windows.devices.geolocation.Geocoordinate], position_override: winrt.windows.devices.geolocation.BasicGeoposition, /) -> None: ...
    def add_destination_reached(self, handler: winrt.windows.foundation.TypedEventHandler[GuidanceNavigator, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_destination_reached(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_guidance_updated(self, handler: winrt.windows.foundation.TypedEventHandler[GuidanceNavigator, GuidanceUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_guidance_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_reroute_failed(self, handler: winrt.windows.foundation.TypedEventHandler[GuidanceNavigator, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reroute_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_rerouted(self, handler: winrt.windows.foundation.TypedEventHandler[GuidanceNavigator, GuidanceReroutedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rerouted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_rerouting(self, handler: winrt.windows.foundation.TypedEventHandler[GuidanceNavigator, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rerouting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_user_location_lost(self, handler: winrt.windows.foundation.TypedEventHandler[GuidanceNavigator, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_user_location_lost(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_user_location_restored(self, handler: winrt.windows.foundation.TypedEventHandler[GuidanceNavigator, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_user_location_restored(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_audio_notification_requested(self, value: winrt.windows.foundation.TypedEventHandler[GuidanceNavigator, GuidanceAudioNotificationRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_audio_notification_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def audio_notifications(self) -> GuidanceAudioNotifications: ...
    @audio_notifications.setter
    def audio_notifications(self, value: GuidanceAudioNotifications) -> None: ...
    @_property
    def audio_measurement_system(self) -> GuidanceAudioMeasurementSystem: ...
    @audio_measurement_system.setter
    def audio_measurement_system(self, value: GuidanceAudioMeasurementSystem) -> None: ...
    @_property
    def is_guidance_audio_muted(self) -> bool: ...
    @is_guidance_audio_muted.setter
    def is_guidance_audio_muted(self, value: bool) -> None: ...

@typing.final
class GuidanceReroutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceReroutedEventArgs: ...
    @_property
    def route(self) -> typing.Optional[GuidanceRoute]: ...

@typing.final
class GuidanceRoadSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceRoadSegment: ...
    @_property
    def id(self) -> str: ...
    @_property
    def is_highway(self) -> bool: ...
    @_property
    def is_toll_road(self) -> bool: ...
    @_property
    def is_tunnel(self) -> bool: ...
    @_property
    def path(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopath]: ...
    @_property
    def road_name(self) -> str: ...
    @_property
    def short_road_name(self) -> str: ...
    @_property
    def speed_limit(self) -> winrt.system.Double: ...
    @_property
    def travel_time(self) -> datetime.timedelta: ...
    @_property
    def is_scenic(self) -> bool: ...

@typing.final
class GuidanceRoadSignpost(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceRoadSignpost: ...
    @_property
    def background_color(self) -> winrt.windows.ui.Color: ...
    @_property
    def exit(self) -> str: ...
    @_property
    def exit_directions(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @_property
    def exit_number(self) -> str: ...
    @_property
    def foreground_color(self) -> winrt.windows.ui.Color: ...

@typing.final
class GuidanceRoute_Static(type):
    def can_create_from_map_route(cls, map_route: typing.Optional[winrt.windows.services.maps.MapRoute], /) -> bool: ...
    def try_create_from_map_route(cls, map_route: typing.Optional[winrt.windows.services.maps.MapRoute], /) -> typing.Optional[GuidanceRoute]: ...

@typing.final
class GuidanceRoute(winrt.system.Object, metaclass=GuidanceRoute_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceRoute: ...
    def convert_to_map_route(self) -> typing.Optional[winrt.windows.services.maps.MapRoute]: ...
    @_property
    def bounding_box(self) -> typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox]: ...
    @_property
    def distance(self) -> winrt.system.Int32: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @_property
    def maneuvers(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[GuidanceManeuver]]: ...
    @_property
    def path(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopath]: ...
    @_property
    def road_segments(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[GuidanceRoadSegment]]: ...

@typing.final
class GuidanceTelemetryCollector_Static(type):
    def get_current(cls) -> typing.Optional[GuidanceTelemetryCollector]: ...

@typing.final
class GuidanceTelemetryCollector(winrt.system.Object, metaclass=GuidanceTelemetryCollector_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceTelemetryCollector: ...
    def clear_local_data(self) -> None: ...
    @_property
    def upload_frequency(self) -> winrt.system.Int32: ...
    @upload_frequency.setter
    def upload_frequency(self, value: winrt.system.Int32) -> None: ...
    @_property
    def speed_trigger(self) -> winrt.system.Double: ...
    @speed_trigger.setter
    def speed_trigger(self, value: winrt.system.Double) -> None: ...
    @_property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> None: ...

@typing.final
class GuidanceUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GuidanceUpdatedEventArgs: ...
    @_property
    def after_next_maneuver(self) -> typing.Optional[GuidanceManeuver]: ...
    @_property
    def after_next_maneuver_distance(self) -> winrt.system.Int32: ...
    @_property
    def current_location(self) -> typing.Optional[GuidanceMapMatchedCoordinate]: ...
    @_property
    def distance_to_destination(self) -> winrt.system.Int32: ...
    @_property
    def elapsed_distance(self) -> winrt.system.Int32: ...
    @_property
    def elapsed_time(self) -> datetime.timedelta: ...
    @_property
    def is_new_maneuver(self) -> bool: ...
    @_property
    def lane_info(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[GuidanceLaneInfo]]: ...
    @_property
    def mode(self) -> GuidanceMode: ...
    @_property
    def next_maneuver(self) -> typing.Optional[GuidanceManeuver]: ...
    @_property
    def next_maneuver_distance(self) -> winrt.system.Int32: ...
    @_property
    def road_name(self) -> str: ...
    @_property
    def route(self) -> typing.Optional[GuidanceRoute]: ...
    @_property
    def time_to_destination(self) -> datetime.timedelta: ...

