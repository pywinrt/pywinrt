# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.ui.text.core

from winrt.windows.data.text import AlternateNormalizationFormat, TextPredictionOptions, UnicodeGeneralCategory, UnicodeNumericType
from winrt.windows.data.text import SelectableWordSegmentsTokenizingHandler, WordSegmentsTokenizingHandler

Self = typing.TypeVar('Self')

@typing.final
class TextSegment:
    start_position: winrt.system.UInt32
    length: winrt.system.UInt32
    def __init__(self, start_position: winrt.system.UInt32, length: winrt.system.UInt32) -> None: ...

@typing.final
class AlternateWordForm(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AlternateWordForm: ...
    @_property
    def alternate_text(self) -> str: ...
    @_property
    def normalization_format(self) -> AlternateNormalizationFormat: ...
    @_property
    def source_text_segment(self) -> TextSegment: ...

@typing.final
class SelectableWordSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SelectableWordSegment: ...
    @_property
    def source_text_segment(self) -> TextSegment: ...
    @_property
    def text(self) -> str: ...

@typing.final
class SelectableWordsSegmenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SelectableWordsSegmenter: ...
    def __new__(cls: typing.Type[SelectableWordsSegmenter], language: str) -> SelectableWordsSegmenter:...
    def get_token_at(self, text: str, start_index: winrt.system.UInt32, /) -> typing.Optional[SelectableWordSegment]: ...
    def get_tokens(self, text: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SelectableWordSegment]]: ...
    def tokenize(self, text: str, start_index: winrt.system.UInt32, handler: typing.Optional[SelectableWordSegmentsTokenizingHandler], /) -> None: ...
    @_property
    def resolved_language(self) -> str: ...

@typing.final
class SemanticTextQuery(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SemanticTextQuery: ...
    @typing.overload
    def __new__(cls: typing.Type[SemanticTextQuery], aqs_filter: str) -> SemanticTextQuery:...
    @typing.overload
    def __new__(cls: typing.Type[SemanticTextQuery], aqs_filter: str, filter_language: str) -> SemanticTextQuery:...
    def find(self, content: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TextSegment]]: ...
    def find_in_property(self, property_content: str, property_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TextSegment]]: ...

@typing.final
class TextConversionGenerator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextConversionGenerator: ...
    def __new__(cls: typing.Type[TextConversionGenerator], language_tag: str) -> TextConversionGenerator:...
    @typing.overload
    def get_candidates_async(self, input: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @_property
    def language_available_but_not_installed(self) -> bool: ...
    @_property
    def resolved_language(self) -> str: ...

@typing.final
class TextPhoneme(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextPhoneme: ...
    @_property
    def display_text(self) -> str: ...
    @_property
    def reading_text(self) -> str: ...

@typing.final
class TextPredictionGenerator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextPredictionGenerator: ...
    def __new__(cls: typing.Type[TextPredictionGenerator], language_tag: str) -> TextPredictionGenerator:...
    @typing.overload
    def get_candidates_async(self, input: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: winrt.system.UInt32, prediction_options: TextPredictionOptions, previous_strings: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_next_word_candidates_async(self, max_candidates: winrt.system.UInt32, previous_strings: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @_property
    def language_available_but_not_installed(self) -> bool: ...
    @_property
    def resolved_language(self) -> str: ...
    @_property
    def input_scope(self) -> winrt.windows.ui.text.core.CoreTextInputScope: ...
    @input_scope.setter
    def input_scope(self, value: winrt.windows.ui.text.core.CoreTextInputScope) -> None: ...

@typing.final
class TextReverseConversionGenerator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextReverseConversionGenerator: ...
    def __new__(cls: typing.Type[TextReverseConversionGenerator], language_tag: str) -> TextReverseConversionGenerator:...
    def convert_back_async(self, input: str, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def get_phonemes_async(self, input: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[TextPhoneme]]: ...
    @_property
    def language_available_but_not_installed(self) -> bool: ...
    @_property
    def resolved_language(self) -> str: ...

@typing.final
class UnicodeCharacters_Static(type):
    def get_codepoint_from_surrogate_pair(cls, high_surrogate: winrt.system.UInt32, low_surrogate: winrt.system.UInt32, /) -> winrt.system.UInt32: ...
    def get_general_category(cls, codepoint: winrt.system.UInt32, /) -> UnicodeGeneralCategory: ...
    def get_numeric_type(cls, codepoint: winrt.system.UInt32, /) -> UnicodeNumericType: ...
    def get_surrogate_pair_from_codepoint(cls, codepoint: winrt.system.UInt32, /) -> typing.Tuple[winrt.system.Char16, winrt.system.Char16]: ...
    def is_alphabetic(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_cased(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_grapheme_base(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_grapheme_extend(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_high_surrogate(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_id_continue(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_id_start(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_low_surrogate(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_lowercase(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_noncharacter(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_supplementary(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_uppercase(cls, codepoint: winrt.system.UInt32, /) -> bool: ...
    def is_whitespace(cls, codepoint: winrt.system.UInt32, /) -> bool: ...

@typing.final
class UnicodeCharacters(winrt.system.Object, metaclass=UnicodeCharacters_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UnicodeCharacters: ...

@typing.final
class WordSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WordSegment: ...
    @_property
    def alternate_forms(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AlternateWordForm]]: ...
    @_property
    def source_text_segment(self) -> TextSegment: ...
    @_property
    def text(self) -> str: ...

@typing.final
class WordsSegmenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WordsSegmenter: ...
    def __new__(cls: typing.Type[WordsSegmenter], language: str) -> WordsSegmenter:...
    def get_token_at(self, text: str, start_index: winrt.system.UInt32, /) -> typing.Optional[WordSegment]: ...
    def get_tokens(self, text: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[WordSegment]]: ...
    def tokenize(self, text: str, start_index: winrt.system.UInt32, handler: typing.Optional[WordSegmentsTokenizingHandler], /) -> None: ...
    @_property
    def resolved_language(self) -> str: ...

