// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.0

#include "py.Windows.Media.Audio.h"

namespace py::cpp::Windows::Media::Audio
{
    // ----- AudioDeviceInputNode class --------------------

    static PyObject* _new_AudioDeviceInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"AddOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_AddOutgoingConnectionWithGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"AddOutgoingConnection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"RemoveOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Device");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Device();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Emitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Emitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioDeviceInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioDeviceInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "add_outgoing_connection_with_gain", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_AddOutgoingConnectionWithGain), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioDeviceInputNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioDeviceInputNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioDeviceInputNode[] = {
        { "device", reinterpret_cast<getter>(AudioDeviceInputNode_get_Device), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioDeviceInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioDeviceInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioDeviceInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioDeviceInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioDeviceInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioDeviceInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioDeviceInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioDeviceInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioDeviceInputNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceInputNode) },
        { }};

    static PyType_Spec type_spec_AudioDeviceInputNode = {
        "winrt._winrt_windows_media_audio.AudioDeviceInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceInputNode};

    // ----- AudioDeviceOutputNode class --------------------

    static PyObject* _new_AudioDeviceOutputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Device");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Device();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Listener");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Listener();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Listener");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            {
                auto _gil = release_gil();
                self->obj.Listener(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioDeviceOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioDeviceOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioDeviceOutputNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioDeviceOutputNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioDeviceOutputNode[] = {
        { "device", reinterpret_cast<getter>(AudioDeviceOutputNode_get_Device), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioDeviceOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioDeviceOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioDeviceOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioDeviceOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioDeviceOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioDeviceOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "listener", reinterpret_cast<getter>(AudioDeviceOutputNode_get_Listener), reinterpret_cast<setter>(AudioDeviceOutputNode_put_Listener), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioDeviceOutputNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceOutputNode) },
        { }};

    static PyType_Spec type_spec_AudioDeviceOutputNode = {
        "winrt._winrt_windows_media_audio.AudioDeviceOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceOutputNode};

    // ----- AudioEffectsPackConfiguration class --------------------

    static PyObject* _new_AudioEffectsPackConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioEffectsPackConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioEffectsPackConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioEffectsPackConfiguration(py::wrapper::Windows::Media::Audio::AudioEffectsPackConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioEffectsPackConfiguration_GetForDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioEffectsPackConfiguration", L"GetForDeviceId", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioEffectsPackConfiguration::GetForDeviceId(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEffectsPackConfiguration_IsDeviceIdSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioEffectsPackConfiguration", L"IsDeviceIdSupported", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioEffectsPackConfiguration::IsDeviceIdSupported(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEffectsPackConfiguration_get_DeviceId(py::wrapper::Windows::Media::Audio::AudioEffectsPackConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioEffectsPackConfiguration", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEffectsPackConfiguration_get_EffectsPackId(py::wrapper::Windows::Media::Audio::AudioEffectsPackConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioEffectsPackConfiguration", L"EffectsPackId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectsPackId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEffectsPackConfiguration_get_Status(py::wrapper::Windows::Media::Audio::AudioEffectsPackConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioEffectsPackConfiguration", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEffectsPackConfiguration_add_StatusChanged(py::wrapper::Windows::Media::Audio::AudioEffectsPackConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioEffectsPackConfiguration", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioEffectsPackConfiguration, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEffectsPackConfiguration_remove_StatusChanged(py::wrapper::Windows::Media::Audio::AudioEffectsPackConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioEffectsPackConfiguration", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioEffectsPackConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioEffectsPackConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioEffectsPackConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioEffectsPackConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffectsPackConfiguration[] = {
        { "add_status_changed", reinterpret_cast<PyCFunction>(AudioEffectsPackConfiguration_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(AudioEffectsPackConfiguration_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioEffectsPackConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEffectsPackConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioEffectsPackConfiguration[] = {
        { "device_id", reinterpret_cast<getter>(AudioEffectsPackConfiguration_get_DeviceId), nullptr, nullptr, nullptr },
        { "effects_pack_id", reinterpret_cast<getter>(AudioEffectsPackConfiguration_get_EffectsPackId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AudioEffectsPackConfiguration_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioEffectsPackConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEffectsPackConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioEffectsPackConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEffectsPackConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEffectsPackConfiguration) },
        { }};

    static PyType_Spec type_spec_AudioEffectsPackConfiguration = {
        "winrt._winrt_windows_media_audio.AudioEffectsPackConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::AudioEffectsPackConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffectsPackConfiguration};

    static PyGetSetDef getset_AudioEffectsPackConfiguration_Static[] = {
        { }};

    static PyMethodDef methods_AudioEffectsPackConfiguration_Static[] = {
        { "get_for_device_id", reinterpret_cast<PyCFunction>(AudioEffectsPackConfiguration_GetForDeviceId), METH_VARARGS, nullptr },
        { "is_device_id_supported", reinterpret_cast<PyCFunction>(AudioEffectsPackConfiguration_IsDeviceIdSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AudioEffectsPackConfiguration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioEffectsPackConfiguration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioEffectsPackConfiguration_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioEffectsPackConfiguration_Static = {
        "winrt._winrt_windows_media_audio.AudioEffectsPackConfiguration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioEffectsPackConfiguration_Static};

    // ----- AudioFileInputNode class --------------------

    static PyObject* _new_AudioFileInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFileInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFileInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFileInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"AddOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_AddOutgoingConnectionWithGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"AddOutgoingConnection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"RemoveOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Seek(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Seek", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Seek(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"PlaybackSpeedFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaybackSpeedFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"PlaybackSpeedFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.PlaybackSpeedFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"LoopCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LoopCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"LoopCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.LoopCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            {
                auto _gil = release_gil();
                self->obj.EndTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            {
                auto _gil = release_gil();
                self->obj.StartTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_Position(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_SourceFile(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"SourceFile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceFile();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Duration(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Emitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Emitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_add_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFileInputNode", L"FileCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFileInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_remove_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFileInputNode", L"FileCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FileCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFileInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFileInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFileInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFileInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "add_outgoing_connection_with_gain", reinterpret_cast<PyCFunction>(AudioFileInputNode_AddOutgoingConnectionWithGain), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioFileInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFileInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFileInputNode_Reset), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(AudioFileInputNode_Seek), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFileInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFileInputNode_Stop), METH_VARARGS, nullptr },
        { "add_file_completed", reinterpret_cast<PyCFunction>(AudioFileInputNode_add_FileCompleted), METH_O, nullptr },
        { "remove_file_completed", reinterpret_cast<PyCFunction>(AudioFileInputNode_remove_FileCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioFileInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFileInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFileInputNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioFileInputNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioFileInputNode[] = {
        { "playback_speed_factor", reinterpret_cast<getter>(AudioFileInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(AudioFileInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "loop_count", reinterpret_cast<getter>(AudioFileInputNode_get_LoopCount), reinterpret_cast<setter>(AudioFileInputNode_put_LoopCount), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(AudioFileInputNode_get_EndTime), reinterpret_cast<setter>(AudioFileInputNode_put_EndTime), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(AudioFileInputNode_get_StartTime), reinterpret_cast<setter>(AudioFileInputNode_put_StartTime), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AudioFileInputNode_get_Position), nullptr, nullptr, nullptr },
        { "source_file", reinterpret_cast<getter>(AudioFileInputNode_get_SourceFile), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AudioFileInputNode_get_Duration), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioFileInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioFileInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFileInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFileInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFileInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFileInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFileInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFileInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioFileInputNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFileInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFileInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFileInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFileInputNode) },
        { }};

    static PyType_Spec type_spec_AudioFileInputNode = {
        "winrt._winrt_windows_media_audio.AudioFileInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileInputNode};

    // ----- AudioFileOutputNode class --------------------

    static PyObject* _new_AudioFileOutputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFileOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_FinalizeAsync(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"FinalizeAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FinalizeAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_File(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.File();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_FileEncodingProfile(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"FileEncodingProfile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileEncodingProfile();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFileOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFileOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFileOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "finalize_async", reinterpret_cast<PyCFunction>(AudioFileOutputNode_FinalizeAsync), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioFileOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFileOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFileOutputNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioFileOutputNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioFileOutputNode[] = {
        { "file", reinterpret_cast<getter>(AudioFileOutputNode_get_File), nullptr, nullptr, nullptr },
        { "file_encoding_profile", reinterpret_cast<getter>(AudioFileOutputNode_get_FileEncodingProfile), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFileOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFileOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFileOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFileOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFileOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFileOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioFileOutputNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFileOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFileOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFileOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFileOutputNode) },
        { }};

    static PyType_Spec type_spec_AudioFileOutputNode = {
        "winrt._winrt_windows_media_audio.AudioFileOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileOutputNode};

    // ----- AudioFrameCompletedEventArgs class --------------------

    static PyObject* _new_AudioFrameCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFrameCompletedEventArgs(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameCompletedEventArgs_get_Frame(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameCompletedEventArgs", L"Frame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Frame();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_AudioFrameCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioFrameCompletedEventArgs[] = {
        { "frame", reinterpret_cast<getter>(AudioFrameCompletedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioFrameCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_AudioFrameCompletedEventArgs = {
        "winrt._winrt_windows_media_audio.AudioFrameCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameCompletedEventArgs};

    // ----- AudioFrameInputNode class --------------------

    static PyObject* _new_AudioFrameInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameInputNode_AddFrame(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddFrame", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::AudioFrame>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddFrame(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_AddOutgoingConnectionWithGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddOutgoingConnection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DiscardQueuedFrames(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"DiscardQueuedFrames", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.DiscardQueuedFrames();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"RemoveOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"PlaybackSpeedFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaybackSpeedFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"PlaybackSpeedFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.PlaybackSpeedFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_QueuedSampleCount(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QueuedSampleCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueuedSampleCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Emitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Emitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AudioFrameCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AudioFrameCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AudioFrameCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.AudioFrameCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QuantumStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuantumStarted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QuantumStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuantumStarted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameInputNode[] = {
        { "add_frame", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddFrame), METH_VARARGS, nullptr },
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "add_outgoing_connection_with_gain", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddOutgoingConnectionWithGain), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(AudioFrameInputNode_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFrameInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Stop), METH_VARARGS, nullptr },
        { "add_audio_frame_completed", reinterpret_cast<PyCFunction>(AudioFrameInputNode_add_AudioFrameCompleted), METH_O, nullptr },
        { "remove_audio_frame_completed", reinterpret_cast<PyCFunction>(AudioFrameInputNode_remove_AudioFrameCompleted), METH_O, nullptr },
        { "add_quantum_started", reinterpret_cast<PyCFunction>(AudioFrameInputNode_add_QuantumStarted), METH_O, nullptr },
        { "remove_quantum_started", reinterpret_cast<PyCFunction>(AudioFrameInputNode_remove_QuantumStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioFrameInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrameInputNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioFrameInputNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioFrameInputNode[] = {
        { "playback_speed_factor", reinterpret_cast<getter>(AudioFrameInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(AudioFrameInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "queued_sample_count", reinterpret_cast<getter>(AudioFrameInputNode_get_QueuedSampleCount), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioFrameInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioFrameInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFrameInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFrameInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFrameInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFrameInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFrameInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFrameInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioFrameInputNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameInputNode) },
        { }};

    static PyType_Spec type_spec_AudioFrameInputNode = {
        "winrt._winrt_windows_media_audio.AudioFrameInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameInputNode};

    // ----- AudioFrameOutputNode class --------------------

    static PyObject* _new_AudioFrameOutputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_GetFrame(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"GetFrame", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFrame();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "get_frame", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_GetFrame), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioFrameOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrameOutputNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioFrameOutputNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioFrameOutputNode[] = {
        { "outgoing_gain", reinterpret_cast<getter>(AudioFrameOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFrameOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFrameOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFrameOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFrameOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFrameOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioFrameOutputNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameOutputNode) },
        { }};

    static PyType_Spec type_spec_AudioFrameOutputNode = {
        "winrt._winrt_windows_media_audio.AudioFrameOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameOutputNode};

    // ----- AudioGraph class --------------------

    static PyObject* _new_AudioGraph(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioGraph>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioGraph>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraph_Close(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraphSettings>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioGraph::CreateAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateBatchUpdater", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateBatchUpdater();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateDeviceInputNodeAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceInputNodeWithFormatAndEmitterOnDeviceAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateDeviceInputNodeAsync(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceInputNodeWithFormatAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateDeviceInputNodeAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceInputNodeWithFormatOnDeviceAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateDeviceInputNodeAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceOutputNodeAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateDeviceOutputNodeAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileInputNodeAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileInputNodeAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileInputNodeWithEmitterAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileInputNodeAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileInputNodeAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileOutputNodeAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileOutputNodeAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileOutputNodeWithFileProfileAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileOutputNodeAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileOutputNodeAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameInputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFrameInputNode();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameInputNodeWithFormat(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFrameInputNode(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameInputNodeWithFormatAndEmitter(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFrameInputNode(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameOutputNode", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFrameOutputNode();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameOutputNodeWithFormat(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameOutputNode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFrameOutputNode(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateMediaSourceAudioInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateMediaSourceAudioInputNodeAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateMediaSourceAudioInputNodeAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateMediaSourceAudioInputNodeWithEmitterAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateMediaSourceAudioInputNodeAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateMediaSourceAudioInputNodeAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateSubmixNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateSubmixNode();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateSubmixNodeWithFormat(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateSubmixNode(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateSubmixNodeWithFormatAndEmitter(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateSubmixNode(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_ResetAllNodes(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"ResetAllNodes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ResetAllNodes();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Start(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Stop(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_CompletedQuantumCount(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"CompletedQuantumCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompletedQuantumCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_LatencyInSamples(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"LatencyInSamples");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LatencyInSamples();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"PrimaryRenderDevice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimaryRenderDevice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_RenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"RenderDeviceAudioProcessing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RenderDeviceAudioProcessing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_SamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"SamplesPerQuantum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SamplesPerQuantum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumProcessed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuantumProcessed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumProcessed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuantumProcessed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuantumStarted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuantumStarted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"UnrecoverableErrorOccurred");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnrecoverableErrorOccurred(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"UnrecoverableErrorOccurred");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnrecoverableErrorOccurred(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraph>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraph>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraph[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioGraph_Close), METH_VARARGS, nullptr },
        { "create_batch_updater", reinterpret_cast<PyCFunction>(AudioGraph_CreateBatchUpdater), METH_VARARGS, nullptr },
        { "create_device_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceInputNodeAsync), METH_VARARGS, nullptr },
        { "create_device_input_node_with_format_and_emitter_on_device_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceInputNodeWithFormatAndEmitterOnDeviceAsync), METH_VARARGS, nullptr },
        { "create_device_input_node_with_format_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceInputNodeWithFormatAsync), METH_VARARGS, nullptr },
        { "create_device_input_node_with_format_on_device_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceInputNodeWithFormatOnDeviceAsync), METH_VARARGS, nullptr },
        { "create_device_output_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceOutputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileInputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_input_node_with_emitter_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileInputNodeWithEmitterAsync), METH_VARARGS, nullptr },
        { "create_file_output_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileOutputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_output_node_with_file_profile_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileOutputNodeWithFileProfileAsync), METH_VARARGS, nullptr },
        { "create_frame_input_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameInputNode), METH_VARARGS, nullptr },
        { "create_frame_input_node_with_format", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameInputNodeWithFormat), METH_VARARGS, nullptr },
        { "create_frame_input_node_with_format_and_emitter", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameInputNodeWithFormatAndEmitter), METH_VARARGS, nullptr },
        { "create_frame_output_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameOutputNode), METH_VARARGS, nullptr },
        { "create_frame_output_node_with_format", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameOutputNodeWithFormat), METH_VARARGS, nullptr },
        { "create_media_source_audio_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateMediaSourceAudioInputNodeAsync), METH_VARARGS, nullptr },
        { "create_media_source_audio_input_node_with_emitter_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateMediaSourceAudioInputNodeWithEmitterAsync), METH_VARARGS, nullptr },
        { "create_submix_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateSubmixNode), METH_VARARGS, nullptr },
        { "create_submix_node_with_format", reinterpret_cast<PyCFunction>(AudioGraph_CreateSubmixNodeWithFormat), METH_VARARGS, nullptr },
        { "create_submix_node_with_format_and_emitter", reinterpret_cast<PyCFunction>(AudioGraph_CreateSubmixNodeWithFormatAndEmitter), METH_VARARGS, nullptr },
        { "reset_all_nodes", reinterpret_cast<PyCFunction>(AudioGraph_ResetAllNodes), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioGraph_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioGraph_Stop), METH_VARARGS, nullptr },
        { "add_quantum_processed", reinterpret_cast<PyCFunction>(AudioGraph_add_QuantumProcessed), METH_O, nullptr },
        { "remove_quantum_processed", reinterpret_cast<PyCFunction>(AudioGraph_remove_QuantumProcessed), METH_O, nullptr },
        { "add_quantum_started", reinterpret_cast<PyCFunction>(AudioGraph_add_QuantumStarted), METH_O, nullptr },
        { "remove_quantum_started", reinterpret_cast<PyCFunction>(AudioGraph_remove_QuantumStarted), METH_O, nullptr },
        { "add_unrecoverable_error_occurred", reinterpret_cast<PyCFunction>(AudioGraph_add_UnrecoverableErrorOccurred), METH_O, nullptr },
        { "remove_unrecoverable_error_occurred", reinterpret_cast<PyCFunction>(AudioGraph_remove_UnrecoverableErrorOccurred), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioGraph, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraph), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioGraph), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioGraph), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioGraph[] = {
        { "completed_quantum_count", reinterpret_cast<getter>(AudioGraph_get_CompletedQuantumCount), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioGraph_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "latency_in_samples", reinterpret_cast<getter>(AudioGraph_get_LatencyInSamples), nullptr, nullptr, nullptr },
        { "primary_render_device", reinterpret_cast<getter>(AudioGraph_get_PrimaryRenderDevice), nullptr, nullptr, nullptr },
        { "render_device_audio_processing", reinterpret_cast<getter>(AudioGraph_get_RenderDeviceAudioProcessing), nullptr, nullptr, nullptr },
        { "samples_per_quantum", reinterpret_cast<getter>(AudioGraph_get_SamplesPerQuantum), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioGraph[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraph) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraph) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraph) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraph) },
        { }};

    static PyType_Spec type_spec_AudioGraph = {
        "winrt._winrt_windows_media_audio.AudioGraph",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraph),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraph};

    static PyGetSetDef getset_AudioGraph_Static[] = {
        { }};

    static PyMethodDef methods_AudioGraph_Static[] = {
        { "create_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AudioGraph_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioGraph_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioGraph_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioGraph_Static = {
        "winrt._winrt_windows_media_audio.AudioGraph_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioGraph_Static};

    // ----- AudioGraphBatchUpdater class --------------------

    static PyObject* _new_AudioGraphBatchUpdater(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphBatchUpdater_Close(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraphBatchUpdater", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphBatchUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphBatchUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphBatchUpdater[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioGraphBatchUpdater_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioGraphBatchUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphBatchUpdater), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioGraphBatchUpdater), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioGraphBatchUpdater), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioGraphBatchUpdater[] = {
        { }};

    static PyType_Slot _type_slots_AudioGraphBatchUpdater[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphBatchUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphBatchUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphBatchUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphBatchUpdater) },
        { }};

    static PyType_Spec type_spec_AudioGraphBatchUpdater = {
        "winrt._winrt_windows_media_audio.AudioGraphBatchUpdater",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphBatchUpdater};

    // ----- AudioGraphConnection class --------------------

    static PyObject* _new_AudioGraphConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioGraphConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioGraphConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioGraphConnection(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphConnection_get_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Gain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Gain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphConnection_put_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Gain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Gain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphConnection_get_Destination(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Destination");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Destination();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphConnection[] = {
        { "_assign_array_", _assign_array_AudioGraphConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphConnection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioGraphConnection[] = {
        { "gain", reinterpret_cast<getter>(AudioGraphConnection_get_Gain), reinterpret_cast<setter>(AudioGraphConnection_put_Gain), nullptr, nullptr },
        { "destination", reinterpret_cast<getter>(AudioGraphConnection_get_Destination), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioGraphConnection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphConnection) },
        { }};

    static PyType_Spec type_spec_AudioGraphConnection = {
        "winrt._winrt_windows_media_audio.AudioGraphConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphConnection};

    // ----- AudioGraphSettings class --------------------

    static PyObject* _new_AudioGraphSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                winrt::Windows::Media::Audio::AudioGraphSettings instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioGraphSettings(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphSettings_get_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"QuantumSizeSelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuantumSizeSelectionMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"QuantumSizeSelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Audio::QuantumSizeSelectionMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuantumSizeSelectionMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"PrimaryRenderDevice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimaryRenderDevice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"PrimaryRenderDevice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrimaryRenderDevice(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            {
                auto _gil = release_gil();
                self->obj.EncodingProperties(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredSamplesPerQuantum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredSamplesPerQuantum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredSamplesPerQuantum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredSamplesPerQuantum(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredRenderDeviceAudioProcessing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredRenderDeviceAudioProcessing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredRenderDeviceAudioProcessing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredRenderDeviceAudioProcessing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"AudioRenderCategory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AudioRenderCategory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"AudioRenderCategory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(arg);

            {
                auto _gil = release_gil();
                self->obj.AudioRenderCategory(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"MaxPlaybackSpeedFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxPlaybackSpeedFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"MaxPlaybackSpeedFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.MaxPlaybackSpeedFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioGraphSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphSettings[] = {
        { "_assign_array_", _assign_array_AudioGraphSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioGraphSettings[] = {
        { "quantum_size_selection_mode", reinterpret_cast<getter>(AudioGraphSettings_get_QuantumSizeSelectionMode), reinterpret_cast<setter>(AudioGraphSettings_put_QuantumSizeSelectionMode), nullptr, nullptr },
        { "primary_render_device", reinterpret_cast<getter>(AudioGraphSettings_get_PrimaryRenderDevice), reinterpret_cast<setter>(AudioGraphSettings_put_PrimaryRenderDevice), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioGraphSettings_get_EncodingProperties), reinterpret_cast<setter>(AudioGraphSettings_put_EncodingProperties), nullptr, nullptr },
        { "desired_samples_per_quantum", reinterpret_cast<getter>(AudioGraphSettings_get_DesiredSamplesPerQuantum), reinterpret_cast<setter>(AudioGraphSettings_put_DesiredSamplesPerQuantum), nullptr, nullptr },
        { "desired_render_device_audio_processing", reinterpret_cast<getter>(AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing), reinterpret_cast<setter>(AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing), nullptr, nullptr },
        { "audio_render_category", reinterpret_cast<getter>(AudioGraphSettings_get_AudioRenderCategory), reinterpret_cast<setter>(AudioGraphSettings_put_AudioRenderCategory), nullptr, nullptr },
        { "max_playback_speed_factor", reinterpret_cast<getter>(AudioGraphSettings_get_MaxPlaybackSpeedFactor), reinterpret_cast<setter>(AudioGraphSettings_put_MaxPlaybackSpeedFactor), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioGraphSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphSettings) },
        { }};

    static PyType_Spec type_spec_AudioGraphSettings = {
        "winrt._winrt_windows_media_audio.AudioGraphSettings",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphSettings};

    // ----- AudioGraphUnrecoverableErrorOccurredEventArgs class --------------------

    static PyObject* _new_AudioGraphUnrecoverableErrorOccurredEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphUnrecoverableErrorOccurredEventArgs", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Error();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphUnrecoverableErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphUnrecoverableErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_AudioGraphUnrecoverableErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphUnrecoverableErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "error", reinterpret_cast<getter>(AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { }};

    static PyType_Spec type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs = {
        "winrt._winrt_windows_media_audio.AudioGraphUnrecoverableErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs};

    // ----- AudioNodeEmitter class --------------------

    static PyObject* _new_AudioNodeEmitter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterShape>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterSettings>(args, 2);

                winrt::Windows::Media::Audio::AudioNodeEmitter instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeEmitter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeEmitter(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitter_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.Position(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Gain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Gain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Gain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Gain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DopplerVelocity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.DopplerVelocity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DopplerScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DopplerScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DistanceScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DistanceScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DistanceScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DistanceScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Direction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.Direction(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DecayModel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DecayModel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_IsDopplerDisabled(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"IsDopplerDisabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDopplerDisabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_Shape(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Shape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Shape();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"SpatialAudioModel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SpatialAudioModel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"SpatialAudioModel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Audio::SpatialAudioModel>(arg);

            {
                auto _gil = release_gil();
                self->obj.SpatialAudioModel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitter[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioNodeEmitter[] = {
        { "position", reinterpret_cast<getter>(AudioNodeEmitter_get_Position), reinterpret_cast<setter>(AudioNodeEmitter_put_Position), nullptr, nullptr },
        { "gain", reinterpret_cast<getter>(AudioNodeEmitter_get_Gain), reinterpret_cast<setter>(AudioNodeEmitter_put_Gain), nullptr, nullptr },
        { "doppler_velocity", reinterpret_cast<getter>(AudioNodeEmitter_get_DopplerVelocity), reinterpret_cast<setter>(AudioNodeEmitter_put_DopplerVelocity), nullptr, nullptr },
        { "doppler_scale", reinterpret_cast<getter>(AudioNodeEmitter_get_DopplerScale), reinterpret_cast<setter>(AudioNodeEmitter_put_DopplerScale), nullptr, nullptr },
        { "distance_scale", reinterpret_cast<getter>(AudioNodeEmitter_get_DistanceScale), reinterpret_cast<setter>(AudioNodeEmitter_put_DistanceScale), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(AudioNodeEmitter_get_Direction), reinterpret_cast<setter>(AudioNodeEmitter_put_Direction), nullptr, nullptr },
        { "decay_model", reinterpret_cast<getter>(AudioNodeEmitter_get_DecayModel), nullptr, nullptr, nullptr },
        { "is_doppler_disabled", reinterpret_cast<getter>(AudioNodeEmitter_get_IsDopplerDisabled), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(AudioNodeEmitter_get_Shape), nullptr, nullptr, nullptr },
        { "spatial_audio_model", reinterpret_cast<getter>(AudioNodeEmitter_get_SpatialAudioModel), reinterpret_cast<setter>(AudioNodeEmitter_put_SpatialAudioModel), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioNodeEmitter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitter) },
        { }};

    static PyType_Spec type_spec_AudioNodeEmitter = {
        "winrt._winrt_windows_media_audio.AudioNodeEmitter",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitter};

    // ----- AudioNodeEmitterConeProperties class --------------------

    static PyObject* _new_AudioNodeEmitterConeProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterConeProperties_get_InnerAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"InnerAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InnerAngle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"OuterAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OuterAngle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngleGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"OuterAngleGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OuterAngleGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterConeProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterConeProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterConeProperties[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterConeProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterConeProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioNodeEmitterConeProperties[] = {
        { "inner_angle", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_InnerAngle), nullptr, nullptr, nullptr },
        { "outer_angle", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_OuterAngle), nullptr, nullptr, nullptr },
        { "outer_angle_gain", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_OuterAngleGain), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioNodeEmitterConeProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterConeProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterConeProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterConeProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterConeProperties) },
        { }};

    static PyType_Spec type_spec_AudioNodeEmitterConeProperties = {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterConeProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterConeProperties};

    // ----- AudioNodeEmitterDecayModel class --------------------

    static PyObject* _new_AudioNodeEmitterDecayModel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterDecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateCustom(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"CreateCustom", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateCustom(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateNatural(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"CreateNatural", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateNatural(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MaxGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"MaxGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MinGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"MinGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_NaturalProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"NaturalProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NaturalProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterDecayModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterDecayModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterDecayModel[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterDecayModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterDecayModel), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioNodeEmitterDecayModel[] = {
        { "kind", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_Kind), nullptr, nullptr, nullptr },
        { "max_gain", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_MaxGain), nullptr, nullptr, nullptr },
        { "min_gain", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_MinGain), nullptr, nullptr, nullptr },
        { "natural_properties", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_NaturalProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioNodeEmitterDecayModel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterDecayModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterDecayModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterDecayModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterDecayModel) },
        { }};

    static PyType_Spec type_spec_AudioNodeEmitterDecayModel = {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterDecayModel",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterDecayModel};

    static PyGetSetDef getset_AudioNodeEmitterDecayModel_Static[] = {
        { }};

    static PyMethodDef methods_AudioNodeEmitterDecayModel_Static[] = {
        { "create_custom", reinterpret_cast<PyCFunction>(AudioNodeEmitterDecayModel_CreateCustom), METH_VARARGS, nullptr },
        { "create_natural", reinterpret_cast<PyCFunction>(AudioNodeEmitterDecayModel_CreateNatural), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AudioNodeEmitterDecayModel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioNodeEmitterDecayModel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioNodeEmitterDecayModel_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioNodeEmitterDecayModel_Static = {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterDecayModel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioNodeEmitterDecayModel_Static};

    // ----- AudioNodeEmitterNaturalDecayModelProperties class --------------------

    static PyObject* _new_AudioNodeEmitterNaturalDecayModelProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterNaturalDecayModelProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterNaturalDecayModelProperties", L"CutoffDistance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CutoffDistance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterNaturalDecayModelProperties", L"UnityGainDistance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnityGainDistance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterNaturalDecayModelProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterNaturalDecayModelProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterNaturalDecayModelProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterNaturalDecayModelProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "cutoff_distance", reinterpret_cast<getter>(AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance), nullptr, nullptr, nullptr },
        { "unity_gain_distance", reinterpret_cast<getter>(AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterNaturalDecayModelProperties) },
        { }};

    static PyType_Spec type_spec_AudioNodeEmitterNaturalDecayModelProperties = {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterNaturalDecayModelProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterNaturalDecayModelProperties};

    // ----- AudioNodeEmitterShape class --------------------

    static PyObject* _new_AudioNodeEmitterShape(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterShape(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterShape_CreateCone(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"CreateCone", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateCone(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_CreateOmnidirectional(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"CreateOmnidirectional", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateOmnidirectional();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_ConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"ConeProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConeProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterShape>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterShape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterShape[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterShape, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterShape), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioNodeEmitterShape[] = {
        { "cone_properties", reinterpret_cast<getter>(AudioNodeEmitterShape_get_ConeProperties), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(AudioNodeEmitterShape_get_Kind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioNodeEmitterShape[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterShape) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterShape) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterShape) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterShape) },
        { }};

    static PyType_Spec type_spec_AudioNodeEmitterShape = {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterShape",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterShape};

    static PyGetSetDef getset_AudioNodeEmitterShape_Static[] = {
        { }};

    static PyMethodDef methods_AudioNodeEmitterShape_Static[] = {
        { "create_cone", reinterpret_cast<PyCFunction>(AudioNodeEmitterShape_CreateCone), METH_VARARGS, nullptr },
        { "create_omnidirectional", reinterpret_cast<PyCFunction>(AudioNodeEmitterShape_CreateOmnidirectional), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AudioNodeEmitterShape_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioNodeEmitterShape_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioNodeEmitterShape_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioNodeEmitterShape_Static = {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterShape_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioNodeEmitterShape_Static};

    // ----- AudioNodeListener class --------------------

    static PyObject* _new_AudioNodeListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeListener instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeListener(py::wrapper::Windows::Media::Audio::AudioNodeListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeListener_get_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"SpeedOfSound");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SpeedOfSound();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"SpeedOfSound");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.SpeedOfSound(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.Position(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            {
                auto _gil = release_gil();
                self->obj.Orientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"DopplerVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DopplerVelocity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"DopplerVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.DopplerVelocity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioNodeListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeListener[] = {
        { "_assign_array_", _assign_array_AudioNodeListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeListener), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioNodeListener[] = {
        { "speed_of_sound", reinterpret_cast<getter>(AudioNodeListener_get_SpeedOfSound), reinterpret_cast<setter>(AudioNodeListener_put_SpeedOfSound), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AudioNodeListener_get_Position), reinterpret_cast<setter>(AudioNodeListener_put_Position), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(AudioNodeListener_get_Orientation), reinterpret_cast<setter>(AudioNodeListener_put_Orientation), nullptr, nullptr },
        { "doppler_velocity", reinterpret_cast<getter>(AudioNodeListener_get_DopplerVelocity), reinterpret_cast<setter>(AudioNodeListener_put_DopplerVelocity), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioNodeListener[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeListener) },
        { }};

    static PyType_Spec type_spec_AudioNodeListener = {
        "winrt._winrt_windows_media_audio.AudioNodeListener",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeListener};

    // ----- AudioPlaybackConnection class --------------------

    static PyObject* _new_AudioPlaybackConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioPlaybackConnection_Close(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"GetDeviceSelector", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioPlaybackConnection::GetDeviceSelector();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Open(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Open", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Open();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_OpenAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"OpenAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Start(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_StartAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StartAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_TryCreateFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"TryCreateFromId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioPlaybackConnection::TryCreateFromId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_DeviceId(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_State(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_add_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioPlaybackConnection, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_remove_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioPlaybackConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioPlaybackConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioPlaybackConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Close), METH_VARARGS, nullptr },
        { "open", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Open), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_OpenAsync), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Start), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_StartAsync), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioPlaybackConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioPlaybackConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioPlaybackConnection), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioPlaybackConnection), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioPlaybackConnection[] = {
        { "device_id", reinterpret_cast<getter>(AudioPlaybackConnection_get_DeviceId), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AudioPlaybackConnection_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioPlaybackConnection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioPlaybackConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioPlaybackConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioPlaybackConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioPlaybackConnection) },
        { }};

    static PyType_Spec type_spec_AudioPlaybackConnection = {
        "winrt._winrt_windows_media_audio.AudioPlaybackConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnection};

    static PyGetSetDef getset_AudioPlaybackConnection_Static[] = {
        { }};

    static PyMethodDef methods_AudioPlaybackConnection_Static[] = {
        { "get_device_selector", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_GetDeviceSelector), METH_VARARGS, nullptr },
        { "try_create_from_id", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_TryCreateFromId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AudioPlaybackConnection_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioPlaybackConnection_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioPlaybackConnection_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioPlaybackConnection_Static = {
        "winrt._winrt_windows_media_audio.AudioPlaybackConnection_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioPlaybackConnection_Static};

    // ----- AudioPlaybackConnectionOpenResult class --------------------

    static PyObject* _new_AudioPlaybackConnectionOpenResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnectionOpenResult(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnectionOpenResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_Status(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnectionOpenResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioPlaybackConnectionOpenResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioPlaybackConnectionOpenResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnectionOpenResult[] = {
        { "_assign_array_", _assign_array_AudioPlaybackConnectionOpenResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioPlaybackConnectionOpenResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioPlaybackConnectionOpenResult[] = {
        { "extended_error", reinterpret_cast<getter>(AudioPlaybackConnectionOpenResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AudioPlaybackConnectionOpenResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioPlaybackConnectionOpenResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioPlaybackConnectionOpenResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioPlaybackConnectionOpenResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioPlaybackConnectionOpenResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioPlaybackConnectionOpenResult) },
        { }};

    static PyType_Spec type_spec_AudioPlaybackConnectionOpenResult = {
        "winrt._winrt_windows_media_audio.AudioPlaybackConnectionOpenResult",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnectionOpenResult};

    // ----- AudioStateMonitor class --------------------

    static PyObject* _new_AudioStateMonitor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioStateMonitor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioStateMonitor>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioStateMonitor(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoringWithCategory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoringWithCategoryAndDeviceId", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoringWithCategoryAndDeviceId(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceRole(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoringWithCategory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoringWithCategoryAndDeviceId", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoringWithCategoryAndDeviceId(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceRole(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_get_SoundLevel(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SoundLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_add_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevelChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioStateMonitor, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SoundLevelChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_remove_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevelChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SoundLevelChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioStateMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioStateMonitor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioStateMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioStateMonitor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStateMonitor[] = {
        { "add_sound_level_changed", reinterpret_cast<PyCFunction>(AudioStateMonitor_add_SoundLevelChanged), METH_O, nullptr },
        { "remove_sound_level_changed", reinterpret_cast<PyCFunction>(AudioStateMonitor_remove_SoundLevelChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioStateMonitor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioStateMonitor), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AudioStateMonitor[] = {
        { "sound_level", reinterpret_cast<getter>(AudioStateMonitor_get_SoundLevel), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioStateMonitor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioStateMonitor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioStateMonitor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioStateMonitor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioStateMonitor) },
        { }};

    static PyType_Spec type_spec_AudioStateMonitor = {
        "winrt._winrt_windows_media_audio.AudioStateMonitor",
        sizeof(py::wrapper::Windows::Media::Audio::AudioStateMonitor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStateMonitor};

    static PyGetSetDef getset_AudioStateMonitor_Static[] = {
        { }};

    static PyMethodDef methods_AudioStateMonitor_Static[] = {
        { "create_for_capture_monitoring", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoring), METH_VARARGS, nullptr },
        { "create_for_capture_monitoring_with_category", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoringWithCategory), METH_VARARGS, nullptr },
        { "create_for_capture_monitoring_with_category_and_device_id", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId), METH_VARARGS, nullptr },
        { "create_for_capture_monitoring_with_category_and_device_role", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceRole), METH_VARARGS, nullptr },
        { "create_for_render_monitoring", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoring), METH_VARARGS, nullptr },
        { "create_for_render_monitoring_with_category", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoringWithCategory), METH_VARARGS, nullptr },
        { "create_for_render_monitoring_with_category_and_device_id", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId), METH_VARARGS, nullptr },
        { "create_for_render_monitoring_with_category_and_device_role", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceRole), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AudioStateMonitor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioStateMonitor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioStateMonitor_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioStateMonitor_Static = {
        "winrt._winrt_windows_media_audio.AudioStateMonitor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioStateMonitor_Static};

    // ----- AudioSubmixNode class --------------------

    static PyObject* _new_AudioSubmixNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioSubmixNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioSubmixNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioSubmixNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"AddOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_AddOutgoingConnectionWithGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"AddOutgoingConnection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Close(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"RemoveOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Reset(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Start(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Stop(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Emitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Emitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioSubmixNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioSubmixNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioSubmixNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioSubmixNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioSubmixNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioSubmixNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "add_outgoing_connection_with_gain", reinterpret_cast<PyCFunction>(AudioSubmixNode_AddOutgoingConnectionWithGain), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioSubmixNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioSubmixNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioSubmixNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioSubmixNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioSubmixNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioSubmixNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioSubmixNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioSubmixNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioSubmixNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioSubmixNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AudioSubmixNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AudioSubmixNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(AudioSubmixNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioSubmixNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioSubmixNode_get_OutgoingGain), reinterpret_cast<setter>(AudioSubmixNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioSubmixNode_get_ConsumeInput), reinterpret_cast<setter>(AudioSubmixNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioSubmixNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioSubmixNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AudioSubmixNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioSubmixNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioSubmixNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioSubmixNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioSubmixNode) },
        { }};

    static PyType_Spec type_spec_AudioSubmixNode = {
        "winrt._winrt_windows_media_audio.AudioSubmixNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioSubmixNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioSubmixNode};

    // ----- CreateAudioDeviceInputNodeResult class --------------------

    static PyObject* _new_CreateAudioDeviceInputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_DeviceInputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"DeviceInputNode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceInputNode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioDeviceInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioDeviceInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioDeviceInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioDeviceInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CreateAudioDeviceInputNodeResult[] = {
        { "device_input_node", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_DeviceInputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CreateAudioDeviceInputNodeResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioDeviceInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioDeviceInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioDeviceInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioDeviceInputNodeResult) },
        { }};

    static PyType_Spec type_spec_CreateAudioDeviceInputNodeResult = {
        "winrt._winrt_windows_media_audio.CreateAudioDeviceInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceInputNodeResult};

    // ----- CreateAudioDeviceOutputNodeResult class --------------------

    static PyObject* _new_CreateAudioDeviceOutputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"DeviceOutputNode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceOutputNode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioDeviceOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioDeviceOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceOutputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioDeviceOutputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioDeviceOutputNodeResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CreateAudioDeviceOutputNodeResult[] = {
        { "device_output_node", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CreateAudioDeviceOutputNodeResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioDeviceOutputNodeResult) },
        { }};

    static PyType_Spec type_spec_CreateAudioDeviceOutputNodeResult = {
        "winrt._winrt_windows_media_audio.CreateAudioDeviceOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceOutputNodeResult};

    // ----- CreateAudioFileInputNodeResult class --------------------

    static PyObject* _new_CreateAudioFileInputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioFileInputNodeResult_get_FileInputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"FileInputNode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileInputNode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioFileInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioFileInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioFileInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioFileInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CreateAudioFileInputNodeResult[] = {
        { "file_input_node", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_FileInputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CreateAudioFileInputNodeResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioFileInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioFileInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioFileInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioFileInputNodeResult) },
        { }};

    static PyType_Spec type_spec_CreateAudioFileInputNodeResult = {
        "winrt._winrt_windows_media_audio.CreateAudioFileInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileInputNodeResult};

    // ----- CreateAudioFileOutputNodeResult class --------------------

    static PyObject* _new_CreateAudioFileOutputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_FileOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"FileOutputNode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileOutputNode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioFileOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioFileOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileOutputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioFileOutputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioFileOutputNodeResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CreateAudioFileOutputNodeResult[] = {
        { "file_output_node", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_FileOutputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CreateAudioFileOutputNodeResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioFileOutputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioFileOutputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioFileOutputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioFileOutputNodeResult) },
        { }};

    static PyType_Spec type_spec_CreateAudioFileOutputNodeResult = {
        "winrt._winrt_windows_media_audio.CreateAudioFileOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileOutputNodeResult};

    // ----- CreateAudioGraphResult class --------------------

    static PyObject* _new_CreateAudioGraphResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioGraphResult(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioGraphResult_get_Graph(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"Graph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Graph();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioGraphResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioGraphResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioGraphResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioGraphResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioGraphResult[] = {
        { "_assign_array_", _assign_array_CreateAudioGraphResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioGraphResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CreateAudioGraphResult[] = {
        { "graph", reinterpret_cast<getter>(CreateAudioGraphResult_get_Graph), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioGraphResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioGraphResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CreateAudioGraphResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioGraphResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioGraphResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioGraphResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioGraphResult) },
        { }};

    static PyType_Spec type_spec_CreateAudioGraphResult = {
        "winrt._winrt_windows_media_audio.CreateAudioGraphResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioGraphResult};

    // ----- CreateMediaSourceAudioInputNodeResult class --------------------

    static PyObject* _new_CreateMediaSourceAudioInputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateMediaSourceAudioInputNodeResult(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Node(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"Node");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Node();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateMediaSourceAudioInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateMediaSourceAudioInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateMediaSourceAudioInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateMediaSourceAudioInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateMediaSourceAudioInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CreateMediaSourceAudioInputNodeResult[] = {
        { "node", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_Node), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CreateMediaSourceAudioInputNodeResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateMediaSourceAudioInputNodeResult) },
        { }};

    static PyType_Spec type_spec_CreateMediaSourceAudioInputNodeResult = {
        "winrt._winrt_windows_media_audio.CreateMediaSourceAudioInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateMediaSourceAudioInputNodeResult};

    // ----- EchoEffectDefinition class --------------------

    static PyObject* _new_EchoEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EchoEffectDefinition instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EchoEffectDefinition(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EchoEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"WetDryMix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WetDryMix();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"WetDryMix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.WetDryMix(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Feedback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Feedback();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Feedback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Feedback(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Delay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Delay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Delay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Delay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"ActivatableClassId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatableClassId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EchoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EchoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EchoEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EchoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EchoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EchoEffectDefinition[] = {
        { "_assign_array_", _assign_array_EchoEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EchoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EchoEffectDefinition[] = {
        { "wet_dry_mix", reinterpret_cast<getter>(EchoEffectDefinition_get_WetDryMix), reinterpret_cast<setter>(EchoEffectDefinition_put_WetDryMix), nullptr, nullptr },
        { "feedback", reinterpret_cast<getter>(EchoEffectDefinition_get_Feedback), reinterpret_cast<setter>(EchoEffectDefinition_put_Feedback), nullptr, nullptr },
        { "delay", reinterpret_cast<getter>(EchoEffectDefinition_get_Delay), reinterpret_cast<setter>(EchoEffectDefinition_put_Delay), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(EchoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(EchoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EchoEffectDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EchoEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EchoEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EchoEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EchoEffectDefinition) },
        { }};

    static PyType_Spec type_spec_EchoEffectDefinition = {
        "winrt._winrt_windows_media_audio.EchoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EchoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EchoEffectDefinition};

    // ----- EqualizerBand class --------------------

    static PyObject* _new_EqualizerBand(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::EqualizerBand>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::EqualizerBand>::type_name);
        return nullptr;
    }

    static void _dealloc_EqualizerBand(py::wrapper::Windows::Media::Audio::EqualizerBand* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EqualizerBand_get_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Gain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Gain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Gain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Gain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"FrequencyCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrequencyCenter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"FrequencyCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrequencyCenter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Bandwidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bandwidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Bandwidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Bandwidth(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EqualizerBand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EqualizerBand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EqualizerBand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerBand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerBand[] = {
        { "_assign_array_", _assign_array_EqualizerBand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EqualizerBand), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EqualizerBand[] = {
        { "gain", reinterpret_cast<getter>(EqualizerBand_get_Gain), reinterpret_cast<setter>(EqualizerBand_put_Gain), nullptr, nullptr },
        { "frequency_center", reinterpret_cast<getter>(EqualizerBand_get_FrequencyCenter), reinterpret_cast<setter>(EqualizerBand_put_FrequencyCenter), nullptr, nullptr },
        { "bandwidth", reinterpret_cast<getter>(EqualizerBand_get_Bandwidth), reinterpret_cast<setter>(EqualizerBand_put_Bandwidth), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EqualizerBand[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EqualizerBand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EqualizerBand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EqualizerBand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EqualizerBand) },
        { }};

    static PyType_Spec type_spec_EqualizerBand = {
        "winrt._winrt_windows_media_audio.EqualizerBand",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerBand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerBand};

    // ----- EqualizerEffectDefinition class --------------------

    static PyObject* _new_EqualizerEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EqualizerEffectDefinition instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EqualizerEffectDefinition(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EqualizerEffectDefinition_get_Bands(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"Bands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bands();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"ActivatableClassId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatableClassId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EqualizerEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EqualizerEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EqualizerEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerEffectDefinition[] = {
        { "_assign_array_", _assign_array_EqualizerEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EqualizerEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EqualizerEffectDefinition[] = {
        { "bands", reinterpret_cast<getter>(EqualizerEffectDefinition_get_Bands), nullptr, nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(EqualizerEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(EqualizerEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EqualizerEffectDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EqualizerEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EqualizerEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EqualizerEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EqualizerEffectDefinition) },
        { }};

    static PyType_Spec type_spec_EqualizerEffectDefinition = {
        "winrt._winrt_windows_media_audio.EqualizerEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerEffectDefinition};

    // ----- FrameInputNodeQuantumStartedEventArgs class --------------------

    static PyObject* _new_FrameInputNodeQuantumStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameInputNodeQuantumStartedEventArgs(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.FrameInputNodeQuantumStartedEventArgs", L"RequiredSamples");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequiredSamples();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameInputNodeQuantumStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameInputNodeQuantumStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameInputNodeQuantumStartedEventArgs[] = {
        { "_assign_array_", _assign_array_FrameInputNodeQuantumStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameInputNodeQuantumStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameInputNodeQuantumStartedEventArgs[] = {
        { "required_samples", reinterpret_cast<getter>(FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameInputNodeQuantumStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameInputNodeQuantumStartedEventArgs) },
        { }};

    static PyType_Spec type_spec_FrameInputNodeQuantumStartedEventArgs = {
        "winrt._winrt_windows_media_audio.FrameInputNodeQuantumStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameInputNodeQuantumStartedEventArgs};

    // ----- LimiterEffectDefinition class --------------------

    static PyObject* _new_LimiterEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::LimiterEffectDefinition instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LimiterEffectDefinition(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LimiterEffectDefinition_get_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Release");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Release();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Release");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Release(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Loudness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Loudness();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Loudness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Loudness(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"ActivatableClassId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatableClassId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LimiterEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::LimiterEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LimiterEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::LimiterEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimiterEffectDefinition[] = {
        { "_assign_array_", _assign_array_LimiterEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LimiterEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LimiterEffectDefinition[] = {
        { "release", reinterpret_cast<getter>(LimiterEffectDefinition_get_Release), reinterpret_cast<setter>(LimiterEffectDefinition_put_Release), nullptr, nullptr },
        { "loudness", reinterpret_cast<getter>(LimiterEffectDefinition_get_Loudness), reinterpret_cast<setter>(LimiterEffectDefinition_put_Loudness), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(LimiterEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(LimiterEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_LimiterEffectDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LimiterEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LimiterEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LimiterEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LimiterEffectDefinition) },
        { }};

    static PyType_Spec type_spec_LimiterEffectDefinition = {
        "winrt._winrt_windows_media_audio.LimiterEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimiterEffectDefinition};

    // ----- MediaSourceAudioInputNode class --------------------

    static PyObject* _new_MediaSourceAudioInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"AddOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_AddOutgoingConnectionWithGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"AddOutgoingConnection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Close(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"RemoveOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Seek(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Seek", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Seek(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Start(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Emitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Emitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            {
                auto _gil = release_gil();
                self->obj.StartTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"PlaybackSpeedFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaybackSpeedFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"PlaybackSpeedFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.PlaybackSpeedFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"LoopCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LoopCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"LoopCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.LoopCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            {
                auto _gil = release_gil();
                self->obj.EndTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Duration(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_MediaSource(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MediaSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Position(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_add_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSourceCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::MediaSourceAudioInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MediaSourceCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_remove_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSourceCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MediaSourceCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAudioInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "add_outgoing_connection_with_gain", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_AddOutgoingConnectionWithGain), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Reset), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Seek), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Stop), METH_VARARGS, nullptr },
        { "add_media_source_completed", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_add_MediaSourceCompleted), METH_O, nullptr },
        { "remove_media_source_completed", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_remove_MediaSourceCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaSourceAudioInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceAudioInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaSourceAudioInputNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MediaSourceAudioInputNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_MediaSourceAudioInputNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_OutgoingGain), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_ConsumeInput), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_StartTime), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_StartTime), nullptr, nullptr },
        { "playback_speed_factor", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "loop_count", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_LoopCount), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_LoopCount), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EndTime), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_EndTime), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Duration), nullptr, nullptr, nullptr },
        { "media_source", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_MediaSource), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MediaSourceAudioInputNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceAudioInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceAudioInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceAudioInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceAudioInputNode) },
        { }};

    static PyType_Spec type_spec_MediaSourceAudioInputNode = {
        "winrt._winrt_windows_media_audio.MediaSourceAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAudioInputNode};

    // ----- ReverbEffectDefinition class --------------------

    static PyObject* _new_ReverbEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::ReverbEffectDefinition instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ReverbEffectDefinition(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReverbEffectDefinition_get_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HighEQGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.HighEQGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HighEQCutoff();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.HighEQCutoff(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DisableLateField");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisableLateField();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DisableLateField");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisableLateField(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Density");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Density();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Density");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Density(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionRight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionRight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionRight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionRight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DecayTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DecayTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DecayTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DecayTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LateDiffusion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LateDiffusion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LateDiffusion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.LateDiffusion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixRight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionMatrixRight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixRight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionMatrixRight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionMatrixLeft();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionMatrixLeft(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionLeft();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionLeft(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LowEQGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.LowEQGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LowEQCutoff();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.LowEQCutoff(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterFreq");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoomFilterFreq();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterFreq");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.RoomFilterFreq(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReverbGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.ReverbGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReverbDelay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ReverbDelay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReflectionsGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.ReflectionsGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReflectionsDelay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ReflectionsDelay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RearDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RearDelay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RearDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.RearDelay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"WetDryMix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WetDryMix();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"WetDryMix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.WetDryMix(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"EarlyDiffusion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EarlyDiffusion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"EarlyDiffusion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.EarlyDiffusion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoomSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.RoomSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterMain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoomFilterMain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterMain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.RoomFilterMain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterHF");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoomFilterHF();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterHF");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.RoomFilterHF(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ActivatableClassId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatableClassId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReverbEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::ReverbEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReverbEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::ReverbEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReverbEffectDefinition[] = {
        { "_assign_array_", _assign_array_ReverbEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReverbEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ReverbEffectDefinition[] = {
        { "high_e_q_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_HighEQGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_HighEQGain), nullptr, nullptr },
        { "high_e_q_cutoff", reinterpret_cast<getter>(ReverbEffectDefinition_get_HighEQCutoff), reinterpret_cast<setter>(ReverbEffectDefinition_put_HighEQCutoff), nullptr, nullptr },
        { "disable_late_field", reinterpret_cast<getter>(ReverbEffectDefinition_get_DisableLateField), reinterpret_cast<setter>(ReverbEffectDefinition_put_DisableLateField), nullptr, nullptr },
        { "density", reinterpret_cast<getter>(ReverbEffectDefinition_get_Density), reinterpret_cast<setter>(ReverbEffectDefinition_put_Density), nullptr, nullptr },
        { "position_right", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionRight), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionRight), nullptr, nullptr },
        { "decay_time", reinterpret_cast<getter>(ReverbEffectDefinition_get_DecayTime), reinterpret_cast<setter>(ReverbEffectDefinition_put_DecayTime), nullptr, nullptr },
        { "late_diffusion", reinterpret_cast<getter>(ReverbEffectDefinition_get_LateDiffusion), reinterpret_cast<setter>(ReverbEffectDefinition_put_LateDiffusion), nullptr, nullptr },
        { "position_matrix_right", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionMatrixRight), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionMatrixRight), nullptr, nullptr },
        { "position_matrix_left", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionMatrixLeft), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionMatrixLeft), nullptr, nullptr },
        { "position_left", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionLeft), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionLeft), nullptr, nullptr },
        { "low_e_q_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_LowEQGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_LowEQGain), nullptr, nullptr },
        { "low_e_q_cutoff", reinterpret_cast<getter>(ReverbEffectDefinition_get_LowEQCutoff), reinterpret_cast<setter>(ReverbEffectDefinition_put_LowEQCutoff), nullptr, nullptr },
        { "room_filter_freq", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterFreq), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterFreq), nullptr, nullptr },
        { "reverb_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReverbGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReverbGain), nullptr, nullptr },
        { "reverb_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReverbDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReverbDelay), nullptr, nullptr },
        { "reflections_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReflectionsGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReflectionsGain), nullptr, nullptr },
        { "reflections_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReflectionsDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReflectionsDelay), nullptr, nullptr },
        { "rear_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_RearDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_RearDelay), nullptr, nullptr },
        { "wet_dry_mix", reinterpret_cast<getter>(ReverbEffectDefinition_get_WetDryMix), reinterpret_cast<setter>(ReverbEffectDefinition_put_WetDryMix), nullptr, nullptr },
        { "early_diffusion", reinterpret_cast<getter>(ReverbEffectDefinition_get_EarlyDiffusion), reinterpret_cast<setter>(ReverbEffectDefinition_put_EarlyDiffusion), nullptr, nullptr },
        { "room_size", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomSize), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomSize), nullptr, nullptr },
        { "room_filter_main", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterMain), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterMain), nullptr, nullptr },
        { "room_filter_h_f", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterHF), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterHF), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(ReverbEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ReverbEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ReverbEffectDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReverbEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReverbEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReverbEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReverbEffectDefinition) },
        { }};

    static PyType_Spec type_spec_ReverbEffectDefinition = {
        "winrt._winrt_windows_media_audio.ReverbEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReverbEffectDefinition};

    // ----- SetDefaultSpatialAudioFormatResult class --------------------

    static PyObject* _new_SetDefaultSpatialAudioFormatResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::type_name);
        return nullptr;
    }

    static void _dealloc_SetDefaultSpatialAudioFormatResult(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetDefaultSpatialAudioFormatResult_get_Status(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SetDefaultSpatialAudioFormatResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetDefaultSpatialAudioFormatResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetDefaultSpatialAudioFormatResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetDefaultSpatialAudioFormatResult[] = {
        { "_assign_array_", _assign_array_SetDefaultSpatialAudioFormatResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetDefaultSpatialAudioFormatResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SetDefaultSpatialAudioFormatResult[] = {
        { "status", reinterpret_cast<getter>(SetDefaultSpatialAudioFormatResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SetDefaultSpatialAudioFormatResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetDefaultSpatialAudioFormatResult) },
        { }};

    static PyType_Spec type_spec_SetDefaultSpatialAudioFormatResult = {
        "winrt._winrt_windows_media_audio.SetDefaultSpatialAudioFormatResult",
        sizeof(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetDefaultSpatialAudioFormatResult};

    // ----- SpatialAudioDeviceConfiguration class --------------------

    static PyObject* _new_SpatialAudioDeviceConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialAudioDeviceConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialAudioDeviceConfiguration_GetForDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"GetForDeviceId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration::GetForDeviceId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"IsSpatialAudioFormatSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsSpatialAudioFormatSupported(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"SetDefaultSpatialAudioFormatAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetDefaultSpatialAudioFormatAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ActiveSpatialAudioFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActiveSpatialAudioFormat();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"DefaultSpatialAudioFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DefaultSpatialAudioFormat();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DeviceId(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"IsSpatialAudioSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSpatialAudioSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_add_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ConfigurationChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConfigurationChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_remove_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ConfigurationChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConfigurationChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialAudioDeviceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialAudioDeviceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioDeviceConfiguration[] = {
        { "is_spatial_audio_format_supported", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported), METH_VARARGS, nullptr },
        { "set_default_spatial_audio_format_async", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync), METH_VARARGS, nullptr },
        { "add_configuration_changed", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_add_ConfigurationChanged), METH_O, nullptr },
        { "remove_configuration_changed", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_remove_ConfigurationChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpatialAudioDeviceConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialAudioDeviceConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpatialAudioDeviceConfiguration[] = {
        { "active_spatial_audio_format", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat), nullptr, nullptr, nullptr },
        { "default_spatial_audio_format", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_spatial_audio_supported", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpatialAudioDeviceConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioDeviceConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialAudioDeviceConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioDeviceConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioDeviceConfiguration) },
        { }};

    static PyType_Spec type_spec_SpatialAudioDeviceConfiguration = {
        "winrt._winrt_windows_media_audio.SpatialAudioDeviceConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioDeviceConfiguration};

    static PyGetSetDef getset_SpatialAudioDeviceConfiguration_Static[] = {
        { }};

    static PyMethodDef methods_SpatialAudioDeviceConfiguration_Static[] = {
        { "get_for_device_id", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_GetForDeviceId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SpatialAudioDeviceConfiguration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialAudioDeviceConfiguration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpatialAudioDeviceConfiguration_Static) },
        { }
    };

    static PyType_Spec type_spec_SpatialAudioDeviceConfiguration_Static = {
        "winrt._winrt_windows_media_audio.SpatialAudioDeviceConfiguration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialAudioDeviceConfiguration_Static};

    // ----- SpatialAudioFormatConfiguration class --------------------

    static PyObject* _new_SpatialAudioFormatConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialAudioFormatConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialAudioFormatConfiguration_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"ReportConfigurationChangedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReportConfigurationChangedAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportLicenseChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"ReportLicenseChangedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReportLicenseChangedAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"MixedRealityExclusiveModePolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MixedRealityExclusiveModePolicy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"MixedRealityExclusiveModePolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Audio::MixedRealitySpatialAudioFormatPolicy>(arg);

            {
                auto _gil = release_gil();
                self->obj.MixedRealityExclusiveModePolicy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpatialAudioFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialAudioFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatConfiguration[] = {
        { "report_configuration_changed_async", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync), METH_VARARGS, nullptr },
        { "report_license_changed_async", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_ReportLicenseChangedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialAudioFormatConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialAudioFormatConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpatialAudioFormatConfiguration[] = {
        { "mixed_reality_exclusive_mode_policy", reinterpret_cast<getter>(SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy), reinterpret_cast<setter>(SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpatialAudioFormatConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioFormatConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialAudioFormatConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioFormatConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioFormatConfiguration) },
        { }};

    static PyType_Spec type_spec_SpatialAudioFormatConfiguration = {
        "winrt._winrt_windows_media_audio.SpatialAudioFormatConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatConfiguration};

    static PyGetSetDef getset_SpatialAudioFormatConfiguration_Static[] = {
        { }};

    static PyMethodDef methods_SpatialAudioFormatConfiguration_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_GetDefault), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SpatialAudioFormatConfiguration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialAudioFormatConfiguration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpatialAudioFormatConfiguration_Static) },
        { }
    };

    static PyType_Spec type_spec_SpatialAudioFormatConfiguration_Static = {
        "winrt._winrt_windows_media_audio.SpatialAudioFormatConfiguration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialAudioFormatConfiguration_Static};

    // ----- SpatialAudioFormatSubtype class --------------------

    static PyObject* _new_SpatialAudioFormatSubtype(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::type_name);
        return nullptr;
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSHeadphoneX(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSHeadphoneX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSHeadphoneX();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXUltra(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSXUltra");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXUltra();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForHeadphones");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHeadphones();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForHomeTheater");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHomeTheater();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForSpeakers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForSpeakers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_WindowsSonic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"WindowsSonic");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::WindowsSonic();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSXForHomeTheater");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXForHomeTheater();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatSubtype[] = {
        { }};

    static PyGetSetDef _getset_SpatialAudioFormatSubtype[] = {
        { }};

    static PyType_Slot _type_slots_SpatialAudioFormatSubtype[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioFormatSubtype) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioFormatSubtype) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioFormatSubtype) },
        { }};

    static PyType_Spec type_spec_SpatialAudioFormatSubtype = {
        "winrt._winrt_windows_media_audio.SpatialAudioFormatSubtype",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatSubtype};

    static PyGetSetDef getset_SpatialAudioFormatSubtype_Static[] = {
        { "d_t_s_headphone_x", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSHeadphoneX), nullptr, nullptr, nullptr },
        { "d_t_s_x_ultra", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSXUltra), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_headphones", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_home_theater", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_speakers", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers), nullptr, nullptr, nullptr },
        { "windows_sonic", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_WindowsSonic), nullptr, nullptr, nullptr },
        { "d_t_s_x_for_home_theater", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSXForHomeTheater), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SpatialAudioFormatSubtype_Static[] = {
        { }};

    static PyType_Slot type_slots_SpatialAudioFormatSubtype_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialAudioFormatSubtype_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpatialAudioFormatSubtype_Static) },
        { }
    };

    static PyType_Spec type_spec_SpatialAudioFormatSubtype_Static = {
        "winrt._winrt_windows_media_audio.SpatialAudioFormatSubtype_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialAudioFormatSubtype_Static};

    // ----- IAudioInputNode interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAudioInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::IAudioInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::IAudioInputNode>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_AddOutgoingConnectionWithGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"RemoveOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode", L"OutgoingConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _enter_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "add_outgoing_connection_with_gain", reinterpret_cast<PyCFunction>(IAudioInputNode_AddOutgoingConnectionWithGain), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioInputNode_Stop), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioInputNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IAudioInputNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAudioInputNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(IAudioInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioInputNode_get_ConsumeInput), reinterpret_cast<setter>(IAudioInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioInputNode_get_OutgoingGain), reinterpret_cast<setter>(IAudioInputNode_put_OutgoingGain), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAudioInputNode[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioInputNode) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioInputNode) },
        { }};

    static PyType_Spec type_spec_IAudioInputNode = {
        "winrt._winrt_windows_media_audio._IAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAudioInputNode};

    struct ImplementsIAudioInputNode : py::ImplementsInterfaceT<ImplementsIAudioInputNode, winrt::Windows::Media::Audio::IAudioInputNode>
    {
        ImplementsIAudioInputNode() = delete;
        ImplementsIAudioInputNode(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAudioInputNode, winrt::Windows::Media::Audio::IAudioInputNode>(py_obj, runtime_class)
        {
        }

        auto AddOutgoingConnection(winrt::Windows::Media::Audio::IAudioNode const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_outgoing_connection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AddOutgoingConnection(winrt::Windows::Media::Audio::IAudioNode const& param0, double param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_outgoing_connection_with_gain")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisableEffectsByDefinition(winrt::Windows::Media::Effects::IAudioEffectDefinition const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "disable_effects_by_definition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EnableEffectsByDefinition(winrt::Windows::Media::Effects::IAudioEffectDefinition const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "enable_effects_by_definition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveOutgoingConnection(winrt::Windows::Media::Audio::IAudioNode const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_outgoing_connection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Reset()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "reset")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Start()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Stop()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "stop")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OutgoingConnections()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "outgoing_connections")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Media::Audio::AudioGraphConnection>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ConsumeInput()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "consume_input")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ConsumeInput(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "consume_input", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EffectDefinitions()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "effect_definitions")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Effects::IAudioEffectDefinition>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EncodingProperties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "encoding_properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OutgoingGain()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "outgoing_gain")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OutgoingGain(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "outgoing_gain", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAudioInputNode(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Audio::IAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAudioInputNode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAudioInputNode>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAudioInputNode[] = {
        { "_assign_array_", _assign_array_IAudioInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioInputNode), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAudioInputNode), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAudioInputNode), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAudioInputNode[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAudioInputNode) },
        { }};

    static PyType_Spec type_spec_ImplementsIAudioInputNode = {
        "winrt._winrt_windows_media_audio.IAudioInputNode",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAudioInputNode};

    // ----- IAudioInputNode2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAudioInputNode2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::IAudioInputNode2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::IAudioInputNode2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioInputNode2_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_AddOutgoingConnectionWithGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddOutgoingConnection(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"RemoveOutgoingConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveOutgoingConnection(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_Emitter(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode2", L"Emitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Emitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode", L"OutgoingConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode2[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode2_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "add_outgoing_connection_with_gain", reinterpret_cast<PyCFunction>(IAudioInputNode2_AddOutgoingConnectionWithGain), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioInputNode2_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode2_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode2_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode2_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioInputNode2_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioInputNode2_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioInputNode2_Stop), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioInputNode2), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IAudioInputNode2), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAudioInputNode2[] = {
        { "emitter", reinterpret_cast<getter>(IAudioInputNode2_get_Emitter), nullptr, nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioInputNode2_get_ConsumeInput), reinterpret_cast<setter>(IAudioInputNode2_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioInputNode2_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioInputNode2_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioInputNode2_get_OutgoingGain), reinterpret_cast<setter>(IAudioInputNode2_put_OutgoingGain), nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(IAudioInputNode2_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAudioInputNode2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioInputNode2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioInputNode2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioInputNode2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioInputNode2) },
        { }};

    static PyType_Spec type_spec_IAudioInputNode2 = {
        "winrt._winrt_windows_media_audio._IAudioInputNode2",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAudioInputNode2};

    struct ImplementsIAudioInputNode2 : py::ImplementsInterfaceT<ImplementsIAudioInputNode2, winrt::Windows::Media::Audio::IAudioInputNode2>
    {
        ImplementsIAudioInputNode2() = delete;
        ImplementsIAudioInputNode2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAudioInputNode2, winrt::Windows::Media::Audio::IAudioInputNode2>(py_obj, runtime_class)
        {
        }

        auto AddOutgoingConnection(winrt::Windows::Media::Audio::IAudioNode const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_outgoing_connection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AddOutgoingConnection(winrt::Windows::Media::Audio::IAudioNode const& param0, double param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_outgoing_connection_with_gain")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisableEffectsByDefinition(winrt::Windows::Media::Effects::IAudioEffectDefinition const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "disable_effects_by_definition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EnableEffectsByDefinition(winrt::Windows::Media::Effects::IAudioEffectDefinition const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "enable_effects_by_definition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveOutgoingConnection(winrt::Windows::Media::Audio::IAudioNode const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_outgoing_connection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Reset()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "reset")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Start()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Stop()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "stop")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Emitter()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "emitter")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ConsumeInput()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "consume_input")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ConsumeInput(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "consume_input", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EffectDefinitions()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "effect_definitions")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Effects::IAudioEffectDefinition>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EncodingProperties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "encoding_properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OutgoingGain()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "outgoing_gain")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OutgoingGain(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "outgoing_gain", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OutgoingConnections()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "outgoing_connections")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Media::Audio::AudioGraphConnection>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAudioInputNode2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioInputNode2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioInputNode2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAudioInputNode2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Audio::IAudioInputNode2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAudioInputNode2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAudioInputNode2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAudioInputNode2[] = {
        { "_assign_array_", _assign_array_IAudioInputNode2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioInputNode2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAudioInputNode2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAudioInputNode2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAudioInputNode2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAudioInputNode2) },
        { }};

    static PyType_Spec type_spec_ImplementsIAudioInputNode2 = {
        "winrt._winrt_windows_media_audio.IAudioInputNode2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAudioInputNode2};

    // ----- IAudioNode interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAudioNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::IAudioNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::IAudioNode>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioNode_Close(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Reset(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Start(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Stop(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _enter_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNode[] = {
        { "close", reinterpret_cast<PyCFunction>(IAudioNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioNode_Stop), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioNode), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IAudioNode), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAudioNode[] = {
        { "consume_input", reinterpret_cast<getter>(IAudioNode_get_ConsumeInput), reinterpret_cast<setter>(IAudioNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioNode_get_OutgoingGain), reinterpret_cast<setter>(IAudioNode_put_OutgoingGain), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAudioNode[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioNode) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioNode) },
        { }};

    static PyType_Spec type_spec_IAudioNode = {
        "winrt._winrt_windows_media_audio._IAudioNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNode),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAudioNode};

    struct ImplementsIAudioNode : py::ImplementsInterfaceT<ImplementsIAudioNode, winrt::Windows::Media::Audio::IAudioNode>
    {
        ImplementsIAudioNode() = delete;
        ImplementsIAudioNode(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAudioNode, winrt::Windows::Media::Audio::IAudioNode>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisableEffectsByDefinition(winrt::Windows::Media::Effects::IAudioEffectDefinition const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "disable_effects_by_definition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EnableEffectsByDefinition(winrt::Windows::Media::Effects::IAudioEffectDefinition const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "enable_effects_by_definition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Reset()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "reset")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Start()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Stop()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "stop")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ConsumeInput()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "consume_input")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ConsumeInput(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "consume_input", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EffectDefinitions()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "effect_definitions")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Effects::IAudioEffectDefinition>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EncodingProperties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "encoding_properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OutgoingGain()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "outgoing_gain")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OutgoingGain(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "outgoing_gain", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAudioNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAudioNode(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Audio::IAudioNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAudioNode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAudioNode>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAudioNode[] = {
        { "_assign_array_", _assign_array_IAudioNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioNode), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAudioNode), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAudioNode), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAudioNode[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAudioNode) },
        { }};

    static PyType_Spec type_spec_ImplementsIAudioNode = {
        "winrt._winrt_windows_media_audio.IAudioNode",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAudioNode};

    // ----- IAudioNodeWithListener interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAudioNodeWithListener(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioNodeWithListener_Close(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DisableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableEffectsByDefinition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Reset(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Start(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Stop(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNodeWithListener", L"Listener");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Listener();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNodeWithListener", L"Listener");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            {
                auto _gil = release_gil();
                self->obj.Listener(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConsumeInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConsumeInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OutgoingGain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OutgoingGain(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _enter_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNodeWithListener[] = {
        { "close", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Stop), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioNodeWithListener), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IAudioNodeWithListener), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAudioNodeWithListener[] = {
        { "listener", reinterpret_cast<getter>(IAudioNodeWithListener_get_Listener), reinterpret_cast<setter>(IAudioNodeWithListener_put_Listener), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioNodeWithListener_get_ConsumeInput), reinterpret_cast<setter>(IAudioNodeWithListener_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioNodeWithListener_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioNodeWithListener_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioNodeWithListener_get_OutgoingGain), reinterpret_cast<setter>(IAudioNodeWithListener_put_OutgoingGain), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAudioNodeWithListener[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioNodeWithListener) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioNodeWithListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioNodeWithListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioNodeWithListener) },
        { }};

    static PyType_Spec type_spec_IAudioNodeWithListener = {
        "winrt._winrt_windows_media_audio._IAudioNodeWithListener",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAudioNodeWithListener};

    struct ImplementsIAudioNodeWithListener : py::ImplementsInterfaceT<ImplementsIAudioNodeWithListener, winrt::Windows::Media::Audio::IAudioNodeWithListener>
    {
        ImplementsIAudioNodeWithListener() = delete;
        ImplementsIAudioNodeWithListener(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAudioNodeWithListener, winrt::Windows::Media::Audio::IAudioNodeWithListener>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisableEffectsByDefinition(winrt::Windows::Media::Effects::IAudioEffectDefinition const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "disable_effects_by_definition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EnableEffectsByDefinition(winrt::Windows::Media::Effects::IAudioEffectDefinition const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "enable_effects_by_definition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Reset()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "reset")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Start()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Stop()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "stop")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Listener()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "listener")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Listener(winrt::Windows::Media::Audio::AudioNodeListener const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "listener", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ConsumeInput()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "consume_input")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ConsumeInput(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "consume_input", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EffectDefinitions()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "effect_definitions")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Effects::IAudioEffectDefinition>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EncodingProperties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "encoding_properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OutgoingGain()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "outgoing_gain")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OutgoingGain(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "outgoing_gain", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAudioNodeWithListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioNodeWithListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioNodeWithListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNodeWithListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAudioNodeWithListener(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Audio::IAudioNodeWithListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAudioNodeWithListener(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAudioNodeWithListener>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAudioNodeWithListener[] = {
        { "_assign_array_", _assign_array_IAudioNodeWithListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioNodeWithListener), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAudioNodeWithListener), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAudioNodeWithListener), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAudioNodeWithListener[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAudioNodeWithListener) },
        { }};

    static PyType_Spec type_spec_ImplementsIAudioNodeWithListener = {
        "winrt._winrt_windows_media_audio.IAudioNodeWithListener",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAudioNodeWithListener};

    // ----- Windows.Media.Audio Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Audio");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_audio",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Audio

PyMODINIT_FUNC PyInit__winrt_windows_media_audio(void) noexcept
{
    using namespace py::cpp::Windows::Media::Audio;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AudioDeviceInputNode_type{py::register_python_type(module.get(), &type_spec_AudioDeviceInputNode, object_bases.get(), inspectable_meta_type)};
    if (!AudioDeviceInputNode_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioDeviceOutputNode_type{py::register_python_type(module.get(), &type_spec_AudioDeviceOutputNode, object_bases.get(), inspectable_meta_type)};
    if (!AudioDeviceOutputNode_type)
    {
        return nullptr;
    }

    py::pyobj_handle AudioEffectsPackConfiguration_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AudioEffectsPackConfiguration_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioEffectsPackConfiguration_Static{PyType_FromSpecWithBases(&type_spec_AudioEffectsPackConfiguration_Static, AudioEffectsPackConfiguration_Static_bases.get())};
    if (!type_AudioEffectsPackConfiguration_Static)
    {
        return nullptr;
    }

    py::pytype_handle AudioEffectsPackConfiguration_type{py::register_python_type(module.get(), &type_spec_AudioEffectsPackConfiguration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioEffectsPackConfiguration_Static.get()))};
    if (!AudioEffectsPackConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioFileInputNode_type{py::register_python_type(module.get(), &type_spec_AudioFileInputNode, object_bases.get(), inspectable_meta_type)};
    if (!AudioFileInputNode_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioFileOutputNode_type{py::register_python_type(module.get(), &type_spec_AudioFileOutputNode, object_bases.get(), inspectable_meta_type)};
    if (!AudioFileOutputNode_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioFrameCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_AudioFrameCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AudioFrameCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioFrameInputNode_type{py::register_python_type(module.get(), &type_spec_AudioFrameInputNode, object_bases.get(), inspectable_meta_type)};
    if (!AudioFrameInputNode_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioFrameOutputNode_type{py::register_python_type(module.get(), &type_spec_AudioFrameOutputNode, object_bases.get(), inspectable_meta_type)};
    if (!AudioFrameOutputNode_type)
    {
        return nullptr;
    }

    py::pyobj_handle AudioGraph_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AudioGraph_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioGraph_Static{PyType_FromSpecWithBases(&type_spec_AudioGraph_Static, AudioGraph_Static_bases.get())};
    if (!type_AudioGraph_Static)
    {
        return nullptr;
    }

    py::pytype_handle AudioGraph_type{py::register_python_type(module.get(), &type_spec_AudioGraph, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioGraph_Static.get()))};
    if (!AudioGraph_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioGraphBatchUpdater_type{py::register_python_type(module.get(), &type_spec_AudioGraphBatchUpdater, object_bases.get(), inspectable_meta_type)};
    if (!AudioGraphBatchUpdater_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioGraphConnection_type{py::register_python_type(module.get(), &type_spec_AudioGraphConnection, object_bases.get(), inspectable_meta_type)};
    if (!AudioGraphConnection_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioGraphSettings_type{py::register_python_type(module.get(), &type_spec_AudioGraphSettings, object_bases.get(), inspectable_meta_type)};
    if (!AudioGraphSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioGraphUnrecoverableErrorOccurredEventArgs_type{py::register_python_type(module.get(), &type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AudioGraphUnrecoverableErrorOccurredEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioNodeEmitter_type{py::register_python_type(module.get(), &type_spec_AudioNodeEmitter, object_bases.get(), inspectable_meta_type)};
    if (!AudioNodeEmitter_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioNodeEmitterConeProperties_type{py::register_python_type(module.get(), &type_spec_AudioNodeEmitterConeProperties, object_bases.get(), inspectable_meta_type)};
    if (!AudioNodeEmitterConeProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle AudioNodeEmitterDecayModel_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AudioNodeEmitterDecayModel_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioNodeEmitterDecayModel_Static{PyType_FromSpecWithBases(&type_spec_AudioNodeEmitterDecayModel_Static, AudioNodeEmitterDecayModel_Static_bases.get())};
    if (!type_AudioNodeEmitterDecayModel_Static)
    {
        return nullptr;
    }

    py::pytype_handle AudioNodeEmitterDecayModel_type{py::register_python_type(module.get(), &type_spec_AudioNodeEmitterDecayModel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioNodeEmitterDecayModel_Static.get()))};
    if (!AudioNodeEmitterDecayModel_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioNodeEmitterNaturalDecayModelProperties_type{py::register_python_type(module.get(), &type_spec_AudioNodeEmitterNaturalDecayModelProperties, object_bases.get(), inspectable_meta_type)};
    if (!AudioNodeEmitterNaturalDecayModelProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle AudioNodeEmitterShape_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AudioNodeEmitterShape_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioNodeEmitterShape_Static{PyType_FromSpecWithBases(&type_spec_AudioNodeEmitterShape_Static, AudioNodeEmitterShape_Static_bases.get())};
    if (!type_AudioNodeEmitterShape_Static)
    {
        return nullptr;
    }

    py::pytype_handle AudioNodeEmitterShape_type{py::register_python_type(module.get(), &type_spec_AudioNodeEmitterShape, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioNodeEmitterShape_Static.get()))};
    if (!AudioNodeEmitterShape_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioNodeListener_type{py::register_python_type(module.get(), &type_spec_AudioNodeListener, object_bases.get(), inspectable_meta_type)};
    if (!AudioNodeListener_type)
    {
        return nullptr;
    }

    py::pyobj_handle AudioPlaybackConnection_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AudioPlaybackConnection_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioPlaybackConnection_Static{PyType_FromSpecWithBases(&type_spec_AudioPlaybackConnection_Static, AudioPlaybackConnection_Static_bases.get())};
    if (!type_AudioPlaybackConnection_Static)
    {
        return nullptr;
    }

    py::pytype_handle AudioPlaybackConnection_type{py::register_python_type(module.get(), &type_spec_AudioPlaybackConnection, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioPlaybackConnection_Static.get()))};
    if (!AudioPlaybackConnection_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioPlaybackConnectionOpenResult_type{py::register_python_type(module.get(), &type_spec_AudioPlaybackConnectionOpenResult, object_bases.get(), inspectable_meta_type)};
    if (!AudioPlaybackConnectionOpenResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle AudioStateMonitor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AudioStateMonitor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioStateMonitor_Static{PyType_FromSpecWithBases(&type_spec_AudioStateMonitor_Static, AudioStateMonitor_Static_bases.get())};
    if (!type_AudioStateMonitor_Static)
    {
        return nullptr;
    }

    py::pytype_handle AudioStateMonitor_type{py::register_python_type(module.get(), &type_spec_AudioStateMonitor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioStateMonitor_Static.get()))};
    if (!AudioStateMonitor_type)
    {
        return nullptr;
    }

    py::pytype_handle AudioSubmixNode_type{py::register_python_type(module.get(), &type_spec_AudioSubmixNode, object_bases.get(), inspectable_meta_type)};
    if (!AudioSubmixNode_type)
    {
        return nullptr;
    }

    py::pytype_handle CreateAudioDeviceInputNodeResult_type{py::register_python_type(module.get(), &type_spec_CreateAudioDeviceInputNodeResult, object_bases.get(), inspectable_meta_type)};
    if (!CreateAudioDeviceInputNodeResult_type)
    {
        return nullptr;
    }

    py::pytype_handle CreateAudioDeviceOutputNodeResult_type{py::register_python_type(module.get(), &type_spec_CreateAudioDeviceOutputNodeResult, object_bases.get(), inspectable_meta_type)};
    if (!CreateAudioDeviceOutputNodeResult_type)
    {
        return nullptr;
    }

    py::pytype_handle CreateAudioFileInputNodeResult_type{py::register_python_type(module.get(), &type_spec_CreateAudioFileInputNodeResult, object_bases.get(), inspectable_meta_type)};
    if (!CreateAudioFileInputNodeResult_type)
    {
        return nullptr;
    }

    py::pytype_handle CreateAudioFileOutputNodeResult_type{py::register_python_type(module.get(), &type_spec_CreateAudioFileOutputNodeResult, object_bases.get(), inspectable_meta_type)};
    if (!CreateAudioFileOutputNodeResult_type)
    {
        return nullptr;
    }

    py::pytype_handle CreateAudioGraphResult_type{py::register_python_type(module.get(), &type_spec_CreateAudioGraphResult, object_bases.get(), inspectable_meta_type)};
    if (!CreateAudioGraphResult_type)
    {
        return nullptr;
    }

    py::pytype_handle CreateMediaSourceAudioInputNodeResult_type{py::register_python_type(module.get(), &type_spec_CreateMediaSourceAudioInputNodeResult, object_bases.get(), inspectable_meta_type)};
    if (!CreateMediaSourceAudioInputNodeResult_type)
    {
        return nullptr;
    }

    py::pytype_handle EchoEffectDefinition_type{py::register_python_type(module.get(), &type_spec_EchoEffectDefinition, object_bases.get(), inspectable_meta_type)};
    if (!EchoEffectDefinition_type)
    {
        return nullptr;
    }

    py::pytype_handle EqualizerBand_type{py::register_python_type(module.get(), &type_spec_EqualizerBand, object_bases.get(), inspectable_meta_type)};
    if (!EqualizerBand_type)
    {
        return nullptr;
    }

    py::pytype_handle EqualizerEffectDefinition_type{py::register_python_type(module.get(), &type_spec_EqualizerEffectDefinition, object_bases.get(), inspectable_meta_type)};
    if (!EqualizerEffectDefinition_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameInputNodeQuantumStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_FrameInputNodeQuantumStartedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FrameInputNodeQuantumStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LimiterEffectDefinition_type{py::register_python_type(module.get(), &type_spec_LimiterEffectDefinition, object_bases.get(), inspectable_meta_type)};
    if (!LimiterEffectDefinition_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaSourceAudioInputNode_type{py::register_python_type(module.get(), &type_spec_MediaSourceAudioInputNode, object_bases.get(), inspectable_meta_type)};
    if (!MediaSourceAudioInputNode_type)
    {
        return nullptr;
    }

    py::pytype_handle ReverbEffectDefinition_type{py::register_python_type(module.get(), &type_spec_ReverbEffectDefinition, object_bases.get(), inspectable_meta_type)};
    if (!ReverbEffectDefinition_type)
    {
        return nullptr;
    }

    py::pytype_handle SetDefaultSpatialAudioFormatResult_type{py::register_python_type(module.get(), &type_spec_SetDefaultSpatialAudioFormatResult, object_bases.get(), inspectable_meta_type)};
    if (!SetDefaultSpatialAudioFormatResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpatialAudioDeviceConfiguration_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SpatialAudioDeviceConfiguration_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialAudioDeviceConfiguration_Static{PyType_FromSpecWithBases(&type_spec_SpatialAudioDeviceConfiguration_Static, SpatialAudioDeviceConfiguration_Static_bases.get())};
    if (!type_SpatialAudioDeviceConfiguration_Static)
    {
        return nullptr;
    }

    py::pytype_handle SpatialAudioDeviceConfiguration_type{py::register_python_type(module.get(), &type_spec_SpatialAudioDeviceConfiguration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpatialAudioDeviceConfiguration_Static.get()))};
    if (!SpatialAudioDeviceConfiguration_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpatialAudioFormatConfiguration_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SpatialAudioFormatConfiguration_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialAudioFormatConfiguration_Static{PyType_FromSpecWithBases(&type_spec_SpatialAudioFormatConfiguration_Static, SpatialAudioFormatConfiguration_Static_bases.get())};
    if (!type_SpatialAudioFormatConfiguration_Static)
    {
        return nullptr;
    }

    py::pytype_handle SpatialAudioFormatConfiguration_type{py::register_python_type(module.get(), &type_spec_SpatialAudioFormatConfiguration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpatialAudioFormatConfiguration_Static.get()))};
    if (!SpatialAudioFormatConfiguration_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpatialAudioFormatSubtype_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SpatialAudioFormatSubtype_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialAudioFormatSubtype_Static{PyType_FromSpecWithBases(&type_spec_SpatialAudioFormatSubtype_Static, SpatialAudioFormatSubtype_Static_bases.get())};
    if (!type_SpatialAudioFormatSubtype_Static)
    {
        return nullptr;
    }

    py::pytype_handle SpatialAudioFormatSubtype_type{py::register_python_type(module.get(), &type_spec_SpatialAudioFormatSubtype, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpatialAudioFormatSubtype_Static.get()))};
    if (!SpatialAudioFormatSubtype_type)
    {
        return nullptr;
    }

    py::pytype_handle IAudioInputNode_type{py::register_python_type(module.get(), &type_spec_IAudioInputNode, object_bases.get(), nullptr)};
    if (!IAudioInputNode_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAudioInputNode_type{py::register_python_type(module.get(), &type_spec_ImplementsIAudioInputNode, nullptr, inspectable_meta_type)};
    if (!ImplementsIAudioInputNode_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAudioInputNode_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAudioInputNode2_type{py::register_python_type(module.get(), &type_spec_IAudioInputNode2, object_bases.get(), nullptr)};
    if (!IAudioInputNode2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAudioInputNode2_type{py::register_python_type(module.get(), &type_spec_ImplementsIAudioInputNode2, nullptr, inspectable_meta_type)};
    if (!ImplementsIAudioInputNode2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAudioInputNode2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAudioNode_type{py::register_python_type(module.get(), &type_spec_IAudioNode, object_bases.get(), nullptr)};
    if (!IAudioNode_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAudioNode_type{py::register_python_type(module.get(), &type_spec_ImplementsIAudioNode, nullptr, inspectable_meta_type)};
    if (!ImplementsIAudioNode_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAudioNode_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAudioNodeWithListener_type{py::register_python_type(module.get(), &type_spec_IAudioNodeWithListener, object_bases.get(), nullptr)};
    if (!IAudioNodeWithListener_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAudioNodeWithListener_type{py::register_python_type(module.get(), &type_spec_ImplementsIAudioNodeWithListener, nullptr, inspectable_meta_type)};
    if (!ImplementsIAudioNodeWithListener_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAudioNodeWithListener_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
