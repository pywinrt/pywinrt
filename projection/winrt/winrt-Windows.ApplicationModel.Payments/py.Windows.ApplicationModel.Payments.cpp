// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.ApplicationModel.Payments.h"

namespace py::cpp::Windows::ApplicationModel::Payments
{
    // ----- PaymentAddress class --------------------

    static PyObject* _new_PaymentAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentAddress instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentAddress_get_SortingCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"SortingCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SortingCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_SortingCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"SortingCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.SortingCode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Region(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Region");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Region();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Region(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Region");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Region(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Recipient(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Recipient");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Recipient();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Recipient(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Recipient");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Recipient(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_PostalCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PostalCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PostalCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_PostalCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PostalCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.PostalCode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_PhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.PhoneNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Organization(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Organization");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Organization();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Organization(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Organization");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Organization(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_LanguageCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"LanguageCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LanguageCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_LanguageCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"LanguageCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.LanguageCode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_DependentLocality(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"DependentLocality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DependentLocality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_DependentLocality(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"DependentLocality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DependentLocality(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Country(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Country");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Country();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Country(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Country");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Country(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_City(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"City");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.City();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_City(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"City");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.City(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_AddressLines(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"AddressLines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AddressLines();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_AddressLines(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"AddressLines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(arg);

            {
                auto _gil = release_gil();
                self->obj.AddressLines(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Properties(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentAddress[] = {
        { "_assign_array_", _assign_array_PaymentAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentAddress), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentAddress[] = {
        { "sorting_code", reinterpret_cast<getter>(PaymentAddress_get_SortingCode), reinterpret_cast<setter>(PaymentAddress_put_SortingCode), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(PaymentAddress_get_Region), reinterpret_cast<setter>(PaymentAddress_put_Region), nullptr, nullptr },
        { "recipient", reinterpret_cast<getter>(PaymentAddress_get_Recipient), reinterpret_cast<setter>(PaymentAddress_put_Recipient), nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(PaymentAddress_get_PostalCode), reinterpret_cast<setter>(PaymentAddress_put_PostalCode), nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PaymentAddress_get_PhoneNumber), reinterpret_cast<setter>(PaymentAddress_put_PhoneNumber), nullptr, nullptr },
        { "organization", reinterpret_cast<getter>(PaymentAddress_get_Organization), reinterpret_cast<setter>(PaymentAddress_put_Organization), nullptr, nullptr },
        { "language_code", reinterpret_cast<getter>(PaymentAddress_get_LanguageCode), reinterpret_cast<setter>(PaymentAddress_put_LanguageCode), nullptr, nullptr },
        { "dependent_locality", reinterpret_cast<getter>(PaymentAddress_get_DependentLocality), reinterpret_cast<setter>(PaymentAddress_put_DependentLocality), nullptr, nullptr },
        { "country", reinterpret_cast<getter>(PaymentAddress_get_Country), reinterpret_cast<setter>(PaymentAddress_put_Country), nullptr, nullptr },
        { "city", reinterpret_cast<getter>(PaymentAddress_get_City), reinterpret_cast<setter>(PaymentAddress_put_City), nullptr, nullptr },
        { "address_lines", reinterpret_cast<getter>(PaymentAddress_get_AddressLines), reinterpret_cast<setter>(PaymentAddress_put_AddressLines), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PaymentAddress_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentAddress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentAddress) },
        { }};

    static PyType_Spec type_spec_PaymentAddress = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentAddress};

    // ----- PaymentCanMakePaymentResult class --------------------

    static PyObject* _new_PaymentCanMakePaymentResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResultStatus>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentCanMakePaymentResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentCanMakePaymentResult_get_Status(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCanMakePaymentResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentCanMakePaymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentCanMakePaymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentCanMakePaymentResult[] = {
        { "_assign_array_", _assign_array_PaymentCanMakePaymentResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentCanMakePaymentResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentCanMakePaymentResult[] = {
        { "status", reinterpret_cast<getter>(PaymentCanMakePaymentResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentCanMakePaymentResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentCanMakePaymentResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentCanMakePaymentResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentCanMakePaymentResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentCanMakePaymentResult) },
        { }};

    static PyType_Spec type_spec_PaymentCanMakePaymentResult = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentCanMakePaymentResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentCanMakePaymentResult};

    // ----- PaymentCurrencyAmount class --------------------

    static PyObject* _new_PaymentCurrencyAmount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentCurrencyAmount(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentCurrencyAmount_get_Value(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_Value(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentCurrencyAmount_get_CurrencySystem(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"CurrencySystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrencySystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_CurrencySystem(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"CurrencySystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.CurrencySystem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentCurrencyAmount_get_Currency(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Currency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Currency();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_Currency(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Currency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Currency(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentCurrencyAmount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentCurrencyAmount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentCurrencyAmount[] = {
        { "_assign_array_", _assign_array_PaymentCurrencyAmount, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentCurrencyAmount), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentCurrencyAmount[] = {
        { "value", reinterpret_cast<getter>(PaymentCurrencyAmount_get_Value), reinterpret_cast<setter>(PaymentCurrencyAmount_put_Value), nullptr, nullptr },
        { "currency_system", reinterpret_cast<getter>(PaymentCurrencyAmount_get_CurrencySystem), reinterpret_cast<setter>(PaymentCurrencyAmount_put_CurrencySystem), nullptr, nullptr },
        { "currency", reinterpret_cast<getter>(PaymentCurrencyAmount_get_Currency), reinterpret_cast<setter>(PaymentCurrencyAmount_put_Currency), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentCurrencyAmount[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentCurrencyAmount) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentCurrencyAmount) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentCurrencyAmount) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentCurrencyAmount) },
        { }};

    static PyType_Spec type_spec_PaymentCurrencyAmount = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentCurrencyAmount",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentCurrencyAmount};

    // ----- PaymentDetails class --------------------

    static PyObject* _new_PaymentDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentDetails_get_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Total");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Total();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Total");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(arg);

            {
                auto _gil = release_gil();
                self->obj.Total(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_ShippingOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"ShippingOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShippingOptions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_ShippingOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"ShippingOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShippingOptions(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_Modifiers(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Modifiers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Modifiers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_Modifiers(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Modifiers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Modifiers(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_DisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"DisplayItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_DisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"DisplayItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayItems(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentDetails[] = {
        { "_assign_array_", _assign_array_PaymentDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentDetails[] = {
        { "total", reinterpret_cast<getter>(PaymentDetails_get_Total), reinterpret_cast<setter>(PaymentDetails_put_Total), nullptr, nullptr },
        { "shipping_options", reinterpret_cast<getter>(PaymentDetails_get_ShippingOptions), reinterpret_cast<setter>(PaymentDetails_put_ShippingOptions), nullptr, nullptr },
        { "modifiers", reinterpret_cast<getter>(PaymentDetails_get_Modifiers), reinterpret_cast<setter>(PaymentDetails_put_Modifiers), nullptr, nullptr },
        { "display_items", reinterpret_cast<getter>(PaymentDetails_get_DisplayItems), reinterpret_cast<setter>(PaymentDetails_put_DisplayItems), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentDetails) },
        { }};

    static PyType_Spec type_spec_PaymentDetails = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentDetails};

    // ----- PaymentDetailsModifier class --------------------

    static PyObject* _new_PaymentDetailsModifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentDetailsModifier(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentDetailsModifier_get_AdditionalDisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"AdditionalDisplayItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdditionalDisplayItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_JsonData(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"JsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_SupportedMethodIds(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"SupportedMethodIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedMethodIds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"Total");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Total();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentDetailsModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentDetailsModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentDetailsModifier[] = {
        { "_assign_array_", _assign_array_PaymentDetailsModifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentDetailsModifier), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentDetailsModifier[] = {
        { "additional_display_items", reinterpret_cast<getter>(PaymentDetailsModifier_get_AdditionalDisplayItems), nullptr, nullptr, nullptr },
        { "json_data", reinterpret_cast<getter>(PaymentDetailsModifier_get_JsonData), nullptr, nullptr, nullptr },
        { "supported_method_ids", reinterpret_cast<getter>(PaymentDetailsModifier_get_SupportedMethodIds), nullptr, nullptr, nullptr },
        { "total", reinterpret_cast<getter>(PaymentDetailsModifier_get_Total), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentDetailsModifier[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentDetailsModifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentDetailsModifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentDetailsModifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentDetailsModifier) },
        { }};

    static PyType_Spec type_spec_PaymentDetailsModifier = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentDetailsModifier",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentDetailsModifier};

    // ----- PaymentItem class --------------------

    static PyObject* _new_PaymentItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentItem instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentItem(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentItem_get_Pending(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Pending");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Pending();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Pending(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Pending");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Pending(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentItem_get_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Label();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Label(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentItem_get_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Amount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Amount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Amount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(arg);

            {
                auto _gil = release_gil();
                self->obj.Amount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentItem[] = {
        { "_assign_array_", _assign_array_PaymentItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentItem[] = {
        { "pending", reinterpret_cast<getter>(PaymentItem_get_Pending), reinterpret_cast<setter>(PaymentItem_put_Pending), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(PaymentItem_get_Label), reinterpret_cast<setter>(PaymentItem_put_Label), nullptr, nullptr },
        { "amount", reinterpret_cast<getter>(PaymentItem_get_Amount), reinterpret_cast<setter>(PaymentItem_put_Amount), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentItem) },
        { }};

    static PyType_Spec type_spec_PaymentItem = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentItem};

    // ----- PaymentMediator class --------------------

    static PyObject* _new_PaymentMediator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentMediator instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMediator(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMediator_CanMakePaymentAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"CanMakePaymentAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CanMakePaymentAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentMediator_GetSupportedMethodIdsAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"GetSupportedMethodIdsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSupportedMethodIdsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentMediator_SubmitPaymentRequestAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"SubmitPaymentRequestAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SubmitPaymentRequestAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentMediator_SubmitPaymentRequestWithChangeHandlerAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"SubmitPaymentRequestAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedHandler>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SubmitPaymentRequestAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMediator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMediator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMediator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMediator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMediator[] = {
        { "can_make_payment_async", reinterpret_cast<PyCFunction>(PaymentMediator_CanMakePaymentAsync), METH_VARARGS, nullptr },
        { "get_supported_method_ids_async", reinterpret_cast<PyCFunction>(PaymentMediator_GetSupportedMethodIdsAsync), METH_VARARGS, nullptr },
        { "submit_payment_request_async", reinterpret_cast<PyCFunction>(PaymentMediator_SubmitPaymentRequestAsync), METH_VARARGS, nullptr },
        { "submit_payment_request_with_change_handler_async", reinterpret_cast<PyCFunction>(PaymentMediator_SubmitPaymentRequestWithChangeHandlerAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentMediator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMediator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentMediator[] = {
        { }};

    static PyType_Slot _type_slots_PaymentMediator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMediator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMediator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMediator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMediator) },
        { }};

    static PyType_Spec type_spec_PaymentMediator = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentMediator",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMediator};

    // ----- PaymentMerchantInfo class --------------------

    static PyObject* _new_PaymentMerchantInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMerchantInfo(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMerchantInfo_get_PackageFullName(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMerchantInfo", L"PackageFullName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PackageFullName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentMerchantInfo_get_Uri(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMerchantInfo", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMerchantInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMerchantInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMerchantInfo[] = {
        { "_assign_array_", _assign_array_PaymentMerchantInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMerchantInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentMerchantInfo[] = {
        { "package_full_name", reinterpret_cast<getter>(PaymentMerchantInfo_get_PackageFullName), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PaymentMerchantInfo_get_Uri), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentMerchantInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMerchantInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMerchantInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMerchantInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMerchantInfo) },
        { }};

    static PyType_Spec type_spec_PaymentMerchantInfo = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentMerchantInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMerchantInfo};

    // ----- PaymentMethodData class --------------------

    static PyObject* _new_PaymentMethodData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentMethodData instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentMethodData instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMethodData(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMethodData_get_JsonData(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMethodData", L"JsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentMethodData_get_SupportedMethodIds(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMethodData", L"SupportedMethodIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedMethodIds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMethodData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMethodData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMethodData[] = {
        { "_assign_array_", _assign_array_PaymentMethodData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMethodData), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentMethodData[] = {
        { "json_data", reinterpret_cast<getter>(PaymentMethodData_get_JsonData), nullptr, nullptr, nullptr },
        { "supported_method_ids", reinterpret_cast<getter>(PaymentMethodData_get_SupportedMethodIds), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentMethodData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMethodData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMethodData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMethodData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMethodData) },
        { }};

    static PyType_Spec type_spec_PaymentMethodData = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentMethodData",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMethodData};

    // ----- PaymentOptions class --------------------

    static PyObject* _new_PaymentOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentOptions_get_ShippingType(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"ShippingType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShippingType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_ShippingType(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"ShippingType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentShippingType>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShippingType(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestShipping(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestShipping");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestShipping();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestShipping(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestShipping");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequestShipping(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerPhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestPayerPhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerPhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequestPayerPhoneNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestPayerName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequestPayerName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerEmail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestPayerEmail();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerEmail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequestPayerEmail(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentOptions[] = {
        { "_assign_array_", _assign_array_PaymentOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentOptions[] = {
        { "shipping_type", reinterpret_cast<getter>(PaymentOptions_get_ShippingType), reinterpret_cast<setter>(PaymentOptions_put_ShippingType), nullptr, nullptr },
        { "request_shipping", reinterpret_cast<getter>(PaymentOptions_get_RequestShipping), reinterpret_cast<setter>(PaymentOptions_put_RequestShipping), nullptr, nullptr },
        { "request_payer_phone_number", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerPhoneNumber), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerPhoneNumber), nullptr, nullptr },
        { "request_payer_name", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerName), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerName), nullptr, nullptr },
        { "request_payer_email", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerEmail), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerEmail), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentOptions) },
        { }};

    static PyType_Spec type_spec_PaymentOptions = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentOptions};

    // ----- PaymentRequest class --------------------

    static PyObject* _new_PaymentRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptions>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{param0, param1, param2, param3, param4};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptions>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentRequest(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequest_get_Details(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Details");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Details();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_MerchantInfo(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"MerchantInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MerchantInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_MethodData(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"MethodData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MethodData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_Options(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Options");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Options();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_Id(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequest[] = {
        { "_assign_array_", _assign_array_PaymentRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentRequest[] = {
        { "details", reinterpret_cast<getter>(PaymentRequest_get_Details), nullptr, nullptr, nullptr },
        { "merchant_info", reinterpret_cast<getter>(PaymentRequest_get_MerchantInfo), nullptr, nullptr, nullptr },
        { "method_data", reinterpret_cast<getter>(PaymentRequest_get_MethodData), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(PaymentRequest_get_Options), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PaymentRequest_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequest) },
        { }};

    static PyType_Spec type_spec_PaymentRequest = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequest};

    // ----- PaymentRequestChangedArgs class --------------------

    static PyObject* _new_PaymentRequestChangedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PaymentRequestChangedArgs(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestChangedArgs_Acknowledge(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"Acknowledge", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Acknowledge(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_ChangeKind(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"ChangeKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_SelectedShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"SelectedShippingOption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedShippingOption();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_ShippingAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"ShippingAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShippingAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequestChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestChangedArgs[] = {
        { "acknowledge", reinterpret_cast<PyCFunction>(PaymentRequestChangedArgs_Acknowledge), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentRequestChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestChangedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentRequestChangedArgs[] = {
        { "change_kind", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_ChangeKind), nullptr, nullptr, nullptr },
        { "selected_shipping_option", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_SelectedShippingOption), nullptr, nullptr, nullptr },
        { "shipping_address", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_ShippingAddress), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentRequestChangedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestChangedArgs) },
        { }};

    static PyType_Spec type_spec_PaymentRequestChangedArgs = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentRequestChangedArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestChangedArgs};

    // ----- PaymentRequestChangedResult class --------------------

    static PyObject* _new_PaymentRequestChangedResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentRequestChangedResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestChangedResult_get_UpdatedPaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"UpdatedPaymentDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdatedPaymentDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_UpdatedPaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"UpdatedPaymentDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(arg);

            {
                auto _gil = release_gil();
                self->obj.UpdatedPaymentDetails(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentRequestChangedResult_get_Message(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_Message(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Message(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentRequestChangedResult_get_ChangeAcceptedByMerchant(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"ChangeAcceptedByMerchant");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeAcceptedByMerchant();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_ChangeAcceptedByMerchant(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"ChangeAcceptedByMerchant");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChangeAcceptedByMerchant(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentRequestChangedResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestChangedResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestChangedResult[] = {
        { "_assign_array_", _assign_array_PaymentRequestChangedResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestChangedResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentRequestChangedResult[] = {
        { "updated_payment_details", reinterpret_cast<getter>(PaymentRequestChangedResult_get_UpdatedPaymentDetails), reinterpret_cast<setter>(PaymentRequestChangedResult_put_UpdatedPaymentDetails), nullptr, nullptr },
        { "message", reinterpret_cast<getter>(PaymentRequestChangedResult_get_Message), reinterpret_cast<setter>(PaymentRequestChangedResult_put_Message), nullptr, nullptr },
        { "change_accepted_by_merchant", reinterpret_cast<getter>(PaymentRequestChangedResult_get_ChangeAcceptedByMerchant), reinterpret_cast<setter>(PaymentRequestChangedResult_put_ChangeAcceptedByMerchant), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentRequestChangedResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestChangedResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestChangedResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestChangedResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestChangedResult) },
        { }};

    static PyType_Spec type_spec_PaymentRequestChangedResult = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentRequestChangedResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestChangedResult};

    // ----- PaymentRequestSubmitResult class --------------------

    static PyObject* _new_PaymentRequestSubmitResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PaymentRequestSubmitResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestSubmitResult_get_Response(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestSubmitResult", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Response();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestSubmitResult_get_Status(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestSubmitResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequestSubmitResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestSubmitResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestSubmitResult[] = {
        { "_assign_array_", _assign_array_PaymentRequestSubmitResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestSubmitResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentRequestSubmitResult[] = {
        { "response", reinterpret_cast<getter>(PaymentRequestSubmitResult_get_Response), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PaymentRequestSubmitResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentRequestSubmitResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestSubmitResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestSubmitResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestSubmitResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestSubmitResult) },
        { }};

    static PyType_Spec type_spec_PaymentRequestSubmitResult = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentRequestSubmitResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestSubmitResult};

    // ----- PaymentResponse class --------------------

    static PyObject* _new_PaymentResponse(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentResponse>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentResponse>::type_name);
        return nullptr;
    }

    static void _dealloc_PaymentResponse(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentResponse_CompleteAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"CompleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestCompletionStatus>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CompleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerEmail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PayerEmail();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PayerName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerPhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PayerPhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PaymentToken(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PaymentToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PaymentToken();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_ShippingAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"ShippingAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShippingAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_ShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"ShippingOption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShippingOption();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentResponse[] = {
        { "complete_async", reinterpret_cast<PyCFunction>(PaymentResponse_CompleteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentResponse), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentResponse[] = {
        { "payer_email", reinterpret_cast<getter>(PaymentResponse_get_PayerEmail), nullptr, nullptr, nullptr },
        { "payer_name", reinterpret_cast<getter>(PaymentResponse_get_PayerName), nullptr, nullptr, nullptr },
        { "payer_phone_number", reinterpret_cast<getter>(PaymentResponse_get_PayerPhoneNumber), nullptr, nullptr, nullptr },
        { "payment_token", reinterpret_cast<getter>(PaymentResponse_get_PaymentToken), nullptr, nullptr, nullptr },
        { "shipping_address", reinterpret_cast<getter>(PaymentResponse_get_ShippingAddress), nullptr, nullptr, nullptr },
        { "shipping_option", reinterpret_cast<getter>(PaymentResponse_get_ShippingOption), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentResponse[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentResponse) },
        { }};

    static PyType_Spec type_spec_PaymentResponse = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentResponse",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentResponse};

    // ----- PaymentShippingOption class --------------------

    static PyObject* _new_PaymentShippingOption(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentShippingOption_get_Tag(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Tag(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Label();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Label(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_IsSelected(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSelected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_IsSelected(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSelected(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Amount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Amount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Amount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(arg);

            {
                auto _gil = release_gil();
                self->obj.Amount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentShippingOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentShippingOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentShippingOption[] = {
        { "_assign_array_", _assign_array_PaymentShippingOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentShippingOption), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentShippingOption[] = {
        { "tag", reinterpret_cast<getter>(PaymentShippingOption_get_Tag), reinterpret_cast<setter>(PaymentShippingOption_put_Tag), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(PaymentShippingOption_get_Label), reinterpret_cast<setter>(PaymentShippingOption_put_Label), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(PaymentShippingOption_get_IsSelected), reinterpret_cast<setter>(PaymentShippingOption_put_IsSelected), nullptr, nullptr },
        { "amount", reinterpret_cast<getter>(PaymentShippingOption_get_Amount), reinterpret_cast<setter>(PaymentShippingOption_put_Amount), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentShippingOption[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentShippingOption) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentShippingOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentShippingOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentShippingOption) },
        { }};

    static PyType_Spec type_spec_PaymentShippingOption = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentShippingOption",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentShippingOption};

    // ----- PaymentToken class --------------------

    static PyObject* _new_PaymentToken(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentToken instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentToken instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentToken(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentToken_get_JsonDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentToken", L"JsonDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JsonDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentToken_get_PaymentMethodId(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentToken", L"PaymentMethodId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PaymentMethodId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentToken>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentToken>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentToken[] = {
        { "_assign_array_", _assign_array_PaymentToken, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentToken), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PaymentToken[] = {
        { "json_details", reinterpret_cast<getter>(PaymentToken_get_JsonDetails), nullptr, nullptr, nullptr },
        { "payment_method_id", reinterpret_cast<getter>(PaymentToken_get_PaymentMethodId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PaymentToken[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentToken) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentToken) },
        { }};

    static PyType_Spec type_spec_PaymentToken = {
        "winrt._winrt_windows_applicationmodel_payments.PaymentToken",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentToken};

    // ----- Windows.ApplicationModel.Payments Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Payments");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_payments",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Payments

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_payments(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle PaymentAddress_type{py::register_python_type(module.get(), &type_spec_PaymentAddress, object_bases.get(), inspectable_meta_type)};
    if (!PaymentAddress_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentCanMakePaymentResult_type{py::register_python_type(module.get(), &type_spec_PaymentCanMakePaymentResult, object_bases.get(), inspectable_meta_type)};
    if (!PaymentCanMakePaymentResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentCurrencyAmount_type{py::register_python_type(module.get(), &type_spec_PaymentCurrencyAmount, object_bases.get(), inspectable_meta_type)};
    if (!PaymentCurrencyAmount_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentDetails_type{py::register_python_type(module.get(), &type_spec_PaymentDetails, object_bases.get(), inspectable_meta_type)};
    if (!PaymentDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentDetailsModifier_type{py::register_python_type(module.get(), &type_spec_PaymentDetailsModifier, object_bases.get(), inspectable_meta_type)};
    if (!PaymentDetailsModifier_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentItem_type{py::register_python_type(module.get(), &type_spec_PaymentItem, object_bases.get(), inspectable_meta_type)};
    if (!PaymentItem_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentMediator_type{py::register_python_type(module.get(), &type_spec_PaymentMediator, object_bases.get(), inspectable_meta_type)};
    if (!PaymentMediator_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentMerchantInfo_type{py::register_python_type(module.get(), &type_spec_PaymentMerchantInfo, object_bases.get(), inspectable_meta_type)};
    if (!PaymentMerchantInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentMethodData_type{py::register_python_type(module.get(), &type_spec_PaymentMethodData, object_bases.get(), inspectable_meta_type)};
    if (!PaymentMethodData_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentOptions_type{py::register_python_type(module.get(), &type_spec_PaymentOptions, object_bases.get(), inspectable_meta_type)};
    if (!PaymentOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentRequest_type{py::register_python_type(module.get(), &type_spec_PaymentRequest, object_bases.get(), inspectable_meta_type)};
    if (!PaymentRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentRequestChangedArgs_type{py::register_python_type(module.get(), &type_spec_PaymentRequestChangedArgs, object_bases.get(), inspectable_meta_type)};
    if (!PaymentRequestChangedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentRequestChangedResult_type{py::register_python_type(module.get(), &type_spec_PaymentRequestChangedResult, object_bases.get(), inspectable_meta_type)};
    if (!PaymentRequestChangedResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentRequestSubmitResult_type{py::register_python_type(module.get(), &type_spec_PaymentRequestSubmitResult, object_bases.get(), inspectable_meta_type)};
    if (!PaymentRequestSubmitResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentResponse_type{py::register_python_type(module.get(), &type_spec_PaymentResponse, object_bases.get(), inspectable_meta_type)};
    if (!PaymentResponse_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentShippingOption_type{py::register_python_type(module.get(), &type_spec_PaymentShippingOption, object_bases.get(), inspectable_meta_type)};
    if (!PaymentShippingOption_type)
    {
        return nullptr;
    }

    py::pytype_handle PaymentToken_type{py::register_python_type(module.get(), &type_spec_PaymentToken, object_bases.get(), inspectable_meta_type)};
    if (!PaymentToken_type)
    {
        return nullptr;
    }


    return module.detach();
}
