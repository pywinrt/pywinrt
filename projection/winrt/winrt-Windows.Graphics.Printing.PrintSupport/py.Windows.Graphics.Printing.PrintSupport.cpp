// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Graphics.Printing.PrintSupport.h"

namespace py::cpp::Windows::Graphics::Printing::PrintSupport
{
    // ----- PrintSupportCommunicationErrorDetectedEventArgs class --------------------

    static PyObject* _new_PrintSupportCommunicationErrorDetectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportCommunicationErrorDetectedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportCommunicationErrorDetectedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportCommunicationErrorDetectedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportCommunicationErrorDetectedEventArgs_get_CommunicationConfiguration(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportCommunicationErrorDetectedEventArgs", L"CommunicationConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CommunicationConfiguration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportCommunicationErrorDetectedEventArgs_get_ErrorKind(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportCommunicationErrorDetectedEventArgs", L"ErrorKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportCommunicationErrorDetectedEventArgs_get_ExtendedError(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportCommunicationErrorDetectedEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportCommunicationErrorDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportCommunicationErrorDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportCommunicationErrorDetectedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportCommunicationErrorDetectedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportCommunicationErrorDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportCommunicationErrorDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportCommunicationErrorDetectedEventArgs[] = {
        { "communication_configuration", reinterpret_cast<getter>(PrintSupportCommunicationErrorDetectedEventArgs_get_CommunicationConfiguration), nullptr, nullptr, nullptr },
        { "error_kind", reinterpret_cast<getter>(PrintSupportCommunicationErrorDetectedEventArgs_get_ErrorKind), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(PrintSupportCommunicationErrorDetectedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportCommunicationErrorDetectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportCommunicationErrorDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportCommunicationErrorDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportCommunicationErrorDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportCommunicationErrorDetectedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintSupportCommunicationErrorDetectedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportCommunicationErrorDetectedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportCommunicationErrorDetectedEventArgs};

    // ----- PrintSupportExtensionSession class --------------------

    static PyObject* _new_PrintSupportExtensionSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportExtensionSession(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportExtensionSession_Start(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_get_Printer(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"Printer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Printer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_add_PrintDeviceCapabilitiesChanged(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrintDeviceCapabilitiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession, winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrintDeviceCapabilitiesChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_remove_PrintDeviceCapabilitiesChanged(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrintDeviceCapabilitiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrintDeviceCapabilitiesChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_add_PrintTicketValidationRequested(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrintTicketValidationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession, winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrintTicketValidationRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_remove_PrintTicketValidationRequested(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrintTicketValidationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrintTicketValidationRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_add_PrinterSelected(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrinterSelected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession, winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrinterSelected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_remove_PrinterSelected(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrinterSelected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrinterSelected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_add_CommunicationErrorDetected(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"CommunicationErrorDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession, winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportCommunicationErrorDetectedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CommunicationErrorDetected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_remove_CommunicationErrorDetected(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"CommunicationErrorDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CommunicationErrorDetected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportExtensionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportExtensionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportExtensionSession[] = {
        { "start", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_Start), METH_VARARGS, nullptr },
        { "add_print_device_capabilities_changed", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_add_PrintDeviceCapabilitiesChanged), METH_O, nullptr },
        { "remove_print_device_capabilities_changed", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_remove_PrintDeviceCapabilitiesChanged), METH_O, nullptr },
        { "add_print_ticket_validation_requested", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_add_PrintTicketValidationRequested), METH_O, nullptr },
        { "remove_print_ticket_validation_requested", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_remove_PrintTicketValidationRequested), METH_O, nullptr },
        { "add_printer_selected", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_add_PrinterSelected), METH_O, nullptr },
        { "remove_printer_selected", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_remove_PrinterSelected), METH_O, nullptr },
        { "add_communication_error_detected", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_add_CommunicationErrorDetected), METH_O, nullptr },
        { "remove_communication_error_detected", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_remove_CommunicationErrorDetected), METH_O, nullptr },
        { "_assign_array_", _assign_array_PrintSupportExtensionSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportExtensionSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportExtensionSession[] = {
        { "printer", reinterpret_cast<getter>(PrintSupportExtensionSession_get_Printer), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportExtensionSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportExtensionSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportExtensionSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportExtensionSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportExtensionSession) },
        { }};

    static PyType_Spec type_spec_PrintSupportExtensionSession = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportExtensionSession",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportExtensionSession};

    // ----- PrintSupportExtensionTriggerDetails class --------------------

    static PyObject* _new_PrintSupportExtensionTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportExtensionTriggerDetails(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportExtensionTriggerDetails_get_Session(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionTriggerDetails", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Session();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportExtensionTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportExtensionTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportExtensionTriggerDetails[] = {
        { "_assign_array_", _assign_array_PrintSupportExtensionTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportExtensionTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportExtensionTriggerDetails[] = {
        { "session", reinterpret_cast<getter>(PrintSupportExtensionTriggerDetails_get_Session), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportExtensionTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportExtensionTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportExtensionTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportExtensionTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportExtensionTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PrintSupportExtensionTriggerDetails = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportExtensionTriggerDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportExtensionTriggerDetails};

    // ----- PrintSupportIppCommunicationConfiguration class --------------------

    static PyObject* _new_PrintSupportIppCommunicationConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportIppCommunicationConfiguration(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportIppCommunicationConfiguration_get_CanModifyTimeouts(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationConfiguration", L"CanModifyTimeouts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanModifyTimeouts();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportIppCommunicationConfiguration_get_CommunicationKind(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationConfiguration", L"CommunicationKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CommunicationKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportIppCommunicationConfiguration_get_IppAttributeTimeouts(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationConfiguration", L"IppAttributeTimeouts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IppAttributeTimeouts();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportIppCommunicationConfiguration_get_IppJobTimeouts(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationConfiguration", L"IppJobTimeouts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IppJobTimeouts();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportIppCommunicationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportIppCommunicationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportIppCommunicationConfiguration[] = {
        { "_assign_array_", _assign_array_PrintSupportIppCommunicationConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportIppCommunicationConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportIppCommunicationConfiguration[] = {
        { "can_modify_timeouts", reinterpret_cast<getter>(PrintSupportIppCommunicationConfiguration_get_CanModifyTimeouts), nullptr, nullptr, nullptr },
        { "communication_kind", reinterpret_cast<getter>(PrintSupportIppCommunicationConfiguration_get_CommunicationKind), nullptr, nullptr, nullptr },
        { "ipp_attribute_timeouts", reinterpret_cast<getter>(PrintSupportIppCommunicationConfiguration_get_IppAttributeTimeouts), nullptr, nullptr, nullptr },
        { "ipp_job_timeouts", reinterpret_cast<getter>(PrintSupportIppCommunicationConfiguration_get_IppJobTimeouts), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportIppCommunicationConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportIppCommunicationConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportIppCommunicationConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportIppCommunicationConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportIppCommunicationConfiguration) },
        { }};

    static PyType_Spec type_spec_PrintSupportIppCommunicationConfiguration = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportIppCommunicationConfiguration",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportIppCommunicationConfiguration};

    // ----- PrintSupportIppCommunicationTimeouts class --------------------

    static PyObject* _new_PrintSupportIppCommunicationTimeouts(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportIppCommunicationTimeouts(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportIppCommunicationTimeouts_get_SendTimeout(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationTimeouts", L"SendTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SendTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportIppCommunicationTimeouts_put_SendTimeout(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationTimeouts", L"SendTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.SendTimeout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportIppCommunicationTimeouts_get_ReceiveTimeout(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationTimeouts", L"ReceiveTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReceiveTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportIppCommunicationTimeouts_put_ReceiveTimeout(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationTimeouts", L"ReceiveTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.ReceiveTimeout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportIppCommunicationTimeouts_get_ConnectTimeout(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationTimeouts", L"ConnectTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportIppCommunicationTimeouts_put_ConnectTimeout(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportIppCommunicationTimeouts", L"ConnectTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConnectTimeout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PrintSupportIppCommunicationTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportIppCommunicationTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportIppCommunicationTimeouts[] = {
        { "_assign_array_", _assign_array_PrintSupportIppCommunicationTimeouts, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportIppCommunicationTimeouts), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportIppCommunicationTimeouts[] = {
        { "send_timeout", reinterpret_cast<getter>(PrintSupportIppCommunicationTimeouts_get_SendTimeout), reinterpret_cast<setter>(PrintSupportIppCommunicationTimeouts_put_SendTimeout), nullptr, nullptr },
        { "receive_timeout", reinterpret_cast<getter>(PrintSupportIppCommunicationTimeouts_get_ReceiveTimeout), reinterpret_cast<setter>(PrintSupportIppCommunicationTimeouts_put_ReceiveTimeout), nullptr, nullptr },
        { "connect_timeout", reinterpret_cast<getter>(PrintSupportIppCommunicationTimeouts_get_ConnectTimeout), reinterpret_cast<setter>(PrintSupportIppCommunicationTimeouts_put_ConnectTimeout), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportIppCommunicationTimeouts[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportIppCommunicationTimeouts) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportIppCommunicationTimeouts) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportIppCommunicationTimeouts) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportIppCommunicationTimeouts) },
        { }};

    static PyType_Spec type_spec_PrintSupportIppCommunicationTimeouts = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportIppCommunicationTimeouts",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportIppCommunicationTimeouts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportIppCommunicationTimeouts};

    // ----- PrintSupportMxdcImageQualityConfiguration class --------------------

    static PyObject* _new_PrintSupportMxdcImageQualityConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportMxdcImageQualityConfiguration(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportMxdcImageQualityConfiguration_get_TextOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"TextOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextOutputQuality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportMxdcImageQualityConfiguration_put_TextOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"TextOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::XpsImageQuality>(arg);

            {
                auto _gil = release_gil();
                self->obj.TextOutputQuality(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportMxdcImageQualityConfiguration_get_PhotographicOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"PhotographicOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotographicOutputQuality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportMxdcImageQualityConfiguration_put_PhotographicOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"PhotographicOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::XpsImageQuality>(arg);

            {
                auto _gil = release_gil();
                self->obj.PhotographicOutputQuality(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportMxdcImageQualityConfiguration_get_NormalOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"NormalOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NormalOutputQuality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportMxdcImageQualityConfiguration_put_NormalOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"NormalOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::XpsImageQuality>(arg);

            {
                auto _gil = release_gil();
                self->obj.NormalOutputQuality(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportMxdcImageQualityConfiguration_get_HighOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"HighOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HighOutputQuality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportMxdcImageQualityConfiguration_put_HighOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"HighOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::XpsImageQuality>(arg);

            {
                auto _gil = release_gil();
                self->obj.HighOutputQuality(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportMxdcImageQualityConfiguration_get_FaxOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"FaxOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FaxOutputQuality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportMxdcImageQualityConfiguration_put_FaxOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"FaxOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::XpsImageQuality>(arg);

            {
                auto _gil = release_gil();
                self->obj.FaxOutputQuality(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportMxdcImageQualityConfiguration_get_DraftOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"DraftOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DraftOutputQuality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportMxdcImageQualityConfiguration_put_DraftOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"DraftOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::XpsImageQuality>(arg);

            {
                auto _gil = release_gil();
                self->obj.DraftOutputQuality(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportMxdcImageQualityConfiguration_get_AutomaticOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"AutomaticOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AutomaticOutputQuality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportMxdcImageQualityConfiguration_put_AutomaticOutputQuality(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportMxdcImageQualityConfiguration", L"AutomaticOutputQuality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::XpsImageQuality>(arg);

            {
                auto _gil = release_gil();
                self->obj.AutomaticOutputQuality(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PrintSupportMxdcImageQualityConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportMxdcImageQualityConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportMxdcImageQualityConfiguration[] = {
        { "_assign_array_", _assign_array_PrintSupportMxdcImageQualityConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportMxdcImageQualityConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportMxdcImageQualityConfiguration[] = {
        { "text_output_quality", reinterpret_cast<getter>(PrintSupportMxdcImageQualityConfiguration_get_TextOutputQuality), reinterpret_cast<setter>(PrintSupportMxdcImageQualityConfiguration_put_TextOutputQuality), nullptr, nullptr },
        { "photographic_output_quality", reinterpret_cast<getter>(PrintSupportMxdcImageQualityConfiguration_get_PhotographicOutputQuality), reinterpret_cast<setter>(PrintSupportMxdcImageQualityConfiguration_put_PhotographicOutputQuality), nullptr, nullptr },
        { "normal_output_quality", reinterpret_cast<getter>(PrintSupportMxdcImageQualityConfiguration_get_NormalOutputQuality), reinterpret_cast<setter>(PrintSupportMxdcImageQualityConfiguration_put_NormalOutputQuality), nullptr, nullptr },
        { "high_output_quality", reinterpret_cast<getter>(PrintSupportMxdcImageQualityConfiguration_get_HighOutputQuality), reinterpret_cast<setter>(PrintSupportMxdcImageQualityConfiguration_put_HighOutputQuality), nullptr, nullptr },
        { "fax_output_quality", reinterpret_cast<getter>(PrintSupportMxdcImageQualityConfiguration_get_FaxOutputQuality), reinterpret_cast<setter>(PrintSupportMxdcImageQualityConfiguration_put_FaxOutputQuality), nullptr, nullptr },
        { "draft_output_quality", reinterpret_cast<getter>(PrintSupportMxdcImageQualityConfiguration_get_DraftOutputQuality), reinterpret_cast<setter>(PrintSupportMxdcImageQualityConfiguration_put_DraftOutputQuality), nullptr, nullptr },
        { "automatic_output_quality", reinterpret_cast<getter>(PrintSupportMxdcImageQualityConfiguration_get_AutomaticOutputQuality), reinterpret_cast<setter>(PrintSupportMxdcImageQualityConfiguration_put_AutomaticOutputQuality), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportMxdcImageQualityConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportMxdcImageQualityConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportMxdcImageQualityConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportMxdcImageQualityConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportMxdcImageQualityConfiguration) },
        { }};

    static PyType_Spec type_spec_PrintSupportMxdcImageQualityConfiguration = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportMxdcImageQualityConfiguration",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportMxdcImageQualityConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportMxdcImageQualityConfiguration};

    // ----- PrintSupportPrintDeviceCapabilitiesChangedEventArgs class --------------------

    static PyObject* _new_PrintSupportPrintDeviceCapabilitiesChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportPrintDeviceCapabilitiesChangedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetCurrentPrintDeviceCapabilities(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"GetCurrentPrintDeviceCapabilities", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentPrintDeviceCapabilities();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetCurrentPrintDeviceResources(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"GetCurrentPrintDeviceResources", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentPrintDeviceResources();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_SetPrintDeviceCapabilitiesUpdatePolicy(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"SetPrintDeviceCapabilitiesUpdatePolicy", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetPrintDeviceCapabilitiesUpdatePolicy(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_SetSupportedPdlPassthroughContentTypes(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"SetSupportedPdlPassthroughContentTypes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetSupportedPdlPassthroughContentTypes(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_UpdatePrintDeviceCapabilities(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"UpdatePrintDeviceCapabilities", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.UpdatePrintDeviceCapabilities(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_UpdatePrintDeviceResources(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"UpdatePrintDeviceResources", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.UpdatePrintDeviceResources(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_get_ResourceLanguage(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"ResourceLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResourceLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_get_CommunicationConfiguration(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"CommunicationConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CommunicationConfiguration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_get_MxdcImageQualityConfiguration(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"MxdcImageQualityConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MxdcImageQualityConfiguration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportPrintDeviceCapabilitiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrintDeviceCapabilitiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrintDeviceCapabilitiesChangedEventArgs[] = {
        { "get_current_print_device_capabilities", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetCurrentPrintDeviceCapabilities), METH_VARARGS, nullptr },
        { "get_current_print_device_resources", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetCurrentPrintDeviceResources), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_print_device_capabilities_update_policy", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_SetPrintDeviceCapabilitiesUpdatePolicy), METH_VARARGS, nullptr },
        { "set_supported_pdl_passthrough_content_types", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_SetSupportedPdlPassthroughContentTypes), METH_VARARGS, nullptr },
        { "update_print_device_capabilities", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_UpdatePrintDeviceCapabilities), METH_VARARGS, nullptr },
        { "update_print_device_resources", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_UpdatePrintDeviceResources), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportPrintDeviceCapabilitiesChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrintDeviceCapabilitiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportPrintDeviceCapabilitiesChangedEventArgs[] = {
        { "resource_language", reinterpret_cast<getter>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_get_ResourceLanguage), nullptr, nullptr, nullptr },
        { "communication_configuration", reinterpret_cast<getter>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_get_CommunicationConfiguration), nullptr, nullptr, nullptr },
        { "mxdc_image_quality_configuration", reinterpret_cast<getter>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_get_MxdcImageQualityConfiguration), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportPrintDeviceCapabilitiesChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrintDeviceCapabilitiesChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrintDeviceCapabilitiesChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrintDeviceCapabilitiesChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrintDeviceCapabilitiesChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintSupportPrintDeviceCapabilitiesChangedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrintDeviceCapabilitiesChangedEventArgs};

    // ----- PrintSupportPrintDeviceCapabilitiesUpdatePolicy class --------------------

    static PyObject* _new_PrintSupportPrintDeviceCapabilitiesUpdatePolicy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportPrintDeviceCapabilitiesUpdatePolicy(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesUpdatePolicy_CreatePeriodicRefresh(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesUpdatePolicy", L"CreatePeriodicRefresh", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy::CreatePeriodicRefresh(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesUpdatePolicy_CreatePrintJobRefresh(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesUpdatePolicy", L"CreatePrintJobRefresh", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy::CreatePrintJobRefresh(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportPrintDeviceCapabilitiesUpdatePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrintDeviceCapabilitiesUpdatePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrintDeviceCapabilitiesUpdatePolicy[] = {
        { "_assign_array_", _assign_array_PrintSupportPrintDeviceCapabilitiesUpdatePolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrintDeviceCapabilitiesUpdatePolicy), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportPrintDeviceCapabilitiesUpdatePolicy[] = {
        { }};

    static PyType_Slot _type_slots_PrintSupportPrintDeviceCapabilitiesUpdatePolicy[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrintDeviceCapabilitiesUpdatePolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrintDeviceCapabilitiesUpdatePolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrintDeviceCapabilitiesUpdatePolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrintDeviceCapabilitiesUpdatePolicy) },
        { }};

    static PyType_Spec type_spec_PrintSupportPrintDeviceCapabilitiesUpdatePolicy = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintDeviceCapabilitiesUpdatePolicy",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrintDeviceCapabilitiesUpdatePolicy};

    static PyGetSetDef getset_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static[] = {
        { }};

    static PyMethodDef methods_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static[] = {
        { "create_periodic_refresh", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesUpdatePolicy_CreatePeriodicRefresh), METH_VARARGS, nullptr },
        { "create_print_job_refresh", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesUpdatePolicy_CreatePrintJobRefresh), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static};

    // ----- PrintSupportPrintTicketElement class --------------------

    static PyObject* _new_PrintSupportPrintTicketElement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PrintSupportPrintTicketElement(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrintTicketElement_get_NamespaceUri(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketElement", L"NamespaceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NamespaceUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportPrintTicketElement_put_NamespaceUri(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketElement", L"NamespaceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NamespaceUri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportPrintTicketElement_get_LocalName(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketElement", L"LocalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportPrintTicketElement_put_LocalName(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketElement", L"LocalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.LocalName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PrintSupportPrintTicketElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrintTicketElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrintTicketElement[] = {
        { "_assign_array_", _assign_array_PrintSupportPrintTicketElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrintTicketElement), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportPrintTicketElement[] = {
        { "namespace_uri", reinterpret_cast<getter>(PrintSupportPrintTicketElement_get_NamespaceUri), reinterpret_cast<setter>(PrintSupportPrintTicketElement_put_NamespaceUri), nullptr, nullptr },
        { "local_name", reinterpret_cast<getter>(PrintSupportPrintTicketElement_get_LocalName), reinterpret_cast<setter>(PrintSupportPrintTicketElement_put_LocalName), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportPrintTicketElement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrintTicketElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrintTicketElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrintTicketElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrintTicketElement) },
        { }};

    static PyType_Spec type_spec_PrintSupportPrintTicketElement = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintTicketElement",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrintTicketElement};

    // ----- PrintSupportPrintTicketValidationRequestedEventArgs class --------------------

    static PyObject* _new_PrintSupportPrintTicketValidationRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportPrintTicketValidationRequestedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrintTicketValidationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketValidationRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintTicketValidationRequestedEventArgs_SetPrintTicketValidationStatus(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketValidationRequestedEventArgs", L"SetPrintTicketValidationStatus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::WorkflowPrintTicketValidationStatus>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetPrintTicketValidationStatus(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintTicketValidationRequestedEventArgs_get_PrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketValidationRequestedEventArgs", L"PrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrintTicket();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportPrintTicketValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrintTicketValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrintTicketValidationRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportPrintTicketValidationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_print_ticket_validation_status", reinterpret_cast<PyCFunction>(PrintSupportPrintTicketValidationRequestedEventArgs_SetPrintTicketValidationStatus), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportPrintTicketValidationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrintTicketValidationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportPrintTicketValidationRequestedEventArgs[] = {
        { "print_ticket", reinterpret_cast<getter>(PrintSupportPrintTicketValidationRequestedEventArgs_get_PrintTicket), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportPrintTicketValidationRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrintTicketValidationRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrintTicketValidationRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrintTicketValidationRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrintTicketValidationRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintSupportPrintTicketValidationRequestedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintTicketValidationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrintTicketValidationRequestedEventArgs};

    // ----- PrintSupportPrinterSelectedEventArgs class --------------------

    static PyObject* _new_PrintSupportPrinterSelectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportPrinterSelectedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_SetAdaptiveCard(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"SetAdaptiveCard", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::IAdaptiveCard>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetAdaptiveCard(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_SetAdditionalFeatures(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"SetAdditionalFeatures", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetAdditionalFeatures(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_SetAdditionalParameters(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"SetAdditionalParameters", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetAdditionalParameters(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_get_PrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"PrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrintTicket();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportPrinterSelectedEventArgs_put_PrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"PrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTicket::WorkflowPrintTicket>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrintTicket(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_get_AllowedAdditionalFeaturesAndParametersCount(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"AllowedAdditionalFeaturesAndParametersCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowedAdditionalFeaturesAndParametersCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_get_SourceAppInfo(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"SourceAppInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceAppInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportPrinterSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrinterSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrinterSelectedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportPrinterSelectedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_adaptive_card", reinterpret_cast<PyCFunction>(PrintSupportPrinterSelectedEventArgs_SetAdaptiveCard), METH_VARARGS, nullptr },
        { "set_additional_features", reinterpret_cast<PyCFunction>(PrintSupportPrinterSelectedEventArgs_SetAdditionalFeatures), METH_VARARGS, nullptr },
        { "set_additional_parameters", reinterpret_cast<PyCFunction>(PrintSupportPrinterSelectedEventArgs_SetAdditionalParameters), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportPrinterSelectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrinterSelectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportPrinterSelectedEventArgs[] = {
        { "print_ticket", reinterpret_cast<getter>(PrintSupportPrinterSelectedEventArgs_get_PrintTicket), reinterpret_cast<setter>(PrintSupportPrinterSelectedEventArgs_put_PrintTicket), nullptr, nullptr },
        { "allowed_additional_features_and_parameters_count", reinterpret_cast<getter>(PrintSupportPrinterSelectedEventArgs_get_AllowedAdditionalFeaturesAndParametersCount), nullptr, nullptr, nullptr },
        { "source_app_info", reinterpret_cast<getter>(PrintSupportPrinterSelectedEventArgs_get_SourceAppInfo), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportPrinterSelectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrinterSelectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrinterSelectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrinterSelectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrinterSelectedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintSupportPrinterSelectedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrinterSelectedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrinterSelectedEventArgs};

    // ----- PrintSupportSessionInfo class --------------------

    static PyObject* _new_PrintSupportSessionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportSessionInfo(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportSessionInfo_get_Printer(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSessionInfo", L"Printer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Printer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSessionInfo_get_SourceAppInfo(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSessionInfo", L"SourceAppInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceAppInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportSessionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportSessionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportSessionInfo[] = {
        { "_assign_array_", _assign_array_PrintSupportSessionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportSessionInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportSessionInfo[] = {
        { "printer", reinterpret_cast<getter>(PrintSupportSessionInfo_get_Printer), nullptr, nullptr, nullptr },
        { "source_app_info", reinterpret_cast<getter>(PrintSupportSessionInfo_get_SourceAppInfo), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportSessionInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportSessionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportSessionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportSessionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportSessionInfo) },
        { }};

    static PyType_Spec type_spec_PrintSupportSessionInfo = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportSessionInfo",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportSessionInfo};

    // ----- PrintSupportSettingsActivatedEventArgs class --------------------

    static PyObject* _new_PrintSupportSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportSettingsActivatedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_User(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_Session(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Session();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_OwnerWindowId(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"OwnerWindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OwnerWindowId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportSettingsActivatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportSettingsActivatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_Session), nullptr, nullptr, nullptr },
        { "owner_window_id", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_OwnerWindowId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintSupportSettingsActivatedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportSettingsActivatedEventArgs};

    // ----- PrintSupportSettingsUISession class --------------------

    static PyObject* _new_PrintSupportSettingsUISession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportSettingsUISession(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportSettingsUISession_UpdatePrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"UpdatePrintTicket", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTicket::WorkflowPrintTicket>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.UpdatePrintTicket(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsUISession_get_DocumentTitle(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"DocumentTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DocumentTitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsUISession_get_LaunchKind(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"LaunchKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LaunchKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsUISession_get_SessionInfo(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"SessionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SessionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsUISession_get_SessionPrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"SessionPrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SessionPrintTicket();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportSettingsUISession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportSettingsUISession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportSettingsUISession[] = {
        { "update_print_ticket", reinterpret_cast<PyCFunction>(PrintSupportSettingsUISession_UpdatePrintTicket), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportSettingsUISession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportSettingsUISession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintSupportSettingsUISession[] = {
        { "document_title", reinterpret_cast<getter>(PrintSupportSettingsUISession_get_DocumentTitle), nullptr, nullptr, nullptr },
        { "launch_kind", reinterpret_cast<getter>(PrintSupportSettingsUISession_get_LaunchKind), nullptr, nullptr, nullptr },
        { "session_info", reinterpret_cast<getter>(PrintSupportSettingsUISession_get_SessionInfo), nullptr, nullptr, nullptr },
        { "session_print_ticket", reinterpret_cast<getter>(PrintSupportSettingsUISession_get_SessionPrintTicket), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintSupportSettingsUISession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportSettingsUISession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportSettingsUISession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportSettingsUISession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportSettingsUISession) },
        { }};

    static PyType_Spec type_spec_PrintSupportSettingsUISession = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportSettingsUISession",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportSettingsUISession};

    // ----- Windows.Graphics.Printing.PrintSupport Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Graphics.Printing.PrintSupport");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_graphics_printing_printsupport",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Graphics::Printing::PrintSupport

PyMODINIT_FUNC PyInit__winrt_windows_graphics_printing_printsupport(void) noexcept
{
    using namespace py::cpp::Windows::Graphics::Printing::PrintSupport;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportCommunicationErrorDetectedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportCommunicationErrorDetectedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportCommunicationErrorDetectedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportExtensionSession_type{py::register_python_type(module.get(), &type_spec_PrintSupportExtensionSession, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportExtensionSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportExtensionTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PrintSupportExtensionTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportExtensionTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportIppCommunicationConfiguration_type{py::register_python_type(module.get(), &type_spec_PrintSupportIppCommunicationConfiguration, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportIppCommunicationConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportIppCommunicationTimeouts_type{py::register_python_type(module.get(), &type_spec_PrintSupportIppCommunicationTimeouts, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportIppCommunicationTimeouts_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportMxdcImageQualityConfiguration_type{py::register_python_type(module.get(), &type_spec_PrintSupportMxdcImageQualityConfiguration, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportMxdcImageQualityConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrintDeviceCapabilitiesChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrintDeviceCapabilitiesChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportPrintDeviceCapabilitiesChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static{PyType_FromSpecWithBases(&type_spec_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static, PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static_bases.get())};
    if (!type_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrintDeviceCapabilitiesUpdatePolicy_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrintDeviceCapabilitiesUpdatePolicy, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static.get()))};
    if (!PrintSupportPrintDeviceCapabilitiesUpdatePolicy_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrintTicketElement_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrintTicketElement, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportPrintTicketElement_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrintTicketValidationRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrintTicketValidationRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportPrintTicketValidationRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrinterSelectedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrinterSelectedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportPrinterSelectedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportSessionInfo_type{py::register_python_type(module.get(), &type_spec_PrintSupportSessionInfo, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportSessionInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportSettingsActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportSettingsUISession_type{py::register_python_type(module.get(), &type_spec_PrintSupportSettingsUISession, object_bases.get(), inspectable_meta_type)};
    if (!PrintSupportSettingsUISession_type)
    {
        return nullptr;
    }


    return module.detach();
}
