// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Media.SpeechRecognition.h"

namespace py::cpp::Windows::Media::SpeechRecognition
{
    // ----- SpeechContinuousRecognitionCompletedEventArgs class --------------------

    static PyObject* _new_SpeechContinuousRecognitionCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionCompletedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionCompletedEventArgs_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechContinuousRecognitionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechContinuousRecognitionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechContinuousRecognitionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(SpeechContinuousRecognitionCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechContinuousRecognitionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechContinuousRecognitionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechContinuousRecognitionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechContinuousRecognitionCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_SpeechContinuousRecognitionCompletedEventArgs = {
        "winrt._winrt_windows_media_speechrecognition.SpeechContinuousRecognitionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionCompletedEventArgs};

    // ----- SpeechContinuousRecognitionResultGeneratedEventArgs class --------------------

    static PyObject* _new_SpeechContinuousRecognitionResultGeneratedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechContinuousRecognitionResultGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechContinuousRecognitionResultGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechContinuousRecognitionResultGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionResultGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "result", reinterpret_cast<getter>(SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechContinuousRecognitionResultGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechContinuousRecognitionResultGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechContinuousRecognitionResultGeneratedEventArgs) },
        { }};

    static PyType_Spec type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs = {
        "winrt._winrt_windows_media_speechrecognition.SpeechContinuousRecognitionResultGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs};

    // ----- SpeechContinuousRecognitionSession class --------------------

    static PyObject* _new_SpeechContinuousRecognitionSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionSession_CancelAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"CancelAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CancelAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_PauseAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"PauseAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.PauseAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_Resume(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Resume", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Resume();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StartAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StartAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StartWithModeAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StartAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StopAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StopAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StopAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"AutoStopSilenceTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AutoStopSilenceTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"AutoStopSilenceTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.AutoStopSilenceTimeout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"ResultGenerated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResultGenerated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"ResultGenerated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ResultGenerated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechContinuousRecognitionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechContinuousRecognitionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionSession[] = {
        { "cancel_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_CancelAsync), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_PauseAsync), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_Resume), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StartAsync), METH_VARARGS, nullptr },
        { "start_with_mode_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StartWithModeAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StopAsync), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_remove_Completed), METH_O, nullptr },
        { "add_result_generated", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_add_ResultGenerated), METH_O, nullptr },
        { "remove_result_generated", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_remove_ResultGenerated), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpeechContinuousRecognitionSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechContinuousRecognitionSession[] = {
        { "auto_stop_silence_timeout", reinterpret_cast<getter>(SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout), reinterpret_cast<setter>(SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechContinuousRecognitionSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechContinuousRecognitionSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechContinuousRecognitionSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechContinuousRecognitionSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechContinuousRecognitionSession) },
        { }};

    static PyType_Spec type_spec_SpeechContinuousRecognitionSession = {
        "winrt._winrt_windows_media_speechrecognition.SpeechContinuousRecognitionSession",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionSession};

    // ----- SpeechRecognitionCompilationResult class --------------------

    static PyObject* _new_SpeechRecognitionCompilationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionCompilationResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionCompilationResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionCompilationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionCompilationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionCompilationResult[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionCompilationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionCompilationResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionCompilationResult[] = {
        { "status", reinterpret_cast<getter>(SpeechRecognitionCompilationResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionCompilationResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionCompilationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionCompilationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionCompilationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionCompilationResult) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionCompilationResult = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionCompilationResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionCompilationResult};

    // ----- SpeechRecognitionGrammarFileConstraint class --------------------

    static PyObject* _new_SpeechRecognitionGrammarFileConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionGrammarFileConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Probability();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            {
                auto _gil = release_gil();
                self->obj.Probability(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_GrammarFile(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"GrammarFile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GrammarFile();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionGrammarFileConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionGrammarFileConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionGrammarFileConstraint[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionGrammarFileConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionGrammarFileConstraint), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionGrammarFileConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Type), nullptr, nullptr, nullptr },
        { "grammar_file", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_GrammarFile), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionGrammarFileConstraint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionGrammarFileConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionGrammarFileConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionGrammarFileConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionGrammarFileConstraint) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionGrammarFileConstraint = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionGrammarFileConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionGrammarFileConstraint};

    // ----- SpeechRecognitionHypothesis class --------------------

    static PyObject* _new_SpeechRecognitionHypothesis(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionHypothesis_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionHypothesis", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionHypothesis(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionHypothesis(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesis[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionHypothesis, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionHypothesis), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionHypothesis[] = {
        { "text", reinterpret_cast<getter>(SpeechRecognitionHypothesis_get_Text), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionHypothesis[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionHypothesis) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionHypothesis) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionHypothesis) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionHypothesis) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionHypothesis = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionHypothesis",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesis};

    // ----- SpeechRecognitionHypothesisGeneratedEventArgs class --------------------

    static PyObject* _new_SpeechRecognitionHypothesisGeneratedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesisGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs", L"Hypothesis");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Hypothesis();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionHypothesisGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionHypothesisGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionHypothesisGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionHypothesisGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "hypothesis", reinterpret_cast<getter>(SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionHypothesisGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionHypothesisGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionHypothesisGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionHypothesisGeneratedEventArgs) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionHypothesisGeneratedEventArgs = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionHypothesisGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs};

    // ----- SpeechRecognitionListConstraint class --------------------

    static PyObject* _new_SpeechRecognitionListConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionListConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionListConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Probability();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            {
                auto _gil = release_gil();
                self->obj.Probability(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Commands(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Commands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Commands();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionListConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionListConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionListConstraint[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionListConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionListConstraint), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionListConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Type), nullptr, nullptr, nullptr },
        { "commands", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Commands), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionListConstraint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionListConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionListConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionListConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionListConstraint) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionListConstraint = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionListConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionListConstraint};

    // ----- SpeechRecognitionQualityDegradingEventArgs class --------------------

    static PyObject* _new_SpeechRecognitionQualityDegradingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionQualityDegradingEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionQualityDegradingEventArgs_get_Problem(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs", L"Problem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Problem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionQualityDegradingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionQualityDegradingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionQualityDegradingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionQualityDegradingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "problem", reinterpret_cast<getter>(SpeechRecognitionQualityDegradingEventArgs_get_Problem), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionQualityDegradingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionQualityDegradingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionQualityDegradingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionQualityDegradingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionQualityDegradingEventArgs) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionQualityDegradingEventArgs = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionQualityDegradingEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionQualityDegradingEventArgs};

    // ----- SpeechRecognitionResult class --------------------

    static PyObject* _new_SpeechRecognitionResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionResult_GetAlternates(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"GetAlternates", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAlternates(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Confidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Confidence");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Confidence();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Constraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Constraint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Constraint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RawConfidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"RawConfidence");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RawConfidence();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RulePath(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"RulePath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RulePath();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_SemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"SemanticInterpretation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SemanticInterpretation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseDuration(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"PhraseDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhraseDuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseStartTime(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"PhraseStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhraseStartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionResult[] = {
        { "get_alternates", reinterpret_cast<PyCFunction>(SpeechRecognitionResult_GetAlternates), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpeechRecognitionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionResult[] = {
        { "confidence", reinterpret_cast<getter>(SpeechRecognitionResult_get_Confidence), nullptr, nullptr, nullptr },
        { "constraint", reinterpret_cast<getter>(SpeechRecognitionResult_get_Constraint), nullptr, nullptr, nullptr },
        { "raw_confidence", reinterpret_cast<getter>(SpeechRecognitionResult_get_RawConfidence), nullptr, nullptr, nullptr },
        { "rule_path", reinterpret_cast<getter>(SpeechRecognitionResult_get_RulePath), nullptr, nullptr, nullptr },
        { "semantic_interpretation", reinterpret_cast<getter>(SpeechRecognitionResult_get_SemanticInterpretation), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SpeechRecognitionResult_get_Status), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(SpeechRecognitionResult_get_Text), nullptr, nullptr, nullptr },
        { "phrase_duration", reinterpret_cast<getter>(SpeechRecognitionResult_get_PhraseDuration), nullptr, nullptr, nullptr },
        { "phrase_start_time", reinterpret_cast<getter>(SpeechRecognitionResult_get_PhraseStartTime), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionResult) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionResult = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionResult};

    // ----- SpeechRecognitionSemanticInterpretation class --------------------

    static PyObject* _new_SpeechRecognitionSemanticInterpretation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionSemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionSemanticInterpretation_get_Properties(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionSemanticInterpretation", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionSemanticInterpretation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionSemanticInterpretation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionSemanticInterpretation[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionSemanticInterpretation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionSemanticInterpretation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionSemanticInterpretation[] = {
        { "properties", reinterpret_cast<getter>(SpeechRecognitionSemanticInterpretation_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionSemanticInterpretation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionSemanticInterpretation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionSemanticInterpretation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionSemanticInterpretation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionSemanticInterpretation) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionSemanticInterpretation = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionSemanticInterpretation",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionSemanticInterpretation};

    // ----- SpeechRecognitionTopicConstraint class --------------------

    static PyObject* _new_SpeechRecognitionTopicConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionTopicConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Probability();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            {
                auto _gil = release_gil();
                self->obj.Probability(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Scenario(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Scenario");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scenario();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_TopicHint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"TopicHint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TopicHint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionTopicConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionTopicConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionTopicConstraint[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionTopicConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionTopicConstraint), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionTopicConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Type), nullptr, nullptr, nullptr },
        { "scenario", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Scenario), nullptr, nullptr, nullptr },
        { "topic_hint", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_TopicHint), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionTopicConstraint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionTopicConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionTopicConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionTopicConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionTopicConstraint) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionTopicConstraint = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionTopicConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionTopicConstraint};

    // ----- SpeechRecognitionVoiceCommandDefinitionConstraint class --------------------

    static PyObject* _new_SpeechRecognitionVoiceCommandDefinitionConstraint(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Probability();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            {
                auto _gil = release_gil();
                self->obj.Probability(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionVoiceCommandDefinitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionVoiceCommandDefinitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionVoiceCommandDefinitionConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionVoiceCommandDefinitionConstraint), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionVoiceCommandDefinitionConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionVoiceCommandDefinitionConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionVoiceCommandDefinitionConstraint) },
        { }};

    static PyType_Spec type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionVoiceCommandDefinitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint};

    // ----- SpeechRecognizer class --------------------

    static PyObject* _new_SpeechRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizer_Close(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_CompileConstraintsAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"CompileConstraintsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CompileConstraintsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognizeAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RecognizeAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeWithUIAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognizeWithUIAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RecognizeWithUIAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_StopRecognitionAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StopRecognitionAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StopRecognitionAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_TrySetSystemSpeechLanguageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"TrySetSystemSpeechLanguageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::TrySetSystemSpeechLanguageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Constraints(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Constraints");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Constraints();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_CurrentLanguage(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"CurrentLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Timeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Timeouts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timeouts();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_UIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"UIOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UIOptions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_ContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"ContinuousRecognitionSession");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuousRecognitionSession();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedGrammarLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SupportedGrammarLanguages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedGrammarLanguages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedTopicLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SupportedTopicLanguages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedTopicLanguages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SystemSpeechLanguage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SystemSpeechLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SystemSpeechLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognitionQualityDegrading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RecognitionQualityDegrading(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognitionQualityDegrading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RecognitionQualityDegrading(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"HypothesisGenerated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HypothesisGenerated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"HypothesisGenerated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HypothesisGenerated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizer[] = {
        { "close", reinterpret_cast<PyCFunction>(SpeechRecognizer_Close), METH_VARARGS, nullptr },
        { "compile_constraints_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_CompileConstraintsAsync), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_RecognizeAsync), METH_VARARGS, nullptr },
        { "recognize_with_ui_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_RecognizeWithUIAsync), METH_VARARGS, nullptr },
        { "stop_recognition_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_StopRecognitionAsync), METH_VARARGS, nullptr },
        { "add_recognition_quality_degrading", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_RecognitionQualityDegrading), METH_O, nullptr },
        { "remove_recognition_quality_degrading", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_RecognitionQualityDegrading), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_StateChanged), METH_O, nullptr },
        { "add_hypothesis_generated", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_HypothesisGenerated), METH_O, nullptr },
        { "remove_hypothesis_generated", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_HypothesisGenerated), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpeechRecognizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SpeechRecognizer), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_SpeechRecognizer), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognizer[] = {
        { "constraints", reinterpret_cast<getter>(SpeechRecognizer_get_Constraints), nullptr, nullptr, nullptr },
        { "current_language", reinterpret_cast<getter>(SpeechRecognizer_get_CurrentLanguage), nullptr, nullptr, nullptr },
        { "timeouts", reinterpret_cast<getter>(SpeechRecognizer_get_Timeouts), nullptr, nullptr, nullptr },
        { "ui_options", reinterpret_cast<getter>(SpeechRecognizer_get_UIOptions), nullptr, nullptr, nullptr },
        { "continuous_recognition_session", reinterpret_cast<getter>(SpeechRecognizer_get_ContinuousRecognitionSession), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(SpeechRecognizer_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognizer) },
        { }};

    static PyType_Spec type_spec_SpeechRecognizer = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizer",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizer};

    static PyGetSetDef getset_SpeechRecognizer_Static[] = {
        { "supported_grammar_languages", reinterpret_cast<getter>(SpeechRecognizer_get_SupportedGrammarLanguages), nullptr, nullptr, nullptr },
        { "supported_topic_languages", reinterpret_cast<getter>(SpeechRecognizer_get_SupportedTopicLanguages), nullptr, nullptr, nullptr },
        { "system_speech_language", reinterpret_cast<getter>(SpeechRecognizer_get_SystemSpeechLanguage), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SpeechRecognizer_Static[] = {
        { "try_set_system_speech_language_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_TrySetSystemSpeechLanguageAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SpeechRecognizer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpeechRecognizer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpeechRecognizer_Static) },
        { }
    };

    static PyType_Spec type_spec_SpeechRecognizer_Static = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpeechRecognizer_Static};

    // ----- SpeechRecognizerStateChangedEventArgs class --------------------

    static PyObject* _new_SpeechRecognizerStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerStateChangedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerStateChangedEventArgs_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerStateChangedEventArgs", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognizerStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognizerStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechRecognizerStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognizerStateChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(SpeechRecognizerStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognizerStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognizerStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognizerStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognizerStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognizerStateChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_SpeechRecognizerStateChangedEventArgs = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizerStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerStateChangedEventArgs};

    // ----- SpeechRecognizerTimeouts class --------------------

    static PyObject* _new_SpeechRecognizerTimeouts(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerTimeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerTimeouts_get_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"InitialSilenceTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InitialSilenceTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"InitialSilenceTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.InitialSilenceTimeout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"EndSilenceTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndSilenceTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"EndSilenceTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.EndSilenceTimeout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"BabbleTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BabbleTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"BabbleTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.BabbleTimeout(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpeechRecognizerTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognizerTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerTimeouts[] = {
        { "_assign_array_", _assign_array_SpeechRecognizerTimeouts, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerTimeouts), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognizerTimeouts[] = {
        { "initial_silence_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_InitialSilenceTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_InitialSilenceTimeout), nullptr, nullptr },
        { "end_silence_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_EndSilenceTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_EndSilenceTimeout), nullptr, nullptr },
        { "babble_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_BabbleTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_BabbleTimeout), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognizerTimeouts[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognizerTimeouts) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognizerTimeouts) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognizerTimeouts) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognizerTimeouts) },
        { }};

    static PyType_Spec type_spec_SpeechRecognizerTimeouts = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizerTimeouts",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerTimeouts};

    // ----- SpeechRecognizerUIOptions class --------------------

    static PyObject* _new_SpeechRecognizerUIOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerUIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerUIOptions_get_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ShowConfirmation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowConfirmation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ShowConfirmation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowConfirmation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"IsReadBackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsReadBackEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"IsReadBackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsReadBackEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ExampleText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExampleText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ExampleText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExampleText(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"AudiblePrompt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AudiblePrompt();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"AudiblePrompt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.AudiblePrompt(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpeechRecognizerUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognizerUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerUIOptions[] = {
        { "_assign_array_", _assign_array_SpeechRecognizerUIOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerUIOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SpeechRecognizerUIOptions[] = {
        { "show_confirmation", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_ShowConfirmation), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_ShowConfirmation), nullptr, nullptr },
        { "is_read_back_enabled", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_IsReadBackEnabled), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_IsReadBackEnabled), nullptr, nullptr },
        { "example_text", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_ExampleText), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_ExampleText), nullptr, nullptr },
        { "audible_prompt", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_AudiblePrompt), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_AudiblePrompt), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SpeechRecognizerUIOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognizerUIOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognizerUIOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognizerUIOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognizerUIOptions) },
        { }};

    static PyType_Spec type_spec_SpeechRecognizerUIOptions = {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizerUIOptions",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerUIOptions};

    // ----- ISpeechRecognitionConstraint interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ISpeechRecognitionConstraint(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ISpeechRecognitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISpeechRecognitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Probability();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Probability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            {
                auto _gil = release_gil();
                self->obj.Probability(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpeechRecognitionConstraint[] = {
        { }};

    static PyGetSetDef _getset_ISpeechRecognitionConstraint[] = {
        { "is_enabled", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_IsEnabled), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_IsEnabled), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Probability), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_Probability), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Tag), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_Tag), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISpeechRecognitionConstraint[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ISpeechRecognitionConstraint) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISpeechRecognitionConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISpeechRecognitionConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISpeechRecognitionConstraint) },
        { }};

    static PyType_Spec type_spec_ISpeechRecognitionConstraint = {
        "winrt._winrt_windows_media_speechrecognition._ISpeechRecognitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ISpeechRecognitionConstraint};

    struct ImplementsISpeechRecognitionConstraint : py::ImplementsInterfaceT<ImplementsISpeechRecognitionConstraint, winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>
    {
        ImplementsISpeechRecognitionConstraint() = delete;
        ImplementsISpeechRecognitionConstraint(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISpeechRecognitionConstraint, winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>(py_obj, runtime_class)
        {
        }

        auto IsEnabled()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_enabled")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void IsEnabled(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "is_enabled", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Probability()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "probability")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Probability(winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "probability", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Tag()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "tag")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Tag(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "tag", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Type()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISpeechRecognitionConstraint>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISpeechRecognitionConstraint[] = {
        { "_assign_array_", _assign_array_ISpeechRecognitionConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISpeechRecognitionConstraint), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISpeechRecognitionConstraint), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISpeechRecognitionConstraint), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISpeechRecognitionConstraint[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISpeechRecognitionConstraint) },
        { }};

    static PyType_Spec type_spec_ImplementsISpeechRecognitionConstraint = {
        "winrt._winrt_windows_media_speechrecognition.ISpeechRecognitionConstraint",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsISpeechRecognitionConstraint};

    // ----- Windows.Media.SpeechRecognition Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.SpeechRecognition");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_speechrecognition",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::SpeechRecognition

PyMODINIT_FUNC PyInit__winrt_windows_media_speechrecognition(void) noexcept
{
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle SpeechContinuousRecognitionCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpeechContinuousRecognitionCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SpeechContinuousRecognitionCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechContinuousRecognitionResultGeneratedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SpeechContinuousRecognitionResultGeneratedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechContinuousRecognitionSession_type{py::register_python_type(module.get(), &type_spec_SpeechContinuousRecognitionSession, object_bases.get(), inspectable_meta_type)};
    if (!SpeechContinuousRecognitionSession_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionCompilationResult_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionCompilationResult, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionCompilationResult_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionGrammarFileConstraint_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionGrammarFileConstraint, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionGrammarFileConstraint_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionHypothesis_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionHypothesis, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionHypothesis_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionHypothesisGeneratedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionHypothesisGeneratedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionHypothesisGeneratedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionListConstraint_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionListConstraint, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionListConstraint_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionQualityDegradingEventArgs_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionQualityDegradingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionQualityDegradingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionResult_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionResult, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionResult_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionSemanticInterpretation_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionSemanticInterpretation, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionSemanticInterpretation_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionTopicConstraint_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionTopicConstraint, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionTopicConstraint_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognitionVoiceCommandDefinitionConstraint_type{py::register_python_type(module.get(), &type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognitionVoiceCommandDefinitionConstraint_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpeechRecognizer_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SpeechRecognizer_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpeechRecognizer_Static{PyType_FromSpecWithBases(&type_spec_SpeechRecognizer_Static, SpeechRecognizer_Static_bases.get())};
    if (!type_SpeechRecognizer_Static)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognizer_type{py::register_python_type(module.get(), &type_spec_SpeechRecognizer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpeechRecognizer_Static.get()))};
    if (!SpeechRecognizer_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognizerStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpeechRecognizerStateChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognizerStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognizerTimeouts_type{py::register_python_type(module.get(), &type_spec_SpeechRecognizerTimeouts, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognizerTimeouts_type)
    {
        return nullptr;
    }

    py::pytype_handle SpeechRecognizerUIOptions_type{py::register_python_type(module.get(), &type_spec_SpeechRecognizerUIOptions, object_bases.get(), inspectable_meta_type)};
    if (!SpeechRecognizerUIOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle ISpeechRecognitionConstraint_type{py::register_python_type(module.get(), &type_spec_ISpeechRecognitionConstraint, object_bases.get(), nullptr)};
    if (!ISpeechRecognitionConstraint_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISpeechRecognitionConstraint_type{py::register_python_type(module.get(), &type_spec_ImplementsISpeechRecognitionConstraint, nullptr, inspectable_meta_type)};
    if (!ImplementsISpeechRecognitionConstraint_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISpeechRecognitionConstraint_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
