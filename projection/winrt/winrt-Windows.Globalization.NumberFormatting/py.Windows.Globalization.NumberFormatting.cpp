// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.1.0

#include "py.Windows.Globalization.NumberFormatting.h"

namespace py::cpp::Windows::Globalization::NumberFormatting
{
    // ----- CurrencyFormatter class --------------------

    static PyObject* _new_CurrencyFormatter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Globalization::NumberFormatting::CurrencyFormatter instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Globalization::NumberFormatting::CurrencyFormatter instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CurrencyFormatter(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CurrencyFormatter_ApplyRoundingForCurrency(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ApplyRoundingForCurrency", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::RoundingAlgorithm>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ApplyRoundingForCurrency(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ParseDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ParseInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ParseUInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseUInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_Currency(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Currency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Currency();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_Currency(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Currency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Currency(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_Mode(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Mode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_Mode(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::CurrencyFormatterMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.Mode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumeralSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumeralSystem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGrouped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsGrouped(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDecimalPointAlwaysDisplayed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsDecimalPointAlwaysDisplayed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IntegerDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.IntegerDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FractionDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.FractionDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"GeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ResolvedGeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedGeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ResolvedLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Languages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Languages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumberRounder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumberRounder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsZeroSigned();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsZeroSigned(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SignificantDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.SignificantDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CurrencyFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::CurrencyFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CurrencyFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::CurrencyFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrencyFormatter[] = {
        { "apply_rounding_for_currency", reinterpret_cast<PyCFunction>(CurrencyFormatter_ApplyRoundingForCurrency), METH_VARARGS, nullptr },
        { "format_double", reinterpret_cast<PyCFunction>(CurrencyFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(CurrencyFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(CurrencyFormatter_FormatUInt), METH_VARARGS, nullptr },
        { "parse_double", reinterpret_cast<PyCFunction>(CurrencyFormatter_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(CurrencyFormatter_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(CurrencyFormatter_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CurrencyFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrencyFormatter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CurrencyFormatter[] = {
        { "currency", reinterpret_cast<getter>(CurrencyFormatter_get_Currency), reinterpret_cast<setter>(CurrencyFormatter_put_Currency), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(CurrencyFormatter_get_Mode), reinterpret_cast<setter>(CurrencyFormatter_put_Mode), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(CurrencyFormatter_get_NumeralSystem), reinterpret_cast<setter>(CurrencyFormatter_put_NumeralSystem), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(CurrencyFormatter_get_IsGrouped), reinterpret_cast<setter>(CurrencyFormatter_put_IsGrouped), nullptr, nullptr },
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(CurrencyFormatter_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(CurrencyFormatter_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(CurrencyFormatter_get_IntegerDigits), reinterpret_cast<setter>(CurrencyFormatter_put_IntegerDigits), nullptr, nullptr },
        { "fraction_digits", reinterpret_cast<getter>(CurrencyFormatter_get_FractionDigits), reinterpret_cast<setter>(CurrencyFormatter_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(CurrencyFormatter_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(CurrencyFormatter_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(CurrencyFormatter_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(CurrencyFormatter_get_Languages), nullptr, nullptr, nullptr },
        { "number_rounder", reinterpret_cast<getter>(CurrencyFormatter_get_NumberRounder), reinterpret_cast<setter>(CurrencyFormatter_put_NumberRounder), nullptr, nullptr },
        { "is_zero_signed", reinterpret_cast<getter>(CurrencyFormatter_get_IsZeroSigned), reinterpret_cast<setter>(CurrencyFormatter_put_IsZeroSigned), nullptr, nullptr },
        { "significant_digits", reinterpret_cast<getter>(CurrencyFormatter_get_SignificantDigits), reinterpret_cast<setter>(CurrencyFormatter_put_SignificantDigits), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CurrencyFormatter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrencyFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CurrencyFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrencyFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrencyFormatter) },
        { }};

    static PyType_Spec type_spec_CurrencyFormatter = {
        "winrt._winrt_windows_globalization_numberformatting.CurrencyFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrencyFormatter};

    // ----- DecimalFormatter class --------------------

    static PyObject* _new_DecimalFormatter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Globalization::NumberFormatting::DecimalFormatter instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::DecimalFormatter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DecimalFormatter(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DecimalFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ParseDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ParseInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ParseUInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseUInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDecimalPointAlwaysDisplayed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsDecimalPointAlwaysDisplayed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IntegerDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.IntegerDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGrouped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsGrouped(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumeralSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumeralSystem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FractionDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.FractionDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"GeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"Languages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Languages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ResolvedGeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedGeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ResolvedLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumberRounder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumberRounder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsZeroSigned();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsZeroSigned(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SignificantDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.SignificantDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DecimalFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::DecimalFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DecimalFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::DecimalFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DecimalFormatter[] = {
        { "format_double", reinterpret_cast<PyCFunction>(DecimalFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(DecimalFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(DecimalFormatter_FormatUInt), METH_VARARGS, nullptr },
        { "parse_double", reinterpret_cast<PyCFunction>(DecimalFormatter_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(DecimalFormatter_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(DecimalFormatter_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DecimalFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DecimalFormatter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DecimalFormatter[] = {
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(DecimalFormatter_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(DecimalFormatter_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(DecimalFormatter_get_IntegerDigits), reinterpret_cast<setter>(DecimalFormatter_put_IntegerDigits), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(DecimalFormatter_get_IsGrouped), reinterpret_cast<setter>(DecimalFormatter_put_IsGrouped), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(DecimalFormatter_get_NumeralSystem), reinterpret_cast<setter>(DecimalFormatter_put_NumeralSystem), nullptr, nullptr },
        { "fraction_digits", reinterpret_cast<getter>(DecimalFormatter_get_FractionDigits), reinterpret_cast<setter>(DecimalFormatter_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(DecimalFormatter_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(DecimalFormatter_get_Languages), nullptr, nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(DecimalFormatter_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(DecimalFormatter_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "number_rounder", reinterpret_cast<getter>(DecimalFormatter_get_NumberRounder), reinterpret_cast<setter>(DecimalFormatter_put_NumberRounder), nullptr, nullptr },
        { "is_zero_signed", reinterpret_cast<getter>(DecimalFormatter_get_IsZeroSigned), reinterpret_cast<setter>(DecimalFormatter_put_IsZeroSigned), nullptr, nullptr },
        { "significant_digits", reinterpret_cast<getter>(DecimalFormatter_get_SignificantDigits), reinterpret_cast<setter>(DecimalFormatter_put_SignificantDigits), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DecimalFormatter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DecimalFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DecimalFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DecimalFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DecimalFormatter) },
        { }};

    static PyType_Spec type_spec_DecimalFormatter = {
        "winrt._winrt_windows_globalization_numberformatting.DecimalFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DecimalFormatter};

    // ----- IncrementNumberRounder class --------------------

    static PyObject* _new_IncrementNumberRounder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::IncrementNumberRounder instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IncrementNumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IncrementNumberRounder_RoundDouble(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundInt32(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundInt32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundInt32(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundInt64(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundInt64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundInt64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundSingle(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundSingle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundSingle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundUInt32(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundUInt32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundUInt32(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundUInt64(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundUInt64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundUInt64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_get_RoundingAlgorithm(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundingAlgorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoundingAlgorithm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IncrementNumberRounder_put_RoundingAlgorithm(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundingAlgorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::RoundingAlgorithm>(arg);

            {
                auto _gil = release_gil();
                self->obj.RoundingAlgorithm(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IncrementNumberRounder_get_Increment(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"Increment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Increment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IncrementNumberRounder_put_Increment(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"Increment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Increment(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IncrementNumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::IncrementNumberRounder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IncrementNumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::IncrementNumberRounder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IncrementNumberRounder[] = {
        { "round_double", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundDouble), METH_VARARGS, nullptr },
        { "round_int32", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundInt32), METH_VARARGS, nullptr },
        { "round_int64", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundInt64), METH_VARARGS, nullptr },
        { "round_single", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundSingle), METH_VARARGS, nullptr },
        { "round_uint32", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundUInt32), METH_VARARGS, nullptr },
        { "round_uint64", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IncrementNumberRounder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IncrementNumberRounder), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IncrementNumberRounder[] = {
        { "rounding_algorithm", reinterpret_cast<getter>(IncrementNumberRounder_get_RoundingAlgorithm), reinterpret_cast<setter>(IncrementNumberRounder_put_RoundingAlgorithm), nullptr, nullptr },
        { "increment", reinterpret_cast<getter>(IncrementNumberRounder_get_Increment), reinterpret_cast<setter>(IncrementNumberRounder_put_Increment), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IncrementNumberRounder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IncrementNumberRounder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IncrementNumberRounder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IncrementNumberRounder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IncrementNumberRounder) },
        { }};

    static PyType_Spec type_spec_IncrementNumberRounder = {
        "winrt._winrt_windows_globalization_numberformatting.IncrementNumberRounder",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IncrementNumberRounder};

    // ----- NumeralSystemTranslator class --------------------

    static PyObject* _new_NumeralSystemTranslator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::Globalization::NumberFormatting::NumeralSystemTranslator instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::NumeralSystemTranslator instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NumeralSystemTranslator(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NumeralSystemTranslator_TranslateNumerals(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"TranslateNumerals", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TranslateNumerals(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NumeralSystemTranslator_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumeralSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumeralSystemTranslator_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumeralSystem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumeralSystemTranslator_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"Languages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Languages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemTranslator_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"ResolvedLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NumeralSystemTranslator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::NumeralSystemTranslator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NumeralSystemTranslator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::NumeralSystemTranslator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NumeralSystemTranslator[] = {
        { "translate_numerals", reinterpret_cast<PyCFunction>(NumeralSystemTranslator_TranslateNumerals), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NumeralSystemTranslator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NumeralSystemTranslator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NumeralSystemTranslator[] = {
        { "numeral_system", reinterpret_cast<getter>(NumeralSystemTranslator_get_NumeralSystem), reinterpret_cast<setter>(NumeralSystemTranslator_put_NumeralSystem), nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(NumeralSystemTranslator_get_Languages), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(NumeralSystemTranslator_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NumeralSystemTranslator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NumeralSystemTranslator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NumeralSystemTranslator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NumeralSystemTranslator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NumeralSystemTranslator) },
        { }};

    static PyType_Spec type_spec_NumeralSystemTranslator = {
        "winrt._winrt_windows_globalization_numberformatting.NumeralSystemTranslator",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NumeralSystemTranslator};

    // ----- PercentFormatter class --------------------

    static PyObject* _new_PercentFormatter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Globalization::NumberFormatting::PercentFormatter instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::PercentFormatter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PercentFormatter(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PercentFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ParseDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ParseInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ParseUInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseUInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDecimalPointAlwaysDisplayed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsDecimalPointAlwaysDisplayed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IntegerDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.IntegerDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGrouped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsGrouped(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumeralSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumeralSystem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FractionDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.FractionDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"GeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"Languages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Languages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ResolvedGeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedGeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ResolvedLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumberRounder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumberRounder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsZeroSigned();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsZeroSigned(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SignificantDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.SignificantDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PercentFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::PercentFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PercentFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::PercentFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PercentFormatter[] = {
        { "format_double", reinterpret_cast<PyCFunction>(PercentFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(PercentFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(PercentFormatter_FormatUInt), METH_VARARGS, nullptr },
        { "parse_double", reinterpret_cast<PyCFunction>(PercentFormatter_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(PercentFormatter_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(PercentFormatter_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PercentFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PercentFormatter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PercentFormatter[] = {
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(PercentFormatter_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(PercentFormatter_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(PercentFormatter_get_IntegerDigits), reinterpret_cast<setter>(PercentFormatter_put_IntegerDigits), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(PercentFormatter_get_IsGrouped), reinterpret_cast<setter>(PercentFormatter_put_IsGrouped), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(PercentFormatter_get_NumeralSystem), reinterpret_cast<setter>(PercentFormatter_put_NumeralSystem), nullptr, nullptr },
        { "fraction_digits", reinterpret_cast<getter>(PercentFormatter_get_FractionDigits), reinterpret_cast<setter>(PercentFormatter_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(PercentFormatter_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(PercentFormatter_get_Languages), nullptr, nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(PercentFormatter_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(PercentFormatter_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "number_rounder", reinterpret_cast<getter>(PercentFormatter_get_NumberRounder), reinterpret_cast<setter>(PercentFormatter_put_NumberRounder), nullptr, nullptr },
        { "is_zero_signed", reinterpret_cast<getter>(PercentFormatter_get_IsZeroSigned), reinterpret_cast<setter>(PercentFormatter_put_IsZeroSigned), nullptr, nullptr },
        { "significant_digits", reinterpret_cast<getter>(PercentFormatter_get_SignificantDigits), reinterpret_cast<setter>(PercentFormatter_put_SignificantDigits), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PercentFormatter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PercentFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PercentFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PercentFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PercentFormatter) },
        { }};

    static PyType_Spec type_spec_PercentFormatter = {
        "winrt._winrt_windows_globalization_numberformatting.PercentFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PercentFormatter};

    // ----- PermilleFormatter class --------------------

    static PyObject* _new_PermilleFormatter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Globalization::NumberFormatting::PermilleFormatter instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::PermilleFormatter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PermilleFormatter(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PermilleFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ParseDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ParseInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ParseUInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseUInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDecimalPointAlwaysDisplayed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsDecimalPointAlwaysDisplayed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IntegerDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.IntegerDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGrouped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsGrouped(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumeralSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumeralSystem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FractionDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.FractionDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"GeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"Languages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Languages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ResolvedGeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedGeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ResolvedLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumberRounder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumberRounder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsZeroSigned();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsZeroSigned(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SignificantDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.SignificantDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PermilleFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::PermilleFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PermilleFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::PermilleFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PermilleFormatter[] = {
        { "format_double", reinterpret_cast<PyCFunction>(PermilleFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(PermilleFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(PermilleFormatter_FormatUInt), METH_VARARGS, nullptr },
        { "parse_double", reinterpret_cast<PyCFunction>(PermilleFormatter_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(PermilleFormatter_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(PermilleFormatter_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PermilleFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PermilleFormatter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PermilleFormatter[] = {
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(PermilleFormatter_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(PermilleFormatter_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(PermilleFormatter_get_IntegerDigits), reinterpret_cast<setter>(PermilleFormatter_put_IntegerDigits), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(PermilleFormatter_get_IsGrouped), reinterpret_cast<setter>(PermilleFormatter_put_IsGrouped), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(PermilleFormatter_get_NumeralSystem), reinterpret_cast<setter>(PermilleFormatter_put_NumeralSystem), nullptr, nullptr },
        { "fraction_digits", reinterpret_cast<getter>(PermilleFormatter_get_FractionDigits), reinterpret_cast<setter>(PermilleFormatter_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(PermilleFormatter_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(PermilleFormatter_get_Languages), nullptr, nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(PermilleFormatter_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(PermilleFormatter_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "number_rounder", reinterpret_cast<getter>(PermilleFormatter_get_NumberRounder), reinterpret_cast<setter>(PermilleFormatter_put_NumberRounder), nullptr, nullptr },
        { "is_zero_signed", reinterpret_cast<getter>(PermilleFormatter_get_IsZeroSigned), reinterpret_cast<setter>(PermilleFormatter_put_IsZeroSigned), nullptr, nullptr },
        { "significant_digits", reinterpret_cast<getter>(PermilleFormatter_get_SignificantDigits), reinterpret_cast<setter>(PermilleFormatter_put_SignificantDigits), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PermilleFormatter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PermilleFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PermilleFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PermilleFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PermilleFormatter) },
        { }};

    static PyType_Spec type_spec_PermilleFormatter = {
        "winrt._winrt_windows_globalization_numberformatting.PermilleFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PermilleFormatter};

    // ----- SignificantDigitsNumberRounder class --------------------

    static PyObject* _new_SignificantDigitsNumberRounder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SignificantDigitsNumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SignificantDigitsNumberRounder_RoundDouble(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundInt32(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundInt32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundInt32(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundInt64(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundInt64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundInt64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundSingle(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundSingle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundSingle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundUInt32(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundUInt32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundUInt32(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundUInt64(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundUInt64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundUInt64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SignificantDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SignificantDigitsNumberRounder_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.SignificantDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_get_RoundingAlgorithm(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundingAlgorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoundingAlgorithm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SignificantDigitsNumberRounder_put_RoundingAlgorithm(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundingAlgorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::RoundingAlgorithm>(arg);

            {
                auto _gil = release_gil();
                self->obj.RoundingAlgorithm(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SignificantDigitsNumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SignificantDigitsNumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SignificantDigitsNumberRounder[] = {
        { "round_double", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundDouble), METH_VARARGS, nullptr },
        { "round_int32", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundInt32), METH_VARARGS, nullptr },
        { "round_int64", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundInt64), METH_VARARGS, nullptr },
        { "round_single", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundSingle), METH_VARARGS, nullptr },
        { "round_uint32", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundUInt32), METH_VARARGS, nullptr },
        { "round_uint64", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SignificantDigitsNumberRounder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SignificantDigitsNumberRounder), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SignificantDigitsNumberRounder[] = {
        { "significant_digits", reinterpret_cast<getter>(SignificantDigitsNumberRounder_get_SignificantDigits), reinterpret_cast<setter>(SignificantDigitsNumberRounder_put_SignificantDigits), nullptr, nullptr },
        { "rounding_algorithm", reinterpret_cast<getter>(SignificantDigitsNumberRounder_get_RoundingAlgorithm), reinterpret_cast<setter>(SignificantDigitsNumberRounder_put_RoundingAlgorithm), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SignificantDigitsNumberRounder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SignificantDigitsNumberRounder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SignificantDigitsNumberRounder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SignificantDigitsNumberRounder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SignificantDigitsNumberRounder) },
        { }};

    static PyType_Spec type_spec_SignificantDigitsNumberRounder = {
        "winrt._winrt_windows_globalization_numberformatting.SignificantDigitsNumberRounder",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SignificantDigitsNumberRounder};

    // ----- INumberFormatter interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_INumberFormatter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_INumberFormatter(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter", L"Format", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Format(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberFormatter[] = {
        { "format_double", reinterpret_cast<PyCFunction>(INumberFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(INumberFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(INumberFormatter_FormatUInt), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INumberFormatter[] = {
        { }};

    static PyType_Slot _type_slots_INumberFormatter[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberFormatter) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberFormatter) },
        { }};

    static PyType_Spec type_spec_INumberFormatter = {
        "winrt._winrt_windows_globalization_numberformatting._INumberFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_INumberFormatter};

    struct ImplementsINumberFormatter : py::ImplementsInterfaceT<ImplementsINumberFormatter, winrt::Windows::Globalization::NumberFormatting::INumberFormatter>
    {
        ImplementsINumberFormatter() = delete;
        ImplementsINumberFormatter(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINumberFormatter, winrt::Windows::Globalization::NumberFormatting::INumberFormatter>(py_obj, runtime_class)
        {
        }

        auto Format(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "format_double")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Format(int64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "format_int")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Format(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "format_uint")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INumberFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINumberFormatter(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINumberFormatter(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINumberFormatter>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINumberFormatter[] = {
        { "_assign_array_", _assign_array_INumberFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberFormatter), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINumberFormatter), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINumberFormatter), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINumberFormatter[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINumberFormatter) },
        { }};

    static PyType_Spec type_spec_ImplementsINumberFormatter = {
        "winrt._winrt_windows_globalization_numberformatting.INumberFormatter",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsINumberFormatter};

    // ----- INumberFormatter2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_INumberFormatter2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_INumberFormatter2(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberFormatter2_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter2", L"FormatDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FormatDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberFormatter2_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter2", L"FormatInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FormatInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberFormatter2_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter2", L"FormatUInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FormatUInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberFormatter2[] = {
        { "format_double", reinterpret_cast<PyCFunction>(INumberFormatter2_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(INumberFormatter2_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(INumberFormatter2_FormatUInt), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INumberFormatter2[] = {
        { }};

    static PyType_Slot _type_slots_INumberFormatter2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberFormatter2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberFormatter2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberFormatter2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberFormatter2) },
        { }};

    static PyType_Spec type_spec_INumberFormatter2 = {
        "winrt._winrt_windows_globalization_numberformatting._INumberFormatter2",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_INumberFormatter2};

    struct ImplementsINumberFormatter2 : py::ImplementsInterfaceT<ImplementsINumberFormatter2, winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>
    {
        ImplementsINumberFormatter2() = delete;
        ImplementsINumberFormatter2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINumberFormatter2, winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>(py_obj, runtime_class)
        {
        }

        auto FormatDouble(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "format_double")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FormatInt(int64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "format_int")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FormatUInt(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "format_uint")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INumberFormatter2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberFormatter2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINumberFormatter2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINumberFormatter2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINumberFormatter2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINumberFormatter2[] = {
        { "_assign_array_", _assign_array_INumberFormatter2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberFormatter2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINumberFormatter2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINumberFormatter2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINumberFormatter2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINumberFormatter2) },
        { }};

    static PyType_Spec type_spec_ImplementsINumberFormatter2 = {
        "winrt._winrt_windows_globalization_numberformatting.INumberFormatter2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsINumberFormatter2};

    // ----- INumberFormatterOptions interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_INumberFormatterOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_INumberFormatterOptions(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberFormatterOptions_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FractionDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"FractionDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.FractionDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"GeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INumberFormatterOptions_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IntegerDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IntegerDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.IntegerDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDecimalPointAlwaysDisplayed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IsDecimalPointAlwaysDisplayed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsDecimalPointAlwaysDisplayed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGrouped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsGrouped(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"Languages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Languages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INumberFormatterOptions_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumeralSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"NumeralSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumeralSystem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"ResolvedGeographicRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedGeographicRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INumberFormatterOptions_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"ResolvedLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResolvedLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberFormatterOptions[] = {
        { }};

    static PyGetSetDef _getset_INumberFormatterOptions[] = {
        { "fraction_digits", reinterpret_cast<getter>(INumberFormatterOptions_get_FractionDigits), reinterpret_cast<setter>(INumberFormatterOptions_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(INumberFormatterOptions_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(INumberFormatterOptions_get_IntegerDigits), reinterpret_cast<setter>(INumberFormatterOptions_put_IntegerDigits), nullptr, nullptr },
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(INumberFormatterOptions_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(INumberFormatterOptions_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(INumberFormatterOptions_get_IsGrouped), reinterpret_cast<setter>(INumberFormatterOptions_put_IsGrouped), nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(INumberFormatterOptions_get_Languages), nullptr, nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(INumberFormatterOptions_get_NumeralSystem), reinterpret_cast<setter>(INumberFormatterOptions_put_NumeralSystem), nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(INumberFormatterOptions_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(INumberFormatterOptions_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INumberFormatterOptions[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberFormatterOptions) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberFormatterOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberFormatterOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberFormatterOptions) },
        { }};

    static PyType_Spec type_spec_INumberFormatterOptions = {
        "winrt._winrt_windows_globalization_numberformatting._INumberFormatterOptions",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_INumberFormatterOptions};

    struct ImplementsINumberFormatterOptions : py::ImplementsInterfaceT<ImplementsINumberFormatterOptions, winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>
    {
        ImplementsINumberFormatterOptions() = delete;
        ImplementsINumberFormatterOptions(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINumberFormatterOptions, winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>(py_obj, runtime_class)
        {
        }

        auto FractionDigits()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "fraction_digits")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void FractionDigits(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "fraction_digits", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GeographicRegion()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "geographic_region")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IntegerDigits()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "integer_digits")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void IntegerDigits(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "integer_digits", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsDecimalPointAlwaysDisplayed()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_decimal_point_always_displayed")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void IsDecimalPointAlwaysDisplayed(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "is_decimal_point_always_displayed", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsGrouped()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_grouped")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void IsGrouped(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "is_grouped", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Languages()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "languages")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto NumeralSystem()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "numeral_system")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void NumeralSystem(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "numeral_system", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ResolvedGeographicRegion()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "resolved_geographic_region")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ResolvedLanguage()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "resolved_language")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INumberFormatterOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberFormatterOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINumberFormatterOptions(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINumberFormatterOptions(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINumberFormatterOptions>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINumberFormatterOptions[] = {
        { "_assign_array_", _assign_array_INumberFormatterOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberFormatterOptions), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINumberFormatterOptions), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINumberFormatterOptions), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINumberFormatterOptions[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINumberFormatterOptions) },
        { }};

    static PyType_Spec type_spec_ImplementsINumberFormatterOptions = {
        "winrt._winrt_windows_globalization_numberformatting.INumberFormatterOptions",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsINumberFormatterOptions};

    // ----- INumberParser interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_INumberParser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberParser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberParser>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_INumberParser(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberParser_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberParser", L"ParseDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberParser_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberParser", L"ParseInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberParser_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberParser", L"ParseUInt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ParseUInt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberParser[] = {
        { "parse_double", reinterpret_cast<PyCFunction>(INumberParser_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(INumberParser_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(INumberParser_ParseUInt), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INumberParser[] = {
        { }};

    static PyType_Slot _type_slots_INumberParser[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberParser) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberParser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberParser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberParser) },
        { }};

    static PyType_Spec type_spec_INumberParser = {
        "winrt._winrt_windows_globalization_numberformatting._INumberParser",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_INumberParser};

    struct ImplementsINumberParser : py::ImplementsInterfaceT<ImplementsINumberParser, winrt::Windows::Globalization::NumberFormatting::INumberParser>
    {
        ImplementsINumberParser() = delete;
        ImplementsINumberParser(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINumberParser, winrt::Windows::Globalization::NumberFormatting::INumberParser>(py_obj, runtime_class)
        {
        }

        auto ParseDouble(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "parse_double")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IReference<double>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ParseInt(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "parse_int")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IReference<int64_t>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ParseUInt(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "parse_uint")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INumberParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberParser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberParser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINumberParser(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Globalization::NumberFormatting::INumberParser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINumberParser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINumberParser>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINumberParser[] = {
        { "_assign_array_", _assign_array_INumberParser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberParser), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINumberParser), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINumberParser), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINumberParser[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINumberParser) },
        { }};

    static PyType_Spec type_spec_ImplementsINumberParser = {
        "winrt._winrt_windows_globalization_numberformatting.INumberParser",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsINumberParser};

    // ----- INumberRounder interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_INumberRounder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberRounder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberRounder>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_INumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberRounder_RoundDouble(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundInt32(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundInt32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundInt32(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundInt64(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundInt64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundInt64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundSingle(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundSingle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundSingle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundUInt32(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundUInt32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundUInt32(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundUInt64(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundUInt64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RoundUInt64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberRounder[] = {
        { "round_double", reinterpret_cast<PyCFunction>(INumberRounder_RoundDouble), METH_VARARGS, nullptr },
        { "round_int32", reinterpret_cast<PyCFunction>(INumberRounder_RoundInt32), METH_VARARGS, nullptr },
        { "round_int64", reinterpret_cast<PyCFunction>(INumberRounder_RoundInt64), METH_VARARGS, nullptr },
        { "round_single", reinterpret_cast<PyCFunction>(INumberRounder_RoundSingle), METH_VARARGS, nullptr },
        { "round_uint32", reinterpret_cast<PyCFunction>(INumberRounder_RoundUInt32), METH_VARARGS, nullptr },
        { "round_uint64", reinterpret_cast<PyCFunction>(INumberRounder_RoundUInt64), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INumberRounder[] = {
        { }};

    static PyType_Slot _type_slots_INumberRounder[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberRounder) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberRounder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberRounder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberRounder) },
        { }};

    static PyType_Spec type_spec_INumberRounder = {
        "winrt._winrt_windows_globalization_numberformatting._INumberRounder",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_INumberRounder};

    struct ImplementsINumberRounder : py::ImplementsInterfaceT<ImplementsINumberRounder, winrt::Windows::Globalization::NumberFormatting::INumberRounder>
    {
        ImplementsINumberRounder() = delete;
        ImplementsINumberRounder(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINumberRounder, winrt::Windows::Globalization::NumberFormatting::INumberRounder>(py_obj, runtime_class)
        {
        }

        auto RoundDouble(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "round_double")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RoundInt32(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "round_int32")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RoundInt64(int64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "round_int64")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int64_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RoundSingle(float param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "round_single")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<float>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RoundUInt32(uint32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "round_uint32")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RoundUInt64(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "round_uint64")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint64_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberRounder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberRounder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINumberRounder(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Globalization::NumberFormatting::INumberRounder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINumberRounder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINumberRounder>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINumberRounder[] = {
        { "_assign_array_", _assign_array_INumberRounder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberRounder), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINumberRounder), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINumberRounder), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINumberRounder[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINumberRounder) },
        { }};

    static PyType_Spec type_spec_ImplementsINumberRounder = {
        "winrt._winrt_windows_globalization_numberformatting.INumberRounder",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsINumberRounder};

    // ----- INumberRounderOption interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_INumberRounderOption(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_INumberRounderOption(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounderOption* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberRounderOption_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounderOption* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberRounderOption", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumberRounder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberRounderOption_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounderOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberRounderOption", L"NumberRounder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumberRounder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_INumberRounderOption[] = {
        { }};

    static PyGetSetDef _getset_INumberRounderOption[] = {
        { "number_rounder", reinterpret_cast<getter>(INumberRounderOption_get_NumberRounder), reinterpret_cast<setter>(INumberRounderOption_put_NumberRounder), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INumberRounderOption[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberRounderOption) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberRounderOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberRounderOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberRounderOption) },
        { }};

    static PyType_Spec type_spec_INumberRounderOption = {
        "winrt._winrt_windows_globalization_numberformatting._INumberRounderOption",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounderOption),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_INumberRounderOption};

    struct ImplementsINumberRounderOption : py::ImplementsInterfaceT<ImplementsINumberRounderOption, winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>
    {
        ImplementsINumberRounderOption() = delete;
        ImplementsINumberRounderOption(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINumberRounderOption, winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>(py_obj, runtime_class)
        {
        }

        auto NumberRounder()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "number_rounder")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void NumberRounder(winrt::Windows::Globalization::NumberFormatting::INumberRounder const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "number_rounder", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INumberRounderOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberRounderOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINumberRounderOption(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINumberRounderOption(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINumberRounderOption>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINumberRounderOption[] = {
        { "_assign_array_", _assign_array_INumberRounderOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberRounderOption), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINumberRounderOption), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINumberRounderOption), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINumberRounderOption[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINumberRounderOption) },
        { }};

    static PyType_Spec type_spec_ImplementsINumberRounderOption = {
        "winrt._winrt_windows_globalization_numberformatting.INumberRounderOption",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsINumberRounderOption};

    // ----- ISignedZeroOption interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ISignedZeroOption(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ISignedZeroOption(py::wrapper::Windows::Globalization::NumberFormatting::ISignedZeroOption* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISignedZeroOption_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::ISignedZeroOption* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.ISignedZeroOption", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsZeroSigned();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISignedZeroOption_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::ISignedZeroOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.ISignedZeroOption", L"IsZeroSigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsZeroSigned(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ISignedZeroOption[] = {
        { }};

    static PyGetSetDef _getset_ISignedZeroOption[] = {
        { "is_zero_signed", reinterpret_cast<getter>(ISignedZeroOption_get_IsZeroSigned), reinterpret_cast<setter>(ISignedZeroOption_put_IsZeroSigned), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISignedZeroOption[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ISignedZeroOption) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISignedZeroOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISignedZeroOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISignedZeroOption) },
        { }};

    static PyType_Spec type_spec_ISignedZeroOption = {
        "winrt._winrt_windows_globalization_numberformatting._ISignedZeroOption",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::ISignedZeroOption),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ISignedZeroOption};

    struct ImplementsISignedZeroOption : py::ImplementsInterfaceT<ImplementsISignedZeroOption, winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>
    {
        ImplementsISignedZeroOption() = delete;
        ImplementsISignedZeroOption(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISignedZeroOption, winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>(py_obj, runtime_class)
        {
        }

        auto IsZeroSigned()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_zero_signed")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void IsZeroSigned(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "is_zero_signed", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISignedZeroOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISignedZeroOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISignedZeroOption(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISignedZeroOption(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISignedZeroOption>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISignedZeroOption[] = {
        { "_assign_array_", _assign_array_ISignedZeroOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISignedZeroOption), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISignedZeroOption), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISignedZeroOption), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISignedZeroOption[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISignedZeroOption) },
        { }};

    static PyType_Spec type_spec_ImplementsISignedZeroOption = {
        "winrt._winrt_windows_globalization_numberformatting.ISignedZeroOption",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsISignedZeroOption};

    // ----- ISignificantDigitsOption interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ISignificantDigitsOption(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ISignificantDigitsOption(py::wrapper::Windows::Globalization::NumberFormatting::ISignificantDigitsOption* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISignificantDigitsOption_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::ISignificantDigitsOption* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.ISignificantDigitsOption", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SignificantDigits();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISignificantDigitsOption_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::ISignificantDigitsOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.ISignificantDigitsOption", L"SignificantDigits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.SignificantDigits(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ISignificantDigitsOption[] = {
        { }};

    static PyGetSetDef _getset_ISignificantDigitsOption[] = {
        { "significant_digits", reinterpret_cast<getter>(ISignificantDigitsOption_get_SignificantDigits), reinterpret_cast<setter>(ISignificantDigitsOption_put_SignificantDigits), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISignificantDigitsOption[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ISignificantDigitsOption) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISignificantDigitsOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISignificantDigitsOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISignificantDigitsOption) },
        { }};

    static PyType_Spec type_spec_ISignificantDigitsOption = {
        "winrt._winrt_windows_globalization_numberformatting._ISignificantDigitsOption",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::ISignificantDigitsOption),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ISignificantDigitsOption};

    struct ImplementsISignificantDigitsOption : py::ImplementsInterfaceT<ImplementsISignificantDigitsOption, winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>
    {
        ImplementsISignificantDigitsOption() = delete;
        ImplementsISignificantDigitsOption(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISignificantDigitsOption, winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>(py_obj, runtime_class)
        {
        }

        auto SignificantDigits()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "significant_digits")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void SignificantDigits(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "significant_digits", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISignificantDigitsOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISignificantDigitsOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISignificantDigitsOption(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISignificantDigitsOption(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISignificantDigitsOption>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISignificantDigitsOption[] = {
        { "_assign_array_", _assign_array_ISignificantDigitsOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISignificantDigitsOption), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISignificantDigitsOption), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISignificantDigitsOption), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISignificantDigitsOption[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISignificantDigitsOption) },
        { }};

    static PyType_Spec type_spec_ImplementsISignificantDigitsOption = {
        "winrt._winrt_windows_globalization_numberformatting.ISignificantDigitsOption",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsISignificantDigitsOption};

    // ----- Windows.Globalization.NumberFormatting Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Globalization.NumberFormatting");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_globalization_numberformatting",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Globalization::NumberFormatting

PyMODINIT_FUNC PyInit__winrt_windows_globalization_numberformatting(void) noexcept
{
    using namespace py::cpp::Windows::Globalization::NumberFormatting;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle CurrencyFormatter_type{py::register_python_type(module.get(), &type_spec_CurrencyFormatter, object_bases.get(), inspectable_meta_type)};
    if (!CurrencyFormatter_type)
    {
        return nullptr;
    }

    py::pytype_handle DecimalFormatter_type{py::register_python_type(module.get(), &type_spec_DecimalFormatter, object_bases.get(), inspectable_meta_type)};
    if (!DecimalFormatter_type)
    {
        return nullptr;
    }

    py::pytype_handle IncrementNumberRounder_type{py::register_python_type(module.get(), &type_spec_IncrementNumberRounder, object_bases.get(), inspectable_meta_type)};
    if (!IncrementNumberRounder_type)
    {
        return nullptr;
    }

    py::pytype_handle NumeralSystemTranslator_type{py::register_python_type(module.get(), &type_spec_NumeralSystemTranslator, object_bases.get(), inspectable_meta_type)};
    if (!NumeralSystemTranslator_type)
    {
        return nullptr;
    }

    py::pytype_handle PercentFormatter_type{py::register_python_type(module.get(), &type_spec_PercentFormatter, object_bases.get(), inspectable_meta_type)};
    if (!PercentFormatter_type)
    {
        return nullptr;
    }

    py::pytype_handle PermilleFormatter_type{py::register_python_type(module.get(), &type_spec_PermilleFormatter, object_bases.get(), inspectable_meta_type)};
    if (!PermilleFormatter_type)
    {
        return nullptr;
    }

    py::pytype_handle SignificantDigitsNumberRounder_type{py::register_python_type(module.get(), &type_spec_SignificantDigitsNumberRounder, object_bases.get(), inspectable_meta_type)};
    if (!SignificantDigitsNumberRounder_type)
    {
        return nullptr;
    }

    py::pytype_handle INumberFormatter_type{py::register_python_type(module.get(), &type_spec_INumberFormatter, object_bases.get(), nullptr)};
    if (!INumberFormatter_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINumberFormatter_type{py::register_python_type(module.get(), &type_spec_ImplementsINumberFormatter, nullptr, inspectable_meta_type)};
    if (!ImplementsINumberFormatter_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINumberFormatter_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INumberFormatter2_type{py::register_python_type(module.get(), &type_spec_INumberFormatter2, object_bases.get(), nullptr)};
    if (!INumberFormatter2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINumberFormatter2_type{py::register_python_type(module.get(), &type_spec_ImplementsINumberFormatter2, nullptr, inspectable_meta_type)};
    if (!ImplementsINumberFormatter2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINumberFormatter2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INumberFormatterOptions_type{py::register_python_type(module.get(), &type_spec_INumberFormatterOptions, object_bases.get(), nullptr)};
    if (!INumberFormatterOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINumberFormatterOptions_type{py::register_python_type(module.get(), &type_spec_ImplementsINumberFormatterOptions, nullptr, inspectable_meta_type)};
    if (!ImplementsINumberFormatterOptions_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINumberFormatterOptions_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INumberParser_type{py::register_python_type(module.get(), &type_spec_INumberParser, object_bases.get(), nullptr)};
    if (!INumberParser_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINumberParser_type{py::register_python_type(module.get(), &type_spec_ImplementsINumberParser, nullptr, inspectable_meta_type)};
    if (!ImplementsINumberParser_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINumberParser_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INumberRounder_type{py::register_python_type(module.get(), &type_spec_INumberRounder, object_bases.get(), nullptr)};
    if (!INumberRounder_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINumberRounder_type{py::register_python_type(module.get(), &type_spec_ImplementsINumberRounder, nullptr, inspectable_meta_type)};
    if (!ImplementsINumberRounder_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINumberRounder_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INumberRounderOption_type{py::register_python_type(module.get(), &type_spec_INumberRounderOption, object_bases.get(), nullptr)};
    if (!INumberRounderOption_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINumberRounderOption_type{py::register_python_type(module.get(), &type_spec_ImplementsINumberRounderOption, nullptr, inspectable_meta_type)};
    if (!ImplementsINumberRounderOption_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINumberRounderOption_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISignedZeroOption_type{py::register_python_type(module.get(), &type_spec_ISignedZeroOption, object_bases.get(), nullptr)};
    if (!ISignedZeroOption_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISignedZeroOption_type{py::register_python_type(module.get(), &type_spec_ImplementsISignedZeroOption, nullptr, inspectable_meta_type)};
    if (!ImplementsISignedZeroOption_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISignedZeroOption_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISignificantDigitsOption_type{py::register_python_type(module.get(), &type_spec_ISignificantDigitsOption, object_bases.get(), nullptr)};
    if (!ISignificantDigitsOption_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISignificantDigitsOption_type{py::register_python_type(module.get(), &type_spec_ImplementsISignificantDigitsOption, nullptr, inspectable_meta_type)};
    if (!ImplementsISignificantDigitsOption_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISignificantDigitsOption_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
