// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.0.0

#include "py.Windows.Storage.h"

namespace py::cpp::Windows::Storage
{
    // ----- AppDataPaths class --------------------

    static PyObject* _new_AppDataPaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::AppDataPaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::AppDataPaths>::type_name);
        return nullptr;
    }

    static void _dealloc_AppDataPaths(py::wrapper::Windows::Storage::AppDataPaths* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.AppDataPaths", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::AppDataPaths::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.AppDataPaths", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::AppDataPaths::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Cookies(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"Cookies");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cookies();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Desktop(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"Desktop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Desktop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Documents(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"Documents");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Documents();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Favorites(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"Favorites");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Favorites();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_History(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"History");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.History();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_InternetCache(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"InternetCache");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InternetCache();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_LocalAppData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"LocalAppData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalAppData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_ProgramData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"ProgramData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProgramData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_RoamingAppData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.AppDataPaths", L"RoamingAppData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingAppData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::AppDataPaths>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::AppDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDataPaths[] = {
        { "_assign_array_", _assign_array_AppDataPaths, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDataPaths), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppDataPaths[] = {
        { "cookies", reinterpret_cast<getter>(AppDataPaths_get_Cookies), nullptr, nullptr, nullptr },
        { "desktop", reinterpret_cast<getter>(AppDataPaths_get_Desktop), nullptr, nullptr, nullptr },
        { "documents", reinterpret_cast<getter>(AppDataPaths_get_Documents), nullptr, nullptr, nullptr },
        { "favorites", reinterpret_cast<getter>(AppDataPaths_get_Favorites), nullptr, nullptr, nullptr },
        { "history", reinterpret_cast<getter>(AppDataPaths_get_History), nullptr, nullptr, nullptr },
        { "internet_cache", reinterpret_cast<getter>(AppDataPaths_get_InternetCache), nullptr, nullptr, nullptr },
        { "local_app_data", reinterpret_cast<getter>(AppDataPaths_get_LocalAppData), nullptr, nullptr, nullptr },
        { "program_data", reinterpret_cast<getter>(AppDataPaths_get_ProgramData), nullptr, nullptr, nullptr },
        { "roaming_app_data", reinterpret_cast<getter>(AppDataPaths_get_RoamingAppData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppDataPaths[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDataPaths) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDataPaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDataPaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDataPaths) },
        { }};

    static PyType_Spec type_spec_AppDataPaths = {
        "winrt._winrt_windows_storage.AppDataPaths",
        sizeof(py::wrapper::Windows::Storage::AppDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDataPaths};

    static PyGetSetDef getset_AppDataPaths_Static[] = {
        { }};

    static PyMethodDef methods_AppDataPaths_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AppDataPaths_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(AppDataPaths_GetForUser), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AppDataPaths_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppDataPaths_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppDataPaths_Static) },
        { }
    };

    static PyType_Spec type_spec_AppDataPaths_Static = {
        "winrt._winrt_windows_storage.AppDataPaths_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppDataPaths_Static};

    // ----- ApplicationData class --------------------

    static PyObject* _new_ApplicationData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::ApplicationData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::ApplicationData>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationData_ClearAllAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"ClearAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ClearAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_ClearAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"ClearAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::ApplicationDataLocality>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ClearAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_ClearPublisherCacheFolderAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"ClearPublisherCacheFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ClearPublisherCacheFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_Close(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_GetForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"GetForUserAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::ApplicationData::GetForUserAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_GetPublisherCacheFolder(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"GetPublisherCacheFolder", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPublisherCacheFolder(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_SetVersionAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"SetVersionAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataSetVersionHandler>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetVersionAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_SignalDataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationData", L"SignalDataChanged", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.SignalDataChanged();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"LocalFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalSettings(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"LocalSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"RoamingFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingSettings(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"RoamingSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingStorageQuota(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"RoamingStorageQuota");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingStorageQuota();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_TemporaryFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"TemporaryFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TemporaryFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_Version(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"Version");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Version();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalCacheFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"LocalCacheFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalCacheFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_SharedLocalFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"SharedLocalFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SharedLocalFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationData", L"Current");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::ApplicationData::Current();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_add_DataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationData", L"DataChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::ApplicationData, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DataChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_remove_DataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationData", L"DataChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DataChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::ApplicationData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationData[] = {
        { "clear_all_async", reinterpret_cast<PyCFunction>(ApplicationData_ClearAllAsync), METH_VARARGS, nullptr },
        { "clear_async", reinterpret_cast<PyCFunction>(ApplicationData_ClearAsync), METH_VARARGS, nullptr },
        { "clear_publisher_cache_folder_async", reinterpret_cast<PyCFunction>(ApplicationData_ClearPublisherCacheFolderAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ApplicationData_Close), METH_VARARGS, nullptr },
        { "get_publisher_cache_folder", reinterpret_cast<PyCFunction>(ApplicationData_GetPublisherCacheFolder), METH_VARARGS, nullptr },
        { "set_version_async", reinterpret_cast<PyCFunction>(ApplicationData_SetVersionAsync), METH_VARARGS, nullptr },
        { "signal_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_SignalDataChanged), METH_VARARGS, nullptr },
        { "add_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_add_DataChanged), METH_O, nullptr },
        { "remove_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_remove_DataChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ApplicationData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationData), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ApplicationData), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ApplicationData), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ApplicationData[] = {
        { "local_folder", reinterpret_cast<getter>(ApplicationData_get_LocalFolder), nullptr, nullptr, nullptr },
        { "local_settings", reinterpret_cast<getter>(ApplicationData_get_LocalSettings), nullptr, nullptr, nullptr },
        { "roaming_folder", reinterpret_cast<getter>(ApplicationData_get_RoamingFolder), nullptr, nullptr, nullptr },
        { "roaming_settings", reinterpret_cast<getter>(ApplicationData_get_RoamingSettings), nullptr, nullptr, nullptr },
        { "roaming_storage_quota", reinterpret_cast<getter>(ApplicationData_get_RoamingStorageQuota), nullptr, nullptr, nullptr },
        { "temporary_folder", reinterpret_cast<getter>(ApplicationData_get_TemporaryFolder), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(ApplicationData_get_Version), nullptr, nullptr, nullptr },
        { "local_cache_folder", reinterpret_cast<getter>(ApplicationData_get_LocalCacheFolder), nullptr, nullptr, nullptr },
        { "shared_local_folder", reinterpret_cast<getter>(ApplicationData_get_SharedLocalFolder), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ApplicationData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationData) },
        { }};

    static PyType_Spec type_spec_ApplicationData = {
        "winrt._winrt_windows_storage.ApplicationData",
        sizeof(py::wrapper::Windows::Storage::ApplicationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationData};

    static PyGetSetDef getset_ApplicationData_Static[] = {
        { "current", reinterpret_cast<getter>(ApplicationData_get_Current), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ApplicationData_Static[] = {
        { "get_for_user_async", reinterpret_cast<PyCFunction>(ApplicationData_GetForUserAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ApplicationData_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ApplicationData_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ApplicationData_Static) },
        { }
    };

    static PyType_Spec type_spec_ApplicationData_Static = {
        "winrt._winrt_windows_storage.ApplicationData_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ApplicationData_Static};

    // ----- ApplicationDataCompositeValue class --------------------

    static PyObject* _new_ApplicationDataCompositeValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::ApplicationDataCompositeValue instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationDataCompositeValue_Clear(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_First(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_GetView(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_HasKey(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"HasKey", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.HasKey(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Insert(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Insert", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Insert(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Lookup(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Lookup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Lookup(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Remove(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Remove(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_get_Size(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_add_MapChanged(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"MapChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MapChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_remove_MapChanged(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationDataCompositeValue", L"MapChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MapChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationDataCompositeValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::ApplicationDataCompositeValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationDataCompositeValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataCompositeValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            {
                auto _gil = py::release_gil();
                return static_cast<int>(self->obj.HasKey(_key));
            }
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.TryLookup(_key);
            }();

            if (!value)
            {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    auto has_key = [&]()
                    {
                        auto _gil = py::release_gil();
                        return self->obj.HasKey(_key);
                    }();

                    if (has_key)
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (!value)
            {
                bool did_remove;
                {
                    auto _gil = py::release_gil();
                    did_remove = self->obj.TryRemove(_key);
                }
                if (!did_remove)
                {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            auto _value = py::convert_to<winrt::Windows::Foundation::IInspectable>(value);
            {
                auto _gil = py::release_gil();
                self->obj.Insert(_key, _value);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ApplicationDataCompositeValue[] = {
        { "clear", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Remove), METH_VARARGS, nullptr },
        { "add_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_add_MapChanged), METH_O, nullptr },
        { "remove_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_remove_MapChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ApplicationDataCompositeValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataCompositeValue), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ApplicationDataCompositeValue[] = {
        { "size", reinterpret_cast<getter>(ApplicationDataCompositeValue_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ApplicationDataCompositeValue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationDataCompositeValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationDataCompositeValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationDataCompositeValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationDataCompositeValue) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ApplicationDataCompositeValue) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_ApplicationDataCompositeValue) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_ApplicationDataCompositeValue) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_ApplicationDataCompositeValue) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_ApplicationDataCompositeValue) },
        { }};

    static PyType_Spec type_spec_ApplicationDataCompositeValue = {
        "winrt._winrt_windows_storage.ApplicationDataCompositeValue",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataCompositeValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataCompositeValue};

    // ----- ApplicationDataContainer class --------------------

    static PyObject* _new_ApplicationDataContainer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::ApplicationDataContainer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::ApplicationDataContainer>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationDataContainer_Close(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainer", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_CreateContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainer", L"CreateContainer", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataCreateDisposition>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateContainer(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_DeleteContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainer", L"DeleteContainer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DeleteContainer(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Containers(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainer", L"Containers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Containers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Locality(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainer", L"Locality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Locality();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Name(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainer", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Values(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainer", L"Values");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Values();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationDataContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::ApplicationDataContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationDataContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationDataContainer[] = {
        { "close", reinterpret_cast<PyCFunction>(ApplicationDataContainer_Close), METH_VARARGS, nullptr },
        { "create_container", reinterpret_cast<PyCFunction>(ApplicationDataContainer_CreateContainer), METH_VARARGS, nullptr },
        { "delete_container", reinterpret_cast<PyCFunction>(ApplicationDataContainer_DeleteContainer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ApplicationDataContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataContainer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ApplicationDataContainer), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ApplicationDataContainer), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ApplicationDataContainer[] = {
        { "containers", reinterpret_cast<getter>(ApplicationDataContainer_get_Containers), nullptr, nullptr, nullptr },
        { "locality", reinterpret_cast<getter>(ApplicationDataContainer_get_Locality), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ApplicationDataContainer_get_Name), nullptr, nullptr, nullptr },
        { "values", reinterpret_cast<getter>(ApplicationDataContainer_get_Values), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ApplicationDataContainer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationDataContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationDataContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationDataContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationDataContainer) },
        { }};

    static PyType_Spec type_spec_ApplicationDataContainer = {
        "winrt._winrt_windows_storage.ApplicationDataContainer",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataContainer};

    // ----- ApplicationDataContainerSettings class --------------------

    static PyObject* _new_ApplicationDataContainerSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationDataContainerSettings_Clear(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_First(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_GetView(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_HasKey(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"HasKey", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.HasKey(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Insert(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Insert", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Insert(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Lookup(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Lookup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Lookup(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Remove(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Remove(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_get_Size(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_add_MapChanged(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"MapChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MapChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_remove_MapChanged(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.ApplicationDataContainerSettings", L"MapChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MapChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationDataContainerSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::ApplicationDataContainerSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationDataContainerSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataContainerSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            {
                auto _gil = py::release_gil();
                return static_cast<int>(self->obj.HasKey(_key));
            }
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.TryLookup(_key);
            }();

            if (!value)
            {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    auto has_key = [&]()
                    {
                        auto _gil = py::release_gil();
                        return self->obj.HasKey(_key);
                    }();

                    if (has_key)
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (!value)
            {
                bool did_remove;
                {
                    auto _gil = py::release_gil();
                    did_remove = self->obj.TryRemove(_key);
                }
                if (!did_remove)
                {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            auto _value = py::convert_to<winrt::Windows::Foundation::IInspectable>(value);
            {
                auto _gil = py::release_gil();
                self->obj.Insert(_key, _value);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ApplicationDataContainerSettings[] = {
        { "clear", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Remove), METH_VARARGS, nullptr },
        { "add_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_add_MapChanged), METH_O, nullptr },
        { "remove_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_remove_MapChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ApplicationDataContainerSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataContainerSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ApplicationDataContainerSettings[] = {
        { "size", reinterpret_cast<getter>(ApplicationDataContainerSettings_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ApplicationDataContainerSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationDataContainerSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationDataContainerSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationDataContainerSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationDataContainerSettings) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ApplicationDataContainerSettings) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_ApplicationDataContainerSettings) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_ApplicationDataContainerSettings) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_ApplicationDataContainerSettings) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_ApplicationDataContainerSettings) },
        { }};

    static PyType_Spec type_spec_ApplicationDataContainerSettings = {
        "winrt._winrt_windows_storage.ApplicationDataContainerSettings",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataContainerSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataContainerSettings};

    // ----- CachedFileManager class --------------------

    static PyObject* _new_CachedFileManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::CachedFileManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::CachedFileManager>::type_name);
        return nullptr;
    }

    static PyObject* CachedFileManager_CompleteUpdatesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.CachedFileManager", L"CompleteUpdatesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::CachedFileManager::CompleteUpdatesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileManager_DeferUpdates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.CachedFileManager", L"DeferUpdates", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Storage::CachedFileManager::DeferUpdates(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileManager[] = {
        { }};

    static PyGetSetDef _getset_CachedFileManager[] = {
        { }};

    static PyType_Slot _type_slots_CachedFileManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileManager) },
        { }};

    static PyType_Spec type_spec_CachedFileManager = {
        "winrt._winrt_windows_storage.CachedFileManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileManager};

    static PyGetSetDef getset_CachedFileManager_Static[] = {
        { }};

    static PyMethodDef methods_CachedFileManager_Static[] = {
        { "complete_updates_async", reinterpret_cast<PyCFunction>(CachedFileManager_CompleteUpdatesAsync), METH_VARARGS, nullptr },
        { "defer_updates", reinterpret_cast<PyCFunction>(CachedFileManager_DeferUpdates), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_CachedFileManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CachedFileManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CachedFileManager_Static) },
        { }
    };

    static PyType_Spec type_spec_CachedFileManager_Static = {
        "winrt._winrt_windows_storage.CachedFileManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CachedFileManager_Static};

    // ----- DownloadsFolder class --------------------

    static PyObject* _new_DownloadsFolder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::DownloadsFolder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::DownloadsFolder>::type_name);
        return nullptr;
    }

    static PyObject* DownloadsFolder_CreateFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFileForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFileForUserAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFileForUserWithCollisionOptionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFileForUserAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFileWithCollisionOptionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFolderForUserAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderForUserWithCollisionOptionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFolderForUserAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderWithCollisionOptionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.DownloadsFolder", L"CreateFolderAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadsFolder[] = {
        { }};

    static PyGetSetDef _getset_DownloadsFolder[] = {
        { }};

    static PyType_Slot _type_slots_DownloadsFolder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DownloadsFolder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DownloadsFolder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DownloadsFolder) },
        { }};

    static PyType_Spec type_spec_DownloadsFolder = {
        "winrt._winrt_windows_storage.DownloadsFolder",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadsFolder};

    static PyGetSetDef getset_DownloadsFolder_Static[] = {
        { }};

    static PyMethodDef methods_DownloadsFolder_Static[] = {
        { "create_file_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFileAsync), METH_VARARGS, nullptr },
        { "create_file_for_user_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFileForUserAsync), METH_VARARGS, nullptr },
        { "create_file_for_user_with_collision_option_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFileForUserWithCollisionOptionAsync), METH_VARARGS, nullptr },
        { "create_file_with_collision_option_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFileWithCollisionOptionAsync), METH_VARARGS, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "create_folder_for_user_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFolderForUserAsync), METH_VARARGS, nullptr },
        { "create_folder_for_user_with_collision_option_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFolderForUserWithCollisionOptionAsync), METH_VARARGS, nullptr },
        { "create_folder_with_collision_option_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFolderWithCollisionOptionAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_DownloadsFolder_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DownloadsFolder_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DownloadsFolder_Static) },
        { }
    };

    static PyType_Spec type_spec_DownloadsFolder_Static = {
        "winrt._winrt_windows_storage.DownloadsFolder_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DownloadsFolder_Static};

    // ----- FileIO class --------------------

    static PyObject* _new_FileIO(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::FileIO>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::FileIO>::type_name);
        return nullptr;
    }

    static PyObject* FileIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"AppendLinesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_AppendLinesWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"AppendLinesAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"AppendTextAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_AppendTextWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"AppendTextAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadBufferAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::ReadBufferAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadLinesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::ReadLinesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadLinesWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadLinesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::ReadLinesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadTextAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::ReadTextAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadTextWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"ReadTextAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::ReadTextAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteBufferAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::WriteBufferAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteBytesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::WriteBytesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteLinesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteLinesWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteLinesAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteTextAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteTextWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.FileIO", L"WriteTextAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileIO[] = {
        { }};

    static PyGetSetDef _getset_FileIO[] = {
        { }};

    static PyType_Slot _type_slots_FileIO[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileIO) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileIO) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileIO) },
        { }};

    static PyType_Spec type_spec_FileIO = {
        "winrt._winrt_windows_storage.FileIO",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileIO};

    static PyGetSetDef getset_FileIO_Static[] = {
        { }};

    static PyMethodDef methods_FileIO_Static[] = {
        { "append_lines_async", reinterpret_cast<PyCFunction>(FileIO_AppendLinesAsync), METH_VARARGS, nullptr },
        { "append_lines_with_encoding_async", reinterpret_cast<PyCFunction>(FileIO_AppendLinesWithEncodingAsync), METH_VARARGS, nullptr },
        { "append_text_async", reinterpret_cast<PyCFunction>(FileIO_AppendTextAsync), METH_VARARGS, nullptr },
        { "append_text_with_encoding_async", reinterpret_cast<PyCFunction>(FileIO_AppendTextWithEncodingAsync), METH_VARARGS, nullptr },
        { "read_buffer_async", reinterpret_cast<PyCFunction>(FileIO_ReadBufferAsync), METH_VARARGS, nullptr },
        { "read_lines_async", reinterpret_cast<PyCFunction>(FileIO_ReadLinesAsync), METH_VARARGS, nullptr },
        { "read_lines_with_encoding_async", reinterpret_cast<PyCFunction>(FileIO_ReadLinesWithEncodingAsync), METH_VARARGS, nullptr },
        { "read_text_async", reinterpret_cast<PyCFunction>(FileIO_ReadTextAsync), METH_VARARGS, nullptr },
        { "read_text_with_encoding_async", reinterpret_cast<PyCFunction>(FileIO_ReadTextWithEncodingAsync), METH_VARARGS, nullptr },
        { "write_buffer_async", reinterpret_cast<PyCFunction>(FileIO_WriteBufferAsync), METH_VARARGS, nullptr },
        { "write_bytes_async", reinterpret_cast<PyCFunction>(FileIO_WriteBytesAsync), METH_VARARGS, nullptr },
        { "write_lines_async", reinterpret_cast<PyCFunction>(FileIO_WriteLinesAsync), METH_VARARGS, nullptr },
        { "write_lines_with_encoding_async", reinterpret_cast<PyCFunction>(FileIO_WriteLinesWithEncodingAsync), METH_VARARGS, nullptr },
        { "write_text_async", reinterpret_cast<PyCFunction>(FileIO_WriteTextAsync), METH_VARARGS, nullptr },
        { "write_text_with_encoding_async", reinterpret_cast<PyCFunction>(FileIO_WriteTextWithEncodingAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_FileIO_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FileIO_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FileIO_Static) },
        { }
    };

    static PyType_Spec type_spec_FileIO_Static = {
        "winrt._winrt_windows_storage.FileIO_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FileIO_Static};

    // ----- KnownFolders class --------------------

    static PyObject* _new_KnownFolders(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::KnownFolders>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::KnownFolders>::type_name);
        return nullptr;
    }

    static PyObject* KnownFolders_GetFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.KnownFolders", L"GetFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::KnownFolders::GetFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_GetFolderForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.KnownFolders", L"GetFolderForUserAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::KnownFolders::GetFolderForUserAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.KnownFolders", L"RequestAccessAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::KnownFolders::RequestAccessAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_RequestAccessForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.KnownFolders", L"RequestAccessForUserAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::KnownFolders::RequestAccessForUserAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_CameraRoll(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"CameraRoll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::CameraRoll();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_Playlists(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"Playlists");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::Playlists();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_SavedPictures(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"SavedPictures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::SavedPictures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_DocumentsLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"DocumentsLibrary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::DocumentsLibrary();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_HomeGroup(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"HomeGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::HomeGroup();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_MediaServerDevices(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"MediaServerDevices");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::MediaServerDevices();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_MusicLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"MusicLibrary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::MusicLibrary();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_PicturesLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"PicturesLibrary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::PicturesLibrary();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_RemovableDevices(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"RemovableDevices");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::RemovableDevices();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_VideosLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"VideosLibrary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::VideosLibrary();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_AppCaptures(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"AppCaptures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::AppCaptures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_Objects3D(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"Objects3D");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::Objects3D();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_RecordedCalls(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.KnownFolders", L"RecordedCalls");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::KnownFolders::RecordedCalls();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownFolders[] = {
        { }};

    static PyGetSetDef _getset_KnownFolders[] = {
        { }};

    static PyType_Slot _type_slots_KnownFolders[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownFolders) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownFolders) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownFolders) },
        { }};

    static PyType_Spec type_spec_KnownFolders = {
        "winrt._winrt_windows_storage.KnownFolders",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownFolders};

    static PyGetSetDef getset_KnownFolders_Static[] = {
        { "camera_roll", reinterpret_cast<getter>(KnownFolders_get_CameraRoll), nullptr, nullptr, nullptr },
        { "playlists", reinterpret_cast<getter>(KnownFolders_get_Playlists), nullptr, nullptr, nullptr },
        { "saved_pictures", reinterpret_cast<getter>(KnownFolders_get_SavedPictures), nullptr, nullptr, nullptr },
        { "documents_library", reinterpret_cast<getter>(KnownFolders_get_DocumentsLibrary), nullptr, nullptr, nullptr },
        { "home_group", reinterpret_cast<getter>(KnownFolders_get_HomeGroup), nullptr, nullptr, nullptr },
        { "media_server_devices", reinterpret_cast<getter>(KnownFolders_get_MediaServerDevices), nullptr, nullptr, nullptr },
        { "music_library", reinterpret_cast<getter>(KnownFolders_get_MusicLibrary), nullptr, nullptr, nullptr },
        { "pictures_library", reinterpret_cast<getter>(KnownFolders_get_PicturesLibrary), nullptr, nullptr, nullptr },
        { "removable_devices", reinterpret_cast<getter>(KnownFolders_get_RemovableDevices), nullptr, nullptr, nullptr },
        { "videos_library", reinterpret_cast<getter>(KnownFolders_get_VideosLibrary), nullptr, nullptr, nullptr },
        { "app_captures", reinterpret_cast<getter>(KnownFolders_get_AppCaptures), nullptr, nullptr, nullptr },
        { "objects_3d", reinterpret_cast<getter>(KnownFolders_get_Objects3D), nullptr, nullptr, nullptr },
        { "recorded_calls", reinterpret_cast<getter>(KnownFolders_get_RecordedCalls), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_KnownFolders_Static[] = {
        { "get_folder_async", reinterpret_cast<PyCFunction>(KnownFolders_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_folder_for_user_async", reinterpret_cast<PyCFunction>(KnownFolders_GetFolderForUserAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(KnownFolders_RequestAccessAsync), METH_VARARGS, nullptr },
        { "request_access_for_user_async", reinterpret_cast<PyCFunction>(KnownFolders_RequestAccessForUserAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_KnownFolders_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownFolders_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownFolders_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownFolders_Static = {
        "winrt._winrt_windows_storage.KnownFolders_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownFolders_Static};

    // ----- PathIO class --------------------

    static PyObject* _new_PathIO(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::PathIO>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::PathIO>::type_name);
        return nullptr;
    }

    static PyObject* PathIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"AppendLinesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_AppendLinesWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"AppendLinesAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"AppendTextAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_AppendTextWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"AppendTextAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadBufferAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::ReadBufferAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadLinesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::ReadLinesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadLinesWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadLinesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::ReadLinesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadTextAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::ReadTextAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadTextWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"ReadTextAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::ReadTextAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteBufferAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::WriteBufferAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteBytesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::WriteBytesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteLinesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteLinesWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteLinesAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteTextAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteTextWithEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.PathIO", L"WriteTextAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathIO[] = {
        { }};

    static PyGetSetDef _getset_PathIO[] = {
        { }};

    static PyType_Slot _type_slots_PathIO[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathIO) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathIO) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathIO) },
        { }};

    static PyType_Spec type_spec_PathIO = {
        "winrt._winrt_windows_storage.PathIO",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathIO};

    static PyGetSetDef getset_PathIO_Static[] = {
        { }};

    static PyMethodDef methods_PathIO_Static[] = {
        { "append_lines_async", reinterpret_cast<PyCFunction>(PathIO_AppendLinesAsync), METH_VARARGS, nullptr },
        { "append_lines_with_encoding_async", reinterpret_cast<PyCFunction>(PathIO_AppendLinesWithEncodingAsync), METH_VARARGS, nullptr },
        { "append_text_async", reinterpret_cast<PyCFunction>(PathIO_AppendTextAsync), METH_VARARGS, nullptr },
        { "append_text_with_encoding_async", reinterpret_cast<PyCFunction>(PathIO_AppendTextWithEncodingAsync), METH_VARARGS, nullptr },
        { "read_buffer_async", reinterpret_cast<PyCFunction>(PathIO_ReadBufferAsync), METH_VARARGS, nullptr },
        { "read_lines_async", reinterpret_cast<PyCFunction>(PathIO_ReadLinesAsync), METH_VARARGS, nullptr },
        { "read_lines_with_encoding_async", reinterpret_cast<PyCFunction>(PathIO_ReadLinesWithEncodingAsync), METH_VARARGS, nullptr },
        { "read_text_async", reinterpret_cast<PyCFunction>(PathIO_ReadTextAsync), METH_VARARGS, nullptr },
        { "read_text_with_encoding_async", reinterpret_cast<PyCFunction>(PathIO_ReadTextWithEncodingAsync), METH_VARARGS, nullptr },
        { "write_buffer_async", reinterpret_cast<PyCFunction>(PathIO_WriteBufferAsync), METH_VARARGS, nullptr },
        { "write_bytes_async", reinterpret_cast<PyCFunction>(PathIO_WriteBytesAsync), METH_VARARGS, nullptr },
        { "write_lines_async", reinterpret_cast<PyCFunction>(PathIO_WriteLinesAsync), METH_VARARGS, nullptr },
        { "write_lines_with_encoding_async", reinterpret_cast<PyCFunction>(PathIO_WriteLinesWithEncodingAsync), METH_VARARGS, nullptr },
        { "write_text_async", reinterpret_cast<PyCFunction>(PathIO_WriteTextAsync), METH_VARARGS, nullptr },
        { "write_text_with_encoding_async", reinterpret_cast<PyCFunction>(PathIO_WriteTextWithEncodingAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PathIO_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PathIO_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PathIO_Static) },
        { }
    };

    static PyType_Spec type_spec_PathIO_Static = {
        "winrt._winrt_windows_storage.PathIO_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PathIO_Static};

    // ----- SetVersionDeferral class --------------------

    static PyObject* _new_SetVersionDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SetVersionDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SetVersionDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SetVersionDeferral(py::wrapper::Windows::Storage::SetVersionDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetVersionDeferral_Complete(py::wrapper::Windows::Storage::SetVersionDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.SetVersionDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetVersionDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SetVersionDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetVersionDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SetVersionDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetVersionDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SetVersionDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SetVersionDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetVersionDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SetVersionDeferral[] = {
        { }};

    static PyType_Slot _type_slots_SetVersionDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetVersionDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetVersionDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetVersionDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetVersionDeferral) },
        { }};

    static PyType_Spec type_spec_SetVersionDeferral = {
        "winrt._winrt_windows_storage.SetVersionDeferral",
        sizeof(py::wrapper::Windows::Storage::SetVersionDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetVersionDeferral};

    // ----- SetVersionRequest class --------------------

    static PyObject* _new_SetVersionRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SetVersionRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SetVersionRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_SetVersionRequest(py::wrapper::Windows::Storage::SetVersionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetVersionRequest_GetDeferral(py::wrapper::Windows::Storage::SetVersionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.SetVersionRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetVersionRequest_get_CurrentVersion(py::wrapper::Windows::Storage::SetVersionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SetVersionRequest", L"CurrentVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentVersion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SetVersionRequest_get_DesiredVersion(py::wrapper::Windows::Storage::SetVersionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SetVersionRequest", L"DesiredVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredVersion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetVersionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SetVersionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetVersionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SetVersionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetVersionRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SetVersionRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SetVersionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetVersionRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SetVersionRequest[] = {
        { "current_version", reinterpret_cast<getter>(SetVersionRequest_get_CurrentVersion), nullptr, nullptr, nullptr },
        { "desired_version", reinterpret_cast<getter>(SetVersionRequest_get_DesiredVersion), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SetVersionRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetVersionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetVersionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetVersionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetVersionRequest) },
        { }};

    static PyType_Spec type_spec_SetVersionRequest = {
        "winrt._winrt_windows_storage.SetVersionRequest",
        sizeof(py::wrapper::Windows::Storage::SetVersionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetVersionRequest};

    // ----- StorageFile class --------------------

    static PyObject* _new_StorageFile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageFile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageFile>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageFile(py::wrapper::Windows::Storage::StorageFile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageFile_CopyAndReplaceAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CopyAndReplaceAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CopyAndReplaceAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CopyOverload(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CopyAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CopyAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CopyOverloadDefaultNameAndOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CopyAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CopyAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CopyOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CopyAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CopyAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CreateStreamedFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CreateStreamedFileAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFile::CreateStreamedFileAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CreateStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"CreateStreamedFileFromUriAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFile::CreateStreamedFileFromUriAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_DeleteAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"DeleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_DeleteAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetBasicPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBasicPropertiesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromApplicationUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetFileFromApplicationUriAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFile::GetFileFromApplicationUriAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetFileFromPathAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFile::GetFileFromPathAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetFileFromPathForUserAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFile::GetFileFromPathForUserAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetParentAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetParentAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetParentAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetScaledImageAsThumbnailAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetScaledImageAsThumbnailAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetScaledImageAsThumbnailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetThumbnailAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetThumbnailAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetThumbnailAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetThumbnailAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"GetThumbnailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_IsEqual(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEqual(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_IsOfType(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"IsOfType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsOfType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveAndReplaceAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"MoveAndReplaceAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveAndReplaceAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveOverload(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"MoveAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveOverloadDefaultNameAndOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"MoveAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"MoveAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenReadAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenReadAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenReadAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenSequentialReadAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenSequentialReadAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenSequentialReadAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenTransactedWriteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenTransactedWriteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenTransactedWriteWithOptionsAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenTransactedWriteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenTransactedWriteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenWithOptionsAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"OpenAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_RenameAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"RenameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_RenameAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"RenameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_ReplaceWithStreamedFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"ReplaceWithStreamedFileAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_ReplaceWithStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFile", L"ReplaceWithStreamedFileFromUriAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileFromUriAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_ContentType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"ContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_FileType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"FileType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_IsAvailable(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"IsAvailable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAvailable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Attributes(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Attributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Attributes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DateCreated(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"DateCreated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateCreated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Name(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Path(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DisplayName(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DisplayType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"DisplayType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_FolderRelativeId(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"FolderRelativeId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FolderRelativeId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Properties(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Provider(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFile", L"Provider");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Provider();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageFile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageFile[] = {
        { "copy_and_replace_async", reinterpret_cast<PyCFunction>(StorageFile_CopyAndReplaceAsync), METH_VARARGS, nullptr },
        { "copy_overload", reinterpret_cast<PyCFunction>(StorageFile_CopyOverload), METH_VARARGS, nullptr },
        { "copy_overload_default_name_and_options", reinterpret_cast<PyCFunction>(StorageFile_CopyOverloadDefaultNameAndOptions), METH_VARARGS, nullptr },
        { "copy_overload_default_options", reinterpret_cast<PyCFunction>(StorageFile_CopyOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(StorageFile_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFile_DeleteAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(StorageFile_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_parent_async", reinterpret_cast<PyCFunction>(StorageFile_GetParentAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFile_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFile_GetScaledImageAsThumbnailAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async_overload_default_size_default_options", reinterpret_cast<PyCFunction>(StorageFile_GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFile_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFile_GetThumbnailAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_size_default_options", reinterpret_cast<PyCFunction>(StorageFile_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(StorageFile_IsEqual), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageFile_IsOfType), METH_VARARGS, nullptr },
        { "move_and_replace_async", reinterpret_cast<PyCFunction>(StorageFile_MoveAndReplaceAsync), METH_VARARGS, nullptr },
        { "move_overload", reinterpret_cast<PyCFunction>(StorageFile_MoveOverload), METH_VARARGS, nullptr },
        { "move_overload_default_name_and_options", reinterpret_cast<PyCFunction>(StorageFile_MoveOverloadDefaultNameAndOptions), METH_VARARGS, nullptr },
        { "move_overload_default_options", reinterpret_cast<PyCFunction>(StorageFile_MoveOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(StorageFile_OpenAsync), METH_VARARGS, nullptr },
        { "open_read_async", reinterpret_cast<PyCFunction>(StorageFile_OpenReadAsync), METH_VARARGS, nullptr },
        { "open_sequential_read_async", reinterpret_cast<PyCFunction>(StorageFile_OpenSequentialReadAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(StorageFile_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_with_options_async", reinterpret_cast<PyCFunction>(StorageFile_OpenTransactedWriteWithOptionsAsync), METH_VARARGS, nullptr },
        { "open_with_options_async", reinterpret_cast<PyCFunction>(StorageFile_OpenWithOptionsAsync), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(StorageFile_RenameAsync), METH_VARARGS, nullptr },
        { "rename_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFile_RenameAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageFile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageFile), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageFile[] = {
        { "content_type", reinterpret_cast<getter>(StorageFile_get_ContentType), nullptr, nullptr, nullptr },
        { "file_type", reinterpret_cast<getter>(StorageFile_get_FileType), nullptr, nullptr, nullptr },
        { "is_available", reinterpret_cast<getter>(StorageFile_get_IsAvailable), nullptr, nullptr, nullptr },
        { "attributes", reinterpret_cast<getter>(StorageFile_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(StorageFile_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(StorageFile_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageFile_get_Path), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(StorageFile_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(StorageFile_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(StorageFile_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(StorageFile_get_Properties), nullptr, nullptr, nullptr },
        { "provider", reinterpret_cast<getter>(StorageFile_get_Provider), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageFile[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageFile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageFile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageFile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageFile) },
        { }};

    static PyType_Spec type_spec_StorageFile = {
        "winrt._winrt_windows_storage.StorageFile",
        sizeof(py::wrapper::Windows::Storage::StorageFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageFile};

    static PyGetSetDef getset_StorageFile_Static[] = {
        { }};

    static PyMethodDef methods_StorageFile_Static[] = {
        { "create_streamed_file_async", reinterpret_cast<PyCFunction>(StorageFile_CreateStreamedFileAsync), METH_VARARGS, nullptr },
        { "create_streamed_file_from_uri_async", reinterpret_cast<PyCFunction>(StorageFile_CreateStreamedFileFromUriAsync), METH_VARARGS, nullptr },
        { "get_file_from_application_uri_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromApplicationUriAsync), METH_VARARGS, nullptr },
        { "get_file_from_path_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromPathAsync), METH_VARARGS, nullptr },
        { "get_file_from_path_for_user_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromPathForUserAsync), METH_VARARGS, nullptr },
        { "replace_with_streamed_file_async", reinterpret_cast<PyCFunction>(StorageFile_ReplaceWithStreamedFileAsync), METH_VARARGS, nullptr },
        { "replace_with_streamed_file_from_uri_async", reinterpret_cast<PyCFunction>(StorageFile_ReplaceWithStreamedFileFromUriAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_StorageFile_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageFile_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageFile_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageFile_Static = {
        "winrt._winrt_windows_storage.StorageFile_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageFile_Static};

    // ----- StorageFolder class --------------------

    static PyObject* _new_StorageFolder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageFolder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageFolder>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageFolder(py::wrapper::Windows::Storage::StorageFolder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageFolder_AreQueryOptionsSupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"AreQueryOptionsSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AreQueryOptionsSupported(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileQuery", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileQuery(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQueryOverloadDefault(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileQuery", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileQuery();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFileQueryWithOptions", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileQueryWithOptions(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFolderAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderQuery", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFolderQuery(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQueryOverloadDefault(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderQuery", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFolderQuery();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateFolderQueryWithOptions", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFolderQueryWithOptions(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateItemQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateItemQuery", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateItemQuery();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateItemQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"CreateItemQueryWithOptions", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateItemQueryWithOptions(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_DeleteAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"DeleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_DeleteAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetBasicPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBasicPropertiesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFileAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFilesAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFilesAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFilesAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFilesAsyncOverloadDefaultOptionsStartAndCount(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFilesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFilesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFilesAsyncOverloadDefaultStartAndCount(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFilesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFilesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderFromPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFolderFromPathAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFolder::GetFolderFromPathAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderFromPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFolderFromPathForUserAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageFolder::GetFolderFromPathForUserAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFoldersAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFoldersAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFoldersAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFoldersAsyncOverloadDefaultOptionsStartAndCount(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFoldersAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFoldersAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFoldersAsyncOverloadDefaultStartAndCount(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetFoldersAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFoldersAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetIndexedStateAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetIndexedStateAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIndexedStateAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetItemAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemsAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetItemsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemsAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemsAsyncOverloadDefaultStartAndCount(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetParentAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetParentAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetParentAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetScaledImageAsThumbnailAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetScaledImageAsThumbnailAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetScaledImageAsThumbnailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetThumbnailAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetThumbnailAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetThumbnailAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetThumbnailAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"GetThumbnailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsCommonFileQuerySupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"IsCommonFileQuerySupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsCommonFileQuerySupported(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsCommonFolderQuerySupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"IsCommonFolderQuerySupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsCommonFolderQuerySupported(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsEqual(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEqual(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsOfType(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"IsOfType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsOfType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_RenameAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"RenameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_RenameAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"RenameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_TryGetChangeTracker(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"TryGetChangeTracker", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetChangeTracker();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_TryGetItemAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageFolder", L"TryGetItemAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetItemAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Attributes(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Attributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Attributes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DateCreated(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"DateCreated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateCreated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Name(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Path(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DisplayName(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DisplayType(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"DisplayType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_FolderRelativeId(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"FolderRelativeId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FolderRelativeId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Properties(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Provider(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageFolder", L"Provider");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Provider();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageFolder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageFolder[] = {
        { "are_query_options_supported", reinterpret_cast<PyCFunction>(StorageFolder_AreQueryOptionsSupported), METH_VARARGS, nullptr },
        { "create_file_async", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileAsync), METH_VARARGS, nullptr },
        { "create_file_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "create_file_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileQuery), METH_VARARGS, nullptr },
        { "create_file_query_overload_default", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileQueryOverloadDefault), METH_VARARGS, nullptr },
        { "create_file_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileQueryWithOptions), METH_VARARGS, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "create_folder_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "create_folder_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderQuery), METH_VARARGS, nullptr },
        { "create_folder_query_overload_default", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderQueryOverloadDefault), METH_VARARGS, nullptr },
        { "create_folder_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderQueryWithOptions), METH_VARARGS, nullptr },
        { "create_item_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateItemQuery), METH_VARARGS, nullptr },
        { "create_item_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateItemQueryWithOptions), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(StorageFolder_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFolder_DeleteAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(StorageFolder_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_file_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFileAsync), METH_VARARGS, nullptr },
        { "get_files_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFilesAsync), METH_VARARGS, nullptr },
        { "get_files_async_overload_default_options_start_and_count", reinterpret_cast<PyCFunction>(StorageFolder_GetFilesAsyncOverloadDefaultOptionsStartAndCount), METH_VARARGS, nullptr },
        { "get_files_async_overload_default_start_and_count", reinterpret_cast<PyCFunction>(StorageFolder_GetFilesAsyncOverloadDefaultStartAndCount), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_folders_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFoldersAsync), METH_VARARGS, nullptr },
        { "get_folders_async_overload_default_options_start_and_count", reinterpret_cast<PyCFunction>(StorageFolder_GetFoldersAsyncOverloadDefaultOptionsStartAndCount), METH_VARARGS, nullptr },
        { "get_folders_async_overload_default_start_and_count", reinterpret_cast<PyCFunction>(StorageFolder_GetFoldersAsyncOverloadDefaultStartAndCount), METH_VARARGS, nullptr },
        { "get_indexed_state_async", reinterpret_cast<PyCFunction>(StorageFolder_GetIndexedStateAsync), METH_VARARGS, nullptr },
        { "get_item_async", reinterpret_cast<PyCFunction>(StorageFolder_GetItemAsync), METH_VARARGS, nullptr },
        { "get_items_async", reinterpret_cast<PyCFunction>(StorageFolder_GetItemsAsync), METH_VARARGS, nullptr },
        { "get_items_async_overload_default_start_and_count", reinterpret_cast<PyCFunction>(StorageFolder_GetItemsAsyncOverloadDefaultStartAndCount), METH_VARARGS, nullptr },
        { "get_parent_async", reinterpret_cast<PyCFunction>(StorageFolder_GetParentAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFolder_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFolder_GetScaledImageAsThumbnailAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async_overload_default_size_default_options", reinterpret_cast<PyCFunction>(StorageFolder_GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFolder_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFolder_GetThumbnailAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_size_default_options", reinterpret_cast<PyCFunction>(StorageFolder_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions), METH_VARARGS, nullptr },
        { "is_common_file_query_supported", reinterpret_cast<PyCFunction>(StorageFolder_IsCommonFileQuerySupported), METH_VARARGS, nullptr },
        { "is_common_folder_query_supported", reinterpret_cast<PyCFunction>(StorageFolder_IsCommonFolderQuerySupported), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(StorageFolder_IsEqual), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageFolder_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(StorageFolder_RenameAsync), METH_VARARGS, nullptr },
        { "rename_async_overload_default_options", reinterpret_cast<PyCFunction>(StorageFolder_RenameAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "try_get_change_tracker", reinterpret_cast<PyCFunction>(StorageFolder_TryGetChangeTracker), METH_VARARGS, nullptr },
        { "try_get_item_async", reinterpret_cast<PyCFunction>(StorageFolder_TryGetItemAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageFolder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageFolder), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageFolder[] = {
        { "attributes", reinterpret_cast<getter>(StorageFolder_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(StorageFolder_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(StorageFolder_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageFolder_get_Path), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(StorageFolder_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(StorageFolder_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(StorageFolder_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(StorageFolder_get_Properties), nullptr, nullptr, nullptr },
        { "provider", reinterpret_cast<getter>(StorageFolder_get_Provider), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageFolder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageFolder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageFolder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageFolder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageFolder) },
        { }};

    static PyType_Spec type_spec_StorageFolder = {
        "winrt._winrt_windows_storage.StorageFolder",
        sizeof(py::wrapper::Windows::Storage::StorageFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageFolder};

    static PyGetSetDef getset_StorageFolder_Static[] = {
        { }};

    static PyMethodDef methods_StorageFolder_Static[] = {
        { "get_folder_from_path_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderFromPathAsync), METH_VARARGS, nullptr },
        { "get_folder_from_path_for_user_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderFromPathForUserAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_StorageFolder_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageFolder_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageFolder_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageFolder_Static = {
        "winrt._winrt_windows_storage.StorageFolder_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageFolder_Static};

    // ----- StorageLibrary class --------------------

    static PyObject* _new_StorageLibrary(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibrary>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibrary>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibrary(py::wrapper::Windows::Storage::StorageLibrary* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibrary_AreFolderSuggestionsAvailableAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"AreFolderSuggestionsAvailableAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AreFolderSuggestionsAvailableAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_GetLibraryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"GetLibraryAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageLibrary::GetLibraryAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_GetLibraryForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"GetLibraryForUserAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::StorageLibrary::GetLibraryForUserAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_RequestAddFolderAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"RequestAddFolderAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestAddFolderAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_RequestRemoveFolderAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibrary", L"RequestRemoveFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestRemoveFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_Folders(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibrary", L"Folders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Folders();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_SaveFolder(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibrary", L"SaveFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SaveFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_ChangeTracker(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibrary", L"ChangeTracker");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeTracker();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_add_DefinitionChanged(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.StorageLibrary", L"DefinitionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::StorageLibrary, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DefinitionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_remove_DefinitionChanged(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.StorageLibrary", L"DefinitionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DefinitionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibrary(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibrary>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibrary(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibrary>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibrary[] = {
        { "are_folder_suggestions_available_async", reinterpret_cast<PyCFunction>(StorageLibrary_AreFolderSuggestionsAvailableAsync), METH_VARARGS, nullptr },
        { "request_add_folder_async", reinterpret_cast<PyCFunction>(StorageLibrary_RequestAddFolderAsync), METH_VARARGS, nullptr },
        { "request_remove_folder_async", reinterpret_cast<PyCFunction>(StorageLibrary_RequestRemoveFolderAsync), METH_VARARGS, nullptr },
        { "add_definition_changed", reinterpret_cast<PyCFunction>(StorageLibrary_add_DefinitionChanged), METH_O, nullptr },
        { "remove_definition_changed", reinterpret_cast<PyCFunction>(StorageLibrary_remove_DefinitionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_StorageLibrary, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibrary), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageLibrary[] = {
        { "folders", reinterpret_cast<getter>(StorageLibrary_get_Folders), nullptr, nullptr, nullptr },
        { "save_folder", reinterpret_cast<getter>(StorageLibrary_get_SaveFolder), nullptr, nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(StorageLibrary_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageLibrary[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibrary) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibrary) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibrary) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibrary) },
        { }};

    static PyType_Spec type_spec_StorageLibrary = {
        "winrt._winrt_windows_storage.StorageLibrary",
        sizeof(py::wrapper::Windows::Storage::StorageLibrary),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibrary};

    static PyGetSetDef getset_StorageLibrary_Static[] = {
        { }};

    static PyMethodDef methods_StorageLibrary_Static[] = {
        { "get_library_async", reinterpret_cast<PyCFunction>(StorageLibrary_GetLibraryAsync), METH_VARARGS, nullptr },
        { "get_library_for_user_async", reinterpret_cast<PyCFunction>(StorageLibrary_GetLibraryForUserAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_StorageLibrary_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageLibrary_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageLibrary_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageLibrary_Static = {
        "winrt._winrt_windows_storage.StorageLibrary_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageLibrary_Static};

    // ----- StorageLibraryChange class --------------------

    static PyObject* _new_StorageLibraryChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibraryChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibraryChange>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChange(py::wrapper::Windows::Storage::StorageLibraryChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryChange_GetStorageItemAsync(py::wrapper::Windows::Storage::StorageLibraryChange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChange", L"GetStorageItemAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStorageItemAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_IsOfType(py::wrapper::Windows::Storage::StorageLibraryChange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChange", L"IsOfType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsOfType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_ChangeType(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChange", L"ChangeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_Path(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChange", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_PreviousPath(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChange", L"PreviousPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousPath();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChange[] = {
        { "get_storage_item_async", reinterpret_cast<PyCFunction>(StorageLibraryChange_GetStorageItemAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageLibraryChange_IsOfType), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageLibraryChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChange), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageLibraryChange[] = {
        { "change_type", reinterpret_cast<getter>(StorageLibraryChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageLibraryChange_get_Path), nullptr, nullptr, nullptr },
        { "previous_path", reinterpret_cast<getter>(StorageLibraryChange_get_PreviousPath), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageLibraryChange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChange) },
        { }};

    static PyType_Spec type_spec_StorageLibraryChange = {
        "winrt._winrt_windows_storage.StorageLibraryChange",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChange};

    // ----- StorageLibraryChangeReader class --------------------

    static PyObject* _new_StorageLibraryChangeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibraryChangeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibraryChangeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChangeReader(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryChangeReader_AcceptChangesAsync(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeReader", L"AcceptChangesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AcceptChangesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeReader_GetLastChangeId(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeReader", L"GetLastChangeId", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetLastChangeId();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeReader_ReadBatchAsync(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeReader", L"ReadBatchAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryChangeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeReader[] = {
        { "accept_changes_async", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_AcceptChangesAsync), METH_VARARGS, nullptr },
        { "get_last_change_id", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_GetLastChangeId), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageLibraryChangeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageLibraryChangeReader[] = {
        { }};

    static PyType_Slot _type_slots_StorageLibraryChangeReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChangeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChangeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChangeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChangeReader) },
        { }};

    static PyType_Spec type_spec_StorageLibraryChangeReader = {
        "winrt._winrt_windows_storage.StorageLibraryChangeReader",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeReader};

    // ----- StorageLibraryChangeTracker class --------------------

    static PyObject* _new_StorageLibraryChangeTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChangeTracker(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryChangeTracker_Disable(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"Disable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Disable();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_Enable(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"Enable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Enable();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_EnableWithOptions(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"Enable", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Enable(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_GetChangeReader(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"GetChangeReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetChangeReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_Reset(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageLibraryChangeTracker", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryChangeTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTracker[] = {
        { "disable", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Disable), METH_VARARGS, nullptr },
        { "enable", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Enable), METH_VARARGS, nullptr },
        { "enable_with_options", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_EnableWithOptions), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageLibraryChangeTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeTracker), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageLibraryChangeTracker[] = {
        { }};

    static PyType_Slot _type_slots_StorageLibraryChangeTracker[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChangeTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChangeTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChangeTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChangeTracker) },
        { }};

    static PyType_Spec type_spec_StorageLibraryChangeTracker = {
        "winrt._winrt_windows_storage.StorageLibraryChangeTracker",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTracker};

    // ----- StorageLibraryChangeTrackerOptions class --------------------

    static PyObject* _new_StorageLibraryChangeTrackerOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::StorageLibraryChangeTrackerOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageLibraryChangeTrackerOptions(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryChangeTrackerOptions_get_TrackChangeDetails(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChangeTrackerOptions", L"TrackChangeDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrackChangeDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageLibraryChangeTrackerOptions_put_TrackChangeDetails(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryChangeTrackerOptions", L"TrackChangeDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.TrackChangeDetails(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageLibraryChangeTrackerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryChangeTrackerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTrackerOptions[] = {
        { "_assign_array_", _assign_array_StorageLibraryChangeTrackerOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeTrackerOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageLibraryChangeTrackerOptions[] = {
        { "track_change_details", reinterpret_cast<getter>(StorageLibraryChangeTrackerOptions_get_TrackChangeDetails), reinterpret_cast<setter>(StorageLibraryChangeTrackerOptions_put_TrackChangeDetails), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageLibraryChangeTrackerOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryChangeTrackerOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryChangeTrackerOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryChangeTrackerOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryChangeTrackerOptions) },
        { }};

    static PyType_Spec type_spec_StorageLibraryChangeTrackerOptions = {
        "winrt._winrt_windows_storage.StorageLibraryChangeTrackerOptions",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTrackerOptions};

    // ----- StorageLibraryLastChangeId class --------------------

    static PyObject* _new_StorageLibraryLastChangeId(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageLibraryLastChangeId>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageLibraryLastChangeId>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageLibraryLastChangeId(py::wrapper::Windows::Storage::StorageLibraryLastChangeId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageLibraryLastChangeId_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageLibraryLastChangeId", L"Unknown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::StorageLibraryLastChangeId::Unknown();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageLibraryLastChangeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageLibraryLastChangeId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageLibraryLastChangeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryLastChangeId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryLastChangeId[] = {
        { "_assign_array_", _assign_array_StorageLibraryLastChangeId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryLastChangeId), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageLibraryLastChangeId[] = {
        { }};

    static PyType_Slot _type_slots_StorageLibraryLastChangeId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageLibraryLastChangeId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageLibraryLastChangeId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageLibraryLastChangeId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageLibraryLastChangeId) },
        { }};

    static PyType_Spec type_spec_StorageLibraryLastChangeId = {
        "winrt._winrt_windows_storage.StorageLibraryLastChangeId",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryLastChangeId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryLastChangeId};

    static PyGetSetDef getset_StorageLibraryLastChangeId_Static[] = {
        { "unknown", reinterpret_cast<getter>(StorageLibraryLastChangeId_get_Unknown), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_StorageLibraryLastChangeId_Static[] = {
        { }};

    static PyType_Slot type_slots_StorageLibraryLastChangeId_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageLibraryLastChangeId_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageLibraryLastChangeId_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageLibraryLastChangeId_Static = {
        "winrt._winrt_windows_storage.StorageLibraryLastChangeId_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageLibraryLastChangeId_Static};

    // ----- StorageProvider class --------------------

    static PyObject* _new_StorageProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageProvider(py::wrapper::Windows::Storage::StorageProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProvider_IsPropertySupportedForPartialFileAsync(py::wrapper::Windows::Storage::StorageProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageProvider", L"IsPropertySupportedForPartialFileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsPropertySupportedForPartialFileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProvider_get_DisplayName(py::wrapper::Windows::Storage::StorageProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageProvider", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProvider_get_Id(py::wrapper::Windows::Storage::StorageProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageProvider", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProvider[] = {
        { "is_property_supported_for_partial_file_async", reinterpret_cast<PyCFunction>(StorageProvider_IsPropertySupportedForPartialFileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProvider), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProvider[] = {
        { "display_name", reinterpret_cast<getter>(StorageProvider_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProvider_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProvider) },
        { }};

    static PyType_Spec type_spec_StorageProvider = {
        "winrt._winrt_windows_storage.StorageProvider",
        sizeof(py::wrapper::Windows::Storage::StorageProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProvider};

    // ----- StorageStreamTransaction class --------------------

    static PyObject* _new_StorageStreamTransaction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StorageStreamTransaction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StorageStreamTransaction>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageStreamTransaction_Close(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageStreamTransaction", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageStreamTransaction_CommitAsync(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StorageStreamTransaction", L"CommitAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CommitAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageStreamTransaction_get_Stream(py::wrapper::Windows::Storage::StorageStreamTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.StorageStreamTransaction", L"Stream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Stream();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageStreamTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StorageStreamTransaction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageStreamTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageStreamTransaction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageStreamTransaction[] = {
        { "close", reinterpret_cast<PyCFunction>(StorageStreamTransaction_Close), METH_VARARGS, nullptr },
        { "commit_async", reinterpret_cast<PyCFunction>(StorageStreamTransaction_CommitAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StorageStreamTransaction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageStreamTransaction), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StorageStreamTransaction), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_StorageStreamTransaction), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_StorageStreamTransaction[] = {
        { "stream", reinterpret_cast<getter>(StorageStreamTransaction_get_Stream), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageStreamTransaction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageStreamTransaction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageStreamTransaction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageStreamTransaction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageStreamTransaction) },
        { }};

    static PyType_Spec type_spec_StorageStreamTransaction = {
        "winrt._winrt_windows_storage.StorageStreamTransaction",
        sizeof(py::wrapper::Windows::Storage::StorageStreamTransaction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageStreamTransaction};

    // ----- StreamedFileDataRequest class --------------------

    static PyObject* _new_StreamedFileDataRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::StreamedFileDataRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::StreamedFileDataRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamedFileDataRequest_Close(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StreamedFileDataRequest", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_FailAndClose(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StreamedFileDataRequest", L"FailAndClose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.FailAndClose(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_FlushAsync(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StreamedFileDataRequest", L"FlushAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FlushAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_WriteAsync(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.StreamedFileDataRequest", L"WriteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.WriteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::StreamedFileDataRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamedFileDataRequest[] = {
        { "close", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_Close), METH_VARARGS, nullptr },
        { "fail_and_close", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_FailAndClose), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_FlushAsync), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StreamedFileDataRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamedFileDataRequest), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamedFileDataRequest), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_StreamedFileDataRequest), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_StreamedFileDataRequest[] = {
        { }};

    static PyType_Slot _type_slots_StreamedFileDataRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamedFileDataRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamedFileDataRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamedFileDataRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamedFileDataRequest) },
        { }};

    static PyType_Spec type_spec_StreamedFileDataRequest = {
        "winrt._winrt_windows_storage.StreamedFileDataRequest",
        sizeof(py::wrapper::Windows::Storage::StreamedFileDataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamedFileDataRequest};

    // ----- SystemAudioProperties class --------------------

    static PyObject* _new_SystemAudioProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemAudioProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemAudioProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemAudioProperties(py::wrapper::Windows::Storage::SystemAudioProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemAudioProperties_get_EncodingBitrate(py::wrapper::Windows::Storage::SystemAudioProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemAudioProperties", L"EncodingBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncodingBitrate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemAudioProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemAudioProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemAudioProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemAudioProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemAudioProperties[] = {
        { "_assign_array_", _assign_array_SystemAudioProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemAudioProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemAudioProperties[] = {
        { "encoding_bitrate", reinterpret_cast<getter>(SystemAudioProperties_get_EncodingBitrate), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemAudioProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemAudioProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemAudioProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemAudioProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemAudioProperties) },
        { }};

    static PyType_Spec type_spec_SystemAudioProperties = {
        "winrt._winrt_windows_storage.SystemAudioProperties",
        sizeof(py::wrapper::Windows::Storage::SystemAudioProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemAudioProperties};

    // ----- SystemDataPaths class --------------------

    static PyObject* _new_SystemDataPaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemDataPaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemDataPaths>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemDataPaths(py::wrapper::Windows::Storage::SystemDataPaths* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.SystemDataPaths", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::SystemDataPaths::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Fonts(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"Fonts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Fonts();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_ProgramData(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"ProgramData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProgramData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Public(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"Public");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Public();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDesktop(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicDesktop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublicDesktop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDocuments(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicDocuments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublicDocuments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDownloads(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicDownloads");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublicDownloads();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicMusic(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicMusic");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublicMusic();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicPictures(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicPictures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublicPictures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicVideos(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"PublicVideos");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublicVideos();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_System(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"System");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.System();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemArm(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"SystemArm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemArm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemHost(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"SystemHost");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemHost();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemX64(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"SystemX64");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemX64();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemX86(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"SystemX86");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemX86();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_UserProfiles(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"UserProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserProfiles();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Windows(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemDataPaths", L"Windows");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Windows();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemDataPaths>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDataPaths[] = {
        { "_assign_array_", _assign_array_SystemDataPaths, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemDataPaths), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemDataPaths[] = {
        { "fonts", reinterpret_cast<getter>(SystemDataPaths_get_Fonts), nullptr, nullptr, nullptr },
        { "program_data", reinterpret_cast<getter>(SystemDataPaths_get_ProgramData), nullptr, nullptr, nullptr },
        { "public", reinterpret_cast<getter>(SystemDataPaths_get_Public), nullptr, nullptr, nullptr },
        { "public_desktop", reinterpret_cast<getter>(SystemDataPaths_get_PublicDesktop), nullptr, nullptr, nullptr },
        { "public_documents", reinterpret_cast<getter>(SystemDataPaths_get_PublicDocuments), nullptr, nullptr, nullptr },
        { "public_downloads", reinterpret_cast<getter>(SystemDataPaths_get_PublicDownloads), nullptr, nullptr, nullptr },
        { "public_music", reinterpret_cast<getter>(SystemDataPaths_get_PublicMusic), nullptr, nullptr, nullptr },
        { "public_pictures", reinterpret_cast<getter>(SystemDataPaths_get_PublicPictures), nullptr, nullptr, nullptr },
        { "public_videos", reinterpret_cast<getter>(SystemDataPaths_get_PublicVideos), nullptr, nullptr, nullptr },
        { "system", reinterpret_cast<getter>(SystemDataPaths_get_System), nullptr, nullptr, nullptr },
        { "system_arm", reinterpret_cast<getter>(SystemDataPaths_get_SystemArm), nullptr, nullptr, nullptr },
        { "system_host", reinterpret_cast<getter>(SystemDataPaths_get_SystemHost), nullptr, nullptr, nullptr },
        { "system_x64", reinterpret_cast<getter>(SystemDataPaths_get_SystemX64), nullptr, nullptr, nullptr },
        { "system_x86", reinterpret_cast<getter>(SystemDataPaths_get_SystemX86), nullptr, nullptr, nullptr },
        { "user_profiles", reinterpret_cast<getter>(SystemDataPaths_get_UserProfiles), nullptr, nullptr, nullptr },
        { "windows", reinterpret_cast<getter>(SystemDataPaths_get_Windows), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemDataPaths[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemDataPaths) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemDataPaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemDataPaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemDataPaths) },
        { }};

    static PyType_Spec type_spec_SystemDataPaths = {
        "winrt._winrt_windows_storage.SystemDataPaths",
        sizeof(py::wrapper::Windows::Storage::SystemDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDataPaths};

    static PyGetSetDef getset_SystemDataPaths_Static[] = {
        { }};

    static PyMethodDef methods_SystemDataPaths_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(SystemDataPaths_GetDefault), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SystemDataPaths_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemDataPaths_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemDataPaths_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemDataPaths_Static = {
        "winrt._winrt_windows_storage.SystemDataPaths_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemDataPaths_Static};

    // ----- SystemGPSProperties class --------------------

    static PyObject* _new_SystemGPSProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemGPSProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemGPSProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemGPSProperties(py::wrapper::Windows::Storage::SystemGPSProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemGPSProperties_get_LatitudeDecimal(py::wrapper::Windows::Storage::SystemGPSProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemGPSProperties", L"LatitudeDecimal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LatitudeDecimal();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemGPSProperties_get_LongitudeDecimal(py::wrapper::Windows::Storage::SystemGPSProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemGPSProperties", L"LongitudeDecimal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LongitudeDecimal();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemGPSProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemGPSProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemGPSProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemGPSProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemGPSProperties[] = {
        { "_assign_array_", _assign_array_SystemGPSProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemGPSProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemGPSProperties[] = {
        { "latitude_decimal", reinterpret_cast<getter>(SystemGPSProperties_get_LatitudeDecimal), nullptr, nullptr, nullptr },
        { "longitude_decimal", reinterpret_cast<getter>(SystemGPSProperties_get_LongitudeDecimal), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemGPSProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemGPSProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemGPSProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemGPSProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemGPSProperties) },
        { }};

    static PyType_Spec type_spec_SystemGPSProperties = {
        "winrt._winrt_windows_storage.SystemGPSProperties",
        sizeof(py::wrapper::Windows::Storage::SystemGPSProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemGPSProperties};

    // ----- SystemImageProperties class --------------------

    static PyObject* _new_SystemImageProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemImageProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemImageProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemImageProperties(py::wrapper::Windows::Storage::SystemImageProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemImageProperties_get_HorizontalSize(py::wrapper::Windows::Storage::SystemImageProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemImageProperties", L"HorizontalSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemImageProperties_get_VerticalSize(py::wrapper::Windows::Storage::SystemImageProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemImageProperties", L"VerticalSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemImageProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemImageProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemImageProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemImageProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemImageProperties[] = {
        { "_assign_array_", _assign_array_SystemImageProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemImageProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemImageProperties[] = {
        { "horizontal_size", reinterpret_cast<getter>(SystemImageProperties_get_HorizontalSize), nullptr, nullptr, nullptr },
        { "vertical_size", reinterpret_cast<getter>(SystemImageProperties_get_VerticalSize), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemImageProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemImageProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemImageProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemImageProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemImageProperties) },
        { }};

    static PyType_Spec type_spec_SystemImageProperties = {
        "winrt._winrt_windows_storage.SystemImageProperties",
        sizeof(py::wrapper::Windows::Storage::SystemImageProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemImageProperties};

    // ----- SystemMediaProperties class --------------------

    static PyObject* _new_SystemMediaProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemMediaProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemMediaProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemMediaProperties(py::wrapper::Windows::Storage::SystemMediaProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMediaProperties_get_Duration(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Producer(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Producer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Producer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Publisher(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Publisher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Publisher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_SubTitle(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"SubTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SubTitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Writer(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Writer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Writer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Year(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMediaProperties", L"Year");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Year();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemMediaProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemMediaProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaProperties[] = {
        { "_assign_array_", _assign_array_SystemMediaProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMediaProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemMediaProperties[] = {
        { "duration", reinterpret_cast<getter>(SystemMediaProperties_get_Duration), nullptr, nullptr, nullptr },
        { "producer", reinterpret_cast<getter>(SystemMediaProperties_get_Producer), nullptr, nullptr, nullptr },
        { "publisher", reinterpret_cast<getter>(SystemMediaProperties_get_Publisher), nullptr, nullptr, nullptr },
        { "sub_title", reinterpret_cast<getter>(SystemMediaProperties_get_SubTitle), nullptr, nullptr, nullptr },
        { "writer", reinterpret_cast<getter>(SystemMediaProperties_get_Writer), nullptr, nullptr, nullptr },
        { "year", reinterpret_cast<getter>(SystemMediaProperties_get_Year), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemMediaProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMediaProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMediaProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMediaProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMediaProperties) },
        { }};

    static PyType_Spec type_spec_SystemMediaProperties = {
        "winrt._winrt_windows_storage.SystemMediaProperties",
        sizeof(py::wrapper::Windows::Storage::SystemMediaProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaProperties};

    // ----- SystemMusicProperties class --------------------

    static PyObject* _new_SystemMusicProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemMusicProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemMusicProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemMusicProperties(py::wrapper::Windows::Storage::SystemMusicProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMusicProperties_get_AlbumArtist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"AlbumArtist");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AlbumArtist();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_AlbumTitle(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"AlbumTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AlbumTitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Artist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"Artist");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Artist();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Composer(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"Composer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Composer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Conductor(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"Conductor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Conductor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_DisplayArtist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"DisplayArtist");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayArtist();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Genre(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"Genre");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Genre();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_TrackNumber(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemMusicProperties", L"TrackNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrackNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMusicProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemMusicProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMusicProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemMusicProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMusicProperties[] = {
        { "_assign_array_", _assign_array_SystemMusicProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMusicProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemMusicProperties[] = {
        { "album_artist", reinterpret_cast<getter>(SystemMusicProperties_get_AlbumArtist), nullptr, nullptr, nullptr },
        { "album_title", reinterpret_cast<getter>(SystemMusicProperties_get_AlbumTitle), nullptr, nullptr, nullptr },
        { "artist", reinterpret_cast<getter>(SystemMusicProperties_get_Artist), nullptr, nullptr, nullptr },
        { "composer", reinterpret_cast<getter>(SystemMusicProperties_get_Composer), nullptr, nullptr, nullptr },
        { "conductor", reinterpret_cast<getter>(SystemMusicProperties_get_Conductor), nullptr, nullptr, nullptr },
        { "display_artist", reinterpret_cast<getter>(SystemMusicProperties_get_DisplayArtist), nullptr, nullptr, nullptr },
        { "genre", reinterpret_cast<getter>(SystemMusicProperties_get_Genre), nullptr, nullptr, nullptr },
        { "track_number", reinterpret_cast<getter>(SystemMusicProperties_get_TrackNumber), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemMusicProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMusicProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMusicProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMusicProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMusicProperties) },
        { }};

    static PyType_Spec type_spec_SystemMusicProperties = {
        "winrt._winrt_windows_storage.SystemMusicProperties",
        sizeof(py::wrapper::Windows::Storage::SystemMusicProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMusicProperties};

    // ----- SystemPhotoProperties class --------------------

    static PyObject* _new_SystemPhotoProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemPhotoProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemPhotoProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemPhotoProperties(py::wrapper::Windows::Storage::SystemPhotoProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemPhotoProperties_get_CameraManufacturer(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"CameraManufacturer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CameraManufacturer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_CameraModel(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"CameraModel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CameraModel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_DateTaken(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"DateTaken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateTaken();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_Orientation(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_PeopleNames(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemPhotoProperties", L"PeopleNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PeopleNames();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemPhotoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemPhotoProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemPhotoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemPhotoProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemPhotoProperties[] = {
        { "_assign_array_", _assign_array_SystemPhotoProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemPhotoProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemPhotoProperties[] = {
        { "camera_manufacturer", reinterpret_cast<getter>(SystemPhotoProperties_get_CameraManufacturer), nullptr, nullptr, nullptr },
        { "camera_model", reinterpret_cast<getter>(SystemPhotoProperties_get_CameraModel), nullptr, nullptr, nullptr },
        { "date_taken", reinterpret_cast<getter>(SystemPhotoProperties_get_DateTaken), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SystemPhotoProperties_get_Orientation), nullptr, nullptr, nullptr },
        { "people_names", reinterpret_cast<getter>(SystemPhotoProperties_get_PeopleNames), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemPhotoProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemPhotoProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemPhotoProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemPhotoProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemPhotoProperties) },
        { }};

    static PyType_Spec type_spec_SystemPhotoProperties = {
        "winrt._winrt_windows_storage.SystemPhotoProperties",
        sizeof(py::wrapper::Windows::Storage::SystemPhotoProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemPhotoProperties};

    // ----- SystemProperties class --------------------

    static PyObject* _new_SystemProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemProperties>::type_name);
        return nullptr;
    }

    static PyObject* SystemProperties_get_Audio(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Audio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Audio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Author(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Author");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Author();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Comment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Comment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Comment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_GPS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"GPS");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::GPS();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Image(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Image");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Image();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_ItemNameDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"ItemNameDisplay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::ItemNameDisplay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Keywords(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Keywords");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Keywords();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Media(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Media");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Media();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Music(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Music");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Music();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Photo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Photo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Photo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Rating(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Rating");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Rating();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Title(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Video(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemProperties", L"Video");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Storage::SystemProperties::Video();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemProperties[] = {
        { }};

    static PyGetSetDef _getset_SystemProperties[] = {
        { }};

    static PyType_Slot _type_slots_SystemProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemProperties) },
        { }};

    static PyType_Spec type_spec_SystemProperties = {
        "winrt._winrt_windows_storage.SystemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemProperties};

    static PyGetSetDef getset_SystemProperties_Static[] = {
        { "audio", reinterpret_cast<getter>(SystemProperties_get_Audio), nullptr, nullptr, nullptr },
        { "author", reinterpret_cast<getter>(SystemProperties_get_Author), nullptr, nullptr, nullptr },
        { "comment", reinterpret_cast<getter>(SystemProperties_get_Comment), nullptr, nullptr, nullptr },
        { "gps", reinterpret_cast<getter>(SystemProperties_get_GPS), nullptr, nullptr, nullptr },
        { "image", reinterpret_cast<getter>(SystemProperties_get_Image), nullptr, nullptr, nullptr },
        { "item_name_display", reinterpret_cast<getter>(SystemProperties_get_ItemNameDisplay), nullptr, nullptr, nullptr },
        { "keywords", reinterpret_cast<getter>(SystemProperties_get_Keywords), nullptr, nullptr, nullptr },
        { "media", reinterpret_cast<getter>(SystemProperties_get_Media), nullptr, nullptr, nullptr },
        { "music", reinterpret_cast<getter>(SystemProperties_get_Music), nullptr, nullptr, nullptr },
        { "photo", reinterpret_cast<getter>(SystemProperties_get_Photo), nullptr, nullptr, nullptr },
        { "rating", reinterpret_cast<getter>(SystemProperties_get_Rating), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(SystemProperties_get_Title), nullptr, nullptr, nullptr },
        { "video", reinterpret_cast<getter>(SystemProperties_get_Video), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SystemProperties_Static[] = {
        { }};

    static PyType_Slot type_slots_SystemProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemProperties_Static = {
        "winrt._winrt_windows_storage.SystemProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemProperties_Static};

    // ----- SystemVideoProperties class --------------------

    static PyObject* _new_SystemVideoProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::SystemVideoProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::SystemVideoProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemVideoProperties(py::wrapper::Windows::Storage::SystemVideoProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemVideoProperties_get_Director(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"Director");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Director();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_FrameHeight(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"FrameHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_FrameWidth(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"FrameWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_Orientation(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_TotalBitrate(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.SystemVideoProperties", L"TotalBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TotalBitrate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemVideoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::SystemVideoProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemVideoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemVideoProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemVideoProperties[] = {
        { "_assign_array_", _assign_array_SystemVideoProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemVideoProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemVideoProperties[] = {
        { "director", reinterpret_cast<getter>(SystemVideoProperties_get_Director), nullptr, nullptr, nullptr },
        { "frame_height", reinterpret_cast<getter>(SystemVideoProperties_get_FrameHeight), nullptr, nullptr, nullptr },
        { "frame_width", reinterpret_cast<getter>(SystemVideoProperties_get_FrameWidth), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SystemVideoProperties_get_Orientation), nullptr, nullptr, nullptr },
        { "total_bitrate", reinterpret_cast<getter>(SystemVideoProperties_get_TotalBitrate), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemVideoProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemVideoProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemVideoProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemVideoProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemVideoProperties) },
        { }};

    static PyType_Spec type_spec_SystemVideoProperties = {
        "winrt._winrt_windows_storage.SystemVideoProperties",
        sizeof(py::wrapper::Windows::Storage::SystemVideoProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemVideoProperties};

    // ----- UserDataPaths class --------------------

    static PyObject* _new_UserDataPaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::UserDataPaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::UserDataPaths>::type_name);
        return nullptr;
    }

    static void _dealloc_UserDataPaths(py::wrapper::Windows::Storage::UserDataPaths* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.UserDataPaths", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::UserDataPaths::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.UserDataPaths", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::UserDataPaths::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_CameraRoll(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"CameraRoll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CameraRoll();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Cookies(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Cookies");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cookies();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Desktop(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Desktop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Desktop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Documents(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Documents");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Documents();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Downloads(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Downloads");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Downloads();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Favorites(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Favorites");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Favorites();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_History(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"History");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.History();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_InternetCache(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"InternetCache");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InternetCache();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_LocalAppData(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"LocalAppData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalAppData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_LocalAppDataLow(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"LocalAppDataLow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalAppDataLow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Music(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Music");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Music();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Pictures(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Pictures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Pictures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Profile(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Profile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Profile();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Recent(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Recent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Recent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_RoamingAppData(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"RoamingAppData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingAppData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_SavedPictures(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"SavedPictures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SavedPictures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Screenshots(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Screenshots");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Screenshots();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Templates(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Templates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Templates();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Videos(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.UserDataPaths", L"Videos");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Videos();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::UserDataPaths>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::UserDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataPaths[] = {
        { "_assign_array_", _assign_array_UserDataPaths, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserDataPaths), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UserDataPaths[] = {
        { "camera_roll", reinterpret_cast<getter>(UserDataPaths_get_CameraRoll), nullptr, nullptr, nullptr },
        { "cookies", reinterpret_cast<getter>(UserDataPaths_get_Cookies), nullptr, nullptr, nullptr },
        { "desktop", reinterpret_cast<getter>(UserDataPaths_get_Desktop), nullptr, nullptr, nullptr },
        { "documents", reinterpret_cast<getter>(UserDataPaths_get_Documents), nullptr, nullptr, nullptr },
        { "downloads", reinterpret_cast<getter>(UserDataPaths_get_Downloads), nullptr, nullptr, nullptr },
        { "favorites", reinterpret_cast<getter>(UserDataPaths_get_Favorites), nullptr, nullptr, nullptr },
        { "history", reinterpret_cast<getter>(UserDataPaths_get_History), nullptr, nullptr, nullptr },
        { "internet_cache", reinterpret_cast<getter>(UserDataPaths_get_InternetCache), nullptr, nullptr, nullptr },
        { "local_app_data", reinterpret_cast<getter>(UserDataPaths_get_LocalAppData), nullptr, nullptr, nullptr },
        { "local_app_data_low", reinterpret_cast<getter>(UserDataPaths_get_LocalAppDataLow), nullptr, nullptr, nullptr },
        { "music", reinterpret_cast<getter>(UserDataPaths_get_Music), nullptr, nullptr, nullptr },
        { "pictures", reinterpret_cast<getter>(UserDataPaths_get_Pictures), nullptr, nullptr, nullptr },
        { "profile", reinterpret_cast<getter>(UserDataPaths_get_Profile), nullptr, nullptr, nullptr },
        { "recent", reinterpret_cast<getter>(UserDataPaths_get_Recent), nullptr, nullptr, nullptr },
        { "roaming_app_data", reinterpret_cast<getter>(UserDataPaths_get_RoamingAppData), nullptr, nullptr, nullptr },
        { "saved_pictures", reinterpret_cast<getter>(UserDataPaths_get_SavedPictures), nullptr, nullptr, nullptr },
        { "screenshots", reinterpret_cast<getter>(UserDataPaths_get_Screenshots), nullptr, nullptr, nullptr },
        { "templates", reinterpret_cast<getter>(UserDataPaths_get_Templates), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(UserDataPaths_get_Videos), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_UserDataPaths[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDataPaths) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserDataPaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDataPaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDataPaths) },
        { }};

    static PyType_Spec type_spec_UserDataPaths = {
        "winrt._winrt_windows_storage.UserDataPaths",
        sizeof(py::wrapper::Windows::Storage::UserDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataPaths};

    static PyGetSetDef getset_UserDataPaths_Static[] = {
        { }};

    static PyMethodDef methods_UserDataPaths_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(UserDataPaths_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(UserDataPaths_GetForUser), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_UserDataPaths_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UserDataPaths_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UserDataPaths_Static) },
        { }
    };

    static PyType_Spec type_spec_UserDataPaths_Static = {
        "winrt._winrt_windows_storage.UserDataPaths_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UserDataPaths_Static};

    // ----- IStorageFile interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageFile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFile>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageFile(py::wrapper::Windows::Storage::IStorageFile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFile_CopyAndReplaceAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"CopyAndReplaceAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CopyAndReplaceAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_CopyOverload(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"CopyAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CopyAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_CopyOverloadDefaultNameAndOptions(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"CopyAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CopyAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_CopyOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"CopyAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CopyAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_DeleteAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_DeleteAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"GetBasicPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBasicPropertiesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_IsOfType(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"IsOfType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsOfType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveAndReplaceAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"MoveAndReplaceAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveAndReplaceAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveOverload(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"MoveAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveOverloadDefaultNameAndOptions(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"MoveAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"MoveAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"OpenAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenReadAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStreamReference", L"OpenReadAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenReadAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenSequentialReadAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IInputStreamReference", L"OpenSequentialReadAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenSequentialReadAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile", L"OpenTransactedWriteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenTransactedWriteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_RenameAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_RenameAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_ContentType(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageFile", L"ContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_FileType(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageFile", L"FileType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Attributes(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Attributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Attributes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_DateCreated(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"DateCreated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateCreated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Name(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Path(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFile[] = {
        { "copy_and_replace_async", reinterpret_cast<PyCFunction>(IStorageFile_CopyAndReplaceAsync), METH_VARARGS, nullptr },
        { "copy_overload", reinterpret_cast<PyCFunction>(IStorageFile_CopyOverload), METH_VARARGS, nullptr },
        { "copy_overload_default_name_and_options", reinterpret_cast<PyCFunction>(IStorageFile_CopyOverloadDefaultNameAndOptions), METH_VARARGS, nullptr },
        { "copy_overload_default_options", reinterpret_cast<PyCFunction>(IStorageFile_CopyOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageFile_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageFile_DeleteAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageFile_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageFile_IsOfType), METH_VARARGS, nullptr },
        { "move_and_replace_async", reinterpret_cast<PyCFunction>(IStorageFile_MoveAndReplaceAsync), METH_VARARGS, nullptr },
        { "move_overload", reinterpret_cast<PyCFunction>(IStorageFile_MoveOverload), METH_VARARGS, nullptr },
        { "move_overload_default_name_and_options", reinterpret_cast<PyCFunction>(IStorageFile_MoveOverloadDefaultNameAndOptions), METH_VARARGS, nullptr },
        { "move_overload_default_options", reinterpret_cast<PyCFunction>(IStorageFile_MoveOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenAsync), METH_VARARGS, nullptr },
        { "open_read_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenReadAsync), METH_VARARGS, nullptr },
        { "open_sequential_read_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenSequentialReadAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageFile_RenameAsync), METH_VARARGS, nullptr },
        { "rename_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageFile_RenameAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageFile[] = {
        { "content_type", reinterpret_cast<getter>(IStorageFile_get_ContentType), nullptr, nullptr, nullptr },
        { "file_type", reinterpret_cast<getter>(IStorageFile_get_FileType), nullptr, nullptr, nullptr },
        { "attributes", reinterpret_cast<getter>(IStorageFile_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageFile_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageFile_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageFile_get_Path), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageFile[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFile) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFile) },
        { }};

    static PyType_Spec type_spec_IStorageFile = {
        "winrt._winrt_windows_storage._IStorageFile",
        sizeof(py::wrapper::Windows::Storage::IStorageFile),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageFile};

    struct ImplementsIStorageFile : py::ImplementsInterfaceT<ImplementsIStorageFile, winrt::Windows::Storage::IStorageFile>
    {
        ImplementsIStorageFile() = delete;
        ImplementsIStorageFile(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageFile, winrt::Windows::Storage::IStorageFile>(py_obj, runtime_class)
        {
        }

        auto CopyAndReplaceAsync(winrt::Windows::Storage::IStorageFile const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "copy_and_replace_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CopyAsync(winrt::Windows::Storage::IStorageFolder const& param0, winrt::hstring const& param1, winrt::Windows::Storage::NameCollisionOption param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "copy_overload")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CopyAsync(winrt::Windows::Storage::IStorageFolder const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "copy_overload_default_name_and_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CopyAsync(winrt::Windows::Storage::IStorageFolder const& param0, winrt::hstring const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "copy_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeleteAsync(winrt::Windows::Storage::StorageDeleteOption param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeleteAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetBasicPropertiesAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_basic_properties_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsOfType(winrt::Windows::Storage::StorageItemTypes param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_of_type")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveAndReplaceAsync(winrt::Windows::Storage::IStorageFile const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_and_replace_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveAsync(winrt::Windows::Storage::IStorageFolder const& param0, winrt::hstring const& param1, winrt::Windows::Storage::NameCollisionOption param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_overload")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveAsync(winrt::Windows::Storage::IStorageFolder const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_overload_default_name_and_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveAsync(winrt::Windows::Storage::IStorageFolder const& param0, winrt::hstring const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OpenAsync(winrt::Windows::Storage::FileAccessMode param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "open_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OpenReadAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "open_read_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OpenSequentialReadAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "open_sequential_read_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IInputStream>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OpenTransactedWriteAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "open_transacted_write_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RenameAsync(winrt::hstring const& param0, winrt::Windows::Storage::NameCollisionOption param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rename_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RenameAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rename_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContentType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "content_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FileType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "file_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Attributes()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "attributes")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::FileAttributes>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DateCreated()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "date_created")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Path()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "path")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageFile(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageFile>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageFile[] = {
        { "_assign_array_", _assign_array_IStorageFile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFile), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageFile), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageFile), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageFile[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageFile) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageFile = {
        "winrt._winrt_windows_storage.IStorageFile",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageFile};

    // ----- IStorageFile2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageFile2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFile2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFile2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageFile2(py::wrapper::Windows::Storage::IStorageFile2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFile2_OpenTransactedWriteWithOptionsAsync(py::wrapper::Windows::Storage::IStorageFile2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile2", L"OpenTransactedWriteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenTransactedWriteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile2_OpenWithOptionsAsync(py::wrapper::Windows::Storage::IStorageFile2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFile2", L"OpenAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.OpenAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFile2[] = {
        { "open_transacted_write_with_options_async", reinterpret_cast<PyCFunction>(IStorageFile2_OpenTransactedWriteWithOptionsAsync), METH_VARARGS, nullptr },
        { "open_with_options_async", reinterpret_cast<PyCFunction>(IStorageFile2_OpenWithOptionsAsync), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageFile2[] = {
        { }};

    static PyType_Slot _type_slots_IStorageFile2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFile2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFile2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFile2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFile2) },
        { }};

    static PyType_Spec type_spec_IStorageFile2 = {
        "winrt._winrt_windows_storage._IStorageFile2",
        sizeof(py::wrapper::Windows::Storage::IStorageFile2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageFile2};

    struct ImplementsIStorageFile2 : py::ImplementsInterfaceT<ImplementsIStorageFile2, winrt::Windows::Storage::IStorageFile2>
    {
        ImplementsIStorageFile2() = delete;
        ImplementsIStorageFile2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageFile2, winrt::Windows::Storage::IStorageFile2>(py_obj, runtime_class)
        {
        }

        auto OpenTransactedWriteAsync(winrt::Windows::Storage::StorageOpenOptions param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "open_transacted_write_with_options_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OpenAsync(winrt::Windows::Storage::FileAccessMode param0, winrt::Windows::Storage::StorageOpenOptions param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "open_with_options_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageFile2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFile2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFile2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFile2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageFile2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageFile2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageFile2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageFile2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageFile2[] = {
        { "_assign_array_", _assign_array_IStorageFile2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFile2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageFile2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageFile2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageFile2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageFile2) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageFile2 = {
        "winrt._winrt_windows_storage.IStorageFile2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageFile2};

    // ----- IStorageFilePropertiesWithAvailability interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageFilePropertiesWithAvailability(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageFilePropertiesWithAvailability(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFilePropertiesWithAvailability_get_IsAvailable(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageFilePropertiesWithAvailability", L"IsAvailable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAvailable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFilePropertiesWithAvailability[] = {
        { }};

    static PyGetSetDef _getset_IStorageFilePropertiesWithAvailability[] = {
        { "is_available", reinterpret_cast<getter>(IStorageFilePropertiesWithAvailability_get_IsAvailable), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageFilePropertiesWithAvailability[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFilePropertiesWithAvailability) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFilePropertiesWithAvailability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFilePropertiesWithAvailability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFilePropertiesWithAvailability) },
        { }};

    static PyType_Spec type_spec_IStorageFilePropertiesWithAvailability = {
        "winrt._winrt_windows_storage._IStorageFilePropertiesWithAvailability",
        sizeof(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageFilePropertiesWithAvailability};

    struct ImplementsIStorageFilePropertiesWithAvailability : py::ImplementsInterfaceT<ImplementsIStorageFilePropertiesWithAvailability, winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>
    {
        ImplementsIStorageFilePropertiesWithAvailability() = delete;
        ImplementsIStorageFilePropertiesWithAvailability(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageFilePropertiesWithAvailability, winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>(py_obj, runtime_class)
        {
        }

        auto IsAvailable()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_available")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageFilePropertiesWithAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFilePropertiesWithAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageFilePropertiesWithAvailability(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageFilePropertiesWithAvailability(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageFilePropertiesWithAvailability>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageFilePropertiesWithAvailability[] = {
        { "_assign_array_", _assign_array_IStorageFilePropertiesWithAvailability, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFilePropertiesWithAvailability), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageFilePropertiesWithAvailability), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageFilePropertiesWithAvailability), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageFilePropertiesWithAvailability[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageFilePropertiesWithAvailability) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageFilePropertiesWithAvailability = {
        "winrt._winrt_windows_storage.IStorageFilePropertiesWithAvailability",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageFilePropertiesWithAvailability};

    // ----- IStorageFolder interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageFolder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFolder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFolder>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageFolder(py::wrapper::Windows::Storage::IStorageFolder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFolder_CreateFileAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"CreateFileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_CreateFileAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"CreateFileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_CreateFolderAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"CreateFolderAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFolderAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_CreateFolderAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"CreateFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_DeleteAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_DeleteAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"GetBasicPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBasicPropertiesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFileAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetFileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFilesAsyncOverloadDefaultOptionsStartAndCount(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetFilesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFilesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFolderAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFoldersAsyncOverloadDefaultOptionsStartAndCount(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetFoldersAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFoldersAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetItemAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetItemAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetItemsAsyncOverloadDefaultStartAndCount(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder", L"GetItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_IsOfType(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"IsOfType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsOfType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_RenameAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_RenameAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Attributes(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Attributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Attributes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_DateCreated(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"DateCreated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateCreated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Name(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Path(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFolder[] = {
        { "create_file_async", reinterpret_cast<PyCFunction>(IStorageFolder_CreateFileAsync), METH_VARARGS, nullptr },
        { "create_file_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageFolder_CreateFileAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(IStorageFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "create_folder_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageFolder_CreateFolderAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageFolder_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageFolder_DeleteAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_file_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFileAsync), METH_VARARGS, nullptr },
        { "get_files_async_overload_default_options_start_and_count", reinterpret_cast<PyCFunction>(IStorageFolder_GetFilesAsyncOverloadDefaultOptionsStartAndCount), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_folders_async_overload_default_options_start_and_count", reinterpret_cast<PyCFunction>(IStorageFolder_GetFoldersAsyncOverloadDefaultOptionsStartAndCount), METH_VARARGS, nullptr },
        { "get_item_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetItemAsync), METH_VARARGS, nullptr },
        { "get_items_async_overload_default_start_and_count", reinterpret_cast<PyCFunction>(IStorageFolder_GetItemsAsyncOverloadDefaultStartAndCount), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageFolder_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageFolder_RenameAsync), METH_VARARGS, nullptr },
        { "rename_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageFolder_RenameAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageFolder[] = {
        { "attributes", reinterpret_cast<getter>(IStorageFolder_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageFolder_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageFolder_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageFolder_get_Path), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageFolder[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFolder) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFolder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFolder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFolder) },
        { }};

    static PyType_Spec type_spec_IStorageFolder = {
        "winrt._winrt_windows_storage._IStorageFolder",
        sizeof(py::wrapper::Windows::Storage::IStorageFolder),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageFolder};

    struct ImplementsIStorageFolder : py::ImplementsInterfaceT<ImplementsIStorageFolder, winrt::Windows::Storage::IStorageFolder>
    {
        ImplementsIStorageFolder() = delete;
        ImplementsIStorageFolder(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageFolder, winrt::Windows::Storage::IStorageFolder>(py_obj, runtime_class)
        {
        }

        auto CreateFileAsync(winrt::hstring const& param0, winrt::Windows::Storage::CreationCollisionOption param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_file_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateFileAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_file_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateFolderAsync(winrt::hstring const& param0, winrt::Windows::Storage::CreationCollisionOption param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_folder_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateFolderAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_folder_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeleteAsync(winrt::Windows::Storage::StorageDeleteOption param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeleteAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetBasicPropertiesAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_basic_properties_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetFileAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_file_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetFilesAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_files_async_overload_default_options_start_and_count")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetFolderAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_folder_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetFoldersAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_folders_async_overload_default_options_start_and_count")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetItemAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_item_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetItemsAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_items_async_overload_default_start_and_count")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsOfType(winrt::Windows::Storage::StorageItemTypes param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_of_type")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RenameAsync(winrt::hstring const& param0, winrt::Windows::Storage::NameCollisionOption param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rename_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RenameAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rename_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Attributes()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "attributes")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::FileAttributes>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DateCreated()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "date_created")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Path()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "path")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFolder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageFolder(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageFolder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageFolder>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageFolder[] = {
        { "_assign_array_", _assign_array_IStorageFolder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFolder), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageFolder), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageFolder), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageFolder[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageFolder) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageFolder = {
        "winrt._winrt_windows_storage.IStorageFolder",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageFolder};

    // ----- IStorageFolder2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageFolder2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageFolder2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageFolder2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageFolder2(py::wrapper::Windows::Storage::IStorageFolder2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageFolder2_TryGetItemAsync(py::wrapper::Windows::Storage::IStorageFolder2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageFolder2", L"TryGetItemAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetItemAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFolder2[] = {
        { "try_get_item_async", reinterpret_cast<PyCFunction>(IStorageFolder2_TryGetItemAsync), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageFolder2[] = {
        { }};

    static PyType_Slot _type_slots_IStorageFolder2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageFolder2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageFolder2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageFolder2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageFolder2) },
        { }};

    static PyType_Spec type_spec_IStorageFolder2 = {
        "winrt._winrt_windows_storage._IStorageFolder2",
        sizeof(py::wrapper::Windows::Storage::IStorageFolder2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageFolder2};

    struct ImplementsIStorageFolder2 : py::ImplementsInterfaceT<ImplementsIStorageFolder2, winrt::Windows::Storage::IStorageFolder2>
    {
        ImplementsIStorageFolder2() = delete;
        ImplementsIStorageFolder2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageFolder2, winrt::Windows::Storage::IStorageFolder2>(py_obj, runtime_class)
        {
        }

        auto TryGetItemAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_get_item_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageFolder2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageFolder2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageFolder2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFolder2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageFolder2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageFolder2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageFolder2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageFolder2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageFolder2[] = {
        { "_assign_array_", _assign_array_IStorageFolder2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFolder2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageFolder2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageFolder2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageFolder2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageFolder2) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageFolder2 = {
        "winrt._winrt_windows_storage.IStorageFolder2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageFolder2};

    // ----- IStorageItem interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItem>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageItem(py::wrapper::Windows::Storage::IStorageItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItem_DeleteAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_DeleteAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"GetBasicPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBasicPropertiesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_IsOfType(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"IsOfType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsOfType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_RenameAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_RenameAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Attributes(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Attributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Attributes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_DateCreated(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"DateCreated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateCreated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Name(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Path(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItem[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageItem_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageItem_DeleteAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageItem_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageItem_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageItem_RenameAsync), METH_VARARGS, nullptr },
        { "rename_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageItem_RenameAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageItem[] = {
        { "attributes", reinterpret_cast<getter>(IStorageItem_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageItem_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageItem_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageItem_get_Path), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageItem[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItem) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItem) },
        { }};

    static PyType_Spec type_spec_IStorageItem = {
        "winrt._winrt_windows_storage._IStorageItem",
        sizeof(py::wrapper::Windows::Storage::IStorageItem),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageItem};

    struct ImplementsIStorageItem : py::ImplementsInterfaceT<ImplementsIStorageItem, winrt::Windows::Storage::IStorageItem>
    {
        ImplementsIStorageItem() = delete;
        ImplementsIStorageItem(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageItem, winrt::Windows::Storage::IStorageItem>(py_obj, runtime_class)
        {
        }

        auto DeleteAsync(winrt::Windows::Storage::StorageDeleteOption param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeleteAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetBasicPropertiesAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_basic_properties_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsOfType(winrt::Windows::Storage::StorageItemTypes param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_of_type")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RenameAsync(winrt::hstring const& param0, winrt::Windows::Storage::NameCollisionOption param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rename_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RenameAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rename_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Attributes()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "attributes")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::FileAttributes>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DateCreated()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "date_created")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Path()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "path")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageItem(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageItem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageItem>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageItem[] = {
        { "_assign_array_", _assign_array_IStorageItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItem), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageItem), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageItem), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageItem[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageItem) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageItem = {
        "winrt._winrt_windows_storage.IStorageItem",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageItem};

    // ----- IStorageItem2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageItem2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItem2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItem2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageItem2(py::wrapper::Windows::Storage::IStorageItem2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItem2_DeleteAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_DeleteAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"GetBasicPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBasicPropertiesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_GetParentAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem2", L"GetParentAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetParentAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_IsEqual(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem2", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEqual(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_IsOfType(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"IsOfType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsOfType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_RenameAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_RenameAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItem", L"RenameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenameAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Attributes(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Attributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Attributes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_DateCreated(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"DateCreated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateCreated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Name(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Path(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItem", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItem2[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageItem2_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageItem2_DeleteAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageItem2_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_parent_async", reinterpret_cast<PyCFunction>(IStorageItem2_GetParentAsync), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(IStorageItem2_IsEqual), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageItem2_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageItem2_RenameAsync), METH_VARARGS, nullptr },
        { "rename_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageItem2_RenameAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageItem2[] = {
        { "attributes", reinterpret_cast<getter>(IStorageItem2_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageItem2_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageItem2_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageItem2_get_Path), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageItem2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItem2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItem2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItem2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItem2) },
        { }};

    static PyType_Spec type_spec_IStorageItem2 = {
        "winrt._winrt_windows_storage._IStorageItem2",
        sizeof(py::wrapper::Windows::Storage::IStorageItem2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageItem2};

    struct ImplementsIStorageItem2 : py::ImplementsInterfaceT<ImplementsIStorageItem2, winrt::Windows::Storage::IStorageItem2>
    {
        ImplementsIStorageItem2() = delete;
        ImplementsIStorageItem2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageItem2, winrt::Windows::Storage::IStorageItem2>(py_obj, runtime_class)
        {
        }

        auto DeleteAsync(winrt::Windows::Storage::StorageDeleteOption param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeleteAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetBasicPropertiesAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_basic_properties_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetParentAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_parent_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsEqual(winrt::Windows::Storage::IStorageItem const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_equal")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsOfType(winrt::Windows::Storage::StorageItemTypes param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_of_type")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RenameAsync(winrt::hstring const& param0, winrt::Windows::Storage::NameCollisionOption param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rename_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RenameAsync(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rename_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Attributes()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "attributes")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::FileAttributes>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DateCreated()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "date_created")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Path()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "path")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageItem2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItem2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItem2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItem2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageItem2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageItem2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageItem2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageItem2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageItem2[] = {
        { "_assign_array_", _assign_array_IStorageItem2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItem2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageItem2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageItem2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageItem2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageItem2) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageItem2 = {
        "winrt._winrt_windows_storage.IStorageItem2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageItem2};

    // ----- IStorageItemProperties interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageItemProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItemProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItemProperties>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageItemProperties(py::wrapper::Windows::Storage::IStorageItemProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItemProperties_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_GetThumbnailAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageItemProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(py::wrapper::Windows::Storage::IStorageItemProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"FolderRelativeId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FolderRelativeId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_Properties(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemProperties[] = {
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageItemProperties_GetThumbnailAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_size_default_options", reinterpret_cast<PyCFunction>(IStorageItemProperties_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageItemProperties[] = {
        { "display_name", reinterpret_cast<getter>(IStorageItemProperties_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemProperties_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemProperties_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemProperties_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageItemProperties[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItemProperties) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItemProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItemProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItemProperties) },
        { }};

    static PyType_Spec type_spec_IStorageItemProperties = {
        "winrt._winrt_windows_storage._IStorageItemProperties",
        sizeof(py::wrapper::Windows::Storage::IStorageItemProperties),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageItemProperties};

    struct ImplementsIStorageItemProperties : py::ImplementsInterfaceT<ImplementsIStorageItemProperties, winrt::Windows::Storage::IStorageItemProperties>
    {
        ImplementsIStorageItemProperties() = delete;
        ImplementsIStorageItemProperties(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageItemProperties, winrt::Windows::Storage::IStorageItemProperties>(py_obj, runtime_class)
        {
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0, uint32_t param1, winrt::Windows::Storage::FileProperties::ThumbnailOptions param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0, uint32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async_overload_default_size_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisplayName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "display_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisplayType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "display_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FolderRelativeId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "folder_relative_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Properties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::FileProperties::StorageItemContentProperties>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageItemProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItemProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItemProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageItemProperties(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageItemProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageItemProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageItemProperties>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageItemProperties[] = {
        { "_assign_array_", _assign_array_IStorageItemProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemProperties), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageItemProperties), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageItemProperties), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageItemProperties[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageItemProperties) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageItemProperties = {
        "winrt._winrt_windows_storage.IStorageItemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageItemProperties};

    // ----- IStorageItemProperties2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageItemProperties2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItemProperties2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItemProperties2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageItemProperties2(py::wrapper::Windows::Storage::IStorageItemProperties2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItemProperties2_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties2", L"GetScaledImageAsThumbnailAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties2", L"GetScaledImageAsThumbnailAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties2", L"GetScaledImageAsThumbnailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScaledImageAsThumbnailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_GetThumbnailAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"FolderRelativeId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FolderRelativeId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_Properties(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemProperties2[] = {
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetScaledImageAsThumbnailAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async_overload_default_size_default_options", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetThumbnailAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_size_default_options", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageItemProperties2[] = {
        { "display_name", reinterpret_cast<getter>(IStorageItemProperties2_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemProperties2_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemProperties2_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemProperties2_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageItemProperties2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItemProperties2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItemProperties2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItemProperties2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItemProperties2) },
        { }};

    static PyType_Spec type_spec_IStorageItemProperties2 = {
        "winrt._winrt_windows_storage._IStorageItemProperties2",
        sizeof(py::wrapper::Windows::Storage::IStorageItemProperties2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageItemProperties2};

    struct ImplementsIStorageItemProperties2 : py::ImplementsInterfaceT<ImplementsIStorageItemProperties2, winrt::Windows::Storage::IStorageItemProperties2>
    {
        ImplementsIStorageItemProperties2() = delete;
        ImplementsIStorageItemProperties2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageItemProperties2, winrt::Windows::Storage::IStorageItemProperties2>(py_obj, runtime_class)
        {
        }

        auto GetScaledImageAsThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0, uint32_t param1, winrt::Windows::Storage::FileProperties::ThumbnailOptions param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_scaled_image_as_thumbnail_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetScaledImageAsThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0, uint32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_scaled_image_as_thumbnail_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetScaledImageAsThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_scaled_image_as_thumbnail_async_overload_default_size_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0, uint32_t param1, winrt::Windows::Storage::FileProperties::ThumbnailOptions param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0, uint32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async_overload_default_size_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisplayName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "display_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisplayType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "display_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FolderRelativeId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "folder_relative_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Properties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::FileProperties::StorageItemContentProperties>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageItemProperties2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItemProperties2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItemProperties2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemProperties2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageItemProperties2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageItemProperties2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageItemProperties2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageItemProperties2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageItemProperties2[] = {
        { "_assign_array_", _assign_array_IStorageItemProperties2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemProperties2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageItemProperties2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageItemProperties2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageItemProperties2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageItemProperties2) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageItemProperties2 = {
        "winrt._winrt_windows_storage.IStorageItemProperties2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageItemProperties2};

    // ----- IStorageItemPropertiesWithProvider interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStorageItemPropertiesWithProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStorageItemPropertiesWithProvider(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageItemPropertiesWithProvider_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_GetThumbnailAsyncOverloadDefaultOptions(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStorageItemProperties", L"GetThumbnailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetThumbnailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_Provider(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemPropertiesWithProvider", L"Provider");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Provider();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"DisplayType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"FolderRelativeId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FolderRelativeId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_Properties(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.IStorageItemProperties", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemPropertiesWithProvider[] = {
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemPropertiesWithProvider_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_options", reinterpret_cast<PyCFunction>(IStorageItemPropertiesWithProvider_GetThumbnailAsyncOverloadDefaultOptions), METH_VARARGS, nullptr },
        { "get_thumbnail_async_overload_default_size_default_options", reinterpret_cast<PyCFunction>(IStorageItemPropertiesWithProvider_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageItemPropertiesWithProvider[] = {
        { "provider", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_Provider), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageItemPropertiesWithProvider[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageItemPropertiesWithProvider) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageItemPropertiesWithProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageItemPropertiesWithProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageItemPropertiesWithProvider) },
        { }};

    static PyType_Spec type_spec_IStorageItemPropertiesWithProvider = {
        "winrt._winrt_windows_storage._IStorageItemPropertiesWithProvider",
        sizeof(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStorageItemPropertiesWithProvider};

    struct ImplementsIStorageItemPropertiesWithProvider : py::ImplementsInterfaceT<ImplementsIStorageItemPropertiesWithProvider, winrt::Windows::Storage::IStorageItemPropertiesWithProvider>
    {
        ImplementsIStorageItemPropertiesWithProvider() = delete;
        ImplementsIStorageItemPropertiesWithProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageItemPropertiesWithProvider, winrt::Windows::Storage::IStorageItemPropertiesWithProvider>(py_obj, runtime_class)
        {
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0, uint32_t param1, winrt::Windows::Storage::FileProperties::ThumbnailOptions param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0, uint32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async_overload_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetThumbnailAsync(winrt::Windows::Storage::FileProperties::ThumbnailMode param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_thumbnail_async_overload_default_size_default_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Provider()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "provider")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::StorageProvider>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisplayName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "display_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisplayType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "display_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FolderRelativeId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "folder_relative_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Properties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::FileProperties::StorageItemContentProperties>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageItemPropertiesWithProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageItemPropertiesWithProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageItemPropertiesWithProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageItemPropertiesWithProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageItemPropertiesWithProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageItemPropertiesWithProvider[] = {
        { "_assign_array_", _assign_array_IStorageItemPropertiesWithProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemPropertiesWithProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageItemPropertiesWithProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageItemPropertiesWithProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageItemPropertiesWithProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageItemPropertiesWithProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageItemPropertiesWithProvider = {
        "winrt._winrt_windows_storage.IStorageItemPropertiesWithProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStorageItemPropertiesWithProvider};

    // ----- IStreamedFileDataRequest interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStreamedFileDataRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::IStreamedFileDataRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::IStreamedFileDataRequest>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStreamedFileDataRequest(py::wrapper::Windows::Storage::IStreamedFileDataRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStreamedFileDataRequest_FailAndClose(py::wrapper::Windows::Storage::IStreamedFileDataRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.IStreamedFileDataRequest", L"FailAndClose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.FailAndClose(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStreamedFileDataRequest[] = {
        { "fail_and_close", reinterpret_cast<PyCFunction>(IStreamedFileDataRequest_FailAndClose), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStreamedFileDataRequest[] = {
        { }};

    static PyType_Slot _type_slots_IStreamedFileDataRequest[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStreamedFileDataRequest) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStreamedFileDataRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStreamedFileDataRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStreamedFileDataRequest) },
        { }};

    static PyType_Spec type_spec_IStreamedFileDataRequest = {
        "winrt._winrt_windows_storage._IStreamedFileDataRequest",
        sizeof(py::wrapper::Windows::Storage::IStreamedFileDataRequest),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStreamedFileDataRequest};

    struct ImplementsIStreamedFileDataRequest : py::ImplementsInterfaceT<ImplementsIStreamedFileDataRequest, winrt::Windows::Storage::IStreamedFileDataRequest>
    {
        ImplementsIStreamedFileDataRequest() = delete;
        ImplementsIStreamedFileDataRequest(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStreamedFileDataRequest, winrt::Windows::Storage::IStreamedFileDataRequest>(py_obj, runtime_class)
        {
        }

        auto FailAndClose(winrt::Windows::Storage::StreamedFileFailureMode param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "fail_and_close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::IStreamedFileDataRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStreamedFileDataRequest(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::IStreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStreamedFileDataRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStreamedFileDataRequest>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStreamedFileDataRequest[] = {
        { "_assign_array_", _assign_array_IStreamedFileDataRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStreamedFileDataRequest), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStreamedFileDataRequest), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStreamedFileDataRequest), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStreamedFileDataRequest[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStreamedFileDataRequest) },
        { }};

    static PyType_Spec type_spec_ImplementsIStreamedFileDataRequest = {
        "winrt._winrt_windows_storage.IStreamedFileDataRequest",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStreamedFileDataRequest};

    // ----- Windows.Storage Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Storage");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_storage",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Storage

PyMODINIT_FUNC PyInit__winrt_windows_storage(void) noexcept
{
    using namespace py::cpp::Windows::Storage;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle AppDataPaths_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AppDataPaths_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppDataPaths_Static{PyType_FromSpecWithBases(&type_spec_AppDataPaths_Static, AppDataPaths_Static_bases.get())};
    if (!type_AppDataPaths_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppDataPaths_type{py::register_python_type(module.get(), &type_spec_AppDataPaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppDataPaths_Static.get()))};
    if (!AppDataPaths_type)
    {
        return nullptr;
    }

    py::pyobj_handle ApplicationData_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ApplicationData_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ApplicationData_Static{PyType_FromSpecWithBases(&type_spec_ApplicationData_Static, ApplicationData_Static_bases.get())};
    if (!type_ApplicationData_Static)
    {
        return nullptr;
    }

    py::pytype_handle ApplicationData_type{py::register_python_type(module.get(), &type_spec_ApplicationData, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ApplicationData_Static.get()))};
    if (!ApplicationData_type)
    {
        return nullptr;
    }

    py::pytype_handle ApplicationDataCompositeValue_type{py::register_python_type(module.get(), &type_spec_ApplicationDataCompositeValue, object_bases.get(), inspectable_meta_type)};
    if (!ApplicationDataCompositeValue_type)
    {
        return nullptr;
    }

    py::pytype_handle ApplicationDataContainer_type{py::register_python_type(module.get(), &type_spec_ApplicationDataContainer, object_bases.get(), inspectable_meta_type)};
    if (!ApplicationDataContainer_type)
    {
        return nullptr;
    }

    py::pytype_handle ApplicationDataContainerSettings_type{py::register_python_type(module.get(), &type_spec_ApplicationDataContainerSettings, object_bases.get(), inspectable_meta_type)};
    if (!ApplicationDataContainerSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CachedFileManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!CachedFileManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CachedFileManager_Static{PyType_FromSpecWithBases(&type_spec_CachedFileManager_Static, CachedFileManager_Static_bases.get())};
    if (!type_CachedFileManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle CachedFileManager_type{py::register_python_type(module.get(), &type_spec_CachedFileManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CachedFileManager_Static.get()))};
    if (!CachedFileManager_type)
    {
        return nullptr;
    }

    py::pyobj_handle DownloadsFolder_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!DownloadsFolder_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DownloadsFolder_Static{PyType_FromSpecWithBases(&type_spec_DownloadsFolder_Static, DownloadsFolder_Static_bases.get())};
    if (!type_DownloadsFolder_Static)
    {
        return nullptr;
    }

    py::pytype_handle DownloadsFolder_type{py::register_python_type(module.get(), &type_spec_DownloadsFolder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DownloadsFolder_Static.get()))};
    if (!DownloadsFolder_type)
    {
        return nullptr;
    }

    py::pyobj_handle FileIO_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!FileIO_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FileIO_Static{PyType_FromSpecWithBases(&type_spec_FileIO_Static, FileIO_Static_bases.get())};
    if (!type_FileIO_Static)
    {
        return nullptr;
    }

    py::pytype_handle FileIO_type{py::register_python_type(module.get(), &type_spec_FileIO, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FileIO_Static.get()))};
    if (!FileIO_type)
    {
        return nullptr;
    }

    py::pyobj_handle KnownFolders_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!KnownFolders_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownFolders_Static{PyType_FromSpecWithBases(&type_spec_KnownFolders_Static, KnownFolders_Static_bases.get())};
    if (!type_KnownFolders_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownFolders_type{py::register_python_type(module.get(), &type_spec_KnownFolders, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownFolders_Static.get()))};
    if (!KnownFolders_type)
    {
        return nullptr;
    }

    py::pyobj_handle PathIO_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PathIO_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PathIO_Static{PyType_FromSpecWithBases(&type_spec_PathIO_Static, PathIO_Static_bases.get())};
    if (!type_PathIO_Static)
    {
        return nullptr;
    }

    py::pytype_handle PathIO_type{py::register_python_type(module.get(), &type_spec_PathIO, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PathIO_Static.get()))};
    if (!PathIO_type)
    {
        return nullptr;
    }

    py::pytype_handle SetVersionDeferral_type{py::register_python_type(module.get(), &type_spec_SetVersionDeferral, object_bases.get(), inspectable_meta_type)};
    if (!SetVersionDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle SetVersionRequest_type{py::register_python_type(module.get(), &type_spec_SetVersionRequest, object_bases.get(), inspectable_meta_type)};
    if (!SetVersionRequest_type)
    {
        return nullptr;
    }

    py::pyobj_handle StorageFile_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!StorageFile_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageFile_Static{PyType_FromSpecWithBases(&type_spec_StorageFile_Static, StorageFile_Static_bases.get())};
    if (!type_StorageFile_Static)
    {
        return nullptr;
    }

    py::pytype_handle StorageFile_type{py::register_python_type(module.get(), &type_spec_StorageFile, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageFile_Static.get()))};
    if (!StorageFile_type)
    {
        return nullptr;
    }

    py::pyobj_handle StorageFolder_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!StorageFolder_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageFolder_Static{PyType_FromSpecWithBases(&type_spec_StorageFolder_Static, StorageFolder_Static_bases.get())};
    if (!type_StorageFolder_Static)
    {
        return nullptr;
    }

    py::pytype_handle StorageFolder_type{py::register_python_type(module.get(), &type_spec_StorageFolder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageFolder_Static.get()))};
    if (!StorageFolder_type)
    {
        return nullptr;
    }

    py::pyobj_handle StorageLibrary_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!StorageLibrary_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageLibrary_Static{PyType_FromSpecWithBases(&type_spec_StorageLibrary_Static, StorageLibrary_Static_bases.get())};
    if (!type_StorageLibrary_Static)
    {
        return nullptr;
    }

    py::pytype_handle StorageLibrary_type{py::register_python_type(module.get(), &type_spec_StorageLibrary, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageLibrary_Static.get()))};
    if (!StorageLibrary_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageLibraryChange_type{py::register_python_type(module.get(), &type_spec_StorageLibraryChange, object_bases.get(), inspectable_meta_type)};
    if (!StorageLibraryChange_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageLibraryChangeReader_type{py::register_python_type(module.get(), &type_spec_StorageLibraryChangeReader, object_bases.get(), inspectable_meta_type)};
    if (!StorageLibraryChangeReader_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageLibraryChangeTracker_type{py::register_python_type(module.get(), &type_spec_StorageLibraryChangeTracker, object_bases.get(), inspectable_meta_type)};
    if (!StorageLibraryChangeTracker_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageLibraryChangeTrackerOptions_type{py::register_python_type(module.get(), &type_spec_StorageLibraryChangeTrackerOptions, object_bases.get(), inspectable_meta_type)};
    if (!StorageLibraryChangeTrackerOptions_type)
    {
        return nullptr;
    }

    py::pyobj_handle StorageLibraryLastChangeId_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!StorageLibraryLastChangeId_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageLibraryLastChangeId_Static{PyType_FromSpecWithBases(&type_spec_StorageLibraryLastChangeId_Static, StorageLibraryLastChangeId_Static_bases.get())};
    if (!type_StorageLibraryLastChangeId_Static)
    {
        return nullptr;
    }

    py::pytype_handle StorageLibraryLastChangeId_type{py::register_python_type(module.get(), &type_spec_StorageLibraryLastChangeId, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageLibraryLastChangeId_Static.get()))};
    if (!StorageLibraryLastChangeId_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProvider_type{py::register_python_type(module.get(), &type_spec_StorageProvider, object_bases.get(), inspectable_meta_type)};
    if (!StorageProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageStreamTransaction_type{py::register_python_type(module.get(), &type_spec_StorageStreamTransaction, object_bases.get(), inspectable_meta_type)};
    if (!StorageStreamTransaction_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamedFileDataRequest_type{py::register_python_type(module.get(), &type_spec_StreamedFileDataRequest, object_bases.get(), inspectable_meta_type)};
    if (!StreamedFileDataRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemAudioProperties_type{py::register_python_type(module.get(), &type_spec_SystemAudioProperties, object_bases.get(), inspectable_meta_type)};
    if (!SystemAudioProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle SystemDataPaths_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SystemDataPaths_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemDataPaths_Static{PyType_FromSpecWithBases(&type_spec_SystemDataPaths_Static, SystemDataPaths_Static_bases.get())};
    if (!type_SystemDataPaths_Static)
    {
        return nullptr;
    }

    py::pytype_handle SystemDataPaths_type{py::register_python_type(module.get(), &type_spec_SystemDataPaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemDataPaths_Static.get()))};
    if (!SystemDataPaths_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemGPSProperties_type{py::register_python_type(module.get(), &type_spec_SystemGPSProperties, object_bases.get(), inspectable_meta_type)};
    if (!SystemGPSProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemImageProperties_type{py::register_python_type(module.get(), &type_spec_SystemImageProperties, object_bases.get(), inspectable_meta_type)};
    if (!SystemImageProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemMediaProperties_type{py::register_python_type(module.get(), &type_spec_SystemMediaProperties, object_bases.get(), inspectable_meta_type)};
    if (!SystemMediaProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemMusicProperties_type{py::register_python_type(module.get(), &type_spec_SystemMusicProperties, object_bases.get(), inspectable_meta_type)};
    if (!SystemMusicProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemPhotoProperties_type{py::register_python_type(module.get(), &type_spec_SystemPhotoProperties, object_bases.get(), inspectable_meta_type)};
    if (!SystemPhotoProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle SystemProperties_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SystemProperties_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemProperties_Static{PyType_FromSpecWithBases(&type_spec_SystemProperties_Static, SystemProperties_Static_bases.get())};
    if (!type_SystemProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle SystemProperties_type{py::register_python_type(module.get(), &type_spec_SystemProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemProperties_Static.get()))};
    if (!SystemProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemVideoProperties_type{py::register_python_type(module.get(), &type_spec_SystemVideoProperties, object_bases.get(), inspectable_meta_type)};
    if (!SystemVideoProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle UserDataPaths_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!UserDataPaths_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_UserDataPaths_Static{PyType_FromSpecWithBases(&type_spec_UserDataPaths_Static, UserDataPaths_Static_bases.get())};
    if (!type_UserDataPaths_Static)
    {
        return nullptr;
    }

    py::pytype_handle UserDataPaths_type{py::register_python_type(module.get(), &type_spec_UserDataPaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UserDataPaths_Static.get()))};
    if (!UserDataPaths_type)
    {
        return nullptr;
    }

    py::pytype_handle IStorageFile_type{py::register_python_type(module.get(), &type_spec_IStorageFile, object_bases.get(), nullptr)};
    if (!IStorageFile_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageFile_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageFile, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageFile_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageFile_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageFile2_type{py::register_python_type(module.get(), &type_spec_IStorageFile2, object_bases.get(), nullptr)};
    if (!IStorageFile2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageFile2_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageFile2, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageFile2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageFile2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageFilePropertiesWithAvailability_type{py::register_python_type(module.get(), &type_spec_IStorageFilePropertiesWithAvailability, object_bases.get(), nullptr)};
    if (!IStorageFilePropertiesWithAvailability_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageFilePropertiesWithAvailability_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageFilePropertiesWithAvailability, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageFilePropertiesWithAvailability_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageFilePropertiesWithAvailability_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageFolder_type{py::register_python_type(module.get(), &type_spec_IStorageFolder, object_bases.get(), nullptr)};
    if (!IStorageFolder_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageFolder_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageFolder, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageFolder_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageFolder_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageFolder2_type{py::register_python_type(module.get(), &type_spec_IStorageFolder2, object_bases.get(), nullptr)};
    if (!IStorageFolder2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageFolder2_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageFolder2, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageFolder2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageFolder2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageItem_type{py::register_python_type(module.get(), &type_spec_IStorageItem, object_bases.get(), nullptr)};
    if (!IStorageItem_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageItem_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageItem, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageItem_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageItem_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageItem2_type{py::register_python_type(module.get(), &type_spec_IStorageItem2, object_bases.get(), nullptr)};
    if (!IStorageItem2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageItem2_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageItem2, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageItem2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageItem2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageItemProperties_type{py::register_python_type(module.get(), &type_spec_IStorageItemProperties, object_bases.get(), nullptr)};
    if (!IStorageItemProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageItemProperties_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageItemProperties, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageItemProperties_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageItemProperties_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageItemProperties2_type{py::register_python_type(module.get(), &type_spec_IStorageItemProperties2, object_bases.get(), nullptr)};
    if (!IStorageItemProperties2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageItemProperties2_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageItemProperties2, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageItemProperties2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageItemProperties2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageItemPropertiesWithProvider_type{py::register_python_type(module.get(), &type_spec_IStorageItemPropertiesWithProvider, object_bases.get(), nullptr)};
    if (!IStorageItemPropertiesWithProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageItemPropertiesWithProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIStorageItemPropertiesWithProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIStorageItemPropertiesWithProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageItemPropertiesWithProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStreamedFileDataRequest_type{py::register_python_type(module.get(), &type_spec_IStreamedFileDataRequest, object_bases.get(), nullptr)};
    if (!IStreamedFileDataRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStreamedFileDataRequest_type{py::register_python_type(module.get(), &type_spec_ImplementsIStreamedFileDataRequest, nullptr, inspectable_meta_type)};
    if (!ImplementsIStreamedFileDataRequest_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStreamedFileDataRequest_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
