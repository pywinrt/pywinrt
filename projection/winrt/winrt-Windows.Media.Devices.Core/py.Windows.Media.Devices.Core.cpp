// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Media.Devices.Core.h"

namespace py::cpp::Windows::Media::Devices::Core
{
    // ----- CameraIntrinsics class --------------------

    static PyObject* _new_CameraIntrinsics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                winrt::Windows::Media::Devices::Core::CameraIntrinsics instance{param0, param1, param2, param3, param4, param5};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CameraIntrinsics(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraIntrinsics_DistortPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"DistortPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DistortPoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_DistortPoints(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"DistortPoints", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.DistortPoints(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_ProjectManyOntoFrame(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"ProjectManyOntoFrame", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.ProjectManyOntoFrame(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_ProjectOntoFrame(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"ProjectOntoFrame", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProjectOntoFrame(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UndistortPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UndistortPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UndistortPoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UndistortPoints(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UndistortPoints", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.UndistortPoints(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UnprojectAtUnitDepth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UnprojectAtUnitDepth", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UnprojectAtUnitDepth(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UnprojectPixelsAtUnitDepth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UnprojectPixelsAtUnitDepth", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float2, true>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.UnprojectPixelsAtUnitDepth(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_FocalLength(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"FocalLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FocalLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_ImageHeight(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"ImageHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImageHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_ImageWidth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"ImageWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImageWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_PrincipalPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"PrincipalPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrincipalPoint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_RadialDistortion(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"RadialDistortion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RadialDistortion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_TangentialDistortion(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"TangentialDistortion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TangentialDistortion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_UndistortedProjectionTransform(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UndistortedProjectionTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UndistortedProjectionTransform();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::CameraIntrinsics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::CameraIntrinsics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraIntrinsics[] = {
        { "distort_point", reinterpret_cast<PyCFunction>(CameraIntrinsics_DistortPoint), METH_VARARGS, nullptr },
        { "distort_points", reinterpret_cast<PyCFunction>(CameraIntrinsics_DistortPoints), METH_VARARGS, nullptr },
        { "project_many_onto_frame", reinterpret_cast<PyCFunction>(CameraIntrinsics_ProjectManyOntoFrame), METH_VARARGS, nullptr },
        { "project_onto_frame", reinterpret_cast<PyCFunction>(CameraIntrinsics_ProjectOntoFrame), METH_VARARGS, nullptr },
        { "undistort_point", reinterpret_cast<PyCFunction>(CameraIntrinsics_UndistortPoint), METH_VARARGS, nullptr },
        { "undistort_points", reinterpret_cast<PyCFunction>(CameraIntrinsics_UndistortPoints), METH_VARARGS, nullptr },
        { "unproject_at_unit_depth", reinterpret_cast<PyCFunction>(CameraIntrinsics_UnprojectAtUnitDepth), METH_VARARGS, nullptr },
        { "unproject_pixels_at_unit_depth", reinterpret_cast<PyCFunction>(CameraIntrinsics_UnprojectPixelsAtUnitDepth), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CameraIntrinsics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraIntrinsics), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CameraIntrinsics[] = {
        { "focal_length", reinterpret_cast<getter>(CameraIntrinsics_get_FocalLength), nullptr, nullptr, nullptr },
        { "image_height", reinterpret_cast<getter>(CameraIntrinsics_get_ImageHeight), nullptr, nullptr, nullptr },
        { "image_width", reinterpret_cast<getter>(CameraIntrinsics_get_ImageWidth), nullptr, nullptr, nullptr },
        { "principal_point", reinterpret_cast<getter>(CameraIntrinsics_get_PrincipalPoint), nullptr, nullptr, nullptr },
        { "radial_distortion", reinterpret_cast<getter>(CameraIntrinsics_get_RadialDistortion), nullptr, nullptr, nullptr },
        { "tangential_distortion", reinterpret_cast<getter>(CameraIntrinsics_get_TangentialDistortion), nullptr, nullptr, nullptr },
        { "undistorted_projection_transform", reinterpret_cast<getter>(CameraIntrinsics_get_UndistortedProjectionTransform), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CameraIntrinsics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraIntrinsics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraIntrinsics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraIntrinsics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraIntrinsics) },
        { }};

    static PyType_Spec type_spec_CameraIntrinsics = {
        "winrt._winrt_windows_media_devices_core.CameraIntrinsics",
        sizeof(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraIntrinsics};

    // ----- DepthCorrelatedCoordinateMapper class --------------------

    static PyObject* _new_DepthCorrelatedCoordinateMapper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>::type_name);
        return nullptr;
    }

    static void _dealloc_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DepthCorrelatedCoordinateMapper_Close(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_MapPoint(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"MapPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Devices::Core::CameraIntrinsics>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MapPoint(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_MapPoints(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"MapPoints", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Devices::Core::CameraIntrinsics>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.MapPoints(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_UnprojectPoint(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"UnprojectPoint", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UnprojectPoint(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_UnprojectPoints(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"UnprojectPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, true>>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.UnprojectPoints(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DepthCorrelatedCoordinateMapper[] = {
        { "close", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_Close), METH_VARARGS, nullptr },
        { "map_point", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_MapPoint), METH_VARARGS, nullptr },
        { "map_points", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_MapPoints), METH_VARARGS, nullptr },
        { "unproject_point", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_UnprojectPoint), METH_VARARGS, nullptr },
        { "unproject_points", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_UnprojectPoints), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DepthCorrelatedCoordinateMapper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DepthCorrelatedCoordinateMapper), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DepthCorrelatedCoordinateMapper), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_DepthCorrelatedCoordinateMapper), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_DepthCorrelatedCoordinateMapper[] = {
        { }};

    static PyType_Slot _type_slots_DepthCorrelatedCoordinateMapper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DepthCorrelatedCoordinateMapper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DepthCorrelatedCoordinateMapper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DepthCorrelatedCoordinateMapper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DepthCorrelatedCoordinateMapper) },
        { }};

    static PyType_Spec type_spec_DepthCorrelatedCoordinateMapper = {
        "winrt._winrt_windows_media_devices_core.DepthCorrelatedCoordinateMapper",
        sizeof(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DepthCorrelatedCoordinateMapper};

    // ----- FrameControlCapabilities class --------------------

    static PyObject* _new_FrameControlCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameControlCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameControlCapabilities_get_Exposure(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"Exposure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Exposure();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_ExposureCompensation(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"ExposureCompensation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExposureCompensation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_Focus(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"Focus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Focus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_IsoSpeed(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"IsoSpeed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsoSpeed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_PhotoConfirmationSupported(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"PhotoConfirmationSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotoConfirmationSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_Flash(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"Flash");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Flash();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameControlCapabilities[] = {
        { "_assign_array_", _assign_array_FrameControlCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameControlCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameControlCapabilities[] = {
        { "exposure", reinterpret_cast<getter>(FrameControlCapabilities_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(FrameControlCapabilities_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { "focus", reinterpret_cast<getter>(FrameControlCapabilities_get_Focus), nullptr, nullptr, nullptr },
        { "iso_speed", reinterpret_cast<getter>(FrameControlCapabilities_get_IsoSpeed), nullptr, nullptr, nullptr },
        { "photo_confirmation_supported", reinterpret_cast<getter>(FrameControlCapabilities_get_PhotoConfirmationSupported), nullptr, nullptr, nullptr },
        { "flash", reinterpret_cast<getter>(FrameControlCapabilities_get_Flash), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameControlCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameControlCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameControlCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameControlCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameControlCapabilities) },
        { }};

    static PyType_Spec type_spec_FrameControlCapabilities = {
        "winrt._winrt_windows_media_devices_core.FrameControlCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameControlCapabilities};

    // ----- FrameController class --------------------

    static PyObject* _new_FrameController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::Core::FrameController instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameController(py::wrapper::Windows::Media::Devices::Core::FrameController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameController_get_PhotoConfirmationEnabled(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"PhotoConfirmationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotoConfirmationEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameController_put_PhotoConfirmationEnabled(py::wrapper::Windows::Media::Devices::Core::FrameController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"PhotoConfirmationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            {
                auto _gil = release_gil();
                self->obj.PhotoConfirmationEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameController_get_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"ExposureCompensationControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExposureCompensationControl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_ExposureControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"ExposureControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExposureControl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_FocusControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"FocusControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FocusControl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_IsoSpeedControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"IsoSpeedControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsoSpeedControl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_FlashControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"FlashControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FlashControl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameController[] = {
        { "_assign_array_", _assign_array_FrameController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameController), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameController[] = {
        { "photo_confirmation_enabled", reinterpret_cast<getter>(FrameController_get_PhotoConfirmationEnabled), reinterpret_cast<setter>(FrameController_put_PhotoConfirmationEnabled), nullptr, nullptr },
        { "exposure_compensation_control", reinterpret_cast<getter>(FrameController_get_ExposureCompensationControl), nullptr, nullptr, nullptr },
        { "exposure_control", reinterpret_cast<getter>(FrameController_get_ExposureControl), nullptr, nullptr, nullptr },
        { "focus_control", reinterpret_cast<getter>(FrameController_get_FocusControl), nullptr, nullptr, nullptr },
        { "iso_speed_control", reinterpret_cast<getter>(FrameController_get_IsoSpeedControl), nullptr, nullptr, nullptr },
        { "flash_control", reinterpret_cast<getter>(FrameController_get_FlashControl), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameController) },
        { }};

    static PyType_Spec type_spec_FrameController = {
        "winrt._winrt_windows_media_devices_core.FrameController",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameController};

    // ----- FrameExposureCapabilities class --------------------

    static PyObject* _new_FrameExposureCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameExposureCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameExposureCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCapabilities", L"Max");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Max();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCapabilities", L"Min");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Min();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCapabilities", L"Step");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Step();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCapabilities", L"Supported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Supported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameExposureCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameExposureCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCapabilities[] = {
        { "_assign_array_", _assign_array_FrameExposureCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameExposureCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameExposureCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameExposureCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameExposureCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameExposureCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameExposureCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameExposureCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameExposureCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameExposureCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameExposureCapabilities) },
        { }};

    static PyType_Spec type_spec_FrameExposureCapabilities = {
        "winrt._winrt_windows_media_devices_core.FrameExposureCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCapabilities};

    // ----- FrameExposureCompensationCapabilities class --------------------

    static PyObject* _new_FrameExposureCompensationCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameExposureCompensationCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationCapabilities", L"Max");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Max();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationCapabilities", L"Min");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Min();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationCapabilities", L"Step");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Step();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationCapabilities", L"Supported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Supported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameExposureCompensationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameExposureCompensationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCompensationCapabilities[] = {
        { "_assign_array_", _assign_array_FrameExposureCompensationCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCompensationCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameExposureCompensationCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameExposureCompensationCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameExposureCompensationCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameExposureCompensationCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameExposureCompensationCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameExposureCompensationCapabilities) },
        { }};

    static PyType_Spec type_spec_FrameExposureCompensationCapabilities = {
        "winrt._winrt_windows_media_devices_core.FrameExposureCompensationCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCompensationCapabilities};

    // ----- FrameExposureCompensationControl class --------------------

    static PyObject* _new_FrameExposureCompensationControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameExposureCompensationControl(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameExposureCompensationControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureCompensationControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCompensationControl[] = {
        { "_assign_array_", _assign_array_FrameExposureCompensationControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCompensationControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameExposureCompensationControl[] = {
        { "value", reinterpret_cast<getter>(FrameExposureCompensationControl_get_Value), reinterpret_cast<setter>(FrameExposureCompensationControl_put_Value), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameExposureCompensationControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameExposureCompensationControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameExposureCompensationControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameExposureCompensationControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameExposureCompensationControl) },
        { }};

    static PyType_Spec type_spec_FrameExposureCompensationControl = {
        "winrt._winrt_windows_media_devices_core.FrameExposureCompensationControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCompensationControl};

    // ----- FrameExposureControl class --------------------

    static PyObject* _new_FrameExposureControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameExposureControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameExposureControl>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameExposureControl(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameExposureControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameExposureControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureControl", L"Auto");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Auto();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureControl", L"Auto");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Auto(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameExposureControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureControl[] = {
        { "_assign_array_", _assign_array_FrameExposureControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameExposureControl[] = {
        { "value", reinterpret_cast<getter>(FrameExposureControl_get_Value), reinterpret_cast<setter>(FrameExposureControl_put_Value), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameExposureControl_get_Auto), reinterpret_cast<setter>(FrameExposureControl_put_Auto), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameExposureControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameExposureControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameExposureControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameExposureControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameExposureControl) },
        { }};

    static PyType_Spec type_spec_FrameExposureControl = {
        "winrt._winrt_windows_media_devices_core.FrameExposureControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureControl};

    // ----- FrameFlashCapabilities class --------------------

    static PyObject* _new_FrameFlashCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameFlashCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameFlashCapabilities_get_PowerSupported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashCapabilities", L"PowerSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PowerSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFlashCapabilities_get_RedEyeReductionSupported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashCapabilities", L"RedEyeReductionSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RedEyeReductionSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFlashCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashCapabilities", L"Supported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Supported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameFlashCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameFlashCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFlashCapabilities[] = {
        { "_assign_array_", _assign_array_FrameFlashCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFlashCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameFlashCapabilities[] = {
        { "power_supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_PowerSupported), nullptr, nullptr, nullptr },
        { "red_eye_reduction_supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_RedEyeReductionSupported), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameFlashCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameFlashCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameFlashCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameFlashCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameFlashCapabilities) },
        { }};

    static PyType_Spec type_spec_FrameFlashCapabilities = {
        "winrt._winrt_windows_media_devices_core.FrameFlashCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFlashCapabilities};

    // ----- FrameFlashControl class --------------------

    static PyObject* _new_FrameFlashControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameFlashControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameFlashControl>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameFlashControl(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameFlashControl_get_RedEyeReduction(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"RedEyeReduction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RedEyeReduction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_RedEyeReduction(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"RedEyeReduction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.RedEyeReduction(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"PowerPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PowerPercent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"PowerPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.PowerPercent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_Mode(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Mode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_Mode(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Devices::Core::FrameFlashMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.Mode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"Auto");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Auto();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"Auto");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Auto(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameFlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameFlashControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameFlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFlashControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFlashControl[] = {
        { "_assign_array_", _assign_array_FrameFlashControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFlashControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameFlashControl[] = {
        { "red_eye_reduction", reinterpret_cast<getter>(FrameFlashControl_get_RedEyeReduction), reinterpret_cast<setter>(FrameFlashControl_put_RedEyeReduction), nullptr, nullptr },
        { "power_percent", reinterpret_cast<getter>(FrameFlashControl_get_PowerPercent), reinterpret_cast<setter>(FrameFlashControl_put_PowerPercent), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(FrameFlashControl_get_Mode), reinterpret_cast<setter>(FrameFlashControl_put_Mode), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameFlashControl_get_Auto), reinterpret_cast<setter>(FrameFlashControl_put_Auto), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameFlashControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameFlashControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameFlashControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameFlashControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameFlashControl) },
        { }};

    static PyType_Spec type_spec_FrameFlashControl = {
        "winrt._winrt_windows_media_devices_core.FrameFlashControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFlashControl};

    // ----- FrameFocusCapabilities class --------------------

    static PyObject* _new_FrameFocusCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameFocusCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameFocusCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusCapabilities", L"Max");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Max();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusCapabilities", L"Min");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Min();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusCapabilities", L"Step");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Step();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusCapabilities", L"Supported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Supported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameFocusCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameFocusCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFocusCapabilities[] = {
        { "_assign_array_", _assign_array_FrameFocusCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFocusCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameFocusCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameFocusCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameFocusCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameFocusCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameFocusCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameFocusCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameFocusCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameFocusCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameFocusCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameFocusCapabilities) },
        { }};

    static PyType_Spec type_spec_FrameFocusCapabilities = {
        "winrt._winrt_windows_media_devices_core.FrameFocusCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFocusCapabilities};

    // ----- FrameFocusControl class --------------------

    static PyObject* _new_FrameFocusControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameFocusControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameFocusControl>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameFocusControl(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameFocusControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFocusControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameFocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameFocusControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameFocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFocusControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFocusControl[] = {
        { "_assign_array_", _assign_array_FrameFocusControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFocusControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameFocusControl[] = {
        { "value", reinterpret_cast<getter>(FrameFocusControl_get_Value), reinterpret_cast<setter>(FrameFocusControl_put_Value), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameFocusControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameFocusControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameFocusControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameFocusControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameFocusControl) },
        { }};

    static PyType_Spec type_spec_FrameFocusControl = {
        "winrt._winrt_windows_media_devices_core.FrameFocusControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFocusControl};

    // ----- FrameIsoSpeedCapabilities class --------------------

    static PyObject* _new_FrameIsoSpeedCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameIsoSpeedCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedCapabilities", L"Max");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Max();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedCapabilities", L"Min");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Min();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedCapabilities", L"Step");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Step();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedCapabilities", L"Supported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Supported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameIsoSpeedCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameIsoSpeedCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameIsoSpeedCapabilities[] = {
        { "_assign_array_", _assign_array_FrameIsoSpeedCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameIsoSpeedCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameIsoSpeedCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameIsoSpeedCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameIsoSpeedCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameIsoSpeedCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameIsoSpeedCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameIsoSpeedCapabilities) },
        { }};

    static PyType_Spec type_spec_FrameIsoSpeedCapabilities = {
        "winrt._winrt_windows_media_devices_core.FrameIsoSpeedCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameIsoSpeedCapabilities};

    // ----- FrameIsoSpeedControl class --------------------

    static PyObject* _new_FrameIsoSpeedControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameIsoSpeedControl(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameIsoSpeedControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameIsoSpeedControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameIsoSpeedControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedControl", L"Auto");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Auto();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameIsoSpeedControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedControl", L"Auto");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Auto(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameIsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameIsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameIsoSpeedControl[] = {
        { "_assign_array_", _assign_array_FrameIsoSpeedControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameIsoSpeedControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FrameIsoSpeedControl[] = {
        { "value", reinterpret_cast<getter>(FrameIsoSpeedControl_get_Value), reinterpret_cast<setter>(FrameIsoSpeedControl_put_Value), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameIsoSpeedControl_get_Auto), reinterpret_cast<setter>(FrameIsoSpeedControl_put_Auto), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FrameIsoSpeedControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameIsoSpeedControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameIsoSpeedControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameIsoSpeedControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameIsoSpeedControl) },
        { }};

    static PyType_Spec type_spec_FrameIsoSpeedControl = {
        "winrt._winrt_windows_media_devices_core.FrameIsoSpeedControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameIsoSpeedControl};

    // ----- VariablePhotoSequenceController class --------------------

    static PyObject* _new_VariablePhotoSequenceController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>::type_name);
        return nullptr;
    }

    static void _dealloc_VariablePhotoSequenceController(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VariablePhotoSequenceController_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"GetCurrentFrameRate", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentFrameRate();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"GetHighestConcurrentFrameRate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetHighestConcurrentFrameRate(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"PhotosPerSecondLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotosPerSecondLimit();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VariablePhotoSequenceController_put_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"PhotosPerSecondLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.PhotosPerSecondLimit(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_DesiredFrameControllers(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"DesiredFrameControllers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredFrameControllers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_FrameCapabilities(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"FrameCapabilities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameCapabilities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_MaxPhotosPerSecond(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"MaxPhotosPerSecond");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxPhotosPerSecond();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_Supported(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"Supported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Supported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VariablePhotoSequenceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VariablePhotoSequenceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VariablePhotoSequenceController[] = {
        { "get_current_frame_rate", reinterpret_cast<PyCFunction>(VariablePhotoSequenceController_GetCurrentFrameRate), METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", reinterpret_cast<PyCFunction>(VariablePhotoSequenceController_GetHighestConcurrentFrameRate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VariablePhotoSequenceController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VariablePhotoSequenceController), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VariablePhotoSequenceController[] = {
        { "photos_per_second_limit", reinterpret_cast<getter>(VariablePhotoSequenceController_get_PhotosPerSecondLimit), reinterpret_cast<setter>(VariablePhotoSequenceController_put_PhotosPerSecondLimit), nullptr, nullptr },
        { "desired_frame_controllers", reinterpret_cast<getter>(VariablePhotoSequenceController_get_DesiredFrameControllers), nullptr, nullptr, nullptr },
        { "frame_capabilities", reinterpret_cast<getter>(VariablePhotoSequenceController_get_FrameCapabilities), nullptr, nullptr, nullptr },
        { "max_photos_per_second", reinterpret_cast<getter>(VariablePhotoSequenceController_get_MaxPhotosPerSecond), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(VariablePhotoSequenceController_get_Supported), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_VariablePhotoSequenceController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VariablePhotoSequenceController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VariablePhotoSequenceController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VariablePhotoSequenceController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VariablePhotoSequenceController) },
        { }};

    static PyType_Spec type_spec_VariablePhotoSequenceController = {
        "winrt._winrt_windows_media_devices_core.VariablePhotoSequenceController",
        sizeof(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VariablePhotoSequenceController};

    // ----- Windows.Media.Devices.Core Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Devices.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_devices_core",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Devices::Core

PyMODINIT_FUNC PyInit__winrt_windows_media_devices_core(void) noexcept
{
    using namespace py::cpp::Windows::Media::Devices::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle CameraIntrinsics_type{py::register_python_type(module.get(), &type_spec_CameraIntrinsics, object_bases.get(), inspectable_meta_type)};
    if (!CameraIntrinsics_type)
    {
        return nullptr;
    }

    py::pytype_handle DepthCorrelatedCoordinateMapper_type{py::register_python_type(module.get(), &type_spec_DepthCorrelatedCoordinateMapper, object_bases.get(), inspectable_meta_type)};
    if (!DepthCorrelatedCoordinateMapper_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameControlCapabilities_type{py::register_python_type(module.get(), &type_spec_FrameControlCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!FrameControlCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameController_type{py::register_python_type(module.get(), &type_spec_FrameController, object_bases.get(), inspectable_meta_type)};
    if (!FrameController_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameExposureCapabilities_type{py::register_python_type(module.get(), &type_spec_FrameExposureCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!FrameExposureCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameExposureCompensationCapabilities_type{py::register_python_type(module.get(), &type_spec_FrameExposureCompensationCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!FrameExposureCompensationCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameExposureCompensationControl_type{py::register_python_type(module.get(), &type_spec_FrameExposureCompensationControl, object_bases.get(), inspectable_meta_type)};
    if (!FrameExposureCompensationControl_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameExposureControl_type{py::register_python_type(module.get(), &type_spec_FrameExposureControl, object_bases.get(), inspectable_meta_type)};
    if (!FrameExposureControl_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameFlashCapabilities_type{py::register_python_type(module.get(), &type_spec_FrameFlashCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!FrameFlashCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameFlashControl_type{py::register_python_type(module.get(), &type_spec_FrameFlashControl, object_bases.get(), inspectable_meta_type)};
    if (!FrameFlashControl_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameFocusCapabilities_type{py::register_python_type(module.get(), &type_spec_FrameFocusCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!FrameFocusCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameFocusControl_type{py::register_python_type(module.get(), &type_spec_FrameFocusControl, object_bases.get(), inspectable_meta_type)};
    if (!FrameFocusControl_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameIsoSpeedCapabilities_type{py::register_python_type(module.get(), &type_spec_FrameIsoSpeedCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!FrameIsoSpeedCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle FrameIsoSpeedControl_type{py::register_python_type(module.get(), &type_spec_FrameIsoSpeedControl, object_bases.get(), inspectable_meta_type)};
    if (!FrameIsoSpeedControl_type)
    {
        return nullptr;
    }

    py::pytype_handle VariablePhotoSequenceController_type{py::register_python_type(module.get(), &type_spec_VariablePhotoSequenceController, object_bases.get(), inspectable_meta_type)};
    if (!VariablePhotoSequenceController_type)
    {
        return nullptr;
    }


    return module.detach();
}
