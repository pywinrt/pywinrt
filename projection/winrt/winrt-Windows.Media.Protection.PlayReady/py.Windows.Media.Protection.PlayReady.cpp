// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Media.Protection.PlayReady.h"

namespace py::cpp::Windows::Media::Protection::PlayReady
{
    // ----- NDClient class --------------------

    static PyObject* _new_NDClient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDMessenger>(args, 2);

                winrt::Windows::Media::Protection::PlayReady::NDClient instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDClient(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDClient_Close(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_LicenseFetchAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"LicenseFetchAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.LicenseFetchAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_ReRegistrationAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ReRegistrationAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReRegistrationAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_StartAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"StartAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartAsync(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ClosedCaptionDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ClosedCaptionDataReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClosedCaptionDataReceived(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ClosedCaptionDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ClosedCaptionDataReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ClosedCaptionDataReceived(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_LicenseFetchCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"LicenseFetchCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LicenseFetchCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_LicenseFetchCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"LicenseFetchCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LicenseFetchCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ProximityDetectionCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ProximityDetectionCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProximityDetectionCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ProximityDetectionCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ProximityDetectionCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProximityDetectionCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ReRegistrationNeeded(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ReRegistrationNeeded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReRegistrationNeeded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ReRegistrationNeeded(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"ReRegistrationNeeded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ReRegistrationNeeded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_RegistrationCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"RegistrationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RegistrationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_RegistrationCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Protection.PlayReady.NDClient", L"RegistrationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RegistrationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDClient>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDClient[] = {
        { "close", reinterpret_cast<PyCFunction>(NDClient_Close), METH_VARARGS, nullptr },
        { "license_fetch_async", reinterpret_cast<PyCFunction>(NDClient_LicenseFetchAsync), METH_VARARGS, nullptr },
        { "re_registration_async", reinterpret_cast<PyCFunction>(NDClient_ReRegistrationAsync), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(NDClient_StartAsync), METH_VARARGS, nullptr },
        { "add_closed_caption_data_received", reinterpret_cast<PyCFunction>(NDClient_add_ClosedCaptionDataReceived), METH_O, nullptr },
        { "remove_closed_caption_data_received", reinterpret_cast<PyCFunction>(NDClient_remove_ClosedCaptionDataReceived), METH_O, nullptr },
        { "add_license_fetch_completed", reinterpret_cast<PyCFunction>(NDClient_add_LicenseFetchCompleted), METH_O, nullptr },
        { "remove_license_fetch_completed", reinterpret_cast<PyCFunction>(NDClient_remove_LicenseFetchCompleted), METH_O, nullptr },
        { "add_proximity_detection_completed", reinterpret_cast<PyCFunction>(NDClient_add_ProximityDetectionCompleted), METH_O, nullptr },
        { "remove_proximity_detection_completed", reinterpret_cast<PyCFunction>(NDClient_remove_ProximityDetectionCompleted), METH_O, nullptr },
        { "add_re_registration_needed", reinterpret_cast<PyCFunction>(NDClient_add_ReRegistrationNeeded), METH_O, nullptr },
        { "remove_re_registration_needed", reinterpret_cast<PyCFunction>(NDClient_remove_ReRegistrationNeeded), METH_O, nullptr },
        { "add_registration_completed", reinterpret_cast<PyCFunction>(NDClient_add_RegistrationCompleted), METH_O, nullptr },
        { "remove_registration_completed", reinterpret_cast<PyCFunction>(NDClient_remove_RegistrationCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_NDClient, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDClient), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NDClient[] = {
        { }};

    static PyType_Slot _type_slots_NDClient[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDClient) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDClient) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDClient) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDClient) },
        { }};

    static PyType_Spec type_spec_NDClient = {
        "winrt._winrt_windows_media_protection_playready.NDClient",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDClient};

    // ----- NDCustomData class --------------------

    static PyObject* _new_NDCustomData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::NDCustomData instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDCustomData_get_CustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDCustomData", L"CustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDCustomData_get_CustomDataTypeID(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDCustomData", L"CustomDataTypeID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomDataTypeID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDCustomData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDCustomData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDCustomData[] = {
        { "_assign_array_", _assign_array_NDCustomData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDCustomData), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NDCustomData[] = {
        { "custom_data", reinterpret_cast<getter>(NDCustomData_get_CustomData), nullptr, nullptr, nullptr },
        { "custom_data_type_id", reinterpret_cast<getter>(NDCustomData_get_CustomDataTypeID), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NDCustomData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDCustomData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDCustomData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDCustomData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDCustomData) },
        { }};

    static PyType_Spec type_spec_NDCustomData = {
        "winrt._winrt_windows_media_protection_playready.NDCustomData",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDCustomData};

    // ----- NDDownloadEngineNotifier class --------------------

    static PyObject* _new_NDDownloadEngineNotifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDDownloadEngineNotifier(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDDownloadEngineNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnContentIDReceived", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnContentIDReceived(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnDataReceived", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.OnDataReceived(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnEndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnEndOfStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.OnEndOfStream();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnNetworkError(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnNetworkError", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.OnNetworkError();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnPlayReadyObjectReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnPlayReadyObjectReceived", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnPlayReadyObjectReceived(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnStreamOpened(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier", L"OnStreamOpened", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.OnStreamOpened();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDDownloadEngineNotifier[] = {
        { "on_content_id_received", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnContentIDReceived), METH_VARARGS, nullptr },
        { "on_data_received", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnDataReceived), METH_VARARGS, nullptr },
        { "on_end_of_stream", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnEndOfStream), METH_VARARGS, nullptr },
        { "on_network_error", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnNetworkError), METH_VARARGS, nullptr },
        { "on_play_ready_object_received", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnPlayReadyObjectReceived), METH_VARARGS, nullptr },
        { "on_stream_opened", reinterpret_cast<PyCFunction>(NDDownloadEngineNotifier_OnStreamOpened), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NDDownloadEngineNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDDownloadEngineNotifier), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NDDownloadEngineNotifier[] = {
        { }};

    static PyType_Slot _type_slots_NDDownloadEngineNotifier[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDDownloadEngineNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDDownloadEngineNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDDownloadEngineNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDDownloadEngineNotifier) },
        { }};

    static PyType_Spec type_spec_NDDownloadEngineNotifier = {
        "winrt._winrt_windows_media_protection_playready.NDDownloadEngineNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDDownloadEngineNotifier};

    // ----- NDLicenseFetchDescriptor class --------------------

    static PyObject* _new_NDLicenseFetchDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDContentIDType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 2);

                winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDLicenseFetchDescriptor(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor", L"LicenseFetchChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LicenseFetchChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor", L"LicenseFetchChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(arg);

            {
                auto _gil = release_gil();
                self->obj.LicenseFetchChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NDLicenseFetchDescriptor_get_ContentID(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor", L"ContentID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDLicenseFetchDescriptor_get_ContentIDType(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor", L"ContentIDType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentIDType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDLicenseFetchDescriptor[] = {
        { "_assign_array_", _assign_array_NDLicenseFetchDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDLicenseFetchDescriptor), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NDLicenseFetchDescriptor[] = {
        { "license_fetch_challenge_custom_data", reinterpret_cast<getter>(NDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData), reinterpret_cast<setter>(NDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(NDLicenseFetchDescriptor_get_ContentID), nullptr, nullptr, nullptr },
        { "content_id_type", reinterpret_cast<getter>(NDLicenseFetchDescriptor_get_ContentIDType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NDLicenseFetchDescriptor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDLicenseFetchDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDLicenseFetchDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDLicenseFetchDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDLicenseFetchDescriptor) },
        { }};

    static PyType_Spec type_spec_NDLicenseFetchDescriptor = {
        "winrt._winrt_windows_media_protection_playready.NDLicenseFetchDescriptor",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDLicenseFetchDescriptor};

    // ----- NDStorageFileHelper class --------------------

    static PyObject* _new_NDStorageFileHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDStorageFileHelper(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDStorageFileHelper_GetFileURLs(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStorageFileHelper", L"GetFileURLs", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFileURLs(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDStorageFileHelper[] = {
        { "get_file_u_r_ls", reinterpret_cast<PyCFunction>(NDStorageFileHelper_GetFileURLs), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NDStorageFileHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDStorageFileHelper), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NDStorageFileHelper[] = {
        { }};

    static PyType_Slot _type_slots_NDStorageFileHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDStorageFileHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDStorageFileHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDStorageFileHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDStorageFileHelper) },
        { }};

    static PyType_Spec type_spec_NDStorageFileHelper = {
        "winrt._winrt_windows_media_protection_playready.NDStorageFileHelper",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDStorageFileHelper};

    // ----- NDStreamParserNotifier class --------------------

    static PyObject* _new_NDStreamParserNotifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDStreamParserNotifier(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDStreamParserNotifier_OnBeginSetupDecryptor(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStreamParserNotifier", L"OnBeginSetupDecryptor", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.OnBeginSetupDecryptor(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStreamParserNotifier", L"OnContentIDReceived", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnContentIDReceived(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnMediaStreamDescriptorCreated(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStreamParserNotifier", L"OnMediaStreamDescriptorCreated", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.OnMediaStreamDescriptorCreated(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnSampleParsed(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 6)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDStreamParserNotifier", L"OnSampleParsed", 6);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(args, 2);
                auto param3 = py::convert_to<int64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDClosedCaptionFormat>(args, 4);
                auto param5 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 5);

                {
                    auto _gil = release_gil();
                    self->obj.OnSampleParsed(param0, param1, param2, param3, param4, param5);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDStreamParserNotifier[] = {
        { "on_begin_setup_decryptor", reinterpret_cast<PyCFunction>(NDStreamParserNotifier_OnBeginSetupDecryptor), METH_VARARGS, nullptr },
        { "on_content_id_received", reinterpret_cast<PyCFunction>(NDStreamParserNotifier_OnContentIDReceived), METH_VARARGS, nullptr },
        { "on_media_stream_descriptor_created", reinterpret_cast<PyCFunction>(NDStreamParserNotifier_OnMediaStreamDescriptorCreated), METH_VARARGS, nullptr },
        { "on_sample_parsed", reinterpret_cast<PyCFunction>(NDStreamParserNotifier_OnSampleParsed), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NDStreamParserNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDStreamParserNotifier), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NDStreamParserNotifier[] = {
        { }};

    static PyType_Slot _type_slots_NDStreamParserNotifier[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDStreamParserNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDStreamParserNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDStreamParserNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDStreamParserNotifier) },
        { }};

    static PyType_Spec type_spec_NDStreamParserNotifier = {
        "winrt._winrt_windows_media_protection_playready.NDStreamParserNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDStreamParserNotifier};

    // ----- NDTCPMessenger class --------------------

    static PyObject* _new_NDTCPMessenger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDTCPMessenger(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NDTCPMessenger_SendLicenseFetchRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDTCPMessenger", L"SendLicenseFetchRequestAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendLicenseFetchRequestAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendProximityDetectionResponseAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDTCPMessenger", L"SendProximityDetectionResponseAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendProximityDetectionResponseAsync(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendProximityDetectionStartAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDTCPMessenger", L"SendProximityDetectionStartAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendProximityDetectionStartAsync(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendRegistrationRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.NDTCPMessenger", L"SendRegistrationRequestAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendRegistrationRequestAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NDTCPMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NDTCPMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDTCPMessenger[] = {
        { "send_license_fetch_request_async", reinterpret_cast<PyCFunction>(NDTCPMessenger_SendLicenseFetchRequestAsync), METH_VARARGS, nullptr },
        { "send_proximity_detection_response_async", reinterpret_cast<PyCFunction>(NDTCPMessenger_SendProximityDetectionResponseAsync), METH_VARARGS, nullptr },
        { "send_proximity_detection_start_async", reinterpret_cast<PyCFunction>(NDTCPMessenger_SendProximityDetectionStartAsync), METH_VARARGS, nullptr },
        { "send_registration_request_async", reinterpret_cast<PyCFunction>(NDTCPMessenger_SendRegistrationRequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NDTCPMessenger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NDTCPMessenger), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NDTCPMessenger[] = {
        { }};

    static PyType_Slot _type_slots_NDTCPMessenger[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NDTCPMessenger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NDTCPMessenger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NDTCPMessenger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NDTCPMessenger) },
        { }};

    static PyType_Spec type_spec_NDTCPMessenger = {
        "winrt._winrt_windows_media_protection_playready.NDTCPMessenger",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDTCPMessenger};

    // ----- PlayReadyContentHeader class --------------------

    static PyObject* _new_PlayReadyContentHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 8)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::guid, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyEncryptionAlgorithm>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::guid>(args, 7);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{param0, param1, param2, param3, param4, param5, param6, param7};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::guid>(args, 4);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{param0, param1, param2, param3, param4};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyEncryptionAlgorithm>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::guid>(args, 6);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{param0, param1, param2, param3, param4, param5, param6};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyContentHeader_GetSerializedHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"GetSerializedHeader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSerializedHeader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_CustomAttributes(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"CustomAttributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomAttributes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_DecryptorSetup(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"DecryptorSetup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DecryptorSetup();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_EncryptionType(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"EncryptionType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EncryptionType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_HeaderWithEmbeddedUpdates(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"HeaderWithEmbeddedUpdates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeaderWithEmbeddedUpdates();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"KeyId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIdString(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"KeyIdString");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyIdString();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_LicenseAcquisitionUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"LicenseAcquisitionUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LicenseAcquisitionUrl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_LicenseAcquisitionUserInterfaceUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"LicenseAcquisitionUserInterfaceUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LicenseAcquisitionUserInterfaceUrl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIdStrings(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"KeyIdStrings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyIdStrings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIds(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentHeader", L"KeyIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyIds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyContentHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyContentHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyContentHeader[] = {
        { "get_serialized_header", reinterpret_cast<PyCFunction>(PlayReadyContentHeader_GetSerializedHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyContentHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyContentHeader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyContentHeader[] = {
        { "custom_attributes", reinterpret_cast<getter>(PlayReadyContentHeader_get_CustomAttributes), nullptr, nullptr, nullptr },
        { "decryptor_setup", reinterpret_cast<getter>(PlayReadyContentHeader_get_DecryptorSetup), nullptr, nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(PlayReadyContentHeader_get_DomainServiceId), nullptr, nullptr, nullptr },
        { "encryption_type", reinterpret_cast<getter>(PlayReadyContentHeader_get_EncryptionType), nullptr, nullptr, nullptr },
        { "header_with_embedded_updates", reinterpret_cast<getter>(PlayReadyContentHeader_get_HeaderWithEmbeddedUpdates), nullptr, nullptr, nullptr },
        { "key_id", reinterpret_cast<getter>(PlayReadyContentHeader_get_KeyId), nullptr, nullptr, nullptr },
        { "key_id_string", reinterpret_cast<getter>(PlayReadyContentHeader_get_KeyIdString), nullptr, nullptr, nullptr },
        { "license_acquisition_url", reinterpret_cast<getter>(PlayReadyContentHeader_get_LicenseAcquisitionUrl), nullptr, nullptr, nullptr },
        { "license_acquisition_user_interface_url", reinterpret_cast<getter>(PlayReadyContentHeader_get_LicenseAcquisitionUserInterfaceUrl), nullptr, nullptr, nullptr },
        { "key_id_strings", reinterpret_cast<getter>(PlayReadyContentHeader_get_KeyIdStrings), nullptr, nullptr, nullptr },
        { "key_ids", reinterpret_cast<getter>(PlayReadyContentHeader_get_KeyIds), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyContentHeader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyContentHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyContentHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyContentHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyContentHeader) },
        { }};

    static PyType_Spec type_spec_PlayReadyContentHeader = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyContentHeader",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyContentHeader};

    // ----- PlayReadyContentResolver class --------------------

    static PyObject* _new_PlayReadyContentResolver(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver>::type_name);
        return nullptr;
    }

    static PyObject* PlayReadyContentResolver_ServiceRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyContentResolver", L"ServiceRequest", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver::ServiceRequest(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyContentResolver[] = {
        { }};

    static PyGetSetDef _getset_PlayReadyContentResolver[] = {
        { }};

    static PyType_Slot _type_slots_PlayReadyContentResolver[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyContentResolver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyContentResolver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyContentResolver) },
        { }};

    static PyType_Spec type_spec_PlayReadyContentResolver = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyContentResolver",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyContentResolver};

    static PyGetSetDef getset_PlayReadyContentResolver_Static[] = {
        { }};

    static PyMethodDef methods_PlayReadyContentResolver_Static[] = {
        { "service_request", reinterpret_cast<PyCFunction>(PlayReadyContentResolver_ServiceRequest), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PlayReadyContentResolver_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlayReadyContentResolver_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlayReadyContentResolver_Static) },
        { }
    };

    static PyType_Spec type_spec_PlayReadyContentResolver_Static = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyContentResolver_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlayReadyContentResolver_Static};

    // ----- PlayReadyDomain class --------------------

    static PyObject* _new_PlayReadyDomain(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadyDomain(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomain_get_AccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"AccountId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AccountId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_DomainJoinUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"DomainJoinUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainJoinUrl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_FriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"FriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FriendlyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_Revision(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"Revision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Revision();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_ServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomain", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomain[] = {
        { "_assign_array_", _assign_array_PlayReadyDomain, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomain), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyDomain[] = {
        { "account_id", reinterpret_cast<getter>(PlayReadyDomain_get_AccountId), nullptr, nullptr, nullptr },
        { "domain_join_url", reinterpret_cast<getter>(PlayReadyDomain_get_DomainJoinUrl), nullptr, nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(PlayReadyDomain_get_FriendlyName), nullptr, nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(PlayReadyDomain_get_Revision), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(PlayReadyDomain_get_ServiceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyDomain[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomain) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomain) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomain) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomain) },
        { }};

    static PyType_Spec type_spec_PlayReadyDomain = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomain",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomain};

    // ----- PlayReadyDomainIterable class --------------------

    static PyObject* _new_PlayReadyDomainIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomainIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterable", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomainIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomainIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyDomainIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainIterable[] = {
        { "first", reinterpret_cast<PyCFunction>(PlayReadyDomainIterable_First), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyDomainIterable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomainIterable), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyDomainIterable[] = {
        { }};

    static PyType_Slot _type_slots_PlayReadyDomainIterable[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomainIterable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomainIterable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomainIterable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomainIterable) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadyDomainIterable) },
        { }};

    static PyType_Spec type_spec_PlayReadyDomainIterable = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomainIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainIterable};

    // ----- PlayReadyDomainIterator class --------------------

    static PyObject* _new_PlayReadyDomainIterator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomainIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterator", L"GetMany", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain, true>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterator", L"MoveNext", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveNext();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterator", L"Current");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Current();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainIterator", L"HasCurrent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasCurrent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomainIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomainIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    auto cur = self->obj.Current();
                    self->obj.MoveNext();
                    return cur;
                }());
            }
            else
            {
                return nullptr;
            }
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainIterator[] = {
        { "get_many", reinterpret_cast<PyCFunction>(PlayReadyDomainIterator_GetMany), METH_VARARGS, nullptr },
        { "move_next", reinterpret_cast<PyCFunction>(PlayReadyDomainIterator_MoveNext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyDomainIterator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomainIterator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyDomainIterator[] = {
        { "current", reinterpret_cast<getter>(PlayReadyDomainIterator_get_Current), nullptr, nullptr, nullptr },
        { "has_current", reinterpret_cast<getter>(PlayReadyDomainIterator_get_HasCurrent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyDomainIterator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomainIterator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomainIterator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomainIterator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomainIterator) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadyDomainIterator) },
        { Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_PlayReadyDomainIterator) },
        { }};

    static PyType_Spec type_spec_PlayReadyDomainIterator = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomainIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainIterator};

    // ----- PlayReadyDomainJoinServiceRequest class --------------------

    static PyObject* _new_PlayReadyDomainJoinServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainJoinServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.DomainServiceId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainFriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainFriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainFriendlyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainFriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainFriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DomainFriendlyName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainAccountId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainAccountId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"DomainAccountId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.DomainAccountId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomainJoinServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomainJoinServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainJoinServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyDomainJoinServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyDomainJoinServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyDomainJoinServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyDomainJoinServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyDomainJoinServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomainJoinServiceRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyDomainJoinServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_DomainServiceId), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_DomainServiceId), nullptr, nullptr },
        { "domain_friendly_name", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_DomainFriendlyName), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_DomainFriendlyName), nullptr, nullptr },
        { "domain_account_id", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_DomainAccountId), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_DomainAccountId), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyDomainJoinServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyDomainJoinServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyDomainJoinServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomainJoinServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomainJoinServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomainJoinServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomainJoinServiceRequest) },
        { }};

    static PyType_Spec type_spec_PlayReadyDomainJoinServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomainJoinServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainJoinServiceRequest};

    // ----- PlayReadyDomainLeaveServiceRequest class --------------------

    static PyObject* _new_PlayReadyDomainLeaveServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainLeaveServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.DomainServiceId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"DomainAccountId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainAccountId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"DomainAccountId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.DomainAccountId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyDomainLeaveServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyDomainLeaveServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainLeaveServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyDomainLeaveServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyDomainLeaveServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyDomainLeaveServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyDomainLeaveServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyDomainLeaveServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyDomainLeaveServiceRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyDomainLeaveServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_DomainServiceId), reinterpret_cast<setter>(PlayReadyDomainLeaveServiceRequest_put_DomainServiceId), nullptr, nullptr },
        { "domain_account_id", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_DomainAccountId), reinterpret_cast<setter>(PlayReadyDomainLeaveServiceRequest_put_DomainAccountId), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyDomainLeaveServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyDomainLeaveServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyDomainLeaveServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyDomainLeaveServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyDomainLeaveServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyDomainLeaveServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyDomainLeaveServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyDomainLeaveServiceRequest) },
        { }};

    static PyType_Spec type_spec_PlayReadyDomainLeaveServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyDomainLeaveServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainLeaveServiceRequest};

    // ----- PlayReadyITADataGenerator class --------------------

    static PyObject* _new_PlayReadyITADataGenerator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyITADataGenerator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyITADataGenerator_GenerateData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyITADataGenerator", L"GenerateData", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataFormat>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateData(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyITADataGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyITADataGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyITADataGenerator[] = {
        { "generate_data", reinterpret_cast<PyCFunction>(PlayReadyITADataGenerator_GenerateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyITADataGenerator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyITADataGenerator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyITADataGenerator[] = {
        { }};

    static PyType_Slot _type_slots_PlayReadyITADataGenerator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyITADataGenerator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyITADataGenerator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyITADataGenerator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyITADataGenerator) },
        { }};

    static PyType_Spec type_spec_PlayReadyITADataGenerator = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyITADataGenerator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyITADataGenerator};

    // ----- PlayReadyIndividualizationServiceRequest class --------------------

    static PyObject* _new_PlayReadyIndividualizationServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyIndividualizationServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyIndividualizationServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyIndividualizationServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyIndividualizationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyIndividualizationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyIndividualizationServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyIndividualizationServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyIndividualizationServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyIndividualizationServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyIndividualizationServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyIndividualizationServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyIndividualizationServiceRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyIndividualizationServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyIndividualizationServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyIndividualizationServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyIndividualizationServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyIndividualizationServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyIndividualizationServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyIndividualizationServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyIndividualizationServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyIndividualizationServiceRequest) },
        { }};

    static PyType_Spec type_spec_PlayReadyIndividualizationServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyIndividualizationServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyIndividualizationServiceRequest};

    // ----- PlayReadyLicense class --------------------

    static PyObject* _new_PlayReadyLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadyLicense(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicense_GetKIDAtChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"GetKIDAtChainDepth", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetKIDAtChainDepth(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"ChainDepth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChainDepth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_DomainAccountID(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"DomainAccountID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainAccountID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpireAfterFirstPlay(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"ExpireAfterFirstPlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpireAfterFirstPlay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_FullyEvaluated(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"FullyEvaluated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FullyEvaluated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_UsableForPlay(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"UsableForPlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsableForPlay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpiresInRealTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"ExpiresInRealTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpiresInRealTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_InMemoryOnly(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"InMemoryOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InMemoryOnly();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_SecureStopId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"SecureStopId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SecureStopId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_SecurityLevel(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicense", L"SecurityLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SecurityLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicense[] = {
        { "get_k_i_d_at_chain_depth", reinterpret_cast<PyCFunction>(PlayReadyLicense_GetKIDAtChainDepth), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicense), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyLicense[] = {
        { "chain_depth", reinterpret_cast<getter>(PlayReadyLicense_get_ChainDepth), nullptr, nullptr, nullptr },
        { "domain_account_id", reinterpret_cast<getter>(PlayReadyLicense_get_DomainAccountID), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(PlayReadyLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "expire_after_first_play", reinterpret_cast<getter>(PlayReadyLicense_get_ExpireAfterFirstPlay), nullptr, nullptr, nullptr },
        { "fully_evaluated", reinterpret_cast<getter>(PlayReadyLicense_get_FullyEvaluated), nullptr, nullptr, nullptr },
        { "usable_for_play", reinterpret_cast<getter>(PlayReadyLicense_get_UsableForPlay), nullptr, nullptr, nullptr },
        { "expires_in_real_time", reinterpret_cast<getter>(PlayReadyLicense_get_ExpiresInRealTime), nullptr, nullptr, nullptr },
        { "in_memory_only", reinterpret_cast<getter>(PlayReadyLicense_get_InMemoryOnly), nullptr, nullptr, nullptr },
        { "secure_stop_id", reinterpret_cast<getter>(PlayReadyLicense_get_SecureStopId), nullptr, nullptr, nullptr },
        { "security_level", reinterpret_cast<getter>(PlayReadyLicense_get_SecurityLevel), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyLicense[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicense) },
        { }};

    static PyType_Spec type_spec_PlayReadyLicense = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicense",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicense};

    // ----- PlayReadyLicenseAcquisitionServiceRequest class --------------------

    static PyObject* _new_PlayReadyLicenseAcquisitionServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseAcquisitionServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"CreateLicenseIterable", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateLicenseIterable(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.DomainServiceId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ContentHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentHeader();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ContentHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContentHeader(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_SessionId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SessionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseAcquisitionServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "create_license_iterable", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_CreateLicenseIterable), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicenseAcquisitionServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicenseAcquisitionServiceRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyLicenseAcquisitionServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId), reinterpret_cast<setter>(PlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId), nullptr, nullptr },
        { "content_header", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader), reinterpret_cast<setter>(PlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader), nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_SessionId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyLicenseAcquisitionServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyLicenseAcquisitionServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseAcquisitionServiceRequest) },
        { }};

    static PyType_Spec type_spec_PlayReadyLicenseAcquisitionServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseAcquisitionServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseAcquisitionServiceRequest};

    // ----- PlayReadyLicenseIterable class --------------------

    static PyObject* _new_PlayReadyLicenseIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicenseIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterable", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicenseIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicenseIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseIterable[] = {
        { "first", reinterpret_cast<PyCFunction>(PlayReadyLicenseIterable_First), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicenseIterable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicenseIterable), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyLicenseIterable[] = {
        { }};

    static PyType_Slot _type_slots_PlayReadyLicenseIterable[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseIterable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicenseIterable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseIterable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseIterable) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadyLicenseIterable) },
        { }};

    static PyType_Spec type_spec_PlayReadyLicenseIterable = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseIterable};

    // ----- PlayReadyLicenseIterator class --------------------

    static PyObject* _new_PlayReadyLicenseIterator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicenseIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator", L"GetMany", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense, true>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator", L"MoveNext", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveNext();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator", L"Current");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Current();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator", L"HasCurrent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasCurrent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicenseIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicenseIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    auto cur = self->obj.Current();
                    self->obj.MoveNext();
                    return cur;
                }());
            }
            else
            {
                return nullptr;
            }
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseIterator[] = {
        { "get_many", reinterpret_cast<PyCFunction>(PlayReadyLicenseIterator_GetMany), METH_VARARGS, nullptr },
        { "move_next", reinterpret_cast<PyCFunction>(PlayReadyLicenseIterator_MoveNext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicenseIterator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicenseIterator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyLicenseIterator[] = {
        { "current", reinterpret_cast<getter>(PlayReadyLicenseIterator_get_Current), nullptr, nullptr, nullptr },
        { "has_current", reinterpret_cast<getter>(PlayReadyLicenseIterator_get_HasCurrent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyLicenseIterator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseIterator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicenseIterator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseIterator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseIterator) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadyLicenseIterator) },
        { Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_PlayReadyLicenseIterator) },
        { }};

    static PyType_Spec type_spec_PlayReadyLicenseIterator = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseIterator};

    // ----- PlayReadyLicenseManagement class --------------------

    static PyObject* _new_PlayReadyLicenseManagement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement>::type_name);
        return nullptr;
    }

    static PyObject* PlayReadyLicenseManagement_DeleteLicenses(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseManagement", L"DeleteLicenses", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement::DeleteLicenses(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseManagement[] = {
        { }};

    static PyGetSetDef _getset_PlayReadyLicenseManagement[] = {
        { }};

    static PyType_Slot _type_slots_PlayReadyLicenseManagement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseManagement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseManagement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseManagement) },
        { }};

    static PyType_Spec type_spec_PlayReadyLicenseManagement = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseManagement",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseManagement};

    static PyGetSetDef getset_PlayReadyLicenseManagement_Static[] = {
        { }};

    static PyMethodDef methods_PlayReadyLicenseManagement_Static[] = {
        { "delete_licenses", reinterpret_cast<PyCFunction>(PlayReadyLicenseManagement_DeleteLicenses), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PlayReadyLicenseManagement_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlayReadyLicenseManagement_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlayReadyLicenseManagement_Static) },
        { }
    };

    static PyType_Spec type_spec_PlayReadyLicenseManagement_Static = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseManagement_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlayReadyLicenseManagement_Static};

    // ----- PlayReadyLicenseSession class --------------------

    static PyObject* _new_PlayReadyLicenseSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseSession(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyLicenseSession_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseSession", L"ConfigureMediaProtectionManager", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigureMediaProtectionManager(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseSession_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseSession", L"CreateLAServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateLAServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseSession_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyLicenseSession", L"CreateLicenseIterable", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateLicenseIterable(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseSession[] = {
        { "configure_media_protection_manager", reinterpret_cast<PyCFunction>(PlayReadyLicenseSession_ConfigureMediaProtectionManager), METH_VARARGS, nullptr },
        { "create_l_a_service_request", reinterpret_cast<PyCFunction>(PlayReadyLicenseSession_CreateLAServiceRequest), METH_VARARGS, nullptr },
        { "create_license_iterable", reinterpret_cast<PyCFunction>(PlayReadyLicenseSession_CreateLicenseIterable), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyLicenseSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyLicenseSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyLicenseSession[] = {
        { }};

    static PyType_Slot _type_slots_PlayReadyLicenseSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyLicenseSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyLicenseSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyLicenseSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyLicenseSession) },
        { }};

    static PyType_Spec type_spec_PlayReadyLicenseSession = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyLicenseSession",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseSession};

    // ----- PlayReadyMeteringReportServiceRequest class --------------------

    static PyObject* _new_PlayReadyMeteringReportServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyMeteringReportServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_MeteringCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"MeteringCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MeteringCertificate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_MeteringCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"MeteringCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(arg);

            {
                auto _gil = release_gil();
                self->obj.MeteringCertificate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyMeteringReportServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyMeteringReportServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyMeteringReportServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyMeteringReportServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyMeteringReportServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyMeteringReportServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyMeteringReportServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyMeteringReportServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyMeteringReportServiceRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyMeteringReportServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "metering_certificate", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_MeteringCertificate), reinterpret_cast<setter>(PlayReadyMeteringReportServiceRequest_put_MeteringCertificate), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyMeteringReportServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyMeteringReportServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyMeteringReportServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyMeteringReportServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyMeteringReportServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyMeteringReportServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyMeteringReportServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyMeteringReportServiceRequest) },
        { }};

    static PyType_Spec type_spec_PlayReadyMeteringReportServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyMeteringReportServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyMeteringReportServiceRequest};

    // ----- PlayReadyRevocationServiceRequest class --------------------

    static PyObject* _new_PlayReadyRevocationServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyRevocationServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadyRevocationServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyRevocationServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyRevocationServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadyRevocationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadyRevocationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyRevocationServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadyRevocationServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadyRevocationServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadyRevocationServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadyRevocationServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadyRevocationServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadyRevocationServiceRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadyRevocationServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadyRevocationServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadyRevocationServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadyRevocationServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadyRevocationServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyRevocationServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadyRevocationServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyRevocationServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyRevocationServiceRequest) },
        { }};

    static PyType_Spec type_spec_PlayReadyRevocationServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyRevocationServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyRevocationServiceRequest};

    // ----- PlayReadySecureStopIterable class --------------------

    static PyObject* _new_PlayReadySecureStopIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadySecureStopIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadySecureStopIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterable", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadySecureStopIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadySecureStopIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadySecureStopIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopIterable[] = {
        { "first", reinterpret_cast<PyCFunction>(PlayReadySecureStopIterable_First), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadySecureStopIterable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadySecureStopIterable), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadySecureStopIterable[] = {
        { }};

    static PyType_Slot _type_slots_PlayReadySecureStopIterable[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadySecureStopIterable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadySecureStopIterable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadySecureStopIterable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadySecureStopIterable) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadySecureStopIterable) },
        { }};

    static PyType_Spec type_spec_PlayReadySecureStopIterable = {
        "winrt._winrt_windows_media_protection_playready.PlayReadySecureStopIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopIterable};

    // ----- PlayReadySecureStopIterator class --------------------

    static PyObject* _new_PlayReadySecureStopIterator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadySecureStopIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator", L"GetMany", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest, true>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator", L"MoveNext", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveNext();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator", L"Current");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Current();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator", L"HasCurrent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasCurrent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadySecureStopIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadySecureStopIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                return py::convert([&]()
                {
                    auto _gil = py::release_gil();
                    auto cur = self->obj.Current();
                    self->obj.MoveNext();
                    return cur;
                }());
            }
            else
            {
                return nullptr;
            }
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopIterator[] = {
        { "get_many", reinterpret_cast<PyCFunction>(PlayReadySecureStopIterator_GetMany), METH_VARARGS, nullptr },
        { "move_next", reinterpret_cast<PyCFunction>(PlayReadySecureStopIterator_MoveNext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadySecureStopIterator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadySecureStopIterator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadySecureStopIterator[] = {
        { "current", reinterpret_cast<getter>(PlayReadySecureStopIterator_get_Current), nullptr, nullptr, nullptr },
        { "has_current", reinterpret_cast<getter>(PlayReadySecureStopIterator_get_HasCurrent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadySecureStopIterator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadySecureStopIterator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadySecureStopIterator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadySecureStopIterator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadySecureStopIterator) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlayReadySecureStopIterator) },
        { Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_PlayReadySecureStopIterator) },
        { }};

    static PyType_Spec type_spec_PlayReadySecureStopIterator = {
        "winrt._winrt_windows_media_protection_playready.PlayReadySecureStopIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopIterator};

    // ----- PlayReadySecureStopServiceRequest class --------------------

    static PyObject* _new_PlayReadySecureStopServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadySecureStopServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadySecureStopServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_PublisherCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"PublisherCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublisherCertificate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_SessionID(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"SessionID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SessionID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_StartTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Stopped(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"Stopped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Stopped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_UpdateTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"UpdateTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdateTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadySecureStopServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadySecureStopServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(PlayReadySecureStopServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(PlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(PlayReadySecureStopServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(PlayReadySecureStopServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadySecureStopServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadySecureStopServiceRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadySecureStopServiceRequest[] = {
        { "protection_system", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { "publisher_certificate", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_PublisherCertificate), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_SessionID), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_StartTime), nullptr, nullptr, nullptr },
        { "stopped", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_Stopped), nullptr, nullptr, nullptr },
        { "update_time", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_UpdateTime), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_Uri), reinterpret_cast<setter>(PlayReadySecureStopServiceRequest_put_Uri), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(PlayReadySecureStopServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(PlayReadySecureStopServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadySecureStopServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadySecureStopServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadySecureStopServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadySecureStopServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadySecureStopServiceRequest) },
        { }};

    static PyType_Spec type_spec_PlayReadySecureStopServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.PlayReadySecureStopServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopServiceRequest};

    // ----- PlayReadySoapMessage class --------------------

    static PyObject* _new_PlayReadySoapMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_PlayReadySoapMessage(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlayReadySoapMessage_GetMessageBody(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadySoapMessage", L"GetMessageBody", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageBody();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySoapMessage_get_MessageHeaders(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySoapMessage", L"MessageHeaders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageHeaders();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySoapMessage_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadySoapMessage", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlayReadySoapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlayReadySoapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySoapMessage[] = {
        { "get_message_body", reinterpret_cast<PyCFunction>(PlayReadySoapMessage_GetMessageBody), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlayReadySoapMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayReadySoapMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlayReadySoapMessage[] = {
        { "message_headers", reinterpret_cast<getter>(PlayReadySoapMessage_get_MessageHeaders), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PlayReadySoapMessage_get_Uri), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PlayReadySoapMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadySoapMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlayReadySoapMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadySoapMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadySoapMessage) },
        { }};

    static PyType_Spec type_spec_PlayReadySoapMessage = {
        "winrt._winrt_windows_media_protection_playready.PlayReadySoapMessage",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySoapMessage};

    // ----- PlayReadyStatics class --------------------

    static PyObject* _new_PlayReadyStatics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics>::type_name);
        return nullptr;
    }

    static PyObject* PlayReadyStatics_CheckSupportedHardware(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"CheckSupportedHardware", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyHardwareDRMFeatures>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::CheckSupportedHardware(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_ResetHardwareDRMDisabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"ResetHardwareDRMDisabled", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::ResetHardwareDRMDisabled();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_DomainJoinServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"DomainJoinServiceRequestType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::DomainJoinServiceRequestType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_DomainLeaveServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"DomainLeaveServiceRequestType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::DomainLeaveServiceRequestType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_IndividualizationServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"IndividualizationServiceRequestType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::IndividualizationServiceRequestType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_LicenseAcquirerServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"LicenseAcquirerServiceRequestType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::LicenseAcquirerServiceRequestType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_MediaProtectionSystemId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"MediaProtectionSystemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::MediaProtectionSystemId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_MeteringReportServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"MeteringReportServiceRequestType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::MeteringReportServiceRequestType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_PlayReadySecurityVersion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"PlayReadySecurityVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::PlayReadySecurityVersion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_RevocationServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"RevocationServiceRequestType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::RevocationServiceRequestType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_PlayReadyCertificateSecurityLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"PlayReadyCertificateSecurityLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::PlayReadyCertificateSecurityLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_SecureStopServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"SecureStopServiceRequestType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::SecureStopServiceRequestType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_ProtectionSystemId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"ProtectionSystemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::ProtectionSystemId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_InputTrustAuthorityToCreate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"InputTrustAuthorityToCreate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::InputTrustAuthorityToCreate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_HardwareDRMDisabledUntilTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"HardwareDRMDisabledUntilTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::HardwareDRMDisabledUntilTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_HardwareDRMDisabledAtTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.PlayReadyStatics", L"HardwareDRMDisabledAtTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::HardwareDRMDisabledAtTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyStatics[] = {
        { }};

    static PyGetSetDef _getset_PlayReadyStatics[] = {
        { }};

    static PyType_Slot _type_slots_PlayReadyStatics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlayReadyStatics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlayReadyStatics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlayReadyStatics) },
        { }};

    static PyType_Spec type_spec_PlayReadyStatics = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyStatics",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyStatics};

    static PyGetSetDef getset_PlayReadyStatics_Static[] = {
        { "domain_join_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_DomainJoinServiceRequestType), nullptr, nullptr, nullptr },
        { "domain_leave_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_DomainLeaveServiceRequestType), nullptr, nullptr, nullptr },
        { "individualization_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_IndividualizationServiceRequestType), nullptr, nullptr, nullptr },
        { "license_acquirer_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_LicenseAcquirerServiceRequestType), nullptr, nullptr, nullptr },
        { "media_protection_system_id", reinterpret_cast<getter>(PlayReadyStatics_get_MediaProtectionSystemId), nullptr, nullptr, nullptr },
        { "metering_report_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_MeteringReportServiceRequestType), nullptr, nullptr, nullptr },
        { "play_ready_security_version", reinterpret_cast<getter>(PlayReadyStatics_get_PlayReadySecurityVersion), nullptr, nullptr, nullptr },
        { "revocation_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_RevocationServiceRequestType), nullptr, nullptr, nullptr },
        { "play_ready_certificate_security_level", reinterpret_cast<getter>(PlayReadyStatics_get_PlayReadyCertificateSecurityLevel), nullptr, nullptr, nullptr },
        { "secure_stop_service_request_type", reinterpret_cast<getter>(PlayReadyStatics_get_SecureStopServiceRequestType), nullptr, nullptr, nullptr },
        { "protection_system_id", reinterpret_cast<getter>(PlayReadyStatics_get_ProtectionSystemId), nullptr, nullptr, nullptr },
        { "input_trust_authority_to_create", reinterpret_cast<getter>(PlayReadyStatics_get_InputTrustAuthorityToCreate), nullptr, nullptr, nullptr },
        { "hardware_drm_disabled_until_time", reinterpret_cast<getter>(PlayReadyStatics_get_HardwareDRMDisabledUntilTime), nullptr, nullptr, nullptr },
        { "hardware_drm_disabled_at_time", reinterpret_cast<getter>(PlayReadyStatics_get_HardwareDRMDisabledAtTime), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_PlayReadyStatics_Static[] = {
        { "check_supported_hardware", reinterpret_cast<PyCFunction>(PlayReadyStatics_CheckSupportedHardware), METH_VARARGS, nullptr },
        { "reset_hardware_drm_disabled", reinterpret_cast<PyCFunction>(PlayReadyStatics_ResetHardwareDRMDisabled), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PlayReadyStatics_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlayReadyStatics_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlayReadyStatics_Static) },
        { }
    };

    static PyType_Spec type_spec_PlayReadyStatics_Static = {
        "winrt._winrt_windows_media_protection_playready.PlayReadyStatics_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlayReadyStatics_Static};

    // ----- INDClosedCaptionDataReceivedEventArgs interface --------------------

    static PyObject* _new_INDClosedCaptionDataReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_INDClosedCaptionDataReceivedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionData(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs", L"ClosedCaptionData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClosedCaptionData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionDataFormat(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs", L"ClosedCaptionDataFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClosedCaptionDataFormat();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_PresentationTimestamp(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs", L"PresentationTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PresentationTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDClosedCaptionDataReceivedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_INDClosedCaptionDataReceivedEventArgs[] = {
        { "closed_caption_data", reinterpret_cast<getter>(INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionData), nullptr, nullptr, nullptr },
        { "closed_caption_data_format", reinterpret_cast<getter>(INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionDataFormat), nullptr, nullptr, nullptr },
        { "presentation_timestamp", reinterpret_cast<getter>(INDClosedCaptionDataReceivedEventArgs_get_PresentationTimestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDClosedCaptionDataReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDClosedCaptionDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDClosedCaptionDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDClosedCaptionDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDClosedCaptionDataReceivedEventArgs) },
        { }};

    static PyType_Spec type_spec_INDClosedCaptionDataReceivedEventArgs = {
        "winrt._winrt_windows_media_protection_playready._INDClosedCaptionDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDClosedCaptionDataReceivedEventArgs};

    struct ImplementsINDClosedCaptionDataReceivedEventArgs : py::ImplementsInterfaceT<ImplementsINDClosedCaptionDataReceivedEventArgs, winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>
    {
        ImplementsINDClosedCaptionDataReceivedEventArgs() = delete;
        ImplementsINDClosedCaptionDataReceivedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDClosedCaptionDataReceivedEventArgs, winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ClosedCaptionData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "closed_caption_data")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ClosedCaptionDataFormat()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "closed_caption_data_format")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDClosedCaptionFormat>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PresentationTimestamp()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "presentation_timestamp")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int64_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDClosedCaptionDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDClosedCaptionDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDClosedCaptionDataReceivedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDClosedCaptionDataReceivedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDClosedCaptionDataReceivedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDClosedCaptionDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_INDClosedCaptionDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDClosedCaptionDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDClosedCaptionDataReceivedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDClosedCaptionDataReceivedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDClosedCaptionDataReceivedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDClosedCaptionDataReceivedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsINDClosedCaptionDataReceivedEventArgs = {
        "winrt._winrt_windows_media_protection_playready.INDClosedCaptionDataReceivedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDClosedCaptionDataReceivedEventArgs};

    // ----- INDCustomData interface --------------------

    static PyObject* _new_INDCustomData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDCustomData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDCustomData>::type_name);
        return nullptr;
    }

    static void _dealloc_INDCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDCustomData_get_CustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDCustomData", L"CustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDCustomData_get_CustomDataTypeID(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDCustomData", L"CustomDataTypeID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomDataTypeID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDCustomData[] = {
        { }};

    static PyGetSetDef _getset_INDCustomData[] = {
        { "custom_data", reinterpret_cast<getter>(INDCustomData_get_CustomData), nullptr, nullptr, nullptr },
        { "custom_data_type_id", reinterpret_cast<getter>(INDCustomData_get_CustomDataTypeID), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDCustomData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDCustomData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDCustomData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDCustomData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDCustomData) },
        { }};

    static PyType_Spec type_spec_INDCustomData = {
        "winrt._winrt_windows_media_protection_playready._INDCustomData",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDCustomData};

    struct ImplementsINDCustomData : py::ImplementsInterfaceT<ImplementsINDCustomData, winrt::Windows::Media::Protection::PlayReady::INDCustomData>
    {
        ImplementsINDCustomData() = delete;
        ImplementsINDCustomData(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDCustomData, winrt::Windows::Media::Protection::PlayReady::INDCustomData>(py_obj, runtime_class)
        {
        }

        auto CustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CustomDataTypeID()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "custom_data_type_id")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDCustomData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDCustomData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDCustomData(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDCustomData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDCustomData(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDCustomData>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDCustomData[] = {
        { "_assign_array_", _assign_array_INDCustomData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDCustomData), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDCustomData), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDCustomData), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDCustomData[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDCustomData) },
        { }};

    static PyType_Spec type_spec_ImplementsINDCustomData = {
        "winrt._winrt_windows_media_protection_playready.INDCustomData",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDCustomData};

    // ----- INDDownloadEngine interface --------------------

    static PyObject* _new_INDDownloadEngine(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>::type_name);
        return nullptr;
    }

    static void _dealloc_INDDownloadEngine(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDDownloadEngine_Close(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Open(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Open", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Open(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Pause(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Pause", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Pause();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Resume(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Resume", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Resume();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Seek(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Seek", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Seek(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_BufferFullMaxThresholdInSamples(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"BufferFullMaxThresholdInSamples");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BufferFullMaxThresholdInSamples();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_BufferFullMinThresholdInSamples(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"BufferFullMinThresholdInSamples");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BufferFullMinThresholdInSamples();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_CanSeek(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"CanSeek");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanSeek();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_Notifier(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngine", L"Notifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Notifier();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDDownloadEngine[] = {
        { "close", reinterpret_cast<PyCFunction>(INDDownloadEngine_Close), METH_VARARGS, nullptr },
        { "open", reinterpret_cast<PyCFunction>(INDDownloadEngine_Open), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(INDDownloadEngine_Pause), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(INDDownloadEngine_Resume), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(INDDownloadEngine_Seek), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INDDownloadEngine[] = {
        { "buffer_full_max_threshold_in_samples", reinterpret_cast<getter>(INDDownloadEngine_get_BufferFullMaxThresholdInSamples), nullptr, nullptr, nullptr },
        { "buffer_full_min_threshold_in_samples", reinterpret_cast<getter>(INDDownloadEngine_get_BufferFullMinThresholdInSamples), nullptr, nullptr, nullptr },
        { "can_seek", reinterpret_cast<getter>(INDDownloadEngine_get_CanSeek), nullptr, nullptr, nullptr },
        { "notifier", reinterpret_cast<getter>(INDDownloadEngine_get_Notifier), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDDownloadEngine[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDDownloadEngine) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDDownloadEngine) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDDownloadEngine) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDDownloadEngine) },
        { }};

    static PyType_Spec type_spec_INDDownloadEngine = {
        "winrt._winrt_windows_media_protection_playready._INDDownloadEngine",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDDownloadEngine};

    struct ImplementsINDDownloadEngine : py::ImplementsInterfaceT<ImplementsINDDownloadEngine, winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>
    {
        ImplementsINDDownloadEngine() = delete;
        ImplementsINDDownloadEngine(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDDownloadEngine, winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Open(winrt::Windows::Foundation::Uri const& param0, winrt::array_view<uint8_t const> param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "open")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Pause()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "pause")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Resume()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "resume")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Seek(winrt::Windows::Foundation::TimeSpan param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "seek")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto BufferFullMaxThresholdInSamples()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "buffer_full_max_threshold_in_samples")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto BufferFullMinThresholdInSamples()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "buffer_full_min_threshold_in_samples")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanSeek()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_seek")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Notifier()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "notifier")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDDownloadEngine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDDownloadEngine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDDownloadEngine(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDDownloadEngine(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDDownloadEngine>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDDownloadEngine[] = {
        { "_assign_array_", _assign_array_INDDownloadEngine, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDDownloadEngine), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDDownloadEngine), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDDownloadEngine), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDDownloadEngine[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDDownloadEngine) },
        { }};

    static PyType_Spec type_spec_ImplementsINDDownloadEngine = {
        "winrt._winrt_windows_media_protection_playready.INDDownloadEngine",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDDownloadEngine};

    // ----- INDDownloadEngineNotifier interface --------------------

    static PyObject* _new_INDDownloadEngineNotifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>::type_name);
        return nullptr;
    }

    static void _dealloc_INDDownloadEngineNotifier(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDDownloadEngineNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnContentIDReceived", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnContentIDReceived(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnDataReceived", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.OnDataReceived(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnEndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnEndOfStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.OnEndOfStream();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnNetworkError(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnNetworkError", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.OnNetworkError();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnPlayReadyObjectReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnPlayReadyObjectReceived", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnPlayReadyObjectReceived(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnStreamOpened(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDDownloadEngineNotifier", L"OnStreamOpened", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.OnStreamOpened();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDDownloadEngineNotifier[] = {
        { "on_content_id_received", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnContentIDReceived), METH_VARARGS, nullptr },
        { "on_data_received", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnDataReceived), METH_VARARGS, nullptr },
        { "on_end_of_stream", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnEndOfStream), METH_VARARGS, nullptr },
        { "on_network_error", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnNetworkError), METH_VARARGS, nullptr },
        { "on_play_ready_object_received", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnPlayReadyObjectReceived), METH_VARARGS, nullptr },
        { "on_stream_opened", reinterpret_cast<PyCFunction>(INDDownloadEngineNotifier_OnStreamOpened), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INDDownloadEngineNotifier[] = {
        { }};

    static PyType_Slot _type_slots_INDDownloadEngineNotifier[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDDownloadEngineNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDDownloadEngineNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDDownloadEngineNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDDownloadEngineNotifier) },
        { }};

    static PyType_Spec type_spec_INDDownloadEngineNotifier = {
        "winrt._winrt_windows_media_protection_playready._INDDownloadEngineNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDDownloadEngineNotifier};

    struct ImplementsINDDownloadEngineNotifier : py::ImplementsInterfaceT<ImplementsINDDownloadEngineNotifier, winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>
    {
        ImplementsINDDownloadEngineNotifier() = delete;
        ImplementsINDDownloadEngineNotifier(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDDownloadEngineNotifier, winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>(py_obj, runtime_class)
        {
        }

        auto OnContentIDReceived(winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_content_id_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnDataReceived(winrt::array_view<uint8_t const> param0, uint32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_data_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnEndOfStream()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_end_of_stream")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnNetworkError()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_network_error")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnPlayReadyObjectReceived(winrt::array_view<uint8_t const> param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_play_ready_object_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnStreamOpened()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_stream_opened")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDDownloadEngineNotifier>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDDownloadEngineNotifier[] = {
        { "_assign_array_", _assign_array_INDDownloadEngineNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDDownloadEngineNotifier), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDDownloadEngineNotifier), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDDownloadEngineNotifier), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDDownloadEngineNotifier[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDDownloadEngineNotifier) },
        { }};

    static PyType_Spec type_spec_ImplementsINDDownloadEngineNotifier = {
        "winrt._winrt_windows_media_protection_playready.INDDownloadEngineNotifier",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDDownloadEngineNotifier};

    // ----- INDLicenseFetchCompletedEventArgs interface --------------------

    static PyObject* _new_INDLicenseFetchCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDLicenseFetchCompletedEventArgs_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchCompletedEventArgs", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchCompletedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_INDLicenseFetchCompletedEventArgs[] = {
        { "response_custom_data", reinterpret_cast<getter>(INDLicenseFetchCompletedEventArgs_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDLicenseFetchCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDLicenseFetchCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDLicenseFetchCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDLicenseFetchCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDLicenseFetchCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_INDLicenseFetchCompletedEventArgs = {
        "winrt._winrt_windows_media_protection_playready._INDLicenseFetchCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchCompletedEventArgs};

    struct ImplementsINDLicenseFetchCompletedEventArgs : py::ImplementsInterfaceT<ImplementsINDLicenseFetchCompletedEventArgs, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>
    {
        ImplementsINDLicenseFetchCompletedEventArgs() = delete;
        ImplementsINDLicenseFetchCompletedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDLicenseFetchCompletedEventArgs, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ResponseCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "response_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDLicenseFetchCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDLicenseFetchCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDLicenseFetchCompletedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDLicenseFetchCompletedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDLicenseFetchCompletedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDLicenseFetchCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_INDLicenseFetchCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDLicenseFetchCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDLicenseFetchCompletedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDLicenseFetchCompletedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDLicenseFetchCompletedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDLicenseFetchCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsINDLicenseFetchCompletedEventArgs = {
        "winrt._winrt_windows_media_protection_playready.INDLicenseFetchCompletedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDLicenseFetchCompletedEventArgs};

    // ----- INDLicenseFetchDescriptor interface --------------------

    static PyObject* _new_INDLicenseFetchDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchDescriptor(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDLicenseFetchDescriptor_get_ContentID(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor", L"ContentID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDLicenseFetchDescriptor_get_ContentIDType(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor", L"ContentIDType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentIDType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor", L"LicenseFetchChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LicenseFetchChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor", L"LicenseFetchChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(arg);

            {
                auto _gil = release_gil();
                self->obj.LicenseFetchChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchDescriptor[] = {
        { }};

    static PyGetSetDef _getset_INDLicenseFetchDescriptor[] = {
        { "content_id", reinterpret_cast<getter>(INDLicenseFetchDescriptor_get_ContentID), nullptr, nullptr, nullptr },
        { "content_id_type", reinterpret_cast<getter>(INDLicenseFetchDescriptor_get_ContentIDType), nullptr, nullptr, nullptr },
        { "license_fetch_challenge_custom_data", reinterpret_cast<getter>(INDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData), reinterpret_cast<setter>(INDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDLicenseFetchDescriptor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDLicenseFetchDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDLicenseFetchDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDLicenseFetchDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDLicenseFetchDescriptor) },
        { }};

    static PyType_Spec type_spec_INDLicenseFetchDescriptor = {
        "winrt._winrt_windows_media_protection_playready._INDLicenseFetchDescriptor",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchDescriptor};

    struct ImplementsINDLicenseFetchDescriptor : py::ImplementsInterfaceT<ImplementsINDLicenseFetchDescriptor, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>
    {
        ImplementsINDLicenseFetchDescriptor() = delete;
        ImplementsINDLicenseFetchDescriptor(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDLicenseFetchDescriptor, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(py_obj, runtime_class)
        {
        }

        auto ContentID()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "content_id")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContentIDType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "content_id_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDContentIDType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LicenseFetchChallengeCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "license_fetch_challenge_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void LicenseFetchChallengeCustomData(winrt::Windows::Media::Protection::PlayReady::INDCustomData const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "license_fetch_challenge_custom_data", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDLicenseFetchDescriptor>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDLicenseFetchDescriptor[] = {
        { "_assign_array_", _assign_array_INDLicenseFetchDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDLicenseFetchDescriptor), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDLicenseFetchDescriptor), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDLicenseFetchDescriptor), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDLicenseFetchDescriptor[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDLicenseFetchDescriptor) },
        { }};

    static PyType_Spec type_spec_ImplementsINDLicenseFetchDescriptor = {
        "winrt._winrt_windows_media_protection_playready.INDLicenseFetchDescriptor",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDLicenseFetchDescriptor};

    // ----- INDLicenseFetchResult interface --------------------

    static PyObject* _new_INDLicenseFetchResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>::type_name);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchResult(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDLicenseFetchResult_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDLicenseFetchResult", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchResult[] = {
        { }};

    static PyGetSetDef _getset_INDLicenseFetchResult[] = {
        { "response_custom_data", reinterpret_cast<getter>(INDLicenseFetchResult_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDLicenseFetchResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDLicenseFetchResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDLicenseFetchResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDLicenseFetchResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDLicenseFetchResult) },
        { }};

    static PyType_Spec type_spec_INDLicenseFetchResult = {
        "winrt._winrt_windows_media_protection_playready._INDLicenseFetchResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchResult};

    struct ImplementsINDLicenseFetchResult : py::ImplementsInterfaceT<ImplementsINDLicenseFetchResult, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>
    {
        ImplementsINDLicenseFetchResult() = delete;
        ImplementsINDLicenseFetchResult(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDLicenseFetchResult, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>(py_obj, runtime_class)
        {
        }

        auto ResponseCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "response_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDLicenseFetchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDLicenseFetchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDLicenseFetchResult(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDLicenseFetchResult(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDLicenseFetchResult>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDLicenseFetchResult[] = {
        { "_assign_array_", _assign_array_INDLicenseFetchResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDLicenseFetchResult), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDLicenseFetchResult), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDLicenseFetchResult), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDLicenseFetchResult[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDLicenseFetchResult) },
        { }};

    static PyType_Spec type_spec_ImplementsINDLicenseFetchResult = {
        "winrt._winrt_windows_media_protection_playready.INDLicenseFetchResult",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDLicenseFetchResult};

    // ----- INDMessenger interface --------------------

    static PyObject* _new_INDMessenger(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDMessenger>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDMessenger>::type_name);
        return nullptr;
    }

    static void _dealloc_INDMessenger(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDMessenger_SendLicenseFetchRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDMessenger", L"SendLicenseFetchRequestAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendLicenseFetchRequestAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendProximityDetectionResponseAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDMessenger", L"SendProximityDetectionResponseAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendProximityDetectionResponseAsync(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendProximityDetectionStartAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDMessenger", L"SendProximityDetectionStartAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendProximityDetectionStartAsync(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendRegistrationRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDMessenger", L"SendRegistrationRequestAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendRegistrationRequestAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDMessenger[] = {
        { "send_license_fetch_request_async", reinterpret_cast<PyCFunction>(INDMessenger_SendLicenseFetchRequestAsync), METH_VARARGS, nullptr },
        { "send_proximity_detection_response_async", reinterpret_cast<PyCFunction>(INDMessenger_SendProximityDetectionResponseAsync), METH_VARARGS, nullptr },
        { "send_proximity_detection_start_async", reinterpret_cast<PyCFunction>(INDMessenger_SendProximityDetectionStartAsync), METH_VARARGS, nullptr },
        { "send_registration_request_async", reinterpret_cast<PyCFunction>(INDMessenger_SendRegistrationRequestAsync), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INDMessenger[] = {
        { }};

    static PyType_Slot _type_slots_INDMessenger[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDMessenger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDMessenger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDMessenger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDMessenger) },
        { }};

    static PyType_Spec type_spec_INDMessenger = {
        "winrt._winrt_windows_media_protection_playready._INDMessenger",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDMessenger};

    struct ImplementsINDMessenger : py::ImplementsInterfaceT<ImplementsINDMessenger, winrt::Windows::Media::Protection::PlayReady::INDMessenger>
    {
        ImplementsINDMessenger() = delete;
        ImplementsINDMessenger(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDMessenger, winrt::Windows::Media::Protection::PlayReady::INDMessenger>(py_obj, runtime_class)
        {
        }

        auto SendLicenseFetchRequestAsync(winrt::array_view<uint8_t const> param0, winrt::array_view<uint8_t const> param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "send_license_fetch_request_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Media::Protection::PlayReady::INDSendResult>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SendProximityDetectionResponseAsync(winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType param0, winrt::array_view<uint8_t const> param1, winrt::array_view<uint8_t const> param2, winrt::array_view<uint8_t const> param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "send_proximity_detection_response_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Media::Protection::PlayReady::INDSendResult>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SendProximityDetectionStartAsync(winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType param0, winrt::array_view<uint8_t const> param1, winrt::array_view<uint8_t const> param2, winrt::array_view<uint8_t const> param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "send_proximity_detection_start_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Media::Protection::PlayReady::INDSendResult>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SendRegistrationRequestAsync(winrt::array_view<uint8_t const> param0, winrt::array_view<uint8_t const> param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "send_registration_request_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Media::Protection::PlayReady::INDSendResult>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDMessenger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDMessenger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDMessenger(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDMessenger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDMessenger(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDMessenger>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDMessenger[] = {
        { "_assign_array_", _assign_array_INDMessenger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDMessenger), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDMessenger), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDMessenger), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDMessenger[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDMessenger) },
        { }};

    static PyType_Spec type_spec_ImplementsINDMessenger = {
        "winrt._winrt_windows_media_protection_playready.INDMessenger",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDMessenger};

    // ----- INDProximityDetectionCompletedEventArgs interface --------------------

    static PyObject* _new_INDProximityDetectionCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_INDProximityDetectionCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDProximityDetectionCompletedEventArgs_get_ProximityDetectionRetryCount(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDProximityDetectionCompletedEventArgs", L"ProximityDetectionRetryCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProximityDetectionRetryCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDProximityDetectionCompletedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_INDProximityDetectionCompletedEventArgs[] = {
        { "proximity_detection_retry_count", reinterpret_cast<getter>(INDProximityDetectionCompletedEventArgs_get_ProximityDetectionRetryCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDProximityDetectionCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDProximityDetectionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDProximityDetectionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDProximityDetectionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDProximityDetectionCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_INDProximityDetectionCompletedEventArgs = {
        "winrt._winrt_windows_media_protection_playready._INDProximityDetectionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDProximityDetectionCompletedEventArgs};

    struct ImplementsINDProximityDetectionCompletedEventArgs : py::ImplementsInterfaceT<ImplementsINDProximityDetectionCompletedEventArgs, winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>
    {
        ImplementsINDProximityDetectionCompletedEventArgs() = delete;
        ImplementsINDProximityDetectionCompletedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDProximityDetectionCompletedEventArgs, winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ProximityDetectionRetryCount()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "proximity_detection_retry_count")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDProximityDetectionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDProximityDetectionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDProximityDetectionCompletedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDProximityDetectionCompletedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDProximityDetectionCompletedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDProximityDetectionCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_INDProximityDetectionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDProximityDetectionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDProximityDetectionCompletedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDProximityDetectionCompletedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDProximityDetectionCompletedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDProximityDetectionCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsINDProximityDetectionCompletedEventArgs = {
        "winrt._winrt_windows_media_protection_playready.INDProximityDetectionCompletedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDProximityDetectionCompletedEventArgs};

    // ----- INDRegistrationCompletedEventArgs interface --------------------

    static PyObject* _new_INDRegistrationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_INDRegistrationCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_TransmitterCertificateAccepted(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs", L"TransmitterCertificateAccepted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransmitterCertificateAccepted();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INDRegistrationCompletedEventArgs_put_TransmitterCertificateAccepted(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs", L"TransmitterCertificateAccepted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.TransmitterCertificateAccepted(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_TransmitterProperties(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs", L"TransmitterProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransmitterProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDRegistrationCompletedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_INDRegistrationCompletedEventArgs[] = {
        { "response_custom_data", reinterpret_cast<getter>(INDRegistrationCompletedEventArgs_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { "transmitter_certificate_accepted", reinterpret_cast<getter>(INDRegistrationCompletedEventArgs_get_TransmitterCertificateAccepted), reinterpret_cast<setter>(INDRegistrationCompletedEventArgs_put_TransmitterCertificateAccepted), nullptr, nullptr },
        { "transmitter_properties", reinterpret_cast<getter>(INDRegistrationCompletedEventArgs_get_TransmitterProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDRegistrationCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDRegistrationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDRegistrationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDRegistrationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDRegistrationCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_INDRegistrationCompletedEventArgs = {
        "winrt._winrt_windows_media_protection_playready._INDRegistrationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDRegistrationCompletedEventArgs};

    struct ImplementsINDRegistrationCompletedEventArgs : py::ImplementsInterfaceT<ImplementsINDRegistrationCompletedEventArgs, winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>
    {
        ImplementsINDRegistrationCompletedEventArgs() = delete;
        ImplementsINDRegistrationCompletedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDRegistrationCompletedEventArgs, winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ResponseCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "response_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TransmitterCertificateAccepted()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "transmitter_certificate_accepted")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void TransmitterCertificateAccepted(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "transmitter_certificate_accepted", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TransmitterProperties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "transmitter_properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDRegistrationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDRegistrationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDRegistrationCompletedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDRegistrationCompletedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDRegistrationCompletedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDRegistrationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_INDRegistrationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDRegistrationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDRegistrationCompletedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDRegistrationCompletedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDRegistrationCompletedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDRegistrationCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsINDRegistrationCompletedEventArgs = {
        "winrt._winrt_windows_media_protection_playready.INDRegistrationCompletedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDRegistrationCompletedEventArgs};

    // ----- INDSendResult interface --------------------

    static PyObject* _new_INDSendResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDSendResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDSendResult>::type_name);
        return nullptr;
    }

    static void _dealloc_INDSendResult(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDSendResult_get_Response(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDSendResult", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Response();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDSendResult[] = {
        { }};

    static PyGetSetDef _getset_INDSendResult[] = {
        { "response", reinterpret_cast<getter>(INDSendResult_get_Response), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDSendResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDSendResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDSendResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDSendResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDSendResult) },
        { }};

    static PyType_Spec type_spec_INDSendResult = {
        "winrt._winrt_windows_media_protection_playready._INDSendResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDSendResult};

    struct ImplementsINDSendResult : py::ImplementsInterfaceT<ImplementsINDSendResult, winrt::Windows::Media::Protection::PlayReady::INDSendResult>
    {
        ImplementsINDSendResult() = delete;
        ImplementsINDSendResult(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDSendResult, winrt::Windows::Media::Protection::PlayReady::INDSendResult>(py_obj, runtime_class)
        {
        }

        auto Response()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "response")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDSendResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDSendResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDSendResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDSendResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDSendResult(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDSendResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDSendResult(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDSendResult>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDSendResult[] = {
        { "_assign_array_", _assign_array_INDSendResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDSendResult), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDSendResult), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDSendResult), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDSendResult[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDSendResult) },
        { }};

    static PyType_Spec type_spec_ImplementsINDSendResult = {
        "winrt._winrt_windows_media_protection_playready.INDSendResult",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDSendResult};

    // ----- INDStartResult interface --------------------

    static PyObject* _new_INDStartResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStartResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStartResult>::type_name);
        return nullptr;
    }

    static void _dealloc_INDStartResult(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDStartResult_get_MediaStreamSource(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDStartResult", L"MediaStreamSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MediaStreamSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStartResult[] = {
        { }};

    static PyGetSetDef _getset_INDStartResult[] = {
        { "media_stream_source", reinterpret_cast<getter>(INDStartResult_get_MediaStreamSource), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDStartResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDStartResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDStartResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDStartResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDStartResult) },
        { }};

    static PyType_Spec type_spec_INDStartResult = {
        "winrt._winrt_windows_media_protection_playready._INDStartResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStartResult};

    struct ImplementsINDStartResult : py::ImplementsInterfaceT<ImplementsINDStartResult, winrt::Windows::Media::Protection::PlayReady::INDStartResult>
    {
        ImplementsINDStartResult() = delete;
        ImplementsINDStartResult(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDStartResult, winrt::Windows::Media::Protection::PlayReady::INDStartResult>(py_obj, runtime_class)
        {
        }

        auto MediaStreamSource()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "media_stream_source")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Core::MediaStreamSource>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDStartResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStartResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDStartResult(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDStartResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDStartResult(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDStartResult>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDStartResult[] = {
        { "_assign_array_", _assign_array_INDStartResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDStartResult), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDStartResult), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDStartResult), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDStartResult[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDStartResult) },
        { }};

    static PyType_Spec type_spec_ImplementsINDStartResult = {
        "winrt._winrt_windows_media_protection_playready.INDStartResult",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDStartResult};

    // ----- INDStorageFileHelper interface --------------------

    static PyObject* _new_INDStorageFileHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_INDStorageFileHelper(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDStorageFileHelper_GetFileURLs(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStorageFileHelper", L"GetFileURLs", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFileURLs(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStorageFileHelper[] = {
        { "get_file_u_r_ls", reinterpret_cast<PyCFunction>(INDStorageFileHelper_GetFileURLs), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INDStorageFileHelper[] = {
        { }};

    static PyType_Slot _type_slots_INDStorageFileHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDStorageFileHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDStorageFileHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDStorageFileHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDStorageFileHelper) },
        { }};

    static PyType_Spec type_spec_INDStorageFileHelper = {
        "winrt._winrt_windows_media_protection_playready._INDStorageFileHelper",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStorageFileHelper};

    struct ImplementsINDStorageFileHelper : py::ImplementsInterfaceT<ImplementsINDStorageFileHelper, winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>
    {
        ImplementsINDStorageFileHelper() = delete;
        ImplementsINDStorageFileHelper(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDStorageFileHelper, winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>(py_obj, runtime_class)
        {
        }

        auto GetFileURLs(winrt::Windows::Storage::IStorageFile const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_file_u_r_ls")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDStorageFileHelper(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDStorageFileHelper(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDStorageFileHelper>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDStorageFileHelper[] = {
        { "_assign_array_", _assign_array_INDStorageFileHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDStorageFileHelper), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDStorageFileHelper), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDStorageFileHelper), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDStorageFileHelper[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDStorageFileHelper) },
        { }};

    static PyType_Spec type_spec_ImplementsINDStorageFileHelper = {
        "winrt._winrt_windows_media_protection_playready.INDStorageFileHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDStorageFileHelper};

    // ----- INDStreamParser interface --------------------

    static PyObject* _new_INDStreamParser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>::type_name);
        return nullptr;
    }

    static void _dealloc_INDStreamParser(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDStreamParser_BeginOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"BeginOfStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.BeginOfStream();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_EndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"EndOfStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.EndOfStream();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_GetStreamInformation(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"GetStreamInformation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStreamInformation(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_ParseData(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"ParseData", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ParseData(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_get_Notifier(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDStreamParser", L"Notifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Notifier();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStreamParser[] = {
        { "begin_of_stream", reinterpret_cast<PyCFunction>(INDStreamParser_BeginOfStream), METH_VARARGS, nullptr },
        { "end_of_stream", reinterpret_cast<PyCFunction>(INDStreamParser_EndOfStream), METH_VARARGS, nullptr },
        { "get_stream_information", reinterpret_cast<PyCFunction>(INDStreamParser_GetStreamInformation), METH_VARARGS, nullptr },
        { "parse_data", reinterpret_cast<PyCFunction>(INDStreamParser_ParseData), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INDStreamParser[] = {
        { "notifier", reinterpret_cast<getter>(INDStreamParser_get_Notifier), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDStreamParser[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDStreamParser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDStreamParser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDStreamParser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDStreamParser) },
        { }};

    static PyType_Spec type_spec_INDStreamParser = {
        "winrt._winrt_windows_media_protection_playready._INDStreamParser",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStreamParser};

    struct ImplementsINDStreamParser : py::ImplementsInterfaceT<ImplementsINDStreamParser, winrt::Windows::Media::Protection::PlayReady::INDStreamParser>
    {
        ImplementsINDStreamParser() = delete;
        ImplementsINDStreamParser(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDStreamParser, winrt::Windows::Media::Protection::PlayReady::INDStreamParser>(py_obj, runtime_class)
        {
        }

        auto BeginOfStream()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "begin_of_stream")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EndOfStream()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "end_of_stream")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetStreamInformation(winrt::Windows::Media::Core::IMediaStreamDescriptor const& param0, winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_stream_information")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType>(return_value.get(), 1);

                return py::convert_to<uint32_t>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ParseData(winrt::array_view<uint8_t const> param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "parse_data")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Notifier()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "notifier")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDStreamParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDStreamParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDStreamParser(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDStreamParser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDStreamParser>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDStreamParser[] = {
        { "_assign_array_", _assign_array_INDStreamParser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDStreamParser), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDStreamParser), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDStreamParser), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDStreamParser[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDStreamParser) },
        { }};

    static PyType_Spec type_spec_ImplementsINDStreamParser = {
        "winrt._winrt_windows_media_protection_playready.INDStreamParser",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDStreamParser};

    // ----- INDStreamParserNotifier interface --------------------

    static PyObject* _new_INDStreamParserNotifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>::type_name);
        return nullptr;
    }

    static void _dealloc_INDStreamParserNotifier(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDStreamParserNotifier_OnBeginSetupDecryptor(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParserNotifier", L"OnBeginSetupDecryptor", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.OnBeginSetupDecryptor(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParserNotifier", L"OnContentIDReceived", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnContentIDReceived(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnMediaStreamDescriptorCreated(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParserNotifier", L"OnMediaStreamDescriptorCreated", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.OnMediaStreamDescriptorCreated(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnSampleParsed(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 6)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.INDStreamParserNotifier", L"OnSampleParsed", 6);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(args, 2);
                auto param3 = py::convert_to<int64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDClosedCaptionFormat>(args, 4);
                auto param5 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 5);

                {
                    auto _gil = release_gil();
                    self->obj.OnSampleParsed(param0, param1, param2, param3, param4, param5);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStreamParserNotifier[] = {
        { "on_begin_setup_decryptor", reinterpret_cast<PyCFunction>(INDStreamParserNotifier_OnBeginSetupDecryptor), METH_VARARGS, nullptr },
        { "on_content_id_received", reinterpret_cast<PyCFunction>(INDStreamParserNotifier_OnContentIDReceived), METH_VARARGS, nullptr },
        { "on_media_stream_descriptor_created", reinterpret_cast<PyCFunction>(INDStreamParserNotifier_OnMediaStreamDescriptorCreated), METH_VARARGS, nullptr },
        { "on_sample_parsed", reinterpret_cast<PyCFunction>(INDStreamParserNotifier_OnSampleParsed), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_INDStreamParserNotifier[] = {
        { }};

    static PyType_Slot _type_slots_INDStreamParserNotifier[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDStreamParserNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDStreamParserNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDStreamParserNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDStreamParserNotifier) },
        { }};

    static PyType_Spec type_spec_INDStreamParserNotifier = {
        "winrt._winrt_windows_media_protection_playready._INDStreamParserNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStreamParserNotifier};

    struct ImplementsINDStreamParserNotifier : py::ImplementsInterfaceT<ImplementsINDStreamParserNotifier, winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>
    {
        ImplementsINDStreamParserNotifier() = delete;
        ImplementsINDStreamParserNotifier(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDStreamParserNotifier, winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>(py_obj, runtime_class)
        {
        }

        auto OnBeginSetupDecryptor(winrt::Windows::Media::Core::IMediaStreamDescriptor const& param0, winrt::guid param1, winrt::array_view<uint8_t const> param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_begin_setup_decryptor")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnContentIDReceived(winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_content_id_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnMediaStreamDescriptorCreated(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::AudioStreamDescriptor> const& param0, winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::VideoStreamDescriptor> const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_media_stream_descriptor_created")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnSampleParsed(uint32_t param0, winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType param1, winrt::Windows::Media::Core::MediaStreamSample const& param2, int64_t param3, winrt::Windows::Media::Protection::PlayReady::NDClosedCaptionFormat param4, winrt::array_view<uint8_t const> param5)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_sample_parsed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param4{py::convert(param4)};
                if (!py_param4)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param5{py::convert(param5)};
                if (!py_param5)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(6, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get(), py_param4.get(), py_param5.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDStreamParserNotifier(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDStreamParserNotifier(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDStreamParserNotifier>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDStreamParserNotifier[] = {
        { "_assign_array_", _assign_array_INDStreamParserNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDStreamParserNotifier), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDStreamParserNotifier), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDStreamParserNotifier), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDStreamParserNotifier[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDStreamParserNotifier) },
        { }};

    static PyType_Spec type_spec_ImplementsINDStreamParserNotifier = {
        "winrt._winrt_windows_media_protection_playready.INDStreamParserNotifier",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDStreamParserNotifier};

    // ----- INDTransmitterProperties interface --------------------

    static PyObject* _new_INDTransmitterProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_INDTransmitterProperties(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INDTransmitterProperties_get_CertificateType(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"CertificateType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CertificateType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ClientID(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ClientID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClientID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelDigest(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ModelDigest");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModelDigest();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelManufacturerName(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ModelManufacturerName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModelManufacturerName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelName(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ModelName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModelName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelNumber(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"ModelNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModelNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_PlatformIdentifier(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"PlatformIdentifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlatformIdentifier();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SecurityLevel(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"SecurityLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SecurityLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SecurityVersion(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"SecurityVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SecurityVersion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SupportedFeatures(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.INDTransmitterProperties", L"SupportedFeatures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedFeatures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDTransmitterProperties[] = {
        { }};

    static PyGetSetDef _getset_INDTransmitterProperties[] = {
        { "certificate_type", reinterpret_cast<getter>(INDTransmitterProperties_get_CertificateType), nullptr, nullptr, nullptr },
        { "client_id", reinterpret_cast<getter>(INDTransmitterProperties_get_ClientID), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(INDTransmitterProperties_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "model_digest", reinterpret_cast<getter>(INDTransmitterProperties_get_ModelDigest), nullptr, nullptr, nullptr },
        { "model_manufacturer_name", reinterpret_cast<getter>(INDTransmitterProperties_get_ModelManufacturerName), nullptr, nullptr, nullptr },
        { "model_name", reinterpret_cast<getter>(INDTransmitterProperties_get_ModelName), nullptr, nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(INDTransmitterProperties_get_ModelNumber), nullptr, nullptr, nullptr },
        { "platform_identifier", reinterpret_cast<getter>(INDTransmitterProperties_get_PlatformIdentifier), nullptr, nullptr, nullptr },
        { "security_level", reinterpret_cast<getter>(INDTransmitterProperties_get_SecurityLevel), nullptr, nullptr, nullptr },
        { "security_version", reinterpret_cast<getter>(INDTransmitterProperties_get_SecurityVersion), nullptr, nullptr, nullptr },
        { "supported_features", reinterpret_cast<getter>(INDTransmitterProperties_get_SupportedFeatures), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_INDTransmitterProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_INDTransmitterProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INDTransmitterProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INDTransmitterProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INDTransmitterProperties) },
        { }};

    static PyType_Spec type_spec_INDTransmitterProperties = {
        "winrt._winrt_windows_media_protection_playready._INDTransmitterProperties",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDTransmitterProperties};

    struct ImplementsINDTransmitterProperties : py::ImplementsInterfaceT<ImplementsINDTransmitterProperties, winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>
    {
        ImplementsINDTransmitterProperties() = delete;
        ImplementsINDTransmitterProperties(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINDTransmitterProperties, winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>(py_obj, runtime_class)
        {
        }

        auto CertificateType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "certificate_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDCertificateType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ClientID()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "client_id")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ExpirationDate()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "expiration_date")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ModelDigest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "model_digest")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ModelManufacturerName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "model_manufacturer_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ModelName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "model_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ModelNumber()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "model_number")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PlatformIdentifier()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "platform_identifier")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDCertificatePlatformID>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SecurityLevel()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "security_level")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SecurityVersion()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "security_version")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SupportedFeatures()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "supported_features")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::Media::Protection::PlayReady::NDCertificateFeature, false>>(value.get());
                return winrt::com_array<winrt::Windows::Media::Protection::PlayReady::NDCertificateFeature>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INDTransmitterProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INDTransmitterProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINDTransmitterProperties(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINDTransmitterProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINDTransmitterProperties>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINDTransmitterProperties[] = {
        { "_assign_array_", _assign_array_INDTransmitterProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INDTransmitterProperties), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINDTransmitterProperties), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINDTransmitterProperties), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINDTransmitterProperties[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINDTransmitterProperties) },
        { }};

    static PyType_Spec type_spec_ImplementsINDTransmitterProperties = {
        "winrt._winrt_windows_media_protection_playready.INDTransmitterProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsINDTransmitterProperties};

    // ----- IPlayReadyDomain interface --------------------

    static PyObject* _new_IPlayReadyDomain(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyDomain(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyDomain_get_AccountId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"AccountId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AccountId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_DomainJoinUrl(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"DomainJoinUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainJoinUrl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_FriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"FriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FriendlyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_Revision(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"Revision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Revision();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_ServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyDomain", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyDomain[] = {
        { }};

    static PyGetSetDef _getset_IPlayReadyDomain[] = {
        { "account_id", reinterpret_cast<getter>(IPlayReadyDomain_get_AccountId), nullptr, nullptr, nullptr },
        { "domain_join_url", reinterpret_cast<getter>(IPlayReadyDomain_get_DomainJoinUrl), nullptr, nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(IPlayReadyDomain_get_FriendlyName), nullptr, nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(IPlayReadyDomain_get_Revision), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IPlayReadyDomain_get_ServiceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPlayReadyDomain[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyDomain) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyDomain) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyDomain) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyDomain) },
        { }};

    static PyType_Spec type_spec_IPlayReadyDomain = {
        "winrt._winrt_windows_media_protection_playready._IPlayReadyDomain",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyDomain};

    struct ImplementsIPlayReadyDomain : py::ImplementsInterfaceT<ImplementsIPlayReadyDomain, winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>
    {
        ImplementsIPlayReadyDomain() = delete;
        ImplementsIPlayReadyDomain(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPlayReadyDomain, winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>(py_obj, runtime_class)
        {
        }

        auto AccountId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "account_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DomainJoinUrl()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "domain_join_url")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Uri>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FriendlyName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "friendly_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Revision()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "revision")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPlayReadyDomain(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPlayReadyDomain(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPlayReadyDomain>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPlayReadyDomain[] = {
        { "_assign_array_", _assign_array_IPlayReadyDomain, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyDomain), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPlayReadyDomain), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPlayReadyDomain), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPlayReadyDomain[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPlayReadyDomain) },
        { }};

    static PyType_Spec type_spec_ImplementsIPlayReadyDomain = {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyDomain",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPlayReadyDomain};

    // ----- IPlayReadyLicense interface --------------------

    static PyObject* _new_IPlayReadyLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicense(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyLicense_GetKIDAtChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"GetKIDAtChainDepth", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetKIDAtChainDepth(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"ChainDepth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChainDepth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_DomainAccountID(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"DomainAccountID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainAccountID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ExpireAfterFirstPlay(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"ExpireAfterFirstPlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpireAfterFirstPlay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_FullyEvaluated(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"FullyEvaluated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FullyEvaluated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_UsableForPlay(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicense", L"UsableForPlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsableForPlay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicense[] = {
        { "get_k_i_d_at_chain_depth", reinterpret_cast<PyCFunction>(IPlayReadyLicense_GetKIDAtChainDepth), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPlayReadyLicense[] = {
        { "chain_depth", reinterpret_cast<getter>(IPlayReadyLicense_get_ChainDepth), nullptr, nullptr, nullptr },
        { "domain_account_id", reinterpret_cast<getter>(IPlayReadyLicense_get_DomainAccountID), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(IPlayReadyLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "expire_after_first_play", reinterpret_cast<getter>(IPlayReadyLicense_get_ExpireAfterFirstPlay), nullptr, nullptr, nullptr },
        { "fully_evaluated", reinterpret_cast<getter>(IPlayReadyLicense_get_FullyEvaluated), nullptr, nullptr, nullptr },
        { "usable_for_play", reinterpret_cast<getter>(IPlayReadyLicense_get_UsableForPlay), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPlayReadyLicense[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyLicense) },
        { }};

    static PyType_Spec type_spec_IPlayReadyLicense = {
        "winrt._winrt_windows_media_protection_playready._IPlayReadyLicense",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicense};

    struct ImplementsIPlayReadyLicense : py::ImplementsInterfaceT<ImplementsIPlayReadyLicense, winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>
    {
        ImplementsIPlayReadyLicense() = delete;
        ImplementsIPlayReadyLicense(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPlayReadyLicense, winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>(py_obj, runtime_class)
        {
        }

        auto GetKIDAtChainDepth(uint32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_k_i_d_at_chain_depth")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ChainDepth()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "chain_depth")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DomainAccountID()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "domain_account_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ExpirationDate()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "expiration_date")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ExpireAfterFirstPlay()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "expire_after_first_play")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FullyEvaluated()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "fully_evaluated")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto UsableForPlay()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "usable_for_play")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPlayReadyLicense(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPlayReadyLicense(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPlayReadyLicense>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPlayReadyLicense[] = {
        { "_assign_array_", _assign_array_IPlayReadyLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyLicense), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPlayReadyLicense), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPlayReadyLicense), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPlayReadyLicense[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPlayReadyLicense) },
        { }};

    static PyType_Spec type_spec_ImplementsIPlayReadyLicense = {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyLicense",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPlayReadyLicense};

    // ----- IPlayReadyLicenseAcquisitionServiceRequest interface --------------------

    static PyObject* _new_IPlayReadyLicenseAcquisitionServiceRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseAcquisitionServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest", L"ContentHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentHeader();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest", L"ContentHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContentHeader(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DomainServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest", L"DomainServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.DomainServiceId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseAcquisitionServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(IPlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(IPlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(IPlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(IPlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPlayReadyLicenseAcquisitionServiceRequest[] = {
        { "content_header", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader), reinterpret_cast<setter>(IPlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader), nullptr, nullptr },
        { "domain_service_id", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId), reinterpret_cast<setter>(IPlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId), nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(IPlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_Uri), reinterpret_cast<setter>(IPlayReadyLicenseAcquisitionServiceRequest_put_Uri), nullptr, nullptr },
        { "protection_system", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPlayReadyLicenseAcquisitionServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPlayReadyLicenseAcquisitionServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyLicenseAcquisitionServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyLicenseAcquisitionServiceRequest) },
        { }};

    static PyType_Spec type_spec_IPlayReadyLicenseAcquisitionServiceRequest = {
        "winrt._winrt_windows_media_protection_playready._IPlayReadyLicenseAcquisitionServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseAcquisitionServiceRequest};

    struct ImplementsIPlayReadyLicenseAcquisitionServiceRequest : py::ImplementsInterfaceT<ImplementsIPlayReadyLicenseAcquisitionServiceRequest, winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>
    {
        ImplementsIPlayReadyLicenseAcquisitionServiceRequest() = delete;
        ImplementsIPlayReadyLicenseAcquisitionServiceRequest(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPlayReadyLicenseAcquisitionServiceRequest, winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>(py_obj, runtime_class)
        {
        }

        auto BeginServiceRequest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "begin_service_request")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GenerateManualEnablingChallenge()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "generate_manual_enabling_challenge")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto NextServiceRequest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "next_service_request")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ProcessManualEnablingResponse(winrt::array_view<uint8_t const> param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "process_manual_enabling_response")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hresult>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContentHeader()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "content_header")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ContentHeader(winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "content_header", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DomainServiceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "domain_service_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void DomainServiceId(winrt::guid param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "domain_service_id", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ChallengeCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "challenge_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ChallengeCustomData(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "challenge_custom_data", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ResponseCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "response_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Uri()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "uri")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Uri>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Uri(winrt::Windows::Foundation::Uri const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "uri", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ProtectionSystem()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "protection_system")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Type()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPlayReadyLicenseAcquisitionServiceRequest>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPlayReadyLicenseAcquisitionServiceRequest[] = {
        { "_assign_array_", _assign_array_IPlayReadyLicenseAcquisitionServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyLicenseAcquisitionServiceRequest), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPlayReadyLicenseAcquisitionServiceRequest), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPlayReadyLicenseAcquisitionServiceRequest), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPlayReadyLicenseAcquisitionServiceRequest[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPlayReadyLicenseAcquisitionServiceRequest) },
        { }};

    static PyType_Spec type_spec_ImplementsIPlayReadyLicenseAcquisitionServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyLicenseAcquisitionServiceRequest",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPlayReadyLicenseAcquisitionServiceRequest};

    // ----- IPlayReadyLicenseSession interface --------------------

    static PyObject* _new_IPlayReadyLicenseSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseSession(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyLicenseSession_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession", L"ConfigureMediaProtectionManager", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigureMediaProtectionManager(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession", L"CreateLAServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateLAServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseSession[] = {
        { "configure_media_protection_manager", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession_ConfigureMediaProtectionManager), METH_VARARGS, nullptr },
        { "create_l_a_service_request", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession_CreateLAServiceRequest), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPlayReadyLicenseSession[] = {
        { }};

    static PyType_Slot _type_slots_IPlayReadyLicenseSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyLicenseSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyLicenseSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyLicenseSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyLicenseSession) },
        { }};

    static PyType_Spec type_spec_IPlayReadyLicenseSession = {
        "winrt._winrt_windows_media_protection_playready._IPlayReadyLicenseSession",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseSession};

    struct ImplementsIPlayReadyLicenseSession : py::ImplementsInterfaceT<ImplementsIPlayReadyLicenseSession, winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>
    {
        ImplementsIPlayReadyLicenseSession() = delete;
        ImplementsIPlayReadyLicenseSession(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPlayReadyLicenseSession, winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>(py_obj, runtime_class)
        {
        }

        auto ConfigureMediaProtectionManager(winrt::Windows::Media::Protection::MediaProtectionManager const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "configure_media_protection_manager")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateLAServiceRequest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_l_a_service_request")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPlayReadyLicenseSession(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPlayReadyLicenseSession(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPlayReadyLicenseSession>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPlayReadyLicenseSession[] = {
        { "_assign_array_", _assign_array_IPlayReadyLicenseSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyLicenseSession), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPlayReadyLicenseSession), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPlayReadyLicenseSession), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPlayReadyLicenseSession[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPlayReadyLicenseSession) },
        { }};

    static PyType_Spec type_spec_ImplementsIPlayReadyLicenseSession = {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyLicenseSession",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPlayReadyLicenseSession};

    // ----- IPlayReadyLicenseSession2 interface --------------------

    static PyObject* _new_IPlayReadyLicenseSession2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseSession2(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyLicenseSession2_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession", L"ConfigureMediaProtectionManager", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigureMediaProtectionManager(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession2_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession", L"CreateLAServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateLAServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession2_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession2", L"CreateLicenseIterable", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateLicenseIterable(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseSession2[] = {
        { "configure_media_protection_manager", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession2_ConfigureMediaProtectionManager), METH_VARARGS, nullptr },
        { "create_l_a_service_request", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession2_CreateLAServiceRequest), METH_VARARGS, nullptr },
        { "create_license_iterable", reinterpret_cast<PyCFunction>(IPlayReadyLicenseSession2_CreateLicenseIterable), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPlayReadyLicenseSession2[] = {
        { }};

    static PyType_Slot _type_slots_IPlayReadyLicenseSession2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyLicenseSession2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyLicenseSession2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyLicenseSession2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyLicenseSession2) },
        { }};

    static PyType_Spec type_spec_IPlayReadyLicenseSession2 = {
        "winrt._winrt_windows_media_protection_playready._IPlayReadyLicenseSession2",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseSession2};

    struct ImplementsIPlayReadyLicenseSession2 : py::ImplementsInterfaceT<ImplementsIPlayReadyLicenseSession2, winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>
    {
        ImplementsIPlayReadyLicenseSession2() = delete;
        ImplementsIPlayReadyLicenseSession2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPlayReadyLicenseSession2, winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>(py_obj, runtime_class)
        {
        }

        auto ConfigureMediaProtectionManager(winrt::Windows::Media::Protection::MediaProtectionManager const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "configure_media_protection_manager")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateLAServiceRequest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_l_a_service_request")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateLicenseIterable(winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader const& param0, bool param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_license_iterable")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPlayReadyLicenseSession2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyLicenseSession2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPlayReadyLicenseSession2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPlayReadyLicenseSession2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPlayReadyLicenseSession2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPlayReadyLicenseSession2[] = {
        { "_assign_array_", _assign_array_IPlayReadyLicenseSession2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyLicenseSession2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPlayReadyLicenseSession2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPlayReadyLicenseSession2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPlayReadyLicenseSession2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPlayReadyLicenseSession2) },
        { }};

    static PyType_Spec type_spec_ImplementsIPlayReadyLicenseSession2 = {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyLicenseSession2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPlayReadyLicenseSession2};

    // ----- IPlayReadySecureStopServiceRequest interface --------------------

    static PyObject* _new_IPlayReadySecureStopServiceRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadySecureStopServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadySecureStopServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_PublisherCertificate(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"PublisherCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublisherCertificate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_SessionID(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"SessionID");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SessionID();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_StartTime(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Stopped(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"Stopped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Stopped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_UpdateTime(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest", L"UpdateTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdateTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadySecureStopServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadySecureStopServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadySecureStopServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(IPlayReadySecureStopServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(IPlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(IPlayReadySecureStopServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(IPlayReadySecureStopServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPlayReadySecureStopServiceRequest[] = {
        { "publisher_certificate", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_PublisherCertificate), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_SessionID), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_StartTime), nullptr, nullptr, nullptr },
        { "stopped", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_Stopped), nullptr, nullptr, nullptr },
        { "update_time", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_UpdateTime), nullptr, nullptr, nullptr },
        { "challenge_custom_data", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(IPlayReadySecureStopServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_Uri), reinterpret_cast<setter>(IPlayReadySecureStopServiceRequest_put_Uri), nullptr, nullptr },
        { "protection_system", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPlayReadySecureStopServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPlayReadySecureStopServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadySecureStopServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadySecureStopServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadySecureStopServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadySecureStopServiceRequest) },
        { }};

    static PyType_Spec type_spec_IPlayReadySecureStopServiceRequest = {
        "winrt._winrt_windows_media_protection_playready._IPlayReadySecureStopServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadySecureStopServiceRequest};

    struct ImplementsIPlayReadySecureStopServiceRequest : py::ImplementsInterfaceT<ImplementsIPlayReadySecureStopServiceRequest, winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>
    {
        ImplementsIPlayReadySecureStopServiceRequest() = delete;
        ImplementsIPlayReadySecureStopServiceRequest(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPlayReadySecureStopServiceRequest, winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>(py_obj, runtime_class)
        {
        }

        auto BeginServiceRequest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "begin_service_request")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GenerateManualEnablingChallenge()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "generate_manual_enabling_challenge")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto NextServiceRequest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "next_service_request")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ProcessManualEnablingResponse(winrt::array_view<uint8_t const> param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "process_manual_enabling_response")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hresult>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PublisherCertificate()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "publisher_certificate")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SessionID()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "session_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StartTime()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "start_time")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Stopped()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "stopped")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto UpdateTime()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "update_time")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ChallengeCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "challenge_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ChallengeCustomData(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "challenge_custom_data", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ResponseCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "response_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Uri()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "uri")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Uri>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Uri(winrt::Windows::Foundation::Uri const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "uri", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ProtectionSystem()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "protection_system")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Type()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPlayReadySecureStopServiceRequest>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPlayReadySecureStopServiceRequest[] = {
        { "_assign_array_", _assign_array_IPlayReadySecureStopServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadySecureStopServiceRequest), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPlayReadySecureStopServiceRequest), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPlayReadySecureStopServiceRequest), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPlayReadySecureStopServiceRequest[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPlayReadySecureStopServiceRequest) },
        { }};

    static PyType_Spec type_spec_ImplementsIPlayReadySecureStopServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.IPlayReadySecureStopServiceRequest",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPlayReadySecureStopServiceRequest};

    // ----- IPlayReadyServiceRequest interface --------------------

    static PyObject* _new_IPlayReadyServiceRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_IPlayReadyServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPlayReadyServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"BeginServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BeginServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"GenerateManualEnablingChallenge", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GenerateManualEnablingChallenge();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"NextServiceRequest", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NextServiceRequest();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ProcessManualEnablingResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ProcessManualEnablingResponse(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChallengeCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ChallengeCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChallengeCustomData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"ResponseCustomData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCustomData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"ProtectionSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Protection.IMediaProtectionServiceRequest", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyServiceRequest[] = {
        { "begin_service_request", reinterpret_cast<PyCFunction>(IPlayReadyServiceRequest_BeginServiceRequest), METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", reinterpret_cast<PyCFunction>(IPlayReadyServiceRequest_GenerateManualEnablingChallenge), METH_VARARGS, nullptr },
        { "next_service_request", reinterpret_cast<PyCFunction>(IPlayReadyServiceRequest_NextServiceRequest), METH_VARARGS, nullptr },
        { "process_manual_enabling_response", reinterpret_cast<PyCFunction>(IPlayReadyServiceRequest_ProcessManualEnablingResponse), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPlayReadyServiceRequest[] = {
        { "challenge_custom_data", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_ChallengeCustomData), reinterpret_cast<setter>(IPlayReadyServiceRequest_put_ChallengeCustomData), nullptr, nullptr },
        { "response_custom_data", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_ResponseCustomData), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_Uri), reinterpret_cast<setter>(IPlayReadyServiceRequest_put_Uri), nullptr, nullptr },
        { "protection_system", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_ProtectionSystem), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPlayReadyServiceRequest_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPlayReadyServiceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPlayReadyServiceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPlayReadyServiceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPlayReadyServiceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPlayReadyServiceRequest) },
        { }};

    static PyType_Spec type_spec_IPlayReadyServiceRequest = {
        "winrt._winrt_windows_media_protection_playready._IPlayReadyServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyServiceRequest};

    struct ImplementsIPlayReadyServiceRequest : py::ImplementsInterfaceT<ImplementsIPlayReadyServiceRequest, winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>
    {
        ImplementsIPlayReadyServiceRequest() = delete;
        ImplementsIPlayReadyServiceRequest(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPlayReadyServiceRequest, winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>(py_obj, runtime_class)
        {
        }

        auto BeginServiceRequest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "begin_service_request")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncAction>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GenerateManualEnablingChallenge()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "generate_manual_enabling_challenge")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto NextServiceRequest()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "next_service_request")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ProcessManualEnablingResponse(winrt::array_view<uint8_t const> param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "process_manual_enabling_response")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hresult>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ChallengeCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "challenge_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ChallengeCustomData(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "challenge_custom_data", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ResponseCustomData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "response_custom_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Uri()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "uri")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Uri>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Uri(winrt::Windows::Foundation::Uri const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "uri", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ProtectionSystem()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "protection_system")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Type()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPlayReadyServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPlayReadyServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPlayReadyServiceRequest(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPlayReadyServiceRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPlayReadyServiceRequest>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPlayReadyServiceRequest[] = {
        { "_assign_array_", _assign_array_IPlayReadyServiceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPlayReadyServiceRequest), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPlayReadyServiceRequest), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPlayReadyServiceRequest), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPlayReadyServiceRequest[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPlayReadyServiceRequest) },
        { }};

    static PyType_Spec type_spec_ImplementsIPlayReadyServiceRequest = {
        "winrt._winrt_windows_media_protection_playready.IPlayReadyServiceRequest",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPlayReadyServiceRequest};

    // ----- Windows.Media.Protection.PlayReady Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Protection.PlayReady");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_protection_playready",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Protection::PlayReady

PyMODINIT_FUNC PyInit__winrt_windows_media_protection_playready(void) noexcept
{
    using namespace py::cpp::Windows::Media::Protection::PlayReady;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle NDClient_type{py::register_python_type(module.get(), &type_spec_NDClient, object_bases.get(), inspectable_meta_type)};
    if (!NDClient_type)
    {
        return nullptr;
    }

    py::pytype_handle NDCustomData_type{py::register_python_type(module.get(), &type_spec_NDCustomData, object_bases.get(), inspectable_meta_type)};
    if (!NDCustomData_type)
    {
        return nullptr;
    }

    py::pytype_handle NDDownloadEngineNotifier_type{py::register_python_type(module.get(), &type_spec_NDDownloadEngineNotifier, object_bases.get(), inspectable_meta_type)};
    if (!NDDownloadEngineNotifier_type)
    {
        return nullptr;
    }

    py::pytype_handle NDLicenseFetchDescriptor_type{py::register_python_type(module.get(), &type_spec_NDLicenseFetchDescriptor, object_bases.get(), inspectable_meta_type)};
    if (!NDLicenseFetchDescriptor_type)
    {
        return nullptr;
    }

    py::pytype_handle NDStorageFileHelper_type{py::register_python_type(module.get(), &type_spec_NDStorageFileHelper, object_bases.get(), inspectable_meta_type)};
    if (!NDStorageFileHelper_type)
    {
        return nullptr;
    }

    py::pytype_handle NDStreamParserNotifier_type{py::register_python_type(module.get(), &type_spec_NDStreamParserNotifier, object_bases.get(), inspectable_meta_type)};
    if (!NDStreamParserNotifier_type)
    {
        return nullptr;
    }

    py::pytype_handle NDTCPMessenger_type{py::register_python_type(module.get(), &type_spec_NDTCPMessenger, object_bases.get(), inspectable_meta_type)};
    if (!NDTCPMessenger_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyContentHeader_type{py::register_python_type(module.get(), &type_spec_PlayReadyContentHeader, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyContentHeader_type)
    {
        return nullptr;
    }

    py::pyobj_handle PlayReadyContentResolver_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PlayReadyContentResolver_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlayReadyContentResolver_Static{PyType_FromSpecWithBases(&type_spec_PlayReadyContentResolver_Static, PlayReadyContentResolver_Static_bases.get())};
    if (!type_PlayReadyContentResolver_Static)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyContentResolver_type{py::register_python_type(module.get(), &type_spec_PlayReadyContentResolver, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlayReadyContentResolver_Static.get()))};
    if (!PlayReadyContentResolver_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyDomain_type{py::register_python_type(module.get(), &type_spec_PlayReadyDomain, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyDomain_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyDomainIterable_type{py::register_python_type(module.get(), &type_spec_PlayReadyDomainIterable, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyDomainIterable_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyDomainIterator_type{py::register_python_type(module.get(), &type_spec_PlayReadyDomainIterator, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyDomainIterator_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyDomainJoinServiceRequest_type{py::register_python_type(module.get(), &type_spec_PlayReadyDomainJoinServiceRequest, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyDomainJoinServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyDomainLeaveServiceRequest_type{py::register_python_type(module.get(), &type_spec_PlayReadyDomainLeaveServiceRequest, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyDomainLeaveServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyITADataGenerator_type{py::register_python_type(module.get(), &type_spec_PlayReadyITADataGenerator, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyITADataGenerator_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyIndividualizationServiceRequest_type{py::register_python_type(module.get(), &type_spec_PlayReadyIndividualizationServiceRequest, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyIndividualizationServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyLicense_type{py::register_python_type(module.get(), &type_spec_PlayReadyLicense, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyLicense_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyLicenseAcquisitionServiceRequest_type{py::register_python_type(module.get(), &type_spec_PlayReadyLicenseAcquisitionServiceRequest, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyLicenseAcquisitionServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyLicenseIterable_type{py::register_python_type(module.get(), &type_spec_PlayReadyLicenseIterable, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyLicenseIterable_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyLicenseIterator_type{py::register_python_type(module.get(), &type_spec_PlayReadyLicenseIterator, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyLicenseIterator_type)
    {
        return nullptr;
    }

    py::pyobj_handle PlayReadyLicenseManagement_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PlayReadyLicenseManagement_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlayReadyLicenseManagement_Static{PyType_FromSpecWithBases(&type_spec_PlayReadyLicenseManagement_Static, PlayReadyLicenseManagement_Static_bases.get())};
    if (!type_PlayReadyLicenseManagement_Static)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyLicenseManagement_type{py::register_python_type(module.get(), &type_spec_PlayReadyLicenseManagement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlayReadyLicenseManagement_Static.get()))};
    if (!PlayReadyLicenseManagement_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyLicenseSession_type{py::register_python_type(module.get(), &type_spec_PlayReadyLicenseSession, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyLicenseSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyMeteringReportServiceRequest_type{py::register_python_type(module.get(), &type_spec_PlayReadyMeteringReportServiceRequest, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyMeteringReportServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyRevocationServiceRequest_type{py::register_python_type(module.get(), &type_spec_PlayReadyRevocationServiceRequest, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadyRevocationServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadySecureStopIterable_type{py::register_python_type(module.get(), &type_spec_PlayReadySecureStopIterable, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadySecureStopIterable_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadySecureStopIterator_type{py::register_python_type(module.get(), &type_spec_PlayReadySecureStopIterator, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadySecureStopIterator_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadySecureStopServiceRequest_type{py::register_python_type(module.get(), &type_spec_PlayReadySecureStopServiceRequest, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadySecureStopServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadySoapMessage_type{py::register_python_type(module.get(), &type_spec_PlayReadySoapMessage, object_bases.get(), inspectable_meta_type)};
    if (!PlayReadySoapMessage_type)
    {
        return nullptr;
    }

    py::pyobj_handle PlayReadyStatics_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PlayReadyStatics_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlayReadyStatics_Static{PyType_FromSpecWithBases(&type_spec_PlayReadyStatics_Static, PlayReadyStatics_Static_bases.get())};
    if (!type_PlayReadyStatics_Static)
    {
        return nullptr;
    }

    py::pytype_handle PlayReadyStatics_type{py::register_python_type(module.get(), &type_spec_PlayReadyStatics, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlayReadyStatics_Static.get()))};
    if (!PlayReadyStatics_type)
    {
        return nullptr;
    }

    py::pytype_handle INDClosedCaptionDataReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_INDClosedCaptionDataReceivedEventArgs, object_bases.get(), nullptr)};
    if (!INDClosedCaptionDataReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDClosedCaptionDataReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsINDClosedCaptionDataReceivedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsINDClosedCaptionDataReceivedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDClosedCaptionDataReceivedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDCustomData_type{py::register_python_type(module.get(), &type_spec_INDCustomData, object_bases.get(), nullptr)};
    if (!INDCustomData_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDCustomData_type{py::register_python_type(module.get(), &type_spec_ImplementsINDCustomData, nullptr, inspectable_meta_type)};
    if (!ImplementsINDCustomData_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDCustomData_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDDownloadEngine_type{py::register_python_type(module.get(), &type_spec_INDDownloadEngine, object_bases.get(), nullptr)};
    if (!INDDownloadEngine_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDDownloadEngine_type{py::register_python_type(module.get(), &type_spec_ImplementsINDDownloadEngine, nullptr, inspectable_meta_type)};
    if (!ImplementsINDDownloadEngine_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDDownloadEngine_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDDownloadEngineNotifier_type{py::register_python_type(module.get(), &type_spec_INDDownloadEngineNotifier, object_bases.get(), nullptr)};
    if (!INDDownloadEngineNotifier_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDDownloadEngineNotifier_type{py::register_python_type(module.get(), &type_spec_ImplementsINDDownloadEngineNotifier, nullptr, inspectable_meta_type)};
    if (!ImplementsINDDownloadEngineNotifier_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDDownloadEngineNotifier_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDLicenseFetchCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_INDLicenseFetchCompletedEventArgs, object_bases.get(), nullptr)};
    if (!INDLicenseFetchCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDLicenseFetchCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsINDLicenseFetchCompletedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsINDLicenseFetchCompletedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDLicenseFetchCompletedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDLicenseFetchDescriptor_type{py::register_python_type(module.get(), &type_spec_INDLicenseFetchDescriptor, object_bases.get(), nullptr)};
    if (!INDLicenseFetchDescriptor_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDLicenseFetchDescriptor_type{py::register_python_type(module.get(), &type_spec_ImplementsINDLicenseFetchDescriptor, nullptr, inspectable_meta_type)};
    if (!ImplementsINDLicenseFetchDescriptor_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDLicenseFetchDescriptor_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDLicenseFetchResult_type{py::register_python_type(module.get(), &type_spec_INDLicenseFetchResult, object_bases.get(), nullptr)};
    if (!INDLicenseFetchResult_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDLicenseFetchResult_type{py::register_python_type(module.get(), &type_spec_ImplementsINDLicenseFetchResult, nullptr, inspectable_meta_type)};
    if (!ImplementsINDLicenseFetchResult_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDLicenseFetchResult_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDMessenger_type{py::register_python_type(module.get(), &type_spec_INDMessenger, object_bases.get(), nullptr)};
    if (!INDMessenger_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDMessenger_type{py::register_python_type(module.get(), &type_spec_ImplementsINDMessenger, nullptr, inspectable_meta_type)};
    if (!ImplementsINDMessenger_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDMessenger_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDProximityDetectionCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_INDProximityDetectionCompletedEventArgs, object_bases.get(), nullptr)};
    if (!INDProximityDetectionCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDProximityDetectionCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsINDProximityDetectionCompletedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsINDProximityDetectionCompletedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDProximityDetectionCompletedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDRegistrationCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_INDRegistrationCompletedEventArgs, object_bases.get(), nullptr)};
    if (!INDRegistrationCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDRegistrationCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsINDRegistrationCompletedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsINDRegistrationCompletedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDRegistrationCompletedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDSendResult_type{py::register_python_type(module.get(), &type_spec_INDSendResult, object_bases.get(), nullptr)};
    if (!INDSendResult_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDSendResult_type{py::register_python_type(module.get(), &type_spec_ImplementsINDSendResult, nullptr, inspectable_meta_type)};
    if (!ImplementsINDSendResult_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDSendResult_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDStartResult_type{py::register_python_type(module.get(), &type_spec_INDStartResult, object_bases.get(), nullptr)};
    if (!INDStartResult_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDStartResult_type{py::register_python_type(module.get(), &type_spec_ImplementsINDStartResult, nullptr, inspectable_meta_type)};
    if (!ImplementsINDStartResult_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDStartResult_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDStorageFileHelper_type{py::register_python_type(module.get(), &type_spec_INDStorageFileHelper, object_bases.get(), nullptr)};
    if (!INDStorageFileHelper_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDStorageFileHelper_type{py::register_python_type(module.get(), &type_spec_ImplementsINDStorageFileHelper, nullptr, inspectable_meta_type)};
    if (!ImplementsINDStorageFileHelper_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDStorageFileHelper_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDStreamParser_type{py::register_python_type(module.get(), &type_spec_INDStreamParser, object_bases.get(), nullptr)};
    if (!INDStreamParser_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDStreamParser_type{py::register_python_type(module.get(), &type_spec_ImplementsINDStreamParser, nullptr, inspectable_meta_type)};
    if (!ImplementsINDStreamParser_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDStreamParser_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDStreamParserNotifier_type{py::register_python_type(module.get(), &type_spec_INDStreamParserNotifier, object_bases.get(), nullptr)};
    if (!INDStreamParserNotifier_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDStreamParserNotifier_type{py::register_python_type(module.get(), &type_spec_ImplementsINDStreamParserNotifier, nullptr, inspectable_meta_type)};
    if (!ImplementsINDStreamParserNotifier_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDStreamParserNotifier_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INDTransmitterProperties_type{py::register_python_type(module.get(), &type_spec_INDTransmitterProperties, object_bases.get(), nullptr)};
    if (!INDTransmitterProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINDTransmitterProperties_type{py::register_python_type(module.get(), &type_spec_ImplementsINDTransmitterProperties, nullptr, inspectable_meta_type)};
    if (!ImplementsINDTransmitterProperties_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINDTransmitterProperties_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPlayReadyDomain_type{py::register_python_type(module.get(), &type_spec_IPlayReadyDomain, object_bases.get(), nullptr)};
    if (!IPlayReadyDomain_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPlayReadyDomain_type{py::register_python_type(module.get(), &type_spec_ImplementsIPlayReadyDomain, nullptr, inspectable_meta_type)};
    if (!ImplementsIPlayReadyDomain_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPlayReadyDomain_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPlayReadyLicense_type{py::register_python_type(module.get(), &type_spec_IPlayReadyLicense, object_bases.get(), nullptr)};
    if (!IPlayReadyLicense_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPlayReadyLicense_type{py::register_python_type(module.get(), &type_spec_ImplementsIPlayReadyLicense, nullptr, inspectable_meta_type)};
    if (!ImplementsIPlayReadyLicense_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPlayReadyLicense_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPlayReadyLicenseAcquisitionServiceRequest_type{py::register_python_type(module.get(), &type_spec_IPlayReadyLicenseAcquisitionServiceRequest, object_bases.get(), nullptr)};
    if (!IPlayReadyLicenseAcquisitionServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPlayReadyLicenseAcquisitionServiceRequest_type{py::register_python_type(module.get(), &type_spec_ImplementsIPlayReadyLicenseAcquisitionServiceRequest, nullptr, inspectable_meta_type)};
    if (!ImplementsIPlayReadyLicenseAcquisitionServiceRequest_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPlayReadyLicenseAcquisitionServiceRequest_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPlayReadyLicenseSession_type{py::register_python_type(module.get(), &type_spec_IPlayReadyLicenseSession, object_bases.get(), nullptr)};
    if (!IPlayReadyLicenseSession_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPlayReadyLicenseSession_type{py::register_python_type(module.get(), &type_spec_ImplementsIPlayReadyLicenseSession, nullptr, inspectable_meta_type)};
    if (!ImplementsIPlayReadyLicenseSession_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPlayReadyLicenseSession_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPlayReadyLicenseSession2_type{py::register_python_type(module.get(), &type_spec_IPlayReadyLicenseSession2, object_bases.get(), nullptr)};
    if (!IPlayReadyLicenseSession2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPlayReadyLicenseSession2_type{py::register_python_type(module.get(), &type_spec_ImplementsIPlayReadyLicenseSession2, nullptr, inspectable_meta_type)};
    if (!ImplementsIPlayReadyLicenseSession2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPlayReadyLicenseSession2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPlayReadySecureStopServiceRequest_type{py::register_python_type(module.get(), &type_spec_IPlayReadySecureStopServiceRequest, object_bases.get(), nullptr)};
    if (!IPlayReadySecureStopServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPlayReadySecureStopServiceRequest_type{py::register_python_type(module.get(), &type_spec_ImplementsIPlayReadySecureStopServiceRequest, nullptr, inspectable_meta_type)};
    if (!ImplementsIPlayReadySecureStopServiceRequest_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPlayReadySecureStopServiceRequest_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPlayReadyServiceRequest_type{py::register_python_type(module.get(), &type_spec_IPlayReadyServiceRequest, object_bases.get(), nullptr)};
    if (!IPlayReadyServiceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPlayReadyServiceRequest_type{py::register_python_type(module.get(), &type_spec_ImplementsIPlayReadyServiceRequest, nullptr, inspectable_meta_type)};
    if (!ImplementsIPlayReadyServiceRequest_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPlayReadyServiceRequest_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
