// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Devices.HumanInterfaceDevice.h"

namespace py::cpp::Windows::Devices::HumanInterfaceDevice
{
    // ----- HidBooleanControl class --------------------

    static PyObject* _new_HidBooleanControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControl>::type_name);
        return nullptr;
    }

    static void _dealloc_HidBooleanControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidBooleanControl_get_IsActive(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidBooleanControl_put_IsActive(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsActive(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidBooleanControl_get_ControlDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"ControlDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ControlDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControl_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControl_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"UsageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControl_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"UsagePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsagePage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidBooleanControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidBooleanControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidBooleanControl[] = {
        { "_assign_array_", _assign_array_HidBooleanControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidBooleanControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidBooleanControl[] = {
        { "is_active", reinterpret_cast<getter>(HidBooleanControl_get_IsActive), reinterpret_cast<setter>(HidBooleanControl_put_IsActive), nullptr, nullptr },
        { "control_description", reinterpret_cast<getter>(HidBooleanControl_get_ControlDescription), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidBooleanControl_get_Id), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidBooleanControl_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidBooleanControl_get_UsagePage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidBooleanControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidBooleanControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidBooleanControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidBooleanControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidBooleanControl) },
        { }};

    static PyType_Spec type_spec_HidBooleanControl = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidBooleanControl",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidBooleanControl};

    // ----- HidBooleanControlDescription class --------------------

    static PyObject* _new_HidBooleanControlDescription(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>::type_name);
        return nullptr;
    }

    static void _dealloc_HidBooleanControlDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidBooleanControlDescription_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_ParentCollections(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"ParentCollections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ParentCollections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_ReportId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"ReportId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReportId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_ReportType(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"ReportType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReportType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"UsageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"UsagePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsagePage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_IsAbsolute(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"IsAbsolute");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAbsolute();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidBooleanControlDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidBooleanControlDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidBooleanControlDescription[] = {
        { "_assign_array_", _assign_array_HidBooleanControlDescription, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidBooleanControlDescription), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidBooleanControlDescription[] = {
        { "id", reinterpret_cast<getter>(HidBooleanControlDescription_get_Id), nullptr, nullptr, nullptr },
        { "parent_collections", reinterpret_cast<getter>(HidBooleanControlDescription_get_ParentCollections), nullptr, nullptr, nullptr },
        { "report_id", reinterpret_cast<getter>(HidBooleanControlDescription_get_ReportId), nullptr, nullptr, nullptr },
        { "report_type", reinterpret_cast<getter>(HidBooleanControlDescription_get_ReportType), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidBooleanControlDescription_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidBooleanControlDescription_get_UsagePage), nullptr, nullptr, nullptr },
        { "is_absolute", reinterpret_cast<getter>(HidBooleanControlDescription_get_IsAbsolute), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidBooleanControlDescription[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidBooleanControlDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidBooleanControlDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidBooleanControlDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidBooleanControlDescription) },
        { }};

    static PyType_Spec type_spec_HidBooleanControlDescription = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidBooleanControlDescription",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidBooleanControlDescription};

    // ----- HidCollection class --------------------

    static PyObject* _new_HidCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HidCollection(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidCollection_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidCollection", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidCollection_get_Type(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidCollection", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidCollection_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidCollection", L"UsageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidCollection_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidCollection", L"UsagePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsagePage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidCollection[] = {
        { "_assign_array_", _assign_array_HidCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidCollection[] = {
        { "id", reinterpret_cast<getter>(HidCollection_get_Id), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(HidCollection_get_Type), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidCollection_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidCollection_get_UsagePage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidCollection) },
        { }};

    static PyType_Spec type_spec_HidCollection = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidCollection",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidCollection};

    // ----- HidDevice class --------------------

    static PyObject* _new_HidDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_HidDevice(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidDevice_Close(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_CreateFeatureReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"CreateFeatureReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFeatureReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_CreateFeatureReportById(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"CreateFeatureReport", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFeatureReport(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_CreateOutputReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"CreateOutputReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateOutputReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_CreateOutputReportById(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"CreateOutputReport", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateOutputReport(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"FromIdAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::HumanInterfaceDevice::HidDevice::FromIdAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetBooleanControlDescriptions(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetBooleanControlDescriptions", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidReportType>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBooleanControlDescriptions(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetDeviceSelector", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::HumanInterfaceDevice::HidDevice::GetDeviceSelector(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetDeviceSelectorVidPid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetDeviceSelector", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);
                auto param3 = py::convert_to<uint16_t>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::HumanInterfaceDevice::HidDevice::GetDeviceSelector(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetFeatureReportAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetFeatureReportAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFeatureReportAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetFeatureReportByIdAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetFeatureReportAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFeatureReportAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetInputReportAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetInputReportAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetInputReportAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetInputReportByIdAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetInputReportAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetInputReportAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetNumericControlDescriptions(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetNumericControlDescriptions", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidReportType>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetNumericControlDescriptions(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_SendFeatureReportAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"SendFeatureReportAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendFeatureReportAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_SendOutputReportAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"SendOutputReportAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendOutputReportAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_ProductId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"ProductId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProductId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"UsageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"UsagePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsagePage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_VendorId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"VendorId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VendorId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_Version(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"Version");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Version();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_add_InputReportReceived(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"InputReportReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice, winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputReportReceived(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_remove_InputReportReceived(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"InputReportReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.InputReportReceived(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HidDevice(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HidDevice(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(HidDevice_Close), METH_VARARGS, nullptr },
        { "create_feature_report", reinterpret_cast<PyCFunction>(HidDevice_CreateFeatureReport), METH_VARARGS, nullptr },
        { "create_feature_report_by_id", reinterpret_cast<PyCFunction>(HidDevice_CreateFeatureReportById), METH_VARARGS, nullptr },
        { "create_output_report", reinterpret_cast<PyCFunction>(HidDevice_CreateOutputReport), METH_VARARGS, nullptr },
        { "create_output_report_by_id", reinterpret_cast<PyCFunction>(HidDevice_CreateOutputReportById), METH_VARARGS, nullptr },
        { "get_boolean_control_descriptions", reinterpret_cast<PyCFunction>(HidDevice_GetBooleanControlDescriptions), METH_VARARGS, nullptr },
        { "get_feature_report_async", reinterpret_cast<PyCFunction>(HidDevice_GetFeatureReportAsync), METH_VARARGS, nullptr },
        { "get_feature_report_by_id_async", reinterpret_cast<PyCFunction>(HidDevice_GetFeatureReportByIdAsync), METH_VARARGS, nullptr },
        { "get_input_report_async", reinterpret_cast<PyCFunction>(HidDevice_GetInputReportAsync), METH_VARARGS, nullptr },
        { "get_input_report_by_id_async", reinterpret_cast<PyCFunction>(HidDevice_GetInputReportByIdAsync), METH_VARARGS, nullptr },
        { "get_numeric_control_descriptions", reinterpret_cast<PyCFunction>(HidDevice_GetNumericControlDescriptions), METH_VARARGS, nullptr },
        { "send_feature_report_async", reinterpret_cast<PyCFunction>(HidDevice_SendFeatureReportAsync), METH_VARARGS, nullptr },
        { "send_output_report_async", reinterpret_cast<PyCFunction>(HidDevice_SendOutputReportAsync), METH_VARARGS, nullptr },
        { "add_input_report_received", reinterpret_cast<PyCFunction>(HidDevice_add_InputReportReceived), METH_O, nullptr },
        { "remove_input_report_received", reinterpret_cast<PyCFunction>(HidDevice_remove_InputReportReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_HidDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HidDevice), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_HidDevice), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_HidDevice[] = {
        { "product_id", reinterpret_cast<getter>(HidDevice_get_ProductId), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidDevice_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidDevice_get_UsagePage), nullptr, nullptr, nullptr },
        { "vendor_id", reinterpret_cast<getter>(HidDevice_get_VendorId), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(HidDevice_get_Version), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidDevice) },
        { }};

    static PyType_Spec type_spec_HidDevice = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidDevice",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidDevice};

    static PyGetSetDef getset_HidDevice_Static[] = {
        { }};

    static PyMethodDef methods_HidDevice_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(HidDevice_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(HidDevice_GetDeviceSelector), METH_VARARGS, nullptr },
        { "get_device_selector_vid_pid", reinterpret_cast<PyCFunction>(HidDevice_GetDeviceSelectorVidPid), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_HidDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HidDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HidDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_HidDevice_Static = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HidDevice_Static};

    // ----- HidFeatureReport class --------------------

    static PyObject* _new_HidFeatureReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>::type_name);
        return nullptr;
    }

    static void _dealloc_HidFeatureReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidFeatureReport_GetBooleanControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"GetBooleanControl", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBooleanControl(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidFeatureReport_GetBooleanControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"GetBooleanControlByDescription", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBooleanControlByDescription(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidFeatureReport_GetNumericControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"GetNumericControl", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetNumericControl(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidFeatureReport_GetNumericControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"GetNumericControlByDescription", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetNumericControlByDescription(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidFeatureReport_get_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidFeatureReport_put_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidFeatureReport_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidFeatureReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidFeatureReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidFeatureReport[] = {
        { "get_boolean_control", reinterpret_cast<PyCFunction>(HidFeatureReport_GetBooleanControl), METH_VARARGS, nullptr },
        { "get_boolean_control_by_description", reinterpret_cast<PyCFunction>(HidFeatureReport_GetBooleanControlByDescription), METH_VARARGS, nullptr },
        { "get_numeric_control", reinterpret_cast<PyCFunction>(HidFeatureReport_GetNumericControl), METH_VARARGS, nullptr },
        { "get_numeric_control_by_description", reinterpret_cast<PyCFunction>(HidFeatureReport_GetNumericControlByDescription), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidFeatureReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidFeatureReport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidFeatureReport[] = {
        { "data", reinterpret_cast<getter>(HidFeatureReport_get_Data), reinterpret_cast<setter>(HidFeatureReport_put_Data), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidFeatureReport_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidFeatureReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidFeatureReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidFeatureReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidFeatureReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidFeatureReport) },
        { }};

    static PyType_Spec type_spec_HidFeatureReport = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidFeatureReport",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidFeatureReport};

    // ----- HidInputReport class --------------------

    static PyObject* _new_HidInputReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReport>::type_name);
        return nullptr;
    }

    static void _dealloc_HidInputReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidInputReport_GetBooleanControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"GetBooleanControl", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBooleanControl(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidInputReport_GetBooleanControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"GetBooleanControlByDescription", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBooleanControlByDescription(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidInputReport_GetNumericControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"GetNumericControl", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetNumericControl(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidInputReport_GetNumericControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"GetNumericControlByDescription", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetNumericControlByDescription(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidInputReport_get_ActivatedBooleanControls(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"ActivatedBooleanControls");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedBooleanControls();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidInputReport_get_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidInputReport_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidInputReport_get_TransitionedBooleanControls(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"TransitionedBooleanControls");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransitionedBooleanControls();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidInputReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidInputReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidInputReport[] = {
        { "get_boolean_control", reinterpret_cast<PyCFunction>(HidInputReport_GetBooleanControl), METH_VARARGS, nullptr },
        { "get_boolean_control_by_description", reinterpret_cast<PyCFunction>(HidInputReport_GetBooleanControlByDescription), METH_VARARGS, nullptr },
        { "get_numeric_control", reinterpret_cast<PyCFunction>(HidInputReport_GetNumericControl), METH_VARARGS, nullptr },
        { "get_numeric_control_by_description", reinterpret_cast<PyCFunction>(HidInputReport_GetNumericControlByDescription), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidInputReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidInputReport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidInputReport[] = {
        { "activated_boolean_controls", reinterpret_cast<getter>(HidInputReport_get_ActivatedBooleanControls), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(HidInputReport_get_Data), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidInputReport_get_Id), nullptr, nullptr, nullptr },
        { "transitioned_boolean_controls", reinterpret_cast<getter>(HidInputReport_get_TransitionedBooleanControls), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidInputReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidInputReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidInputReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidInputReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidInputReport) },
        { }};

    static PyType_Spec type_spec_HidInputReport = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidInputReport",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidInputReport};

    // ----- HidInputReportReceivedEventArgs class --------------------

    static PyObject* _new_HidInputReportReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HidInputReportReceivedEventArgs(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidInputReportReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReportReceivedEventArgs", L"Report");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Report();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidInputReportReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidInputReportReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidInputReportReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_HidInputReportReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidInputReportReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidInputReportReceivedEventArgs[] = {
        { "report", reinterpret_cast<getter>(HidInputReportReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidInputReportReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidInputReportReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidInputReportReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidInputReportReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidInputReportReceivedEventArgs) },
        { }};

    static PyType_Spec type_spec_HidInputReportReceivedEventArgs = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidInputReportReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidInputReportReceivedEventArgs};

    // ----- HidNumericControl class --------------------

    static PyObject* _new_HidNumericControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControl>::type_name);
        return nullptr;
    }

    static void _dealloc_HidNumericControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidNumericControl_get_Value(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidNumericControl_put_Value(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidNumericControl_get_ScaledValue(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"ScaledValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScaledValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidNumericControl_put_ScaledValue(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"ScaledValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScaledValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidNumericControl_get_ControlDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"ControlDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ControlDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControl_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControl_get_IsGrouped(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"IsGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGrouped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControl_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"UsageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControl_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"UsagePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsagePage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidNumericControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidNumericControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidNumericControl[] = {
        { "_assign_array_", _assign_array_HidNumericControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidNumericControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidNumericControl[] = {
        { "value", reinterpret_cast<getter>(HidNumericControl_get_Value), reinterpret_cast<setter>(HidNumericControl_put_Value), nullptr, nullptr },
        { "scaled_value", reinterpret_cast<getter>(HidNumericControl_get_ScaledValue), reinterpret_cast<setter>(HidNumericControl_put_ScaledValue), nullptr, nullptr },
        { "control_description", reinterpret_cast<getter>(HidNumericControl_get_ControlDescription), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidNumericControl_get_Id), nullptr, nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(HidNumericControl_get_IsGrouped), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidNumericControl_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidNumericControl_get_UsagePage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidNumericControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidNumericControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidNumericControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidNumericControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidNumericControl) },
        { }};

    static PyType_Spec type_spec_HidNumericControl = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidNumericControl",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidNumericControl};

    // ----- HidNumericControlDescription class --------------------

    static PyObject* _new_HidNumericControlDescription(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>::type_name);
        return nullptr;
    }

    static void _dealloc_HidNumericControlDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidNumericControlDescription_get_HasNull(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"HasNull");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasNull();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_IsAbsolute(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"IsAbsolute");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAbsolute();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_LogicalMaximum(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"LogicalMaximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LogicalMaximum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_LogicalMinimum(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"LogicalMinimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LogicalMinimum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ParentCollections(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ParentCollections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ParentCollections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_PhysicalMaximum(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"PhysicalMaximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhysicalMaximum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_PhysicalMinimum(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"PhysicalMinimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhysicalMinimum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ReportCount(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ReportCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReportCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ReportId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ReportId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReportId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ReportSize(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ReportSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReportSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ReportType(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ReportType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReportType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_Unit(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"Unit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Unit();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_UnitExponent(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"UnitExponent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnitExponent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"UsageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"UsagePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsagePage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidNumericControlDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidNumericControlDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidNumericControlDescription[] = {
        { "_assign_array_", _assign_array_HidNumericControlDescription, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidNumericControlDescription), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidNumericControlDescription[] = {
        { "has_null", reinterpret_cast<getter>(HidNumericControlDescription_get_HasNull), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidNumericControlDescription_get_Id), nullptr, nullptr, nullptr },
        { "is_absolute", reinterpret_cast<getter>(HidNumericControlDescription_get_IsAbsolute), nullptr, nullptr, nullptr },
        { "logical_maximum", reinterpret_cast<getter>(HidNumericControlDescription_get_LogicalMaximum), nullptr, nullptr, nullptr },
        { "logical_minimum", reinterpret_cast<getter>(HidNumericControlDescription_get_LogicalMinimum), nullptr, nullptr, nullptr },
        { "parent_collections", reinterpret_cast<getter>(HidNumericControlDescription_get_ParentCollections), nullptr, nullptr, nullptr },
        { "physical_maximum", reinterpret_cast<getter>(HidNumericControlDescription_get_PhysicalMaximum), nullptr, nullptr, nullptr },
        { "physical_minimum", reinterpret_cast<getter>(HidNumericControlDescription_get_PhysicalMinimum), nullptr, nullptr, nullptr },
        { "report_count", reinterpret_cast<getter>(HidNumericControlDescription_get_ReportCount), nullptr, nullptr, nullptr },
        { "report_id", reinterpret_cast<getter>(HidNumericControlDescription_get_ReportId), nullptr, nullptr, nullptr },
        { "report_size", reinterpret_cast<getter>(HidNumericControlDescription_get_ReportSize), nullptr, nullptr, nullptr },
        { "report_type", reinterpret_cast<getter>(HidNumericControlDescription_get_ReportType), nullptr, nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(HidNumericControlDescription_get_Unit), nullptr, nullptr, nullptr },
        { "unit_exponent", reinterpret_cast<getter>(HidNumericControlDescription_get_UnitExponent), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidNumericControlDescription_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidNumericControlDescription_get_UsagePage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidNumericControlDescription[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidNumericControlDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidNumericControlDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidNumericControlDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidNumericControlDescription) },
        { }};

    static PyType_Spec type_spec_HidNumericControlDescription = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidNumericControlDescription",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidNumericControlDescription};

    // ----- HidOutputReport class --------------------

    static PyObject* _new_HidOutputReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>::type_name);
        return nullptr;
    }

    static void _dealloc_HidOutputReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidOutputReport_GetBooleanControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"GetBooleanControl", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBooleanControl(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidOutputReport_GetBooleanControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"GetBooleanControlByDescription", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBooleanControlByDescription(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidOutputReport_GetNumericControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"GetNumericControl", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetNumericControl(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidOutputReport_GetNumericControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"GetNumericControlByDescription", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetNumericControlByDescription(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidOutputReport_get_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidOutputReport_put_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidOutputReport_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidOutputReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidOutputReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidOutputReport[] = {
        { "get_boolean_control", reinterpret_cast<PyCFunction>(HidOutputReport_GetBooleanControl), METH_VARARGS, nullptr },
        { "get_boolean_control_by_description", reinterpret_cast<PyCFunction>(HidOutputReport_GetBooleanControlByDescription), METH_VARARGS, nullptr },
        { "get_numeric_control", reinterpret_cast<PyCFunction>(HidOutputReport_GetNumericControl), METH_VARARGS, nullptr },
        { "get_numeric_control_by_description", reinterpret_cast<PyCFunction>(HidOutputReport_GetNumericControlByDescription), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidOutputReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidOutputReport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidOutputReport[] = {
        { "data", reinterpret_cast<getter>(HidOutputReport_get_Data), reinterpret_cast<setter>(HidOutputReport_put_Data), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidOutputReport_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidOutputReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidOutputReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidOutputReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidOutputReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidOutputReport) },
        { }};

    static PyType_Spec type_spec_HidOutputReport = {
        "winrt._winrt_windows_devices_humaninterfacedevice.HidOutputReport",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidOutputReport};

    // ----- Windows.Devices.HumanInterfaceDevice Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.HumanInterfaceDevice");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_humaninterfacedevice",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::HumanInterfaceDevice

PyMODINIT_FUNC PyInit__winrt_windows_devices_humaninterfacedevice(void) noexcept
{
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle HidBooleanControl_type{py::register_python_type(module.get(), &type_spec_HidBooleanControl, object_bases.get(), inspectable_meta_type)};
    if (!HidBooleanControl_type)
    {
        return nullptr;
    }

    py::pytype_handle HidBooleanControlDescription_type{py::register_python_type(module.get(), &type_spec_HidBooleanControlDescription, object_bases.get(), inspectable_meta_type)};
    if (!HidBooleanControlDescription_type)
    {
        return nullptr;
    }

    py::pytype_handle HidCollection_type{py::register_python_type(module.get(), &type_spec_HidCollection, object_bases.get(), inspectable_meta_type)};
    if (!HidCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle HidDevice_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!HidDevice_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_HidDevice_Static{PyType_FromSpecWithBases(&type_spec_HidDevice_Static, HidDevice_Static_bases.get())};
    if (!type_HidDevice_Static)
    {
        return nullptr;
    }

    py::pytype_handle HidDevice_type{py::register_python_type(module.get(), &type_spec_HidDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HidDevice_Static.get()))};
    if (!HidDevice_type)
    {
        return nullptr;
    }

    py::pytype_handle HidFeatureReport_type{py::register_python_type(module.get(), &type_spec_HidFeatureReport, object_bases.get(), inspectable_meta_type)};
    if (!HidFeatureReport_type)
    {
        return nullptr;
    }

    py::pytype_handle HidInputReport_type{py::register_python_type(module.get(), &type_spec_HidInputReport, object_bases.get(), inspectable_meta_type)};
    if (!HidInputReport_type)
    {
        return nullptr;
    }

    py::pytype_handle HidInputReportReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_HidInputReportReceivedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!HidInputReportReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle HidNumericControl_type{py::register_python_type(module.get(), &type_spec_HidNumericControl, object_bases.get(), inspectable_meta_type)};
    if (!HidNumericControl_type)
    {
        return nullptr;
    }

    py::pytype_handle HidNumericControlDescription_type{py::register_python_type(module.get(), &type_spec_HidNumericControlDescription, object_bases.get(), inspectable_meta_type)};
    if (!HidNumericControlDescription_type)
    {
        return nullptr;
    }

    py::pytype_handle HidOutputReport_type{py::register_python_type(module.get(), &type_spec_HidOutputReport, object_bases.get(), inspectable_meta_type)};
    if (!HidOutputReport_type)
    {
        return nullptr;
    }


    return module.detach();
}
