// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Networking.XboxLive.h"

namespace py::cpp::Windows::Networking::XboxLive
{
    // ----- XboxLiveDeviceAddress class --------------------

    static PyObject* _new_XboxLiveDeviceAddress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveDeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveDeviceAddress_Compare(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"Compare", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Compare(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_CreateFromSnapshotBase64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"CreateFromSnapshotBase64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::CreateFromSnapshotBase64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_CreateFromSnapshotBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"CreateFromSnapshotBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::CreateFromSnapshotBuffer(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_CreateFromSnapshotBytes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"CreateFromSnapshotBytes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::CreateFromSnapshotBytes(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_GetLocal(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"GetLocal", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::GetLocal();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_GetSnapshotAsBase64(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"GetSnapshotAsBase64", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSnapshotAsBase64();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_GetSnapshotAsBuffer(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"GetSnapshotAsBuffer", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSnapshotAsBuffer();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_GetSnapshotAsBytes(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"GetSnapshotAsBytes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 0);
                uint32_t param1{};

                {
                    auto _gil = release_gil();
                    self->obj.GetSnapshotAsBytes(param0, param1);
                }

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_get_IsLocal(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"IsLocal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsLocal();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_get_IsValid(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"IsValid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsValid();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_get_NetworkAccessKind(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"NetworkAccessKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NetworkAccessKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_get_MaxSnapshotBytesSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"MaxSnapshotBytesSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::MaxSnapshotBytesSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_add_SnapshotChanged(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"SnapshotChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SnapshotChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_remove_SnapshotChanged(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"SnapshotChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SnapshotChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveDeviceAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveDeviceAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveDeviceAddress[] = {
        { "compare", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_Compare), METH_VARARGS, nullptr },
        { "get_snapshot_as_base64", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_GetSnapshotAsBase64), METH_VARARGS, nullptr },
        { "get_snapshot_as_buffer", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_GetSnapshotAsBuffer), METH_VARARGS, nullptr },
        { "get_snapshot_as_bytes", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_GetSnapshotAsBytes), METH_VARARGS, nullptr },
        { "add_snapshot_changed", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_add_SnapshotChanged), METH_O, nullptr },
        { "remove_snapshot_changed", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_remove_SnapshotChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_XboxLiveDeviceAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveDeviceAddress), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveDeviceAddress[] = {
        { "is_local", reinterpret_cast<getter>(XboxLiveDeviceAddress_get_IsLocal), nullptr, nullptr, nullptr },
        { "is_valid", reinterpret_cast<getter>(XboxLiveDeviceAddress_get_IsValid), nullptr, nullptr, nullptr },
        { "network_access_kind", reinterpret_cast<getter>(XboxLiveDeviceAddress_get_NetworkAccessKind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveDeviceAddress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveDeviceAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveDeviceAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveDeviceAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveDeviceAddress) },
        { }};

    static PyType_Spec type_spec_XboxLiveDeviceAddress = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveDeviceAddress",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveDeviceAddress};

    static PyGetSetDef getset_XboxLiveDeviceAddress_Static[] = {
        { "max_snapshot_bytes_size", reinterpret_cast<getter>(XboxLiveDeviceAddress_get_MaxSnapshotBytesSize), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_XboxLiveDeviceAddress_Static[] = {
        { "create_from_snapshot_base64", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_CreateFromSnapshotBase64), METH_VARARGS, nullptr },
        { "create_from_snapshot_buffer", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_CreateFromSnapshotBuffer), METH_VARARGS, nullptr },
        { "create_from_snapshot_bytes", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_CreateFromSnapshotBytes), METH_VARARGS, nullptr },
        { "get_local", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_GetLocal), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XboxLiveDeviceAddress_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XboxLiveDeviceAddress_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XboxLiveDeviceAddress_Static) },
        { }
    };

    static PyType_Spec type_spec_XboxLiveDeviceAddress_Static = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveDeviceAddress_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XboxLiveDeviceAddress_Static};

    // ----- XboxLiveEndpointPair class --------------------

    static PyObject* _new_XboxLiveEndpointPair(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveEndpointPair(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveEndpointPair_DeleteAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_FindEndpointPairByHostNamesAndPorts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"FindEndpointPairByHostNamesAndPorts", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostName>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair::FindEndpointPairByHostNamesAndPorts(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_FindEndpointPairBySocketAddressBytes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"FindEndpointPairBySocketAddressBytes", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair::FindEndpointPairBySocketAddressBytes(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_GetLocalSocketAddressBytes(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"GetLocalSocketAddressBytes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.GetLocalSocketAddressBytes(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_GetRemoteSocketAddressBytes(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"GetRemoteSocketAddressBytes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.GetRemoteSocketAddressBytes(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_LocalHostName(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"LocalHostName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalHostName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_LocalPort(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"LocalPort");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalPort();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_RemoteDeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"RemoteDeviceAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteDeviceAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_RemoteHostName(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"RemoteHostName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteHostName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_RemotePort(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"RemotePort");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemotePort();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_State(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_Template(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"Template");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Template();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_add_StateChanged(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair, winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_remove_StateChanged(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveEndpointPair(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveEndpointPair(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveEndpointPair[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_DeleteAsync), METH_VARARGS, nullptr },
        { "get_local_socket_address_bytes", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_GetLocalSocketAddressBytes), METH_VARARGS, nullptr },
        { "get_remote_socket_address_bytes", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_GetRemoteSocketAddressBytes), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_XboxLiveEndpointPair, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveEndpointPair), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveEndpointPair[] = {
        { "local_host_name", reinterpret_cast<getter>(XboxLiveEndpointPair_get_LocalHostName), nullptr, nullptr, nullptr },
        { "local_port", reinterpret_cast<getter>(XboxLiveEndpointPair_get_LocalPort), nullptr, nullptr, nullptr },
        { "remote_device_address", reinterpret_cast<getter>(XboxLiveEndpointPair_get_RemoteDeviceAddress), nullptr, nullptr, nullptr },
        { "remote_host_name", reinterpret_cast<getter>(XboxLiveEndpointPair_get_RemoteHostName), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(XboxLiveEndpointPair_get_RemotePort), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(XboxLiveEndpointPair_get_State), nullptr, nullptr, nullptr },
        { "template", reinterpret_cast<getter>(XboxLiveEndpointPair_get_Template), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveEndpointPair[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveEndpointPair) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveEndpointPair) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveEndpointPair) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveEndpointPair) },
        { }};

    static PyType_Spec type_spec_XboxLiveEndpointPair = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPair",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveEndpointPair};

    static PyGetSetDef getset_XboxLiveEndpointPair_Static[] = {
        { }};

    static PyMethodDef methods_XboxLiveEndpointPair_Static[] = {
        { "find_endpoint_pair_by_host_names_and_ports", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_FindEndpointPairByHostNamesAndPorts), METH_VARARGS, nullptr },
        { "find_endpoint_pair_by_socket_address_bytes", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_FindEndpointPairBySocketAddressBytes), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XboxLiveEndpointPair_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XboxLiveEndpointPair_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XboxLiveEndpointPair_Static) },
        { }
    };

    static PyType_Spec type_spec_XboxLiveEndpointPair_Static = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPair_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XboxLiveEndpointPair_Static};

    // ----- XboxLiveEndpointPairCreationResult class --------------------

    static PyObject* _new_XboxLiveEndpointPairCreationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveEndpointPairCreationResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveEndpointPairCreationResult_get_DeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult", L"DeviceAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairCreationResult_get_EndpointPair(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult", L"EndpointPair");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndpointPair();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairCreationResult_get_IsExistingPathEvaluation(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult", L"IsExistingPathEvaluation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsExistingPathEvaluation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairCreationResult_get_Status(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveEndpointPairCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveEndpointPairCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveEndpointPairCreationResult[] = {
        { "_assign_array_", _assign_array_XboxLiveEndpointPairCreationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveEndpointPairCreationResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveEndpointPairCreationResult[] = {
        { "device_address", reinterpret_cast<getter>(XboxLiveEndpointPairCreationResult_get_DeviceAddress), nullptr, nullptr, nullptr },
        { "endpoint_pair", reinterpret_cast<getter>(XboxLiveEndpointPairCreationResult_get_EndpointPair), nullptr, nullptr, nullptr },
        { "is_existing_path_evaluation", reinterpret_cast<getter>(XboxLiveEndpointPairCreationResult_get_IsExistingPathEvaluation), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(XboxLiveEndpointPairCreationResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveEndpointPairCreationResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveEndpointPairCreationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveEndpointPairCreationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveEndpointPairCreationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveEndpointPairCreationResult) },
        { }};

    static PyType_Spec type_spec_XboxLiveEndpointPairCreationResult = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPairCreationResult",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveEndpointPairCreationResult};

    // ----- XboxLiveEndpointPairStateChangedEventArgs class --------------------

    static PyObject* _new_XboxLiveEndpointPairStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveEndpointPairStateChangedEventArgs(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveEndpointPairStateChangedEventArgs_get_NewState(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs", L"NewState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairStateChangedEventArgs_get_OldState(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs", L"OldState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveEndpointPairStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveEndpointPairStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveEndpointPairStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_XboxLiveEndpointPairStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveEndpointPairStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveEndpointPairStateChangedEventArgs[] = {
        { "new_state", reinterpret_cast<getter>(XboxLiveEndpointPairStateChangedEventArgs_get_NewState), nullptr, nullptr, nullptr },
        { "old_state", reinterpret_cast<getter>(XboxLiveEndpointPairStateChangedEventArgs_get_OldState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveEndpointPairStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveEndpointPairStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveEndpointPairStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveEndpointPairStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveEndpointPairStateChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_XboxLiveEndpointPairStateChangedEventArgs = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPairStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveEndpointPairStateChangedEventArgs};

    // ----- XboxLiveEndpointPairTemplate class --------------------

    static PyObject* _new_XboxLiveEndpointPairTemplate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveEndpointPairTemplate(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveEndpointPairTemplate_CreateEndpointPairDefaultAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"CreateEndpointPairAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateEndpointPairAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_CreateEndpointPairForPortsDefaultAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"CreateEndpointPairForPortsAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateEndpointPairForPortsAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_CreateEndpointPairForPortsWithBehaviorsAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"CreateEndpointPairForPortsAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationBehaviors>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateEndpointPairForPortsAsync(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_CreateEndpointPairWithBehaviorsAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"CreateEndpointPairAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationBehaviors>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateEndpointPairAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_GetTemplateByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"GetTemplateByName", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate::GetTemplateByName(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_AcceptorBoundPortRangeLower(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"AcceptorBoundPortRangeLower");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AcceptorBoundPortRangeLower();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_AcceptorBoundPortRangeUpper(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"AcceptorBoundPortRangeUpper");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AcceptorBoundPortRangeUpper();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_EndpointPairs(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"EndpointPairs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndpointPairs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_InitiatorBoundPortRangeLower(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"InitiatorBoundPortRangeLower");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InitiatorBoundPortRangeLower();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_InitiatorBoundPortRangeUpper(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"InitiatorBoundPortRangeUpper");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InitiatorBoundPortRangeUpper();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_Name(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_SocketKind(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"SocketKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SocketKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_Templates(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"Templates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate::Templates();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_add_InboundEndpointPairCreated(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"InboundEndpointPairCreated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate, winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InboundEndpointPairCreated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_remove_InboundEndpointPairCreated(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"InboundEndpointPairCreated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.InboundEndpointPairCreated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveEndpointPairTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveEndpointPairTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveEndpointPairTemplate[] = {
        { "create_endpoint_pair_default_async", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_CreateEndpointPairDefaultAsync), METH_VARARGS, nullptr },
        { "create_endpoint_pair_for_ports_default_async", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_CreateEndpointPairForPortsDefaultAsync), METH_VARARGS, nullptr },
        { "create_endpoint_pair_for_ports_with_behaviors_async", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_CreateEndpointPairForPortsWithBehaviorsAsync), METH_VARARGS, nullptr },
        { "create_endpoint_pair_with_behaviors_async", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_CreateEndpointPairWithBehaviorsAsync), METH_VARARGS, nullptr },
        { "add_inbound_endpoint_pair_created", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_add_InboundEndpointPairCreated), METH_O, nullptr },
        { "remove_inbound_endpoint_pair_created", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_remove_InboundEndpointPairCreated), METH_O, nullptr },
        { "_assign_array_", _assign_array_XboxLiveEndpointPairTemplate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveEndpointPairTemplate), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveEndpointPairTemplate[] = {
        { "acceptor_bound_port_range_lower", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_AcceptorBoundPortRangeLower), nullptr, nullptr, nullptr },
        { "acceptor_bound_port_range_upper", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_AcceptorBoundPortRangeUpper), nullptr, nullptr, nullptr },
        { "endpoint_pairs", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_EndpointPairs), nullptr, nullptr, nullptr },
        { "initiator_bound_port_range_lower", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_InitiatorBoundPortRangeLower), nullptr, nullptr, nullptr },
        { "initiator_bound_port_range_upper", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_InitiatorBoundPortRangeUpper), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_Name), nullptr, nullptr, nullptr },
        { "socket_kind", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_SocketKind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveEndpointPairTemplate[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveEndpointPairTemplate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveEndpointPairTemplate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveEndpointPairTemplate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveEndpointPairTemplate) },
        { }};

    static PyType_Spec type_spec_XboxLiveEndpointPairTemplate = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPairTemplate",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveEndpointPairTemplate};

    static PyGetSetDef getset_XboxLiveEndpointPairTemplate_Static[] = {
        { "templates", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_Templates), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_XboxLiveEndpointPairTemplate_Static[] = {
        { "get_template_by_name", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_GetTemplateByName), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XboxLiveEndpointPairTemplate_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XboxLiveEndpointPairTemplate_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XboxLiveEndpointPairTemplate_Static) },
        { }
    };

    static PyType_Spec type_spec_XboxLiveEndpointPairTemplate_Static = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPairTemplate_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XboxLiveEndpointPairTemplate_Static};

    // ----- XboxLiveInboundEndpointPairCreatedEventArgs class --------------------

    static PyObject* _new_XboxLiveInboundEndpointPairCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveInboundEndpointPairCreatedEventArgs(py::wrapper::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveInboundEndpointPairCreatedEventArgs_get_EndpointPair(py::wrapper::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveInboundEndpointPairCreatedEventArgs", L"EndpointPair");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndpointPair();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveInboundEndpointPairCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveInboundEndpointPairCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveInboundEndpointPairCreatedEventArgs[] = {
        { "_assign_array_", _assign_array_XboxLiveInboundEndpointPairCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveInboundEndpointPairCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveInboundEndpointPairCreatedEventArgs[] = {
        { "endpoint_pair", reinterpret_cast<getter>(XboxLiveInboundEndpointPairCreatedEventArgs_get_EndpointPair), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveInboundEndpointPairCreatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveInboundEndpointPairCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveInboundEndpointPairCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveInboundEndpointPairCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveInboundEndpointPairCreatedEventArgs) },
        { }};

    static PyType_Spec type_spec_XboxLiveInboundEndpointPairCreatedEventArgs = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveInboundEndpointPairCreatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveInboundEndpointPairCreatedEventArgs};

    // ----- XboxLiveQualityOfServiceMeasurement class --------------------

    static PyObject* _new_XboxLiveQualityOfServiceMeasurement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_XboxLiveQualityOfServiceMeasurement(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_ClearPrivatePayload(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"ClearPrivatePayload", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::ClearPrivatePayload();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_GetMetricResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"GetMetricResult", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetric>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMetricResult(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_GetMetricResultsForDevice(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"GetMetricResultsForDevice", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMetricResultsForDevice(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_GetMetricResultsForMetric(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"GetMetricResultsForMetric", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetric>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMetricResultsForMetric(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_GetPrivatePayloadResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"GetPrivatePayloadResult", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPrivatePayloadResult(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_MeasureAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MeasureAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MeasureAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_PublishPrivatePayloadBytes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"PublishPrivatePayloadBytes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::PublishPrivatePayloadBytes(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_TimeoutInMilliseconds(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"TimeoutInMilliseconds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TimeoutInMilliseconds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_TimeoutInMilliseconds(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"TimeoutInMilliseconds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TimeoutInMilliseconds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_ShouldRequestPrivatePayloads(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"ShouldRequestPrivatePayloads");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShouldRequestPrivatePayloads();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_ShouldRequestPrivatePayloads(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"ShouldRequestPrivatePayloads");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShouldRequestPrivatePayloads(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_NumberOfProbesToAttempt(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"NumberOfProbesToAttempt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumberOfProbesToAttempt();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_NumberOfProbesToAttempt(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"NumberOfProbesToAttempt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.NumberOfProbesToAttempt(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_DeviceAddresses(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"DeviceAddresses");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceAddresses();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_MetricResults(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MetricResults");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MetricResults();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_Metrics(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"Metrics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Metrics();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_NumberOfResultsPending(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"NumberOfResultsPending");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumberOfResultsPending();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_PrivatePayloadResults(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"PrivatePayloadResults");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrivatePayloadResults();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_PublishedPrivatePayload(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"PublishedPrivatePayload");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::PublishedPrivatePayload();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_PublishedPrivatePayload(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"PublishedPrivatePayload");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::PublishedPrivatePayload(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_MaxSimultaneousProbeConnections(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MaxSimultaneousProbeConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::MaxSimultaneousProbeConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_MaxSimultaneousProbeConnections(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MaxSimultaneousProbeConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::MaxSimultaneousProbeConnections(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_IsSystemOutboundBandwidthConstrained(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"IsSystemOutboundBandwidthConstrained");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::IsSystemOutboundBandwidthConstrained();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_IsSystemOutboundBandwidthConstrained(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"IsSystemOutboundBandwidthConstrained");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::IsSystemOutboundBandwidthConstrained(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_IsSystemInboundBandwidthConstrained(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"IsSystemInboundBandwidthConstrained");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::IsSystemInboundBandwidthConstrained();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_IsSystemInboundBandwidthConstrained(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"IsSystemInboundBandwidthConstrained");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::IsSystemInboundBandwidthConstrained(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_MaxPrivatePayloadSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MaxPrivatePayloadSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::MaxPrivatePayloadSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveQualityOfServiceMeasurement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveQualityOfServiceMeasurement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveQualityOfServiceMeasurement[] = {
        { "get_metric_result", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_GetMetricResult), METH_VARARGS, nullptr },
        { "get_metric_results_for_device", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_GetMetricResultsForDevice), METH_VARARGS, nullptr },
        { "get_metric_results_for_metric", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_GetMetricResultsForMetric), METH_VARARGS, nullptr },
        { "get_private_payload_result", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_GetPrivatePayloadResult), METH_VARARGS, nullptr },
        { "measure_async", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_MeasureAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XboxLiveQualityOfServiceMeasurement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveQualityOfServiceMeasurement), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveQualityOfServiceMeasurement[] = {
        { "timeout_in_milliseconds", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_TimeoutInMilliseconds), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_TimeoutInMilliseconds), nullptr, nullptr },
        { "should_request_private_payloads", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_ShouldRequestPrivatePayloads), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_ShouldRequestPrivatePayloads), nullptr, nullptr },
        { "number_of_probes_to_attempt", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_NumberOfProbesToAttempt), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_NumberOfProbesToAttempt), nullptr, nullptr },
        { "device_addresses", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_DeviceAddresses), nullptr, nullptr, nullptr },
        { "metric_results", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_MetricResults), nullptr, nullptr, nullptr },
        { "metrics", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_Metrics), nullptr, nullptr, nullptr },
        { "number_of_results_pending", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_NumberOfResultsPending), nullptr, nullptr, nullptr },
        { "private_payload_results", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_PrivatePayloadResults), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveQualityOfServiceMeasurement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveQualityOfServiceMeasurement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveQualityOfServiceMeasurement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveQualityOfServiceMeasurement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveQualityOfServiceMeasurement) },
        { }};

    static PyType_Spec type_spec_XboxLiveQualityOfServiceMeasurement = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveQualityOfServiceMeasurement",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveQualityOfServiceMeasurement};

    static PyGetSetDef getset_XboxLiveQualityOfServiceMeasurement_Static[] = {
        { "published_private_payload", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_PublishedPrivatePayload), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_PublishedPrivatePayload), nullptr, nullptr },
        { "max_simultaneous_probe_connections", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_MaxSimultaneousProbeConnections), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_MaxSimultaneousProbeConnections), nullptr, nullptr },
        { "is_system_outbound_bandwidth_constrained", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_IsSystemOutboundBandwidthConstrained), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_IsSystemOutboundBandwidthConstrained), nullptr, nullptr },
        { "is_system_inbound_bandwidth_constrained", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_IsSystemInboundBandwidthConstrained), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_IsSystemInboundBandwidthConstrained), nullptr, nullptr },
        { "max_private_payload_size", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_MaxPrivatePayloadSize), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_XboxLiveQualityOfServiceMeasurement_Static[] = {
        { "clear_private_payload", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_ClearPrivatePayload), METH_VARARGS, nullptr },
        { "publish_private_payload_bytes", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_PublishPrivatePayloadBytes), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XboxLiveQualityOfServiceMeasurement_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XboxLiveQualityOfServiceMeasurement_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XboxLiveQualityOfServiceMeasurement_Static) },
        { }
    };

    static PyType_Spec type_spec_XboxLiveQualityOfServiceMeasurement_Static = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveQualityOfServiceMeasurement_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XboxLiveQualityOfServiceMeasurement_Static};

    // ----- XboxLiveQualityOfServiceMetricResult class --------------------

    static PyObject* _new_XboxLiveQualityOfServiceMetricResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveQualityOfServiceMetricResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveQualityOfServiceMetricResult_get_DeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult", L"DeviceAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMetricResult_get_Metric(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult", L"Metric");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Metric();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMetricResult_get_Status(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMetricResult_get_Value(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveQualityOfServiceMetricResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveQualityOfServiceMetricResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveQualityOfServiceMetricResult[] = {
        { "_assign_array_", _assign_array_XboxLiveQualityOfServiceMetricResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveQualityOfServiceMetricResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveQualityOfServiceMetricResult[] = {
        { "device_address", reinterpret_cast<getter>(XboxLiveQualityOfServiceMetricResult_get_DeviceAddress), nullptr, nullptr, nullptr },
        { "metric", reinterpret_cast<getter>(XboxLiveQualityOfServiceMetricResult_get_Metric), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(XboxLiveQualityOfServiceMetricResult_get_Status), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(XboxLiveQualityOfServiceMetricResult_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveQualityOfServiceMetricResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveQualityOfServiceMetricResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveQualityOfServiceMetricResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveQualityOfServiceMetricResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveQualityOfServiceMetricResult) },
        { }};

    static PyType_Spec type_spec_XboxLiveQualityOfServiceMetricResult = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveQualityOfServiceMetricResult",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveQualityOfServiceMetricResult};

    // ----- XboxLiveQualityOfServicePrivatePayloadResult class --------------------

    static PyObject* _new_XboxLiveQualityOfServicePrivatePayloadResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveQualityOfServicePrivatePayloadResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveQualityOfServicePrivatePayloadResult_get_DeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult", L"DeviceAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServicePrivatePayloadResult_get_Status(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServicePrivatePayloadResult_get_Value(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveQualityOfServicePrivatePayloadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveQualityOfServicePrivatePayloadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveQualityOfServicePrivatePayloadResult[] = {
        { "_assign_array_", _assign_array_XboxLiveQualityOfServicePrivatePayloadResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveQualityOfServicePrivatePayloadResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XboxLiveQualityOfServicePrivatePayloadResult[] = {
        { "device_address", reinterpret_cast<getter>(XboxLiveQualityOfServicePrivatePayloadResult_get_DeviceAddress), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(XboxLiveQualityOfServicePrivatePayloadResult_get_Status), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(XboxLiveQualityOfServicePrivatePayloadResult_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XboxLiveQualityOfServicePrivatePayloadResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveQualityOfServicePrivatePayloadResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveQualityOfServicePrivatePayloadResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveQualityOfServicePrivatePayloadResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveQualityOfServicePrivatePayloadResult) },
        { }};

    static PyType_Spec type_spec_XboxLiveQualityOfServicePrivatePayloadResult = {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveQualityOfServicePrivatePayloadResult",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveQualityOfServicePrivatePayloadResult};

    // ----- Windows.Networking.XboxLive Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Networking.XboxLive");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_networking_xboxlive",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Networking::XboxLive

PyMODINIT_FUNC PyInit__winrt_windows_networking_xboxlive(void) noexcept
{
    using namespace py::cpp::Windows::Networking::XboxLive;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle XboxLiveDeviceAddress_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XboxLiveDeviceAddress_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XboxLiveDeviceAddress_Static{PyType_FromSpecWithBases(&type_spec_XboxLiveDeviceAddress_Static, XboxLiveDeviceAddress_Static_bases.get())};
    if (!type_XboxLiveDeviceAddress_Static)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveDeviceAddress_type{py::register_python_type(module.get(), &type_spec_XboxLiveDeviceAddress, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XboxLiveDeviceAddress_Static.get()))};
    if (!XboxLiveDeviceAddress_type)
    {
        return nullptr;
    }

    py::pyobj_handle XboxLiveEndpointPair_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XboxLiveEndpointPair_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XboxLiveEndpointPair_Static{PyType_FromSpecWithBases(&type_spec_XboxLiveEndpointPair_Static, XboxLiveEndpointPair_Static_bases.get())};
    if (!type_XboxLiveEndpointPair_Static)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveEndpointPair_type{py::register_python_type(module.get(), &type_spec_XboxLiveEndpointPair, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XboxLiveEndpointPair_Static.get()))};
    if (!XboxLiveEndpointPair_type)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveEndpointPairCreationResult_type{py::register_python_type(module.get(), &type_spec_XboxLiveEndpointPairCreationResult, object_bases.get(), inspectable_meta_type)};
    if (!XboxLiveEndpointPairCreationResult_type)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveEndpointPairStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_XboxLiveEndpointPairStateChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!XboxLiveEndpointPairStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle XboxLiveEndpointPairTemplate_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XboxLiveEndpointPairTemplate_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XboxLiveEndpointPairTemplate_Static{PyType_FromSpecWithBases(&type_spec_XboxLiveEndpointPairTemplate_Static, XboxLiveEndpointPairTemplate_Static_bases.get())};
    if (!type_XboxLiveEndpointPairTemplate_Static)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveEndpointPairTemplate_type{py::register_python_type(module.get(), &type_spec_XboxLiveEndpointPairTemplate, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XboxLiveEndpointPairTemplate_Static.get()))};
    if (!XboxLiveEndpointPairTemplate_type)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveInboundEndpointPairCreatedEventArgs_type{py::register_python_type(module.get(), &type_spec_XboxLiveInboundEndpointPairCreatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!XboxLiveInboundEndpointPairCreatedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle XboxLiveQualityOfServiceMeasurement_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XboxLiveQualityOfServiceMeasurement_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XboxLiveQualityOfServiceMeasurement_Static{PyType_FromSpecWithBases(&type_spec_XboxLiveQualityOfServiceMeasurement_Static, XboxLiveQualityOfServiceMeasurement_Static_bases.get())};
    if (!type_XboxLiveQualityOfServiceMeasurement_Static)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveQualityOfServiceMeasurement_type{py::register_python_type(module.get(), &type_spec_XboxLiveQualityOfServiceMeasurement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XboxLiveQualityOfServiceMeasurement_Static.get()))};
    if (!XboxLiveQualityOfServiceMeasurement_type)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveQualityOfServiceMetricResult_type{py::register_python_type(module.get(), &type_spec_XboxLiveQualityOfServiceMetricResult, object_bases.get(), inspectable_meta_type)};
    if (!XboxLiveQualityOfServiceMetricResult_type)
    {
        return nullptr;
    }

    py::pytype_handle XboxLiveQualityOfServicePrivatePayloadResult_type{py::register_python_type(module.get(), &type_spec_XboxLiveQualityOfServicePrivatePayloadResult, object_bases.get(), inspectable_meta_type)};
    if (!XboxLiveQualityOfServicePrivatePayloadResult_type)
    {
        return nullptr;
    }


    return module.detach();
}
