// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.ApplicationModel.Wallet.h"

namespace py::cpp::Windows::ApplicationModel::Wallet
{
    // ----- WalletBarcode class --------------------

    static PyObject* _new_WalletBarcode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletBarcodeSymbology>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletBarcode instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                winrt::Windows::ApplicationModel::Wallet::WalletBarcode instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletBarcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletBarcode_GetImageAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletBarcode", L"GetImageAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetImageAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletBarcode_get_Symbology(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletBarcode", L"Symbology");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Symbology();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletBarcode_get_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletBarcode", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WalletBarcode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletBarcode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletBarcode[] = {
        { "get_image_async", reinterpret_cast<PyCFunction>(WalletBarcode_GetImageAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WalletBarcode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletBarcode), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WalletBarcode[] = {
        { "symbology", reinterpret_cast<getter>(WalletBarcode_get_Symbology), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WalletBarcode_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WalletBarcode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletBarcode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletBarcode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletBarcode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletBarcode) },
        { }};

    static PyType_Spec type_spec_WalletBarcode = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletBarcode",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletBarcode};

    // ----- WalletItem class --------------------

    static PyObject* _new_WalletItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItemKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletItem instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletItem(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItem_get_DisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_DisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayMessage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LogoText(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LogoText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LogoText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LogoText(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LogoText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.LogoText(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyFontColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BodyFontColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyFontColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.BodyFontColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BodyColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.BodyColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyBackgroundImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BodyBackgroundImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyBackgroundImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.BodyBackgroundImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsDisplayMessageLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsDisplayMessageLaunchable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDisplayMessageLaunchable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsDisplayMessageLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsDisplayMessageLaunchable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsDisplayMessageLaunchable(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsAcknowledged(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsAcknowledged");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAcknowledged();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsAcknowledged(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsAcknowledged");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsAcknowledged(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsMoreTransactionHistoryLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsMoreTransactionHistoryLaunchable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMoreTransactionHistoryLaunchable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsMoreTransactionHistoryLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsMoreTransactionHistoryLaunchable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsMoreTransactionHistoryLaunchable(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderFontColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeaderFontColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderFontColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeaderFontColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeaderColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeaderColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderBackgroundImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeaderBackgroundImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderBackgroundImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeaderBackgroundImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_ExpirationDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_ExpirationDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationDate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo99x99(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo99x99");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Logo99x99();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo99x99(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo99x99");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.Logo99x99(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LogoImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LogoImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LogoImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LogoImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LogoImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.LogoImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_PromotionalImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"PromotionalImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PromotionalImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_PromotionalImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"PromotionalImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.PromotionalImage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo159x159(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo159x159");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Logo159x159();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo159x159(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo159x159");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.Logo159x159(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LastUpdated(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LastUpdated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastUpdated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LastUpdated(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LastUpdated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.LastUpdated(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IssuerDisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IssuerDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IssuerDisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IssuerDisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IssuerDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.IssuerDisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Barcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Barcode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Barcode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Barcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Barcode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>(arg);

            {
                auto _gil = release_gil();
                self->obj.Barcode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_RelevantDateDisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantDateDisplayMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RelevantDateDisplayMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_RelevantDateDisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantDateDisplayMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.RelevantDateDisplayMessage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_RelevantDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RelevantDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_RelevantDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.RelevantDate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo336x336(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo336x336");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Logo336x336();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo336x336(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo336x336");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.Logo336x336(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Kind(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_DisplayProperties(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_Id(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_RelevantLocations(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantLocations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RelevantLocations();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_TransactionHistory(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"TransactionHistory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransactionHistory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_Verbs(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Verbs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verbs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WalletItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItem[] = {
        { "_assign_array_", _assign_array_WalletItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WalletItem[] = {
        { "display_name", reinterpret_cast<getter>(WalletItem_get_DisplayName), reinterpret_cast<setter>(WalletItem_put_DisplayName), nullptr, nullptr },
        { "display_message", reinterpret_cast<getter>(WalletItem_get_DisplayMessage), reinterpret_cast<setter>(WalletItem_put_DisplayMessage), nullptr, nullptr },
        { "logo_text", reinterpret_cast<getter>(WalletItem_get_LogoText), reinterpret_cast<setter>(WalletItem_put_LogoText), nullptr, nullptr },
        { "body_font_color", reinterpret_cast<getter>(WalletItem_get_BodyFontColor), reinterpret_cast<setter>(WalletItem_put_BodyFontColor), nullptr, nullptr },
        { "body_color", reinterpret_cast<getter>(WalletItem_get_BodyColor), reinterpret_cast<setter>(WalletItem_put_BodyColor), nullptr, nullptr },
        { "body_background_image", reinterpret_cast<getter>(WalletItem_get_BodyBackgroundImage), reinterpret_cast<setter>(WalletItem_put_BodyBackgroundImage), nullptr, nullptr },
        { "is_display_message_launchable", reinterpret_cast<getter>(WalletItem_get_IsDisplayMessageLaunchable), reinterpret_cast<setter>(WalletItem_put_IsDisplayMessageLaunchable), nullptr, nullptr },
        { "is_acknowledged", reinterpret_cast<getter>(WalletItem_get_IsAcknowledged), reinterpret_cast<setter>(WalletItem_put_IsAcknowledged), nullptr, nullptr },
        { "is_more_transaction_history_launchable", reinterpret_cast<getter>(WalletItem_get_IsMoreTransactionHistoryLaunchable), reinterpret_cast<setter>(WalletItem_put_IsMoreTransactionHistoryLaunchable), nullptr, nullptr },
        { "header_font_color", reinterpret_cast<getter>(WalletItem_get_HeaderFontColor), reinterpret_cast<setter>(WalletItem_put_HeaderFontColor), nullptr, nullptr },
        { "header_color", reinterpret_cast<getter>(WalletItem_get_HeaderColor), reinterpret_cast<setter>(WalletItem_put_HeaderColor), nullptr, nullptr },
        { "header_background_image", reinterpret_cast<getter>(WalletItem_get_HeaderBackgroundImage), reinterpret_cast<setter>(WalletItem_put_HeaderBackgroundImage), nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(WalletItem_get_ExpirationDate), reinterpret_cast<setter>(WalletItem_put_ExpirationDate), nullptr, nullptr },
        { "logo99x99", reinterpret_cast<getter>(WalletItem_get_Logo99x99), reinterpret_cast<setter>(WalletItem_put_Logo99x99), nullptr, nullptr },
        { "logo_image", reinterpret_cast<getter>(WalletItem_get_LogoImage), reinterpret_cast<setter>(WalletItem_put_LogoImage), nullptr, nullptr },
        { "promotional_image", reinterpret_cast<getter>(WalletItem_get_PromotionalImage), reinterpret_cast<setter>(WalletItem_put_PromotionalImage), nullptr, nullptr },
        { "logo159x159", reinterpret_cast<getter>(WalletItem_get_Logo159x159), reinterpret_cast<setter>(WalletItem_put_Logo159x159), nullptr, nullptr },
        { "last_updated", reinterpret_cast<getter>(WalletItem_get_LastUpdated), reinterpret_cast<setter>(WalletItem_put_LastUpdated), nullptr, nullptr },
        { "issuer_display_name", reinterpret_cast<getter>(WalletItem_get_IssuerDisplayName), reinterpret_cast<setter>(WalletItem_put_IssuerDisplayName), nullptr, nullptr },
        { "barcode", reinterpret_cast<getter>(WalletItem_get_Barcode), reinterpret_cast<setter>(WalletItem_put_Barcode), nullptr, nullptr },
        { "relevant_date_display_message", reinterpret_cast<getter>(WalletItem_get_RelevantDateDisplayMessage), reinterpret_cast<setter>(WalletItem_put_RelevantDateDisplayMessage), nullptr, nullptr },
        { "relevant_date", reinterpret_cast<getter>(WalletItem_get_RelevantDate), reinterpret_cast<setter>(WalletItem_put_RelevantDate), nullptr, nullptr },
        { "logo336x336", reinterpret_cast<getter>(WalletItem_get_Logo336x336), reinterpret_cast<setter>(WalletItem_put_Logo336x336), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(WalletItem_get_Kind), nullptr, nullptr, nullptr },
        { "display_properties", reinterpret_cast<getter>(WalletItem_get_DisplayProperties), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(WalletItem_get_Id), nullptr, nullptr, nullptr },
        { "relevant_locations", reinterpret_cast<getter>(WalletItem_get_RelevantLocations), nullptr, nullptr, nullptr },
        { "transaction_history", reinterpret_cast<getter>(WalletItem_get_TransactionHistory), nullptr, nullptr, nullptr },
        { "verbs", reinterpret_cast<getter>(WalletItem_get_Verbs), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WalletItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletItem) },
        { }};

    static PyType_Spec type_spec_WalletItem = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItem};

    // ----- WalletItemCustomProperty class --------------------

    static PyObject* _new_WalletItemCustomProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletItemCustomProperty(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItemCustomProperty_get_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_SummaryViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"SummaryViewPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SummaryViewPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_SummaryViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"SummaryViewPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletSummaryViewPosition>(arg);

            {
                auto _gil = release_gil();
                self->obj.SummaryViewPosition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_DetailViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"DetailViewPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DetailViewPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_DetailViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"DetailViewPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletDetailViewPosition>(arg);

            {
                auto _gil = release_gil();
                self->obj.DetailViewPosition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_AutoDetectLinks(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"AutoDetectLinks");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AutoDetectLinks();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_AutoDetectLinks(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"AutoDetectLinks");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AutoDetectLinks(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WalletItemCustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletItemCustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItemCustomProperty[] = {
        { "_assign_array_", _assign_array_WalletItemCustomProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItemCustomProperty), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WalletItemCustomProperty[] = {
        { "value", reinterpret_cast<getter>(WalletItemCustomProperty_get_Value), reinterpret_cast<setter>(WalletItemCustomProperty_put_Value), nullptr, nullptr },
        { "summary_view_position", reinterpret_cast<getter>(WalletItemCustomProperty_get_SummaryViewPosition), reinterpret_cast<setter>(WalletItemCustomProperty_put_SummaryViewPosition), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(WalletItemCustomProperty_get_Name), reinterpret_cast<setter>(WalletItemCustomProperty_put_Name), nullptr, nullptr },
        { "detail_view_position", reinterpret_cast<getter>(WalletItemCustomProperty_get_DetailViewPosition), reinterpret_cast<setter>(WalletItemCustomProperty_put_DetailViewPosition), nullptr, nullptr },
        { "auto_detect_links", reinterpret_cast<getter>(WalletItemCustomProperty_get_AutoDetectLinks), reinterpret_cast<setter>(WalletItemCustomProperty_put_AutoDetectLinks), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WalletItemCustomProperty[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletItemCustomProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletItemCustomProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletItemCustomProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletItemCustomProperty) },
        { }};

    static PyType_Spec type_spec_WalletItemCustomProperty = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletItemCustomProperty",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItemCustomProperty};

    // ----- WalletItemStore class --------------------

    static PyObject* _new_WalletItemStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>::type_name);
        return nullptr;
    }

    static void _dealloc_WalletItemStore(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItemStore_AddAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"AddAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItem>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ClearAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"ClearAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ClearAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_DeleteAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"DeleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_GetItemsAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"GetItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_GetItemsWithKindAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"GetItemsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItemKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_GetWalletItemAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"GetWalletItemAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetWalletItemAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ImportItemAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"ImportItemAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ImportItemAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ShowAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"ShowAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ShowAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ShowItemAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"ShowAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ShowAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_UpdateAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"UpdateAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItem>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UpdateAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WalletItemStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletItemStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItemStore[] = {
        { "add_async", reinterpret_cast<PyCFunction>(WalletItemStore_AddAsync), METH_VARARGS, nullptr },
        { "clear_async", reinterpret_cast<PyCFunction>(WalletItemStore_ClearAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(WalletItemStore_DeleteAsync), METH_VARARGS, nullptr },
        { "get_items_async", reinterpret_cast<PyCFunction>(WalletItemStore_GetItemsAsync), METH_VARARGS, nullptr },
        { "get_items_with_kind_async", reinterpret_cast<PyCFunction>(WalletItemStore_GetItemsWithKindAsync), METH_VARARGS, nullptr },
        { "get_wallet_item_async", reinterpret_cast<PyCFunction>(WalletItemStore_GetWalletItemAsync), METH_VARARGS, nullptr },
        { "import_item_async", reinterpret_cast<PyCFunction>(WalletItemStore_ImportItemAsync), METH_VARARGS, nullptr },
        { "show_async", reinterpret_cast<PyCFunction>(WalletItemStore_ShowAsync), METH_VARARGS, nullptr },
        { "show_item_async", reinterpret_cast<PyCFunction>(WalletItemStore_ShowItemAsync), METH_VARARGS, nullptr },
        { "update_async", reinterpret_cast<PyCFunction>(WalletItemStore_UpdateAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WalletItemStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItemStore), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WalletItemStore[] = {
        { }};

    static PyType_Slot _type_slots_WalletItemStore[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletItemStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletItemStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletItemStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletItemStore) },
        { }};

    static PyType_Spec type_spec_WalletItemStore = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletItemStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItemStore};

    // ----- WalletManager class --------------------

    static PyObject* _new_WalletManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletManager>::type_name);
        return nullptr;
    }

    static PyObject* WalletManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletManager", L"RequestStoreAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Wallet::WalletManager::RequestStoreAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletManager[] = {
        { }};

    static PyGetSetDef _getset_WalletManager[] = {
        { }};

    static PyType_Slot _type_slots_WalletManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletManager) },
        { }};

    static PyType_Spec type_spec_WalletManager = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletManager};

    static PyGetSetDef getset_WalletManager_Static[] = {
        { }};

    static PyMethodDef methods_WalletManager_Static[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(WalletManager_RequestStoreAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_WalletManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WalletManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WalletManager_Static) },
        { }
    };

    static PyType_Spec type_spec_WalletManager_Static = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WalletManager_Static};

    // ----- WalletRelevantLocation class --------------------

    static PyObject* _new_WalletRelevantLocation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletRelevantLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletRelevantLocation_get_Position(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletRelevantLocation", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletRelevantLocation_put_Position(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletRelevantLocation", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(arg);

            {
                auto _gil = release_gil();
                self->obj.Position(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletRelevantLocation_get_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletRelevantLocation", L"DisplayMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletRelevantLocation_put_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletRelevantLocation", L"DisplayMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayMessage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WalletRelevantLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletRelevantLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletRelevantLocation[] = {
        { "_assign_array_", _assign_array_WalletRelevantLocation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletRelevantLocation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WalletRelevantLocation[] = {
        { "position", reinterpret_cast<getter>(WalletRelevantLocation_get_Position), reinterpret_cast<setter>(WalletRelevantLocation_put_Position), nullptr, nullptr },
        { "display_message", reinterpret_cast<getter>(WalletRelevantLocation_get_DisplayMessage), reinterpret_cast<setter>(WalletRelevantLocation_put_DisplayMessage), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WalletRelevantLocation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletRelevantLocation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletRelevantLocation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletRelevantLocation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletRelevantLocation) },
        { }};

    static PyType_Spec type_spec_WalletRelevantLocation = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletRelevantLocation",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletRelevantLocation};

    // ----- WalletTransaction class --------------------

    static PyObject* _new_WalletTransaction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Wallet::WalletTransaction instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletTransaction(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletTransaction_get_TransactionDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"TransactionDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransactionDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_TransactionDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"TransactionDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.TransactionDate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_IsLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"IsLaunchable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsLaunchable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_IsLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"IsLaunchable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsLaunchable(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_IgnoreTimeOfDay(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"IgnoreTimeOfDay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IgnoreTimeOfDay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_IgnoreTimeOfDay(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"IgnoreTimeOfDay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IgnoreTimeOfDay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_DisplayLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"DisplayLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayLocation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_DisplayLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"DisplayLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayLocation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_DisplayAmount(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"DisplayAmount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayAmount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_DisplayAmount(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"DisplayAmount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayAmount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_Description(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_Description(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Description(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WalletTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletTransaction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletTransaction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletTransaction[] = {
        { "_assign_array_", _assign_array_WalletTransaction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletTransaction), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WalletTransaction[] = {
        { "transaction_date", reinterpret_cast<getter>(WalletTransaction_get_TransactionDate), reinterpret_cast<setter>(WalletTransaction_put_TransactionDate), nullptr, nullptr },
        { "is_launchable", reinterpret_cast<getter>(WalletTransaction_get_IsLaunchable), reinterpret_cast<setter>(WalletTransaction_put_IsLaunchable), nullptr, nullptr },
        { "ignore_time_of_day", reinterpret_cast<getter>(WalletTransaction_get_IgnoreTimeOfDay), reinterpret_cast<setter>(WalletTransaction_put_IgnoreTimeOfDay), nullptr, nullptr },
        { "display_location", reinterpret_cast<getter>(WalletTransaction_get_DisplayLocation), reinterpret_cast<setter>(WalletTransaction_put_DisplayLocation), nullptr, nullptr },
        { "display_amount", reinterpret_cast<getter>(WalletTransaction_get_DisplayAmount), reinterpret_cast<setter>(WalletTransaction_put_DisplayAmount), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WalletTransaction_get_Description), reinterpret_cast<setter>(WalletTransaction_put_Description), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WalletTransaction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletTransaction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletTransaction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletTransaction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletTransaction) },
        { }};

    static PyType_Spec type_spec_WalletTransaction = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletTransaction",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletTransaction};

    // ----- WalletVerb class --------------------

    static PyObject* _new_WalletVerb(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Wallet::WalletVerb instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletVerb(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletVerb_get_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletVerb", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletVerb_put_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletVerb", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WalletVerb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletVerb>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletVerb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletVerb>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletVerb[] = {
        { "_assign_array_", _assign_array_WalletVerb, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletVerb), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WalletVerb[] = {
        { "name", reinterpret_cast<getter>(WalletVerb_get_Name), reinterpret_cast<setter>(WalletVerb_put_Name), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WalletVerb[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletVerb) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletVerb) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletVerb) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletVerb) },
        { }};

    static PyType_Spec type_spec_WalletVerb = {
        "winrt._winrt_windows_applicationmodel_wallet.WalletVerb",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletVerb};

    // ----- Windows.ApplicationModel.Wallet Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Wallet");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_wallet",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Wallet

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_wallet(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle WalletBarcode_type{py::register_python_type(module.get(), &type_spec_WalletBarcode, object_bases.get(), inspectable_meta_type)};
    if (!WalletBarcode_type)
    {
        return nullptr;
    }

    py::pytype_handle WalletItem_type{py::register_python_type(module.get(), &type_spec_WalletItem, object_bases.get(), inspectable_meta_type)};
    if (!WalletItem_type)
    {
        return nullptr;
    }

    py::pytype_handle WalletItemCustomProperty_type{py::register_python_type(module.get(), &type_spec_WalletItemCustomProperty, object_bases.get(), inspectable_meta_type)};
    if (!WalletItemCustomProperty_type)
    {
        return nullptr;
    }

    py::pytype_handle WalletItemStore_type{py::register_python_type(module.get(), &type_spec_WalletItemStore, object_bases.get(), inspectable_meta_type)};
    if (!WalletItemStore_type)
    {
        return nullptr;
    }

    py::pyobj_handle WalletManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!WalletManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WalletManager_Static{PyType_FromSpecWithBases(&type_spec_WalletManager_Static, WalletManager_Static_bases.get())};
    if (!type_WalletManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle WalletManager_type{py::register_python_type(module.get(), &type_spec_WalletManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WalletManager_Static.get()))};
    if (!WalletManager_type)
    {
        return nullptr;
    }

    py::pytype_handle WalletRelevantLocation_type{py::register_python_type(module.get(), &type_spec_WalletRelevantLocation, object_bases.get(), inspectable_meta_type)};
    if (!WalletRelevantLocation_type)
    {
        return nullptr;
    }

    py::pytype_handle WalletTransaction_type{py::register_python_type(module.get(), &type_spec_WalletTransaction, object_bases.get(), inspectable_meta_type)};
    if (!WalletTransaction_type)
    {
        return nullptr;
    }

    py::pytype_handle WalletVerb_type{py::register_python_type(module.get(), &type_spec_WalletVerb, object_bases.get(), inspectable_meta_type)};
    if (!WalletVerb_type)
    {
        return nullptr;
    }


    return module.detach();
}
