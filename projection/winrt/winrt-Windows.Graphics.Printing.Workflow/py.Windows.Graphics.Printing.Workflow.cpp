// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Graphics.Printing.Workflow.h"

namespace py::cpp::Windows::Graphics::Printing::Workflow
{
    // ----- PrintWorkflowBackgroundSession class --------------------

    static PyObject* _new_PrintWorkflowBackgroundSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowBackgroundSession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowBackgroundSession_Start(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowBackgroundSession_get_Status(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSession", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowBackgroundSession_add_SetupRequested(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSession", L"SetupRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SetupRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowBackgroundSession_remove_SetupRequested(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSession", L"SetupRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SetupRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowBackgroundSession_add_Submitted(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSession", L"Submitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Submitted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowBackgroundSession_remove_Submitted(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSession", L"Submitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Submitted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowBackgroundSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowBackgroundSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowBackgroundSession[] = {
        { "start", reinterpret_cast<PyCFunction>(PrintWorkflowBackgroundSession_Start), METH_VARARGS, nullptr },
        { "add_setup_requested", reinterpret_cast<PyCFunction>(PrintWorkflowBackgroundSession_add_SetupRequested), METH_O, nullptr },
        { "remove_setup_requested", reinterpret_cast<PyCFunction>(PrintWorkflowBackgroundSession_remove_SetupRequested), METH_O, nullptr },
        { "add_submitted", reinterpret_cast<PyCFunction>(PrintWorkflowBackgroundSession_add_Submitted), METH_O, nullptr },
        { "remove_submitted", reinterpret_cast<PyCFunction>(PrintWorkflowBackgroundSession_remove_Submitted), METH_O, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowBackgroundSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowBackgroundSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowBackgroundSession[] = {
        { "status", reinterpret_cast<getter>(PrintWorkflowBackgroundSession_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowBackgroundSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowBackgroundSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowBackgroundSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowBackgroundSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowBackgroundSession) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowBackgroundSession = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowBackgroundSession",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowBackgroundSession};

    // ----- PrintWorkflowBackgroundSetupRequestedEventArgs class --------------------

    static PyObject* _new_PrintWorkflowBackgroundSetupRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowBackgroundSetupRequestedEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowBackgroundSetupRequestedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSetupRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowBackgroundSetupRequestedEventArgs_GetUserPrintTicketAsync(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSetupRequestedEventArgs", L"GetUserPrintTicketAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUserPrintTicketAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowBackgroundSetupRequestedEventArgs_SetRequiresUI(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSetupRequestedEventArgs", L"SetRequiresUI", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.SetRequiresUI();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowBackgroundSetupRequestedEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowBackgroundSetupRequestedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowBackgroundSetupRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowBackgroundSetupRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowBackgroundSetupRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowBackgroundSetupRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_user_print_ticket_async", reinterpret_cast<PyCFunction>(PrintWorkflowBackgroundSetupRequestedEventArgs_GetUserPrintTicketAsync), METH_VARARGS, nullptr },
        { "set_requires_ui", reinterpret_cast<PyCFunction>(PrintWorkflowBackgroundSetupRequestedEventArgs_SetRequiresUI), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowBackgroundSetupRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowBackgroundSetupRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowBackgroundSetupRequestedEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowBackgroundSetupRequestedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowBackgroundSetupRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowBackgroundSetupRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowBackgroundSetupRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowBackgroundSetupRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowBackgroundSetupRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowBackgroundSetupRequestedEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowBackgroundSetupRequestedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowBackgroundSetupRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowBackgroundSetupRequestedEventArgs};

    // ----- PrintWorkflowConfiguration class --------------------

    static PyObject* _new_PrintWorkflowConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowConfiguration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowConfiguration_AbortPrintFlow(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowConfiguration", L"AbortPrintFlow", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobAbortReason>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AbortPrintFlow(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowConfiguration_get_JobTitle(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowConfiguration", L"JobTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JobTitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowConfiguration_get_SessionId(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowConfiguration", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SessionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowConfiguration_get_SourceAppDisplayName(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowConfiguration", L"SourceAppDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceAppDisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowConfiguration[] = {
        { "abort_print_flow", reinterpret_cast<PyCFunction>(PrintWorkflowConfiguration_AbortPrintFlow), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowConfiguration[] = {
        { "job_title", reinterpret_cast<getter>(PrintWorkflowConfiguration_get_JobTitle), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(PrintWorkflowConfiguration_get_SessionId), nullptr, nullptr, nullptr },
        { "source_app_display_name", reinterpret_cast<getter>(PrintWorkflowConfiguration_get_SourceAppDisplayName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowConfiguration) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowConfiguration = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowConfiguration",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowConfiguration};

    // ----- PrintWorkflowForegroundSession class --------------------

    static PyObject* _new_PrintWorkflowForegroundSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowForegroundSession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowForegroundSession_Start(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowForegroundSession_get_Status(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSession", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowForegroundSession_add_SetupRequested(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSession", L"SetupRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SetupRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowForegroundSession_remove_SetupRequested(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSession", L"SetupRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SetupRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowForegroundSession_add_XpsDataAvailable(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSession", L"XpsDataAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XpsDataAvailable(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowForegroundSession_remove_XpsDataAvailable(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSession", L"XpsDataAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.XpsDataAvailable(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowForegroundSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowForegroundSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowForegroundSession[] = {
        { "start", reinterpret_cast<PyCFunction>(PrintWorkflowForegroundSession_Start), METH_VARARGS, nullptr },
        { "add_setup_requested", reinterpret_cast<PyCFunction>(PrintWorkflowForegroundSession_add_SetupRequested), METH_O, nullptr },
        { "remove_setup_requested", reinterpret_cast<PyCFunction>(PrintWorkflowForegroundSession_remove_SetupRequested), METH_O, nullptr },
        { "add_xps_data_available", reinterpret_cast<PyCFunction>(PrintWorkflowForegroundSession_add_XpsDataAvailable), METH_O, nullptr },
        { "remove_xps_data_available", reinterpret_cast<PyCFunction>(PrintWorkflowForegroundSession_remove_XpsDataAvailable), METH_O, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowForegroundSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowForegroundSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowForegroundSession[] = {
        { "status", reinterpret_cast<getter>(PrintWorkflowForegroundSession_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowForegroundSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowForegroundSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowForegroundSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowForegroundSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowForegroundSession) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowForegroundSession = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowForegroundSession",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowForegroundSession};

    // ----- PrintWorkflowForegroundSetupRequestedEventArgs class --------------------

    static PyObject* _new_PrintWorkflowForegroundSetupRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowForegroundSetupRequestedEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowForegroundSetupRequestedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSetupRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowForegroundSetupRequestedEventArgs_GetUserPrintTicketAsync(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSetupRequestedEventArgs", L"GetUserPrintTicketAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUserPrintTicketAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowForegroundSetupRequestedEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowForegroundSetupRequestedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowForegroundSetupRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowForegroundSetupRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowForegroundSetupRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowForegroundSetupRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_user_print_ticket_async", reinterpret_cast<PyCFunction>(PrintWorkflowForegroundSetupRequestedEventArgs_GetUserPrintTicketAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowForegroundSetupRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowForegroundSetupRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowForegroundSetupRequestedEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowForegroundSetupRequestedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowForegroundSetupRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowForegroundSetupRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowForegroundSetupRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowForegroundSetupRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowForegroundSetupRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowForegroundSetupRequestedEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowForegroundSetupRequestedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowForegroundSetupRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowForegroundSetupRequestedEventArgs};

    // ----- PrintWorkflowJobActivatedEventArgs class --------------------

    static PyObject* _new_PrintWorkflowJobActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowJobActivatedEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowJobActivatedEventArgs_get_Kind(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobActivatedEventArgs_get_User(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobActivatedEventArgs_get_Session(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobActivatedEventArgs", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Session();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowJobActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowJobActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowJobActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_PrintWorkflowJobActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowJobActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowJobActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PrintWorkflowJobActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PrintWorkflowJobActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PrintWorkflowJobActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(PrintWorkflowJobActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PrintWorkflowJobActivatedEventArgs_get_Session), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowJobActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowJobActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowJobActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowJobActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowJobActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowJobActivatedEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowJobActivatedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowJobActivatedEventArgs};

    // ----- PrintWorkflowJobBackgroundSession class --------------------

    static PyObject* _new_PrintWorkflowJobBackgroundSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowJobBackgroundSession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowJobBackgroundSession_Start(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobBackgroundSession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobBackgroundSession_get_Status(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobBackgroundSession", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobBackgroundSession_add_JobStarting(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobBackgroundSession", L"JobStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JobStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobBackgroundSession_remove_JobStarting(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobBackgroundSession", L"JobStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.JobStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobBackgroundSession_add_PdlModificationRequested(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobBackgroundSession", L"PdlModificationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PdlModificationRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobBackgroundSession_remove_PdlModificationRequested(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobBackgroundSession", L"PdlModificationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PdlModificationRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobBackgroundSession_add_JobIssueDetected(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobBackgroundSession", L"JobIssueDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JobIssueDetected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobBackgroundSession_remove_JobIssueDetected(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobBackgroundSession", L"JobIssueDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.JobIssueDetected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowJobBackgroundSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowJobBackgroundSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowJobBackgroundSession[] = {
        { "start", reinterpret_cast<PyCFunction>(PrintWorkflowJobBackgroundSession_Start), METH_VARARGS, nullptr },
        { "add_job_starting", reinterpret_cast<PyCFunction>(PrintWorkflowJobBackgroundSession_add_JobStarting), METH_O, nullptr },
        { "remove_job_starting", reinterpret_cast<PyCFunction>(PrintWorkflowJobBackgroundSession_remove_JobStarting), METH_O, nullptr },
        { "add_pdl_modification_requested", reinterpret_cast<PyCFunction>(PrintWorkflowJobBackgroundSession_add_PdlModificationRequested), METH_O, nullptr },
        { "remove_pdl_modification_requested", reinterpret_cast<PyCFunction>(PrintWorkflowJobBackgroundSession_remove_PdlModificationRequested), METH_O, nullptr },
        { "add_job_issue_detected", reinterpret_cast<PyCFunction>(PrintWorkflowJobBackgroundSession_add_JobIssueDetected), METH_O, nullptr },
        { "remove_job_issue_detected", reinterpret_cast<PyCFunction>(PrintWorkflowJobBackgroundSession_remove_JobIssueDetected), METH_O, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowJobBackgroundSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowJobBackgroundSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowJobBackgroundSession[] = {
        { "status", reinterpret_cast<getter>(PrintWorkflowJobBackgroundSession_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowJobBackgroundSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowJobBackgroundSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowJobBackgroundSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowJobBackgroundSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowJobBackgroundSession) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowJobBackgroundSession = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowJobBackgroundSession",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobBackgroundSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowJobBackgroundSession};

    // ----- PrintWorkflowJobIssueDetectedEventArgs class --------------------

    static PyObject* _new_PrintWorkflowJobIssueDetectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowJobIssueDetectedEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowJobIssueDetectedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobIssueDetectedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobIssueDetectedEventArgs_get_SkipSystemErrorToast(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobIssueDetectedEventArgs", L"SkipSystemErrorToast");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SkipSystemErrorToast();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintWorkflowJobIssueDetectedEventArgs_put_SkipSystemErrorToast(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobIssueDetectedEventArgs", L"SkipSystemErrorToast");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.SkipSystemErrorToast(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintWorkflowJobIssueDetectedEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobIssueDetectedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobIssueDetectedEventArgs_get_ExtendedError(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobIssueDetectedEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobIssueDetectedEventArgs_get_JobIssueKind(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobIssueDetectedEventArgs", L"JobIssueKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JobIssueKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobIssueDetectedEventArgs_get_PrinterJob(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobIssueDetectedEventArgs", L"PrinterJob");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrinterJob();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobIssueDetectedEventArgs_get_UILauncher(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobIssueDetectedEventArgs", L"UILauncher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UILauncher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowJobIssueDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowJobIssueDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowJobIssueDetectedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowJobIssueDetectedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowJobIssueDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowJobIssueDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowJobIssueDetectedEventArgs[] = {
        { "skip_system_error_toast", reinterpret_cast<getter>(PrintWorkflowJobIssueDetectedEventArgs_get_SkipSystemErrorToast), reinterpret_cast<setter>(PrintWorkflowJobIssueDetectedEventArgs_put_SkipSystemErrorToast), nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(PrintWorkflowJobIssueDetectedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(PrintWorkflowJobIssueDetectedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { "job_issue_kind", reinterpret_cast<getter>(PrintWorkflowJobIssueDetectedEventArgs_get_JobIssueKind), nullptr, nullptr, nullptr },
        { "printer_job", reinterpret_cast<getter>(PrintWorkflowJobIssueDetectedEventArgs_get_PrinterJob), nullptr, nullptr, nullptr },
        { "ui_launcher", reinterpret_cast<getter>(PrintWorkflowJobIssueDetectedEventArgs_get_UILauncher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowJobIssueDetectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowJobIssueDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowJobIssueDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowJobIssueDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowJobIssueDetectedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowJobIssueDetectedEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowJobIssueDetectedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobIssueDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowJobIssueDetectedEventArgs};

    // ----- PrintWorkflowJobNotificationEventArgs class --------------------

    static PyObject* _new_PrintWorkflowJobNotificationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowJobNotificationEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowJobNotificationEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobNotificationEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobNotificationEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobNotificationEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobNotificationEventArgs_get_PrinterJob(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobNotificationEventArgs", L"PrinterJob");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrinterJob();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowJobNotificationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowJobNotificationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowJobNotificationEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowJobNotificationEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowJobNotificationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowJobNotificationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowJobNotificationEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowJobNotificationEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "printer_job", reinterpret_cast<getter>(PrintWorkflowJobNotificationEventArgs_get_PrinterJob), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowJobNotificationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowJobNotificationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowJobNotificationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowJobNotificationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowJobNotificationEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowJobNotificationEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowJobNotificationEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowJobNotificationEventArgs};

    // ----- PrintWorkflowJobStartingEventArgs class --------------------

    static PyObject* _new_PrintWorkflowJobStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowJobStartingEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowJobStartingEventArgs_DisableIppCompressionForJob(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobStartingEventArgs", L"DisableIppCompressionForJob", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.DisableIppCompressionForJob();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobStartingEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobStartingEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobStartingEventArgs_SetSkipSystemRendering(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobStartingEventArgs", L"SetSkipSystemRendering", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.SetSkipSystemRendering();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobStartingEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobStartingEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobStartingEventArgs_get_Printer(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobStartingEventArgs", L"Printer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Printer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobStartingEventArgs_get_SkipSystemFaxUI(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobStartingEventArgs", L"SkipSystemFaxUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SkipSystemFaxUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintWorkflowJobStartingEventArgs_put_SkipSystemFaxUI(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobStartingEventArgs", L"SkipSystemFaxUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.SkipSystemFaxUI(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintWorkflowJobStartingEventArgs_get_IsIppCompressionEnabled(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobStartingEventArgs", L"IsIppCompressionEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsIppCompressionEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowJobStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowJobStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowJobStartingEventArgs[] = {
        { "disable_ipp_compression_for_job", reinterpret_cast<PyCFunction>(PrintWorkflowJobStartingEventArgs_DisableIppCompressionForJob), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowJobStartingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_skip_system_rendering", reinterpret_cast<PyCFunction>(PrintWorkflowJobStartingEventArgs_SetSkipSystemRendering), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowJobStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowJobStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowJobStartingEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowJobStartingEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "printer", reinterpret_cast<getter>(PrintWorkflowJobStartingEventArgs_get_Printer), nullptr, nullptr, nullptr },
        { "skip_system_fax_ui", reinterpret_cast<getter>(PrintWorkflowJobStartingEventArgs_get_SkipSystemFaxUI), reinterpret_cast<setter>(PrintWorkflowJobStartingEventArgs_put_SkipSystemFaxUI), nullptr, nullptr },
        { "is_ipp_compression_enabled", reinterpret_cast<getter>(PrintWorkflowJobStartingEventArgs_get_IsIppCompressionEnabled), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowJobStartingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowJobStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowJobStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowJobStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowJobStartingEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowJobStartingEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowJobStartingEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowJobStartingEventArgs};

    // ----- PrintWorkflowJobTriggerDetails class --------------------

    static PyObject* _new_PrintWorkflowJobTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowJobTriggerDetails(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowJobTriggerDetails_get_PrintWorkflowJobSession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobTriggerDetails", L"PrintWorkflowJobSession");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrintWorkflowJobSession();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowJobTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowJobTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowJobTriggerDetails[] = {
        { "_assign_array_", _assign_array_PrintWorkflowJobTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowJobTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowJobTriggerDetails[] = {
        { "print_workflow_job_session", reinterpret_cast<getter>(PrintWorkflowJobTriggerDetails_get_PrintWorkflowJobSession), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowJobTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowJobTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowJobTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowJobTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowJobTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowJobTriggerDetails = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowJobTriggerDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowJobTriggerDetails};

    // ----- PrintWorkflowJobUISession class --------------------

    static PyObject* _new_PrintWorkflowJobUISession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowJobUISession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowJobUISession_Start(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobUISession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobUISession_get_Status(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobUISession", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobUISession_add_JobNotification(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobUISession", L"JobNotification");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobNotificationEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JobNotification(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobUISession_remove_JobNotification(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobUISession", L"JobNotification");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.JobNotification(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobUISession_add_PdlDataAvailable(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobUISession", L"PdlDataAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PdlDataAvailable(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobUISession_remove_PdlDataAvailable(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobUISession", L"PdlDataAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PdlDataAvailable(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobUISession_add_VirtualPrinterUIDataAvailable(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobUISession", L"VirtualPrinterUIDataAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VirtualPrinterUIDataAvailable(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowJobUISession_remove_VirtualPrinterUIDataAvailable(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowJobUISession", L"VirtualPrinterUIDataAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VirtualPrinterUIDataAvailable(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowJobUISession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowJobUISession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowJobUISession[] = {
        { "start", reinterpret_cast<PyCFunction>(PrintWorkflowJobUISession_Start), METH_VARARGS, nullptr },
        { "add_job_notification", reinterpret_cast<PyCFunction>(PrintWorkflowJobUISession_add_JobNotification), METH_O, nullptr },
        { "remove_job_notification", reinterpret_cast<PyCFunction>(PrintWorkflowJobUISession_remove_JobNotification), METH_O, nullptr },
        { "add_pdl_data_available", reinterpret_cast<PyCFunction>(PrintWorkflowJobUISession_add_PdlDataAvailable), METH_O, nullptr },
        { "remove_pdl_data_available", reinterpret_cast<PyCFunction>(PrintWorkflowJobUISession_remove_PdlDataAvailable), METH_O, nullptr },
        { "add_virtual_printer_ui_data_available", reinterpret_cast<PyCFunction>(PrintWorkflowJobUISession_add_VirtualPrinterUIDataAvailable), METH_O, nullptr },
        { "remove_virtual_printer_ui_data_available", reinterpret_cast<PyCFunction>(PrintWorkflowJobUISession_remove_VirtualPrinterUIDataAvailable), METH_O, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowJobUISession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowJobUISession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowJobUISession[] = {
        { "status", reinterpret_cast<getter>(PrintWorkflowJobUISession_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowJobUISession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowJobUISession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowJobUISession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowJobUISession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowJobUISession) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowJobUISession = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowJobUISession",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowJobUISession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowJobUISession};

    // ----- PrintWorkflowObjectModelSourceFileContent class --------------------

    static PyObject* _new_PrintWorkflowObjectModelSourceFileContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelSourceFileContent instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PrintWorkflowObjectModelSourceFileContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelSourceFileContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PrintWorkflowObjectModelSourceFileContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelSourceFileContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowObjectModelSourceFileContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelSourceFileContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowObjectModelSourceFileContent[] = {
        { "_assign_array_", _assign_array_PrintWorkflowObjectModelSourceFileContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowObjectModelSourceFileContent), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowObjectModelSourceFileContent[] = {
        { }};

    static PyType_Slot _type_slots_PrintWorkflowObjectModelSourceFileContent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowObjectModelSourceFileContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowObjectModelSourceFileContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowObjectModelSourceFileContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowObjectModelSourceFileContent) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowObjectModelSourceFileContent = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowObjectModelSourceFileContent",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelSourceFileContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowObjectModelSourceFileContent};

    // ----- PrintWorkflowObjectModelTargetPackage class --------------------

    static PyObject* _new_PrintWorkflowObjectModelTargetPackage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelTargetPackage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelTargetPackage>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowObjectModelTargetPackage(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelTargetPackage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PrintWorkflowObjectModelTargetPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelTargetPackage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowObjectModelTargetPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelTargetPackage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowObjectModelTargetPackage[] = {
        { "_assign_array_", _assign_array_PrintWorkflowObjectModelTargetPackage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowObjectModelTargetPackage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowObjectModelTargetPackage[] = {
        { }};

    static PyType_Slot _type_slots_PrintWorkflowObjectModelTargetPackage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowObjectModelTargetPackage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowObjectModelTargetPackage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowObjectModelTargetPackage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowObjectModelTargetPackage) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowObjectModelTargetPackage = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowObjectModelTargetPackage",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelTargetPackage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowObjectModelTargetPackage};

    // ----- PrintWorkflowPdlConverter class --------------------

    static PyObject* _new_PrintWorkflowPdlConverter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConverter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConverter>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowPdlConverter(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowPdlConverter_ConvertPdlAsync(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlConverter", L"ConvertPdlAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTicket::WorkflowPrintTicket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertPdlAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlConverter", L"ConvertPdlAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTicket::WorkflowPrintTicket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PdlConversionHostBasedProcessingOperations>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertPdlAsync(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowPdlConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowPdlConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowPdlConverter[] = {
        { "convert_pdl_async", reinterpret_cast<PyCFunction>(PrintWorkflowPdlConverter_ConvertPdlAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowPdlConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowPdlConverter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowPdlConverter[] = {
        { }};

    static PyType_Slot _type_slots_PrintWorkflowPdlConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowPdlConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowPdlConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowPdlConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowPdlConverter) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowPdlConverter = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowPdlConverter",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowPdlConverter};

    // ----- PrintWorkflowPdlDataAvailableEventArgs class --------------------

    static PyObject* _new_PrintWorkflowPdlDataAvailableEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowPdlDataAvailableEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowPdlDataAvailableEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlDataAvailableEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlDataAvailableEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlDataAvailableEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlDataAvailableEventArgs_get_PrinterJob(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlDataAvailableEventArgs", L"PrinterJob");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrinterJob();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlDataAvailableEventArgs_get_SourceContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlDataAvailableEventArgs", L"SourceContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowPdlDataAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowPdlDataAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowPdlDataAvailableEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowPdlDataAvailableEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowPdlDataAvailableEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowPdlDataAvailableEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowPdlDataAvailableEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowPdlDataAvailableEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "printer_job", reinterpret_cast<getter>(PrintWorkflowPdlDataAvailableEventArgs_get_PrinterJob), nullptr, nullptr, nullptr },
        { "source_content", reinterpret_cast<getter>(PrintWorkflowPdlDataAvailableEventArgs_get_SourceContent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowPdlDataAvailableEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowPdlDataAvailableEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowPdlDataAvailableEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowPdlDataAvailableEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowPdlDataAvailableEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowPdlDataAvailableEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowPdlDataAvailableEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlDataAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowPdlDataAvailableEventArgs};

    // ----- PrintWorkflowPdlModificationRequestedEventArgs class --------------------

    static PyObject* _new_PrintWorkflowPdlModificationRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowPdlModificationRequestedEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_CreateJobOnPrinter(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"CreateJobOnPrinter", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateJobOnPrinter(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_CreateJobOnPrinterWithAttributes(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"CreateJobOnPrinterWithAttributes", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Devices::Printers::IppAttributeValue>>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateJobOnPrinterWithAttributes(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"CreateJobOnPrinterWithAttributes", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Devices::Printers::IppAttributeValue>>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Devices::Printers::IppAttributeValue>>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowAttributesMergePolicy>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowAttributesMergePolicy>(args, 4);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateJobOnPrinterWithAttributes(param0, param1, param2, param3, param4);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_CreateJobOnPrinterWithAttributesBuffer(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"CreateJobOnPrinterWithAttributesBuffer", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateJobOnPrinterWithAttributesBuffer(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"CreateJobOnPrinterWithAttributesBuffer", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowAttributesMergePolicy>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowAttributesMergePolicy>(args, 4);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateJobOnPrinterWithAttributesBuffer(param0, param1, param2, param3, param4);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_GetPdlConverter(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"GetPdlConverter", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConversionType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPdlConverter(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_get_PrinterJob(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"PrinterJob");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrinterJob();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_get_SourceContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"SourceContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlModificationRequestedEventArgs_get_UILauncher(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlModificationRequestedEventArgs", L"UILauncher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UILauncher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowPdlModificationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowPdlModificationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowPdlModificationRequestedEventArgs[] = {
        { "create_job_on_printer", reinterpret_cast<PyCFunction>(PrintWorkflowPdlModificationRequestedEventArgs_CreateJobOnPrinter), METH_VARARGS, nullptr },
        { "create_job_on_printer_with_attributes", reinterpret_cast<PyCFunction>(PrintWorkflowPdlModificationRequestedEventArgs_CreateJobOnPrinterWithAttributes), METH_VARARGS, nullptr },
        { "create_job_on_printer_with_attributes_buffer", reinterpret_cast<PyCFunction>(PrintWorkflowPdlModificationRequestedEventArgs_CreateJobOnPrinterWithAttributesBuffer), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowPdlModificationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_pdl_converter", reinterpret_cast<PyCFunction>(PrintWorkflowPdlModificationRequestedEventArgs_GetPdlConverter), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowPdlModificationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowPdlModificationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowPdlModificationRequestedEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowPdlModificationRequestedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "printer_job", reinterpret_cast<getter>(PrintWorkflowPdlModificationRequestedEventArgs_get_PrinterJob), nullptr, nullptr, nullptr },
        { "source_content", reinterpret_cast<getter>(PrintWorkflowPdlModificationRequestedEventArgs_get_SourceContent), nullptr, nullptr, nullptr },
        { "ui_launcher", reinterpret_cast<getter>(PrintWorkflowPdlModificationRequestedEventArgs_get_UILauncher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowPdlModificationRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowPdlModificationRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowPdlModificationRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowPdlModificationRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowPdlModificationRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowPdlModificationRequestedEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowPdlModificationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlModificationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowPdlModificationRequestedEventArgs};

    // ----- PrintWorkflowPdlSourceContent class --------------------

    static PyObject* _new_PrintWorkflowPdlSourceContent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowPdlSourceContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowPdlSourceContent_GetContentFileAsync(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlSourceContent", L"GetContentFileAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetContentFileAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlSourceContent_GetInputStream(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlSourceContent", L"GetInputStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetInputStream();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlSourceContent_get_ContentType(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlSourceContent", L"ContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowPdlSourceContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowPdlSourceContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowPdlSourceContent[] = {
        { "get_content_file_async", reinterpret_cast<PyCFunction>(PrintWorkflowPdlSourceContent_GetContentFileAsync), METH_VARARGS, nullptr },
        { "get_input_stream", reinterpret_cast<PyCFunction>(PrintWorkflowPdlSourceContent_GetInputStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowPdlSourceContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowPdlSourceContent), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowPdlSourceContent[] = {
        { "content_type", reinterpret_cast<getter>(PrintWorkflowPdlSourceContent_get_ContentType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowPdlSourceContent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowPdlSourceContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowPdlSourceContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowPdlSourceContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowPdlSourceContent) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowPdlSourceContent = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowPdlSourceContent",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlSourceContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowPdlSourceContent};

    // ----- PrintWorkflowPdlTargetStream class --------------------

    static PyObject* _new_PrintWorkflowPdlTargetStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlTargetStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlTargetStream>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowPdlTargetStream(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlTargetStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowPdlTargetStream_CompleteStreamSubmission(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlTargetStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlTargetStream", L"CompleteStreamSubmission", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedStatus>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.CompleteStreamSubmission(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPdlTargetStream_GetOutputStream(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlTargetStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPdlTargetStream", L"GetOutputStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetOutputStream();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowPdlTargetStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlTargetStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowPdlTargetStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlTargetStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowPdlTargetStream[] = {
        { "complete_stream_submission", reinterpret_cast<PyCFunction>(PrintWorkflowPdlTargetStream_CompleteStreamSubmission), METH_VARARGS, nullptr },
        { "get_output_stream", reinterpret_cast<PyCFunction>(PrintWorkflowPdlTargetStream_GetOutputStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowPdlTargetStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowPdlTargetStream), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowPdlTargetStream[] = {
        { }};

    static PyType_Slot _type_slots_PrintWorkflowPdlTargetStream[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowPdlTargetStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowPdlTargetStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowPdlTargetStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowPdlTargetStream) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowPdlTargetStream = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowPdlTargetStream",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlTargetStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowPdlTargetStream};

    // ----- PrintWorkflowPrinterJob class --------------------

    static PyObject* _new_PrintWorkflowPrinterJob(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowPrinterJob(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowPrinterJob_ConvertPrintTicketToJobAttributes(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"ConvertPrintTicketToJobAttributes", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTicket::WorkflowPrintTicket>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertPrintTicketToJobAttributes(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPrinterJob_GetJobAttributes(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"GetJobAttributes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetJobAttributes(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPrinterJob_GetJobAttributesAsBuffer(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"GetJobAttributesAsBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetJobAttributesAsBuffer(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPrinterJob_GetJobPrintTicket(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"GetJobPrintTicket", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetJobPrintTicket();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPrinterJob_GetJobStatus(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"GetJobStatus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetJobStatus();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPrinterJob_SetJobAttributes(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"SetJobAttributes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Devices::Printers::IppAttributeValue>>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetJobAttributes(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPrinterJob_SetJobAttributesFromBuffer(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"SetJobAttributesFromBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetJobAttributesFromBuffer(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPrinterJob_get_JobId(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"JobId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.JobId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowPrinterJob_get_Printer(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowPrinterJob", L"Printer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Printer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowPrinterJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowPrinterJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowPrinterJob[] = {
        { "convert_print_ticket_to_job_attributes", reinterpret_cast<PyCFunction>(PrintWorkflowPrinterJob_ConvertPrintTicketToJobAttributes), METH_VARARGS, nullptr },
        { "get_job_attributes", reinterpret_cast<PyCFunction>(PrintWorkflowPrinterJob_GetJobAttributes), METH_VARARGS, nullptr },
        { "get_job_attributes_as_buffer", reinterpret_cast<PyCFunction>(PrintWorkflowPrinterJob_GetJobAttributesAsBuffer), METH_VARARGS, nullptr },
        { "get_job_print_ticket", reinterpret_cast<PyCFunction>(PrintWorkflowPrinterJob_GetJobPrintTicket), METH_VARARGS, nullptr },
        { "get_job_status", reinterpret_cast<PyCFunction>(PrintWorkflowPrinterJob_GetJobStatus), METH_VARARGS, nullptr },
        { "set_job_attributes", reinterpret_cast<PyCFunction>(PrintWorkflowPrinterJob_SetJobAttributes), METH_VARARGS, nullptr },
        { "set_job_attributes_from_buffer", reinterpret_cast<PyCFunction>(PrintWorkflowPrinterJob_SetJobAttributesFromBuffer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowPrinterJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowPrinterJob), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowPrinterJob[] = {
        { "job_id", reinterpret_cast<getter>(PrintWorkflowPrinterJob_get_JobId), nullptr, nullptr, nullptr },
        { "printer", reinterpret_cast<getter>(PrintWorkflowPrinterJob_get_Printer), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowPrinterJob[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowPrinterJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowPrinterJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowPrinterJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowPrinterJob) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowPrinterJob = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowPrinterJob",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowPrinterJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowPrinterJob};

    // ----- PrintWorkflowSourceContent class --------------------

    static PyObject* _new_PrintWorkflowSourceContent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowSourceContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowSourceContent_GetJobPrintTicketAsync(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSourceContent", L"GetJobPrintTicketAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetJobPrintTicketAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowSourceContent_GetSourceSpoolDataAsStreamContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSourceContent", L"GetSourceSpoolDataAsStreamContent", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSourceSpoolDataAsStreamContent();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowSourceContent_GetSourceSpoolDataAsXpsObjectModel(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSourceContent", L"GetSourceSpoolDataAsXpsObjectModel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSourceSpoolDataAsXpsObjectModel();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowSourceContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowSourceContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowSourceContent[] = {
        { "get_job_print_ticket_async", reinterpret_cast<PyCFunction>(PrintWorkflowSourceContent_GetJobPrintTicketAsync), METH_VARARGS, nullptr },
        { "get_source_spool_data_as_stream_content", reinterpret_cast<PyCFunction>(PrintWorkflowSourceContent_GetSourceSpoolDataAsStreamContent), METH_VARARGS, nullptr },
        { "get_source_spool_data_as_xps_object_model", reinterpret_cast<PyCFunction>(PrintWorkflowSourceContent_GetSourceSpoolDataAsXpsObjectModel), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowSourceContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowSourceContent), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowSourceContent[] = {
        { }};

    static PyType_Slot _type_slots_PrintWorkflowSourceContent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowSourceContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowSourceContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowSourceContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowSourceContent) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowSourceContent = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowSourceContent",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSourceContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowSourceContent};

    // ----- PrintWorkflowSpoolStreamContent class --------------------

    static PyObject* _new_PrintWorkflowSpoolStreamContent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSpoolStreamContent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSpoolStreamContent>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowSpoolStreamContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSpoolStreamContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowSpoolStreamContent_GetInputStream(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSpoolStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSpoolStreamContent", L"GetInputStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetInputStream();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowSpoolStreamContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSpoolStreamContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowSpoolStreamContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSpoolStreamContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowSpoolStreamContent[] = {
        { "get_input_stream", reinterpret_cast<PyCFunction>(PrintWorkflowSpoolStreamContent_GetInputStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowSpoolStreamContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowSpoolStreamContent), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowSpoolStreamContent[] = {
        { }};

    static PyType_Slot _type_slots_PrintWorkflowSpoolStreamContent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowSpoolStreamContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowSpoolStreamContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowSpoolStreamContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowSpoolStreamContent) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowSpoolStreamContent = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowSpoolStreamContent",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSpoolStreamContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowSpoolStreamContent};

    // ----- PrintWorkflowStreamTarget class --------------------

    static PyObject* _new_PrintWorkflowStreamTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowStreamTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowStreamTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowStreamTarget(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowStreamTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowStreamTarget_GetOutputStream(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowStreamTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowStreamTarget", L"GetOutputStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetOutputStream();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowStreamTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowStreamTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowStreamTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowStreamTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowStreamTarget[] = {
        { "get_output_stream", reinterpret_cast<PyCFunction>(PrintWorkflowStreamTarget_GetOutputStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowStreamTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowStreamTarget), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowStreamTarget[] = {
        { }};

    static PyType_Slot _type_slots_PrintWorkflowStreamTarget[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowStreamTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowStreamTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowStreamTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowStreamTarget) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowStreamTarget = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowStreamTarget",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowStreamTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowStreamTarget};

    // ----- PrintWorkflowSubmittedEventArgs class --------------------

    static PyObject* _new_PrintWorkflowSubmittedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowSubmittedEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowSubmittedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSubmittedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowSubmittedEventArgs_GetTarget(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSubmittedEventArgs", L"GetTarget", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTicket::WorkflowPrintTicket>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetTarget(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowSubmittedEventArgs_get_Operation(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSubmittedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowSubmittedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowSubmittedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowSubmittedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowSubmittedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_target", reinterpret_cast<PyCFunction>(PrintWorkflowSubmittedEventArgs_GetTarget), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowSubmittedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowSubmittedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowSubmittedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(PrintWorkflowSubmittedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowSubmittedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowSubmittedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowSubmittedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowSubmittedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowSubmittedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowSubmittedEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowSubmittedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowSubmittedEventArgs};

    // ----- PrintWorkflowSubmittedOperation class --------------------

    static PyObject* _new_PrintWorkflowSubmittedOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowSubmittedOperation(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowSubmittedOperation_Complete(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSubmittedOperation", L"Complete", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedStatus>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Complete(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowSubmittedOperation_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSubmittedOperation", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowSubmittedOperation_get_XpsContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowSubmittedOperation", L"XpsContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XpsContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowSubmittedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowSubmittedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowSubmittedOperation[] = {
        { "complete", reinterpret_cast<PyCFunction>(PrintWorkflowSubmittedOperation_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowSubmittedOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowSubmittedOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowSubmittedOperation[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowSubmittedOperation_get_Configuration), nullptr, nullptr, nullptr },
        { "xps_content", reinterpret_cast<getter>(PrintWorkflowSubmittedOperation_get_XpsContent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowSubmittedOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowSubmittedOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowSubmittedOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowSubmittedOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowSubmittedOperation) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowSubmittedOperation = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowSubmittedOperation",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowSubmittedOperation};

    // ----- PrintWorkflowTarget class --------------------

    static PyObject* _new_PrintWorkflowTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowTarget(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowTarget_get_TargetAsStream(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowTarget", L"TargetAsStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TargetAsStream();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowTarget_get_TargetAsXpsObjectModelPackage(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowTarget", L"TargetAsXpsObjectModelPackage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TargetAsXpsObjectModelPackage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowTarget[] = {
        { "_assign_array_", _assign_array_PrintWorkflowTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowTarget), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowTarget[] = {
        { "target_as_stream", reinterpret_cast<getter>(PrintWorkflowTarget_get_TargetAsStream), nullptr, nullptr, nullptr },
        { "target_as_xps_object_model_package", reinterpret_cast<getter>(PrintWorkflowTarget_get_TargetAsXpsObjectModelPackage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowTarget[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowTarget) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowTarget = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowTarget",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowTarget};

    // ----- PrintWorkflowTriggerDetails class --------------------

    static PyObject* _new_PrintWorkflowTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowTriggerDetails(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowTriggerDetails_get_PrintWorkflowSession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowTriggerDetails", L"PrintWorkflowSession");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrintWorkflowSession();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowTriggerDetails[] = {
        { "_assign_array_", _assign_array_PrintWorkflowTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowTriggerDetails[] = {
        { "print_workflow_session", reinterpret_cast<getter>(PrintWorkflowTriggerDetails_get_PrintWorkflowSession), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowTriggerDetails = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowTriggerDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowTriggerDetails};

    // ----- PrintWorkflowUIActivatedEventArgs class --------------------

    static PyObject* _new_PrintWorkflowUIActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowUIActivatedEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowUIActivatedEventArgs_get_Kind(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowUIActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowUIActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowUIActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowUIActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowUIActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowUIActivatedEventArgs_get_User(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowUIActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowUIActivatedEventArgs_get_PrintWorkflowSession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowUIActivatedEventArgs", L"PrintWorkflowSession");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrintWorkflowSession();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowUIActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowUIActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowUIActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_PrintWorkflowUIActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowUIActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowUIActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PrintWorkflowUIActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PrintWorkflowUIActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PrintWorkflowUIActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(PrintWorkflowUIActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "print_workflow_session", reinterpret_cast<getter>(PrintWorkflowUIActivatedEventArgs_get_PrintWorkflowSession), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowUIActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowUIActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowUIActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowUIActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowUIActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowUIActivatedEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowUIActivatedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUIActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowUIActivatedEventArgs};

    // ----- PrintWorkflowUILauncher class --------------------

    static PyObject* _new_PrintWorkflowUILauncher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowUILauncher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowUILauncher>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowUILauncher(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUILauncher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowUILauncher_IsUILaunchEnabled(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUILauncher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowUILauncher", L"IsUILaunchEnabled", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsUILaunchEnabled();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowUILauncher_LaunchAndCompleteUIAsync(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUILauncher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowUILauncher", L"LaunchAndCompleteUIAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.LaunchAndCompleteUIAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowUILauncher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowUILauncher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowUILauncher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowUILauncher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowUILauncher[] = {
        { "is_ui_launch_enabled", reinterpret_cast<PyCFunction>(PrintWorkflowUILauncher_IsUILaunchEnabled), METH_VARARGS, nullptr },
        { "launch_and_complete_ui_async", reinterpret_cast<PyCFunction>(PrintWorkflowUILauncher_LaunchAndCompleteUIAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowUILauncher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowUILauncher), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowUILauncher[] = {
        { }};

    static PyType_Slot _type_slots_PrintWorkflowUILauncher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowUILauncher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowUILauncher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowUILauncher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowUILauncher) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowUILauncher = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowUILauncher",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowUILauncher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowUILauncher};

    // ----- PrintWorkflowVirtualPrinterDataAvailableEventArgs class --------------------

    static PyObject* _new_PrintWorkflowVirtualPrinterDataAvailableEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowVirtualPrinterDataAvailableEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowVirtualPrinterDataAvailableEventArgs_CompleteJob(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterDataAvailableEventArgs", L"CompleteJob", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowSubmittedStatus>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.CompleteJob(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterDataAvailableEventArgs_GetJobPrintTicket(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterDataAvailableEventArgs", L"GetJobPrintTicket", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetJobPrintTicket();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterDataAvailableEventArgs_GetPdlConverter(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterDataAvailableEventArgs", L"GetPdlConverter", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowPdlConversionType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPdlConverter(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterDataAvailableEventArgs_GetTargetFileAsync(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterDataAvailableEventArgs", L"GetTargetFileAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetTargetFileAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterDataAvailableEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterDataAvailableEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterDataAvailableEventArgs_get_SourceContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterDataAvailableEventArgs", L"SourceContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterDataAvailableEventArgs_get_UILauncher(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterDataAvailableEventArgs", L"UILauncher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UILauncher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowVirtualPrinterDataAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowVirtualPrinterDataAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowVirtualPrinterDataAvailableEventArgs[] = {
        { "complete_job", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterDataAvailableEventArgs_CompleteJob), METH_VARARGS, nullptr },
        { "get_job_print_ticket", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterDataAvailableEventArgs_GetJobPrintTicket), METH_VARARGS, nullptr },
        { "get_pdl_converter", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterDataAvailableEventArgs_GetPdlConverter), METH_VARARGS, nullptr },
        { "get_target_file_async", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterDataAvailableEventArgs_GetTargetFileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowVirtualPrinterDataAvailableEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowVirtualPrinterDataAvailableEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowVirtualPrinterDataAvailableEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterDataAvailableEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "source_content", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterDataAvailableEventArgs_get_SourceContent), nullptr, nullptr, nullptr },
        { "ui_launcher", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterDataAvailableEventArgs_get_UILauncher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowVirtualPrinterDataAvailableEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowVirtualPrinterDataAvailableEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowVirtualPrinterDataAvailableEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowVirtualPrinterDataAvailableEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowVirtualPrinterDataAvailableEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowVirtualPrinterDataAvailableEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowVirtualPrinterDataAvailableEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowVirtualPrinterDataAvailableEventArgs};

    // ----- PrintWorkflowVirtualPrinterSession class --------------------

    static PyObject* _new_PrintWorkflowVirtualPrinterSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowVirtualPrinterSession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowVirtualPrinterSession_Start(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterSession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterSession_get_Printer(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterSession", L"Printer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Printer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterSession_get_Status(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterSession", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterSession_add_VirtualPrinterDataAvailable(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterSession", L"VirtualPrinterDataAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession, winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterDataAvailableEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VirtualPrinterDataAvailable(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterSession_remove_VirtualPrinterDataAvailable(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterSession", L"VirtualPrinterDataAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VirtualPrinterDataAvailable(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowVirtualPrinterSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowVirtualPrinterSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowVirtualPrinterSession[] = {
        { "start", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterSession_Start), METH_VARARGS, nullptr },
        { "add_virtual_printer_data_available", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterSession_add_VirtualPrinterDataAvailable), METH_O, nullptr },
        { "remove_virtual_printer_data_available", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterSession_remove_VirtualPrinterDataAvailable), METH_O, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowVirtualPrinterSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowVirtualPrinterSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowVirtualPrinterSession[] = {
        { "printer", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterSession_get_Printer), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterSession_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowVirtualPrinterSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowVirtualPrinterSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowVirtualPrinterSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowVirtualPrinterSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowVirtualPrinterSession) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowVirtualPrinterSession = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowVirtualPrinterSession",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowVirtualPrinterSession};

    // ----- PrintWorkflowVirtualPrinterTriggerDetails class --------------------

    static PyObject* _new_PrintWorkflowVirtualPrinterTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowVirtualPrinterTriggerDetails(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowVirtualPrinterTriggerDetails_get_VirtualPrinterSession(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterTriggerDetails", L"VirtualPrinterSession");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VirtualPrinterSession();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowVirtualPrinterTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowVirtualPrinterTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowVirtualPrinterTriggerDetails[] = {
        { "_assign_array_", _assign_array_PrintWorkflowVirtualPrinterTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowVirtualPrinterTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowVirtualPrinterTriggerDetails[] = {
        { "virtual_printer_session", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterTriggerDetails_get_VirtualPrinterSession), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowVirtualPrinterTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowVirtualPrinterTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowVirtualPrinterTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowVirtualPrinterTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowVirtualPrinterTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowVirtualPrinterTriggerDetails = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowVirtualPrinterTriggerDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowVirtualPrinterTriggerDetails};

    // ----- PrintWorkflowVirtualPrinterUIEventArgs class --------------------

    static PyObject* _new_PrintWorkflowVirtualPrinterUIEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowVirtualPrinterUIEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowVirtualPrinterUIEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterUIEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterUIEventArgs_GetJobPrintTicket(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterUIEventArgs", L"GetJobPrintTicket", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetJobPrintTicket();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterUIEventArgs_get_Configuration(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterUIEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterUIEventArgs_get_Printer(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterUIEventArgs", L"Printer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Printer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowVirtualPrinterUIEventArgs_get_SourceContent(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowVirtualPrinterUIEventArgs", L"SourceContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowVirtualPrinterUIEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowVirtualPrinterUIEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowVirtualPrinterUIEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterUIEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_job_print_ticket", reinterpret_cast<PyCFunction>(PrintWorkflowVirtualPrinterUIEventArgs_GetJobPrintTicket), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowVirtualPrinterUIEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowVirtualPrinterUIEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowVirtualPrinterUIEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterUIEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "printer", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterUIEventArgs_get_Printer), nullptr, nullptr, nullptr },
        { "source_content", reinterpret_cast<getter>(PrintWorkflowVirtualPrinterUIEventArgs_get_SourceContent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowVirtualPrinterUIEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowVirtualPrinterUIEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowVirtualPrinterUIEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowVirtualPrinterUIEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowVirtualPrinterUIEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowVirtualPrinterUIEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowVirtualPrinterUIEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowVirtualPrinterUIEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowVirtualPrinterUIEventArgs};

    // ----- PrintWorkflowXpsDataAvailableEventArgs class --------------------

    static PyObject* _new_PrintWorkflowXpsDataAvailableEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintWorkflowXpsDataAvailableEventArgs(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintWorkflowXpsDataAvailableEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowXpsDataAvailableEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintWorkflowXpsDataAvailableEventArgs_get_Operation(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.Workflow.PrintWorkflowXpsDataAvailableEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintWorkflowXpsDataAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintWorkflowXpsDataAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintWorkflowXpsDataAvailableEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintWorkflowXpsDataAvailableEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintWorkflowXpsDataAvailableEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintWorkflowXpsDataAvailableEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintWorkflowXpsDataAvailableEventArgs[] = {
        { "operation", reinterpret_cast<getter>(PrintWorkflowXpsDataAvailableEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintWorkflowXpsDataAvailableEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintWorkflowXpsDataAvailableEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintWorkflowXpsDataAvailableEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintWorkflowXpsDataAvailableEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintWorkflowXpsDataAvailableEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintWorkflowXpsDataAvailableEventArgs = {
        "winrt._winrt_windows_graphics_printing_workflow.PrintWorkflowXpsDataAvailableEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::Workflow::PrintWorkflowXpsDataAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintWorkflowXpsDataAvailableEventArgs};

    // ----- Windows.Graphics.Printing.Workflow Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Graphics.Printing.Workflow");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_graphics_printing_workflow",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Graphics::Printing::Workflow

PyMODINIT_FUNC PyInit__winrt_windows_graphics_printing_workflow(void) noexcept
{
    using namespace py::cpp::Windows::Graphics::Printing::Workflow;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowBackgroundSession_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowBackgroundSession, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowBackgroundSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowBackgroundSetupRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowBackgroundSetupRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowBackgroundSetupRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowConfiguration_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowConfiguration, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowForegroundSession_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowForegroundSession, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowForegroundSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowForegroundSetupRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowForegroundSetupRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowForegroundSetupRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowJobActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowJobActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowJobActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowJobBackgroundSession_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowJobBackgroundSession, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowJobBackgroundSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowJobIssueDetectedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowJobIssueDetectedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowJobIssueDetectedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowJobNotificationEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowJobNotificationEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowJobNotificationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowJobStartingEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowJobStartingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowJobStartingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowJobTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowJobTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowJobTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowJobUISession_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowJobUISession, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowJobUISession_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowObjectModelSourceFileContent_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowObjectModelSourceFileContent, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowObjectModelSourceFileContent_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowObjectModelTargetPackage_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowObjectModelTargetPackage, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowObjectModelTargetPackage_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowPdlConverter_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowPdlConverter, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowPdlConverter_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowPdlDataAvailableEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowPdlDataAvailableEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowPdlDataAvailableEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowPdlModificationRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowPdlModificationRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowPdlModificationRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowPdlSourceContent_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowPdlSourceContent, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowPdlSourceContent_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowPdlTargetStream_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowPdlTargetStream, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowPdlTargetStream_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowPrinterJob_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowPrinterJob, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowPrinterJob_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowSourceContent_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowSourceContent, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowSourceContent_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowSpoolStreamContent_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowSpoolStreamContent, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowSpoolStreamContent_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowStreamTarget_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowStreamTarget, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowStreamTarget_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowSubmittedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowSubmittedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowSubmittedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowSubmittedOperation_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowSubmittedOperation, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowSubmittedOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowTarget_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowTarget, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowTarget_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowUIActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowUIActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowUIActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowUILauncher_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowUILauncher, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowUILauncher_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowVirtualPrinterDataAvailableEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowVirtualPrinterDataAvailableEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowVirtualPrinterDataAvailableEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowVirtualPrinterSession_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowVirtualPrinterSession, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowVirtualPrinterSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowVirtualPrinterTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowVirtualPrinterTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowVirtualPrinterTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowVirtualPrinterUIEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowVirtualPrinterUIEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowVirtualPrinterUIEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintWorkflowXpsDataAvailableEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintWorkflowXpsDataAvailableEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintWorkflowXpsDataAvailableEventArgs_type)
    {
        return nullptr;
    }


    return module.detach();
}
