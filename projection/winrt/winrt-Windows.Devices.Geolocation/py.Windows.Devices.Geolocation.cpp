// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Devices.Geolocation.h"

namespace py::cpp::Windows::Devices::Geolocation
{
    // ----- CivicAddress class --------------------

    static PyObject* _new_CivicAddress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::CivicAddress>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::CivicAddress>::type_name);
        return nullptr;
    }

    static void _dealloc_CivicAddress(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CivicAddress_get_City(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.CivicAddress", L"City");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.City();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CivicAddress_get_Country(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.CivicAddress", L"Country");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Country();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CivicAddress_get_PostalCode(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.CivicAddress", L"PostalCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PostalCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CivicAddress_get_State(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.CivicAddress", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CivicAddress_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.CivicAddress", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CivicAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::CivicAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CivicAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::CivicAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CivicAddress[] = {
        { "_assign_array_", _assign_array_CivicAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CivicAddress), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CivicAddress[] = {
        { "city", reinterpret_cast<getter>(CivicAddress_get_City), nullptr, nullptr, nullptr },
        { "country", reinterpret_cast<getter>(CivicAddress_get_Country), nullptr, nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(CivicAddress_get_PostalCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(CivicAddress_get_State), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(CivicAddress_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CivicAddress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CivicAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CivicAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CivicAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CivicAddress) },
        { }};

    static PyType_Spec type_spec_CivicAddress = {
        "winrt._winrt_windows_devices_geolocation.CivicAddress",
        sizeof(py::wrapper::Windows::Devices::Geolocation::CivicAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CivicAddress};

    // ----- GeoboundingBox class --------------------

    static PyObject* _new_GeoboundingBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);

                winrt::Windows::Devices::Geolocation::GeoboundingBox instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);

                winrt::Windows::Devices::Geolocation::GeoboundingBox instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::Devices::Geolocation::GeoboundingBox instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeoboundingBox(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeoboundingBox_TryCompute(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"TryCompute", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_TryComputeWithAltitudeReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"TryCompute", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_TryComputeWithAltitudeReferenceAndSpatialReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"TryCompute", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_Center(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Center();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_MaxAltitude(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"MaxAltitude");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxAltitude();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_MinAltitude(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"MinAltitude");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinAltitude();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_NorthwestCorner(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"NorthwestCorner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NorthwestCorner();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_SoutheastCorner(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"SoutheastCorner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SoutheastCorner();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"AltitudeReferenceSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AltitudeReferenceSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"GeoshapeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeoshapeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeoboundingBox", L"SpatialReferenceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SpatialReferenceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeoboundingBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::GeoboundingBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeoboundingBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeoboundingBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeoboundingBox[] = {
        { "_assign_array_", _assign_array_GeoboundingBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeoboundingBox), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GeoboundingBox[] = {
        { "center", reinterpret_cast<getter>(GeoboundingBox_get_Center), nullptr, nullptr, nullptr },
        { "max_altitude", reinterpret_cast<getter>(GeoboundingBox_get_MaxAltitude), nullptr, nullptr, nullptr },
        { "min_altitude", reinterpret_cast<getter>(GeoboundingBox_get_MinAltitude), nullptr, nullptr, nullptr },
        { "northwest_corner", reinterpret_cast<getter>(GeoboundingBox_get_NorthwestCorner), nullptr, nullptr, nullptr },
        { "southeast_corner", reinterpret_cast<getter>(GeoboundingBox_get_SoutheastCorner), nullptr, nullptr, nullptr },
        { "altitude_reference_system", reinterpret_cast<getter>(GeoboundingBox_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(GeoboundingBox_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(GeoboundingBox_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GeoboundingBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeoboundingBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeoboundingBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeoboundingBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeoboundingBox) },
        { }};

    static PyType_Spec type_spec_GeoboundingBox = {
        "winrt._winrt_windows_devices_geolocation.GeoboundingBox",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeoboundingBox};

    static PyGetSetDef getset_GeoboundingBox_Static[] = {
        { }};

    static PyMethodDef methods_GeoboundingBox_Static[] = {
        { "try_compute", reinterpret_cast<PyCFunction>(GeoboundingBox_TryCompute), METH_VARARGS, nullptr },
        { "try_compute_with_altitude_reference", reinterpret_cast<PyCFunction>(GeoboundingBox_TryComputeWithAltitudeReference), METH_VARARGS, nullptr },
        { "try_compute_with_altitude_reference_and_spatial_reference", reinterpret_cast<PyCFunction>(GeoboundingBox_TryComputeWithAltitudeReferenceAndSpatialReference), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_GeoboundingBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeoboundingBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeoboundingBox_Static) },
        { }
    };

    static PyType_Spec type_spec_GeoboundingBox_Static = {
        "winrt._winrt_windows_devices_geolocation.GeoboundingBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GeoboundingBox_Static};

    // ----- Geocircle class --------------------

    static PyObject* _new_Geocircle(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::Devices::Geolocation::Geocircle instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);

                winrt::Windows::Devices::Geolocation::Geocircle instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::Devices::Geolocation::Geocircle instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Geocircle(py::wrapper::Windows::Devices::Geolocation::Geocircle* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geocircle_get_Center(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocircle", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Center();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocircle_get_Radius(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocircle", L"Radius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Radius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocircle_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocircle", L"AltitudeReferenceSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AltitudeReferenceSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocircle_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocircle", L"GeoshapeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeoshapeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocircle_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocircle", L"SpatialReferenceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SpatialReferenceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geocircle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::Geocircle>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geocircle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geocircle>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geocircle[] = {
        { "_assign_array_", _assign_array_Geocircle, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geocircle), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Geocircle[] = {
        { "center", reinterpret_cast<getter>(Geocircle_get_Center), nullptr, nullptr, nullptr },
        { "radius", reinterpret_cast<getter>(Geocircle_get_Radius), nullptr, nullptr, nullptr },
        { "altitude_reference_system", reinterpret_cast<getter>(Geocircle_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(Geocircle_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(Geocircle_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Geocircle[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geocircle) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geocircle) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geocircle) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geocircle) },
        { }};

    static PyType_Spec type_spec_Geocircle = {
        "winrt._winrt_windows_devices_geolocation.Geocircle",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geocircle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geocircle};

    // ----- Geocoordinate class --------------------

    static PyObject* _new_Geocoordinate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::type_name);
        return nullptr;
    }

    static void _dealloc_Geocoordinate(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geocoordinate_get_Accuracy(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"Accuracy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Accuracy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Altitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"Altitude");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Altitude();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_AltitudeAccuracy(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"AltitudeAccuracy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AltitudeAccuracy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Heading(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"Heading");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Heading();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Latitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"Latitude");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Latitude();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Longitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"Longitude");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Longitude();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Speed(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"Speed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Speed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Point(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"Point");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Point();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_PositionSource(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"PositionSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_SatelliteData(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"SatelliteData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SatelliteData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_PositionSourceTimestamp(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"PositionSourceTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionSourceTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_IsRemoteSource(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geocoordinate", L"IsRemoteSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRemoteSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geocoordinate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::Geocoordinate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geocoordinate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geocoordinate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geocoordinate[] = {
        { "_assign_array_", _assign_array_Geocoordinate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geocoordinate), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Geocoordinate[] = {
        { "accuracy", reinterpret_cast<getter>(Geocoordinate_get_Accuracy), nullptr, nullptr, nullptr },
        { "altitude", reinterpret_cast<getter>(Geocoordinate_get_Altitude), nullptr, nullptr, nullptr },
        { "altitude_accuracy", reinterpret_cast<getter>(Geocoordinate_get_AltitudeAccuracy), nullptr, nullptr, nullptr },
        { "heading", reinterpret_cast<getter>(Geocoordinate_get_Heading), nullptr, nullptr, nullptr },
        { "latitude", reinterpret_cast<getter>(Geocoordinate_get_Latitude), nullptr, nullptr, nullptr },
        { "longitude", reinterpret_cast<getter>(Geocoordinate_get_Longitude), nullptr, nullptr, nullptr },
        { "speed", reinterpret_cast<getter>(Geocoordinate_get_Speed), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(Geocoordinate_get_Timestamp), nullptr, nullptr, nullptr },
        { "point", reinterpret_cast<getter>(Geocoordinate_get_Point), nullptr, nullptr, nullptr },
        { "position_source", reinterpret_cast<getter>(Geocoordinate_get_PositionSource), nullptr, nullptr, nullptr },
        { "satellite_data", reinterpret_cast<getter>(Geocoordinate_get_SatelliteData), nullptr, nullptr, nullptr },
        { "position_source_timestamp", reinterpret_cast<getter>(Geocoordinate_get_PositionSourceTimestamp), nullptr, nullptr, nullptr },
        { "is_remote_source", reinterpret_cast<getter>(Geocoordinate_get_IsRemoteSource), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Geocoordinate[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geocoordinate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geocoordinate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geocoordinate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geocoordinate) },
        { }};

    static PyType_Spec type_spec_Geocoordinate = {
        "winrt._winrt_windows_devices_geolocation.Geocoordinate",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geocoordinate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geocoordinate};

    // ----- GeocoordinateSatelliteData class --------------------

    static PyObject* _new_GeocoordinateSatelliteData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::type_name);
        return nullptr;
    }

    static void _dealloc_GeocoordinateSatelliteData(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeocoordinateSatelliteData", L"HorizontalDilutionOfPrecision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalDilutionOfPrecision();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeocoordinateSatelliteData_get_PositionDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeocoordinateSatelliteData", L"PositionDilutionOfPrecision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionDilutionOfPrecision();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeocoordinateSatelliteData", L"VerticalDilutionOfPrecision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalDilutionOfPrecision();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeocoordinateSatelliteData_get_GeometricDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeocoordinateSatelliteData", L"GeometricDilutionOfPrecision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeometricDilutionOfPrecision();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeocoordinateSatelliteData_get_TimeDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeocoordinateSatelliteData", L"TimeDilutionOfPrecision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TimeDilutionOfPrecision();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeocoordinateSatelliteData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeocoordinateSatelliteData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeocoordinateSatelliteData[] = {
        { "_assign_array_", _assign_array_GeocoordinateSatelliteData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeocoordinateSatelliteData), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GeocoordinateSatelliteData[] = {
        { "horizontal_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision), nullptr, nullptr, nullptr },
        { "position_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_PositionDilutionOfPrecision), nullptr, nullptr, nullptr },
        { "vertical_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision), nullptr, nullptr, nullptr },
        { "geometric_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_GeometricDilutionOfPrecision), nullptr, nullptr, nullptr },
        { "time_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_TimeDilutionOfPrecision), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GeocoordinateSatelliteData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeocoordinateSatelliteData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeocoordinateSatelliteData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeocoordinateSatelliteData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeocoordinateSatelliteData) },
        { }};

    static PyType_Spec type_spec_GeocoordinateSatelliteData = {
        "winrt._winrt_windows_devices_geolocation.GeocoordinateSatelliteData",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeocoordinateSatelliteData};

    // ----- Geolocator class --------------------

    static PyObject* _new_Geolocator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Geolocation::Geolocator instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Geolocator(py::wrapper::Windows::Devices::Geolocation::Geolocator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geolocator_AllowFallbackToConsentlessPositions(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.Geolocator", L"AllowFallbackToConsentlessPositions", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.AllowFallbackToConsentlessPositions();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_GetGeopositionAsync(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.Geolocator", L"GetGeopositionAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetGeopositionAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_GetGeopositionAsyncWithAgeAndTimeout(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.Geolocator", L"GetGeopositionAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetGeopositionAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_GetGeopositionHistoryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.Geolocator", L"GetGeopositionHistoryAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_GetGeopositionHistoryWithDurationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.Geolocator", L"GetGeopositionHistoryAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.Geolocator", L"RequestAccessAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Geolocation::Geolocator::RequestAccessAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_get_ReportInterval(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"ReportInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReportInterval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_ReportInterval(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"ReportInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ReportInterval(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_MovementThreshold(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"MovementThreshold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MovementThreshold();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_MovementThreshold(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"MovementThreshold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.MovementThreshold(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_DesiredAccuracy(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"DesiredAccuracy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredAccuracy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_DesiredAccuracy(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"DesiredAccuracy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::PositionAccuracy>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredAccuracy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_LocationStatus(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"LocationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocationStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_get_DesiredAccuracyInMeters(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"DesiredAccuracyInMeters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredAccuracyInMeters();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_DesiredAccuracyInMeters(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"DesiredAccuracyInMeters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredAccuracyInMeters(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_DefaultGeoposition(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"DefaultGeoposition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_DefaultGeoposition(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"DefaultGeoposition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_IsDefaultGeopositionRecommended(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geolocator", L"IsDefaultGeopositionRecommended");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Geolocation::Geolocator::IsDefaultGeopositionRecommended();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_add_PositionChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Geolocation.Geolocator", L"PositionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_remove_PositionChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Geolocation.Geolocator", L"PositionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_add_StatusChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Geolocation.Geolocator", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_remove_StatusChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Geolocation.Geolocator", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geolocator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::Geolocator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geolocator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geolocator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geolocator[] = {
        { "allow_fallback_to_consentless_positions", reinterpret_cast<PyCFunction>(Geolocator_AllowFallbackToConsentlessPositions), METH_VARARGS, nullptr },
        { "get_geoposition_async", reinterpret_cast<PyCFunction>(Geolocator_GetGeopositionAsync), METH_VARARGS, nullptr },
        { "get_geoposition_async_with_age_and_timeout", reinterpret_cast<PyCFunction>(Geolocator_GetGeopositionAsyncWithAgeAndTimeout), METH_VARARGS, nullptr },
        { "add_position_changed", reinterpret_cast<PyCFunction>(Geolocator_add_PositionChanged), METH_O, nullptr },
        { "remove_position_changed", reinterpret_cast<PyCFunction>(Geolocator_remove_PositionChanged), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(Geolocator_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(Geolocator_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Geolocator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geolocator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Geolocator[] = {
        { "report_interval", reinterpret_cast<getter>(Geolocator_get_ReportInterval), reinterpret_cast<setter>(Geolocator_put_ReportInterval), nullptr, nullptr },
        { "movement_threshold", reinterpret_cast<getter>(Geolocator_get_MovementThreshold), reinterpret_cast<setter>(Geolocator_put_MovementThreshold), nullptr, nullptr },
        { "desired_accuracy", reinterpret_cast<getter>(Geolocator_get_DesiredAccuracy), reinterpret_cast<setter>(Geolocator_put_DesiredAccuracy), nullptr, nullptr },
        { "location_status", reinterpret_cast<getter>(Geolocator_get_LocationStatus), nullptr, nullptr, nullptr },
        { "desired_accuracy_in_meters", reinterpret_cast<getter>(Geolocator_get_DesiredAccuracyInMeters), reinterpret_cast<setter>(Geolocator_put_DesiredAccuracyInMeters), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Geolocator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geolocator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geolocator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geolocator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geolocator) },
        { }};

    static PyType_Spec type_spec_Geolocator = {
        "winrt._winrt_windows_devices_geolocation.Geolocator",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geolocator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geolocator};

    static PyGetSetDef getset_Geolocator_Static[] = {
        { "default_geoposition", reinterpret_cast<getter>(Geolocator_get_DefaultGeoposition), reinterpret_cast<setter>(Geolocator_put_DefaultGeoposition), nullptr, nullptr },
        { "is_default_geoposition_recommended", reinterpret_cast<getter>(Geolocator_get_IsDefaultGeopositionRecommended), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Geolocator_Static[] = {
        { "get_geoposition_history_async", reinterpret_cast<PyCFunction>(Geolocator_GetGeopositionHistoryAsync), METH_VARARGS, nullptr },
        { "get_geoposition_history_with_duration_async", reinterpret_cast<PyCFunction>(Geolocator_GetGeopositionHistoryWithDurationAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(Geolocator_RequestAccessAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Geolocator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Geolocator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Geolocator_Static) },
        { }
    };

    static PyType_Spec type_spec_Geolocator_Static = {
        "winrt._winrt_windows_devices_geolocation.Geolocator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Geolocator_Static};

    // ----- Geopath class --------------------

    static PyObject* _new_Geopath(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);

                winrt::Windows::Devices::Geolocation::Geopath instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);

                winrt::Windows::Devices::Geolocation::Geopath instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Devices::Geolocation::Geopath instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Geopath(py::wrapper::Windows::Devices::Geolocation::Geopath* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geopath_get_Positions(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geopath", L"Positions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Positions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopath_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geopath", L"AltitudeReferenceSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AltitudeReferenceSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopath_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geopath", L"GeoshapeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeoshapeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopath_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geopath", L"SpatialReferenceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SpatialReferenceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geopath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::Geopath>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geopath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geopath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geopath[] = {
        { "_assign_array_", _assign_array_Geopath, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geopath), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Geopath[] = {
        { "positions", reinterpret_cast<getter>(Geopath_get_Positions), nullptr, nullptr, nullptr },
        { "altitude_reference_system", reinterpret_cast<getter>(Geopath_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(Geopath_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(Geopath_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Geopath[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geopath) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geopath) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geopath) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geopath) },
        { }};

    static PyType_Spec type_spec_Geopath = {
        "winrt._winrt_windows_devices_geolocation.Geopath",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geopath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geopath};

    // ----- Geopoint class --------------------

    static PyObject* _new_Geopoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);

                winrt::Windows::Devices::Geolocation::Geopoint instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);

                winrt::Windows::Devices::Geolocation::Geopoint instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Devices::Geolocation::Geopoint instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Geopoint(py::wrapper::Windows::Devices::Geolocation::Geopoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geopoint_get_Position(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geopoint", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopoint_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geopoint", L"AltitudeReferenceSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AltitudeReferenceSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopoint_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geopoint", L"GeoshapeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeoshapeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopoint_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geopoint", L"SpatialReferenceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SpatialReferenceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geopoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::Geopoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geopoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geopoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geopoint[] = {
        { "_assign_array_", _assign_array_Geopoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geopoint), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Geopoint[] = {
        { "position", reinterpret_cast<getter>(Geopoint_get_Position), nullptr, nullptr, nullptr },
        { "altitude_reference_system", reinterpret_cast<getter>(Geopoint_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(Geopoint_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(Geopoint_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Geopoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geopoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geopoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geopoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geopoint) },
        { }};

    static PyType_Spec type_spec_Geopoint = {
        "winrt._winrt_windows_devices_geolocation.Geopoint",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geopoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geopoint};

    // ----- Geoposition class --------------------

    static PyObject* _new_Geoposition(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::Geoposition>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::Geoposition>::type_name);
        return nullptr;
    }

    static void _dealloc_Geoposition(py::wrapper::Windows::Devices::Geolocation::Geoposition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geoposition_get_CivicAddress(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geoposition", L"CivicAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CivicAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geoposition_get_Coordinate(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geoposition", L"Coordinate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Coordinate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geoposition_get_VenueData(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geoposition", L"VenueData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VenueData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geoposition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::Geoposition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geoposition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geoposition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geoposition[] = {
        { "_assign_array_", _assign_array_Geoposition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geoposition), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Geoposition[] = {
        { "civic_address", reinterpret_cast<getter>(Geoposition_get_CivicAddress), nullptr, nullptr, nullptr },
        { "coordinate", reinterpret_cast<getter>(Geoposition_get_Coordinate), nullptr, nullptr, nullptr },
        { "venue_data", reinterpret_cast<getter>(Geoposition_get_VenueData), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Geoposition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geoposition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geoposition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geoposition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geoposition) },
        { }};

    static PyType_Spec type_spec_Geoposition = {
        "winrt._winrt_windows_devices_geolocation.Geoposition",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geoposition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geoposition};

    // ----- Geovisit class --------------------

    static PyObject* _new_Geovisit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::Geovisit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::Geovisit>::type_name);
        return nullptr;
    }

    static void _dealloc_Geovisit(py::wrapper::Windows::Devices::Geolocation::Geovisit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geovisit_get_Position(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geovisit", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geovisit_get_StateChange(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geovisit", L"StateChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StateChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geovisit_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.Geovisit", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geovisit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::Geovisit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geovisit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geovisit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geovisit[] = {
        { "_assign_array_", _assign_array_Geovisit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geovisit), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Geovisit[] = {
        { "position", reinterpret_cast<getter>(Geovisit_get_Position), nullptr, nullptr, nullptr },
        { "state_change", reinterpret_cast<getter>(Geovisit_get_StateChange), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(Geovisit_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Geovisit[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geovisit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geovisit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geovisit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geovisit) },
        { }};

    static PyType_Spec type_spec_Geovisit = {
        "winrt._winrt_windows_devices_geolocation.Geovisit",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geovisit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geovisit};

    // ----- GeovisitMonitor class --------------------

    static PyObject* _new_GeovisitMonitor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Geolocation::GeovisitMonitor instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeovisitMonitor(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeovisitMonitor_GetLastReportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.GeovisitMonitor", L"GetLastReportAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Geolocation::GeovisitMonitor::GetLastReportAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_Start(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.GeovisitMonitor", L"Start", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Start(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_Stop(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.GeovisitMonitor", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_get_MonitoringScope(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeovisitMonitor", L"MonitoringScope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MonitoringScope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_add_VisitStateChanged(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Geolocation.GeovisitMonitor", L"VisitStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::GeovisitMonitor, winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VisitStateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_remove_VisitStateChanged(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Geolocation.GeovisitMonitor", L"VisitStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VisitStateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeovisitMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::GeovisitMonitor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeovisitMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitMonitor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitMonitor[] = {
        { "start", reinterpret_cast<PyCFunction>(GeovisitMonitor_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(GeovisitMonitor_Stop), METH_VARARGS, nullptr },
        { "add_visit_state_changed", reinterpret_cast<PyCFunction>(GeovisitMonitor_add_VisitStateChanged), METH_O, nullptr },
        { "remove_visit_state_changed", reinterpret_cast<PyCFunction>(GeovisitMonitor_remove_VisitStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GeovisitMonitor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeovisitMonitor), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GeovisitMonitor[] = {
        { "monitoring_scope", reinterpret_cast<getter>(GeovisitMonitor_get_MonitoringScope), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GeovisitMonitor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeovisitMonitor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeovisitMonitor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeovisitMonitor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeovisitMonitor) },
        { }};

    static PyType_Spec type_spec_GeovisitMonitor = {
        "winrt._winrt_windows_devices_geolocation.GeovisitMonitor",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitMonitor};

    static PyGetSetDef getset_GeovisitMonitor_Static[] = {
        { }};

    static PyMethodDef methods_GeovisitMonitor_Static[] = {
        { "get_last_report_async", reinterpret_cast<PyCFunction>(GeovisitMonitor_GetLastReportAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_GeovisitMonitor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeovisitMonitor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeovisitMonitor_Static) },
        { }
    };

    static PyType_Spec type_spec_GeovisitMonitor_Static = {
        "winrt._winrt_windows_devices_geolocation.GeovisitMonitor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GeovisitMonitor_Static};

    // ----- GeovisitStateChangedEventArgs class --------------------

    static PyObject* _new_GeovisitStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GeovisitStateChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeovisitStateChangedEventArgs_get_Visit(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.GeovisitStateChangedEventArgs", L"Visit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Visit();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeovisitStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeovisitStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_GeovisitStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeovisitStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GeovisitStateChangedEventArgs[] = {
        { "visit", reinterpret_cast<getter>(GeovisitStateChangedEventArgs_get_Visit), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GeovisitStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeovisitStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeovisitStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeovisitStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeovisitStateChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_GeovisitStateChangedEventArgs = {
        "winrt._winrt_windows_devices_geolocation.GeovisitStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitStateChangedEventArgs};

    // ----- GeovisitTriggerDetails class --------------------

    static PyObject* _new_GeovisitTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_GeovisitTriggerDetails(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeovisitTriggerDetails_ReadReports(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Geolocation.GeovisitTriggerDetails", L"ReadReports", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadReports();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeovisitTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeovisitTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitTriggerDetails[] = {
        { "read_reports", reinterpret_cast<PyCFunction>(GeovisitTriggerDetails_ReadReports), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GeovisitTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeovisitTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GeovisitTriggerDetails[] = {
        { }};

    static PyType_Slot _type_slots_GeovisitTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeovisitTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeovisitTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeovisitTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeovisitTriggerDetails) },
        { }};

    static PyType_Spec type_spec_GeovisitTriggerDetails = {
        "winrt._winrt_windows_devices_geolocation.GeovisitTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitTriggerDetails};

    // ----- PositionChangedEventArgs class --------------------

    static PyObject* _new_PositionChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PositionChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PositionChangedEventArgs_get_Position(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.PositionChangedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PositionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PositionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PositionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PositionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PositionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PositionChangedEventArgs[] = {
        { "position", reinterpret_cast<getter>(PositionChangedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PositionChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PositionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PositionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PositionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PositionChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_PositionChangedEventArgs = {
        "winrt._winrt_windows_devices_geolocation.PositionChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PositionChangedEventArgs};

    // ----- StatusChangedEventArgs class --------------------

    static PyObject* _new_StatusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_StatusChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StatusChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.StatusChangedEventArgs", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_StatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StatusChangedEventArgs[] = {
        { "status", reinterpret_cast<getter>(StatusChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StatusChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StatusChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_StatusChangedEventArgs = {
        "winrt._winrt_windows_devices_geolocation.StatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StatusChangedEventArgs};

    // ----- VenueData class --------------------

    static PyObject* _new_VenueData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::VenueData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::VenueData>::type_name);
        return nullptr;
    }

    static void _dealloc_VenueData(py::wrapper::Windows::Devices::Geolocation::VenueData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VenueData_get_Id(py::wrapper::Windows::Devices::Geolocation::VenueData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.VenueData", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VenueData_get_Level(py::wrapper::Windows::Devices::Geolocation::VenueData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.VenueData", L"Level");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Level();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VenueData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::VenueData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VenueData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::VenueData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VenueData[] = {
        { "_assign_array_", _assign_array_VenueData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VenueData), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VenueData[] = {
        { "id", reinterpret_cast<getter>(VenueData_get_Id), nullptr, nullptr, nullptr },
        { "level", reinterpret_cast<getter>(VenueData_get_Level), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_VenueData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VenueData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VenueData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VenueData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VenueData) },
        { }};

    static PyType_Spec type_spec_VenueData = {
        "winrt._winrt_windows_devices_geolocation.VenueData",
        sizeof(py::wrapper::Windows::Devices::Geolocation::VenueData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VenueData};

    // ----- IGeoshape interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IGeoshape(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Geolocation::IGeoshape>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Geolocation::IGeoshape>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IGeoshape(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGeoshape_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.IGeoshape", L"AltitudeReferenceSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AltitudeReferenceSystem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGeoshape_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.IGeoshape", L"GeoshapeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeoshapeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGeoshape_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Geolocation.IGeoshape", L"SpatialReferenceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SpatialReferenceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGeoshape[] = {
        { }};

    static PyGetSetDef _getset_IGeoshape[] = {
        { "altitude_reference_system", reinterpret_cast<getter>(IGeoshape_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(IGeoshape_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(IGeoshape_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IGeoshape[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IGeoshape) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGeoshape) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGeoshape) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGeoshape) },
        { }};

    static PyType_Spec type_spec_IGeoshape = {
        "winrt._winrt_windows_devices_geolocation._IGeoshape",
        sizeof(py::wrapper::Windows::Devices::Geolocation::IGeoshape),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IGeoshape};

    struct ImplementsIGeoshape : py::ImplementsInterfaceT<ImplementsIGeoshape, winrt::Windows::Devices::Geolocation::IGeoshape>
    {
        ImplementsIGeoshape() = delete;
        ImplementsIGeoshape(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGeoshape, winrt::Windows::Devices::Geolocation::IGeoshape>(py_obj, runtime_class)
        {
        }

        auto AltitudeReferenceSystem()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "altitude_reference_system")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GeoshapeType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "geoshape_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Geolocation::GeoshapeType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SpatialReferenceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "spatial_reference_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IGeoshape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::IGeoshape>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGeoshape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::IGeoshape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIGeoshape(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Devices::Geolocation::IGeoshape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGeoshape(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGeoshape>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGeoshape[] = {
        { "_assign_array_", _assign_array_IGeoshape, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGeoshape), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGeoshape), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGeoshape), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIGeoshape[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGeoshape) },
        { }};

    static PyType_Spec type_spec_ImplementsIGeoshape = {
        "winrt._winrt_windows_devices_geolocation.IGeoshape",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIGeoshape};

    // ----- BasicGeoposition struct --------------------

    winrt::Windows::Devices::Geolocation::BasicGeoposition BasicGeoposition_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 3)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Devices::Geolocation::BasicGeoposition result{};

        result.Latitude = py::convert_to<double>(tuple, 0);
        result.Longitude = py::convert_to<double>(tuple, 1);
        result.Altitude = py::convert_to<double>(tuple, 2);

        return result;
    }

    PyObject* _new_BasicGeoposition(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        double _Latitude{};
        double _Longitude{};
        double _Altitude{};

        static const char* kwlist[] = {"latitude", "longitude", "altitude", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ddd", const_cast<char**>(kwlist), &_Latitude, &_Longitude, &_Altitude))
        {
            return nullptr;
        }

        try
        {
            self->obj.Latitude = _Latitude;
            self->obj.Longitude = _Longitude;
            self->obj.Altitude = _Altitude;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BasicGeoposition(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BasicGeoposition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Geolocation::BasicGeoposition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_BasicGeoposition(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            double _Latitude{self->obj.Latitude};
            double _Longitude{self->obj.Longitude};
            double _Altitude{self->obj.Altitude};

            static const char* kwlist[] = {"latitude", "longitude", "altitude", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ddd", const_cast<char**>(kwlist), &_Latitude, &_Longitude, &_Altitude))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Latitude = _Latitude;
            copy.Longitude = _Longitude;
            copy.Altitude = _Altitude;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_BasicGeoposition(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle Latitude{convert(self->obj.Latitude)};
        if (!Latitude)
        {
            return nullptr;
        }

        py::pyobj_handle Longitude{convert(self->obj.Longitude)};
        if (!Longitude)
        {
            return nullptr;
        }

        py::pyobj_handle Altitude{convert(self->obj.Altitude)};
        if (!Altitude)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(3)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, Latitude.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Longitude.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, Altitude.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_BasicGeoposition[] = {
        { "_assign_array_", _assign_array_BasicGeoposition, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_BasicGeoposition)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_BasicGeoposition), METH_NOARGS, nullptr },
        { }};

    static PyObject* BasicGeoposition_get_Latitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Latitude);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BasicGeoposition_get_Longitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Longitude);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BasicGeoposition_get_Altitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Altitude);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_BasicGeoposition[] = {
        { "latitude", reinterpret_cast<getter>(BasicGeoposition_get_Latitude), nullptr, nullptr, nullptr },
        { "longitude", reinterpret_cast<getter>(BasicGeoposition_get_Longitude), nullptr, nullptr, nullptr },
        { "altitude", reinterpret_cast<getter>(BasicGeoposition_get_Altitude), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_BasicGeoposition(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_BasicGeoposition(PyObject* self) noexcept
    {
        py::pyobj_handle Latitude{PyObject_GetAttrString(self, "latitude")};
        if (!Latitude)
        {
            return nullptr;
        }

        py::pyobj_handle Longitude{PyObject_GetAttrString(self, "longitude")};
        if (!Longitude)
        {
            return nullptr;
        }

        py::pyobj_handle Altitude{PyObject_GetAttrString(self, "altitude")};
        if (!Altitude)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("BasicGeoposition(latitude=%R, longitude=%R, altitude=%R)", Latitude.get(), Longitude.get(), Altitude.get());
    }

    static PyType_Slot _type_slots_BasicGeoposition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BasicGeoposition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BasicGeoposition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BasicGeoposition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BasicGeoposition) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_BasicGeoposition) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_BasicGeoposition) },
        { }};

    static PyType_Spec type_spec_BasicGeoposition = {
        "winrt._winrt_windows_devices_geolocation.BasicGeoposition",
        sizeof(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BasicGeoposition};

    // ----- Windows.Devices.Geolocation Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.Geolocation");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_geolocation",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::Geolocation

PyMODINIT_FUNC PyInit__winrt_windows_devices_geolocation(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Geolocation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle CivicAddress_type{py::register_python_type(module.get(), &type_spec_CivicAddress, object_bases.get(), inspectable_meta_type)};
    if (!CivicAddress_type)
    {
        return nullptr;
    }

    py::pyobj_handle GeoboundingBox_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!GeoboundingBox_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeoboundingBox_Static{PyType_FromSpecWithBases(&type_spec_GeoboundingBox_Static, GeoboundingBox_Static_bases.get())};
    if (!type_GeoboundingBox_Static)
    {
        return nullptr;
    }

    py::pytype_handle GeoboundingBox_type{py::register_python_type(module.get(), &type_spec_GeoboundingBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeoboundingBox_Static.get()))};
    if (!GeoboundingBox_type)
    {
        return nullptr;
    }

    py::pytype_handle Geocircle_type{py::register_python_type(module.get(), &type_spec_Geocircle, object_bases.get(), inspectable_meta_type)};
    if (!Geocircle_type)
    {
        return nullptr;
    }

    py::pytype_handle Geocoordinate_type{py::register_python_type(module.get(), &type_spec_Geocoordinate, object_bases.get(), inspectable_meta_type)};
    if (!Geocoordinate_type)
    {
        return nullptr;
    }

    py::pytype_handle GeocoordinateSatelliteData_type{py::register_python_type(module.get(), &type_spec_GeocoordinateSatelliteData, object_bases.get(), inspectable_meta_type)};
    if (!GeocoordinateSatelliteData_type)
    {
        return nullptr;
    }

    py::pyobj_handle Geolocator_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!Geolocator_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Geolocator_Static{PyType_FromSpecWithBases(&type_spec_Geolocator_Static, Geolocator_Static_bases.get())};
    if (!type_Geolocator_Static)
    {
        return nullptr;
    }

    py::pytype_handle Geolocator_type{py::register_python_type(module.get(), &type_spec_Geolocator, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Geolocator_Static.get()))};
    if (!Geolocator_type)
    {
        return nullptr;
    }

    py::pytype_handle Geopath_type{py::register_python_type(module.get(), &type_spec_Geopath, object_bases.get(), inspectable_meta_type)};
    if (!Geopath_type)
    {
        return nullptr;
    }

    py::pytype_handle Geopoint_type{py::register_python_type(module.get(), &type_spec_Geopoint, object_bases.get(), inspectable_meta_type)};
    if (!Geopoint_type)
    {
        return nullptr;
    }

    py::pytype_handle Geoposition_type{py::register_python_type(module.get(), &type_spec_Geoposition, object_bases.get(), inspectable_meta_type)};
    if (!Geoposition_type)
    {
        return nullptr;
    }

    py::pytype_handle Geovisit_type{py::register_python_type(module.get(), &type_spec_Geovisit, object_bases.get(), inspectable_meta_type)};
    if (!Geovisit_type)
    {
        return nullptr;
    }

    py::pyobj_handle GeovisitMonitor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!GeovisitMonitor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeovisitMonitor_Static{PyType_FromSpecWithBases(&type_spec_GeovisitMonitor_Static, GeovisitMonitor_Static_bases.get())};
    if (!type_GeovisitMonitor_Static)
    {
        return nullptr;
    }

    py::pytype_handle GeovisitMonitor_type{py::register_python_type(module.get(), &type_spec_GeovisitMonitor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeovisitMonitor_Static.get()))};
    if (!GeovisitMonitor_type)
    {
        return nullptr;
    }

    py::pytype_handle GeovisitStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_GeovisitStateChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!GeovisitStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle GeovisitTriggerDetails_type{py::register_python_type(module.get(), &type_spec_GeovisitTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!GeovisitTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PositionChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PositionChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PositionChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle StatusChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_StatusChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!StatusChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle VenueData_type{py::register_python_type(module.get(), &type_spec_VenueData, object_bases.get(), inspectable_meta_type)};
    if (!VenueData_type)
    {
        return nullptr;
    }

    py::pytype_handle IGeoshape_type{py::register_python_type(module.get(), &type_spec_IGeoshape, object_bases.get(), nullptr)};
    if (!IGeoshape_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGeoshape_type{py::register_python_type(module.get(), &type_spec_ImplementsIGeoshape, nullptr, inspectable_meta_type)};
    if (!ImplementsIGeoshape_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGeoshape_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle BasicGeoposition_type{py::register_python_type(module.get(), &type_spec_BasicGeoposition, nullptr, nullptr)};
    if (!BasicGeoposition_type)
    {
        return nullptr;
    }

    py::pyobj_handle BasicGeoposition_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(BasicGeoposition_from_tuple),"winrt._winrt_windows_devices_geolocation.BasicGeoposition_from_tuple", nullptr)};
    if (!BasicGeoposition_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "BasicGeoposition_from_tuple", BasicGeoposition_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
