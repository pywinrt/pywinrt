// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Web.UI.Interop.h"

namespace py::cpp::Windows::Web::UI::Interop
{
    // ----- WebViewControl class --------------------

    static PyObject* _new_WebViewControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::Interop::WebViewControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::Interop::WebViewControl>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControl(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControl_AddInitializeScript(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"AddInitializeScript", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddInitializeScript(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_BuildLocalStreamUri(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"BuildLocalStreamUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BuildLocalStreamUri(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_CapturePreviewToStreamAsync(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"CapturePreviewToStreamAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CapturePreviewToStreamAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_CaptureSelectedContentToDataPackageAsync(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"CaptureSelectedContentToDataPackageAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CaptureSelectedContentToDataPackageAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_Close(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_GetDeferredPermissionRequestById(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"GetDeferredPermissionRequestById", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                winrt::Windows::Web::UI::WebViewControlDeferredPermissionRequest param1{nullptr};

                {
                    auto _gil = release_gil();
                    self->obj.GetDeferredPermissionRequestById(param0, param1);
                }

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_GoBack(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"GoBack", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.GoBack();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_GoForward(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"GoForward", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.GoForward();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_InvokeScriptAsync(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"InvokeScriptAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.InvokeScriptAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_MoveFocus(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"MoveFocus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::UI::Interop::WebViewControlMoveFocusReason>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.MoveFocus(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_Navigate(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Navigate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Navigate(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_NavigateToLocalStreamUri(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NavigateToLocalStreamUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::IUriToStreamResolver>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.NavigateToLocalStreamUri(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_NavigateToString(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NavigateToString", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.NavigateToString(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_NavigateWithHttpRequestMessage(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NavigateWithHttpRequestMessage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.NavigateWithHttpRequestMessage(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_Refresh(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Refresh", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Refresh();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_Stop(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControl_get_Scale(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControl_put_Scale(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Scale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControl_get_IsVisible(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControl_put_IsVisible(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControl_get_Bounds(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Bounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControl_put_Bounds(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Bounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            {
                auto _gil = release_gil();
                self->obj.Bounds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControl_get_Process(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Process");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Process();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_get_Source(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControl_put_Source(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControl_get_DefaultBackgroundColor(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"DefaultBackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DefaultBackgroundColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControl_put_DefaultBackgroundColor(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"DefaultBackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.DefaultBackgroundColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControl_get_CanGoBack(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"CanGoBack");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanGoBack();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_get_CanGoForward(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"CanGoForward");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanGoForward();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_get_ContainsFullScreenElement(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"ContainsFullScreenElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainsFullScreenElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_get_DeferredPermissionRequests(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"DeferredPermissionRequests");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeferredPermissionRequests();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_get_DocumentTitle(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"DocumentTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DocumentTitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_get_Settings(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControl", L"Settings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Settings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_ContainsFullScreenElementChanged(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"ContainsFullScreenElementChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainsFullScreenElementChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_ContainsFullScreenElementChanged(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"ContainsFullScreenElementChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContainsFullScreenElementChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_ContentLoading(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"ContentLoading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentLoading(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_ContentLoading(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"ContentLoading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContentLoading(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_DOMContentLoaded(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"DOMContentLoaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DOMContentLoaded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_DOMContentLoaded(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"DOMContentLoaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DOMContentLoaded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_FrameContentLoading(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"FrameContentLoading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameContentLoading(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_FrameContentLoading(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"FrameContentLoading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrameContentLoading(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_FrameDOMContentLoaded(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"FrameDOMContentLoaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameDOMContentLoaded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_FrameDOMContentLoaded(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"FrameDOMContentLoaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrameDOMContentLoaded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_FrameNavigationCompleted(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"FrameNavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameNavigationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_FrameNavigationCompleted(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"FrameNavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrameNavigationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_FrameNavigationStarting(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"FrameNavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameNavigationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_FrameNavigationStarting(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"FrameNavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrameNavigationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_LongRunningScriptDetected(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"LongRunningScriptDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LongRunningScriptDetected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_LongRunningScriptDetected(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"LongRunningScriptDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LongRunningScriptDetected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_NavigationCompleted(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NavigationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_NavigationCompleted(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NavigationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_NavigationStarting(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NavigationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_NavigationStarting(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NavigationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_NewWindowRequested(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NewWindowRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewWindowRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_NewWindowRequested(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"NewWindowRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NewWindowRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_PermissionRequested(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"PermissionRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PermissionRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_PermissionRequested(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"PermissionRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PermissionRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_ScriptNotify(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"ScriptNotify");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlScriptNotifyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScriptNotify(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_ScriptNotify(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"ScriptNotify");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScriptNotify(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_UnsafeContentWarningDisplaying(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"UnsafeContentWarningDisplaying");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnsafeContentWarningDisplaying(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_UnsafeContentWarningDisplaying(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"UnsafeContentWarningDisplaying");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnsafeContentWarningDisplaying(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_UnsupportedUriSchemeIdentified(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"UnsupportedUriSchemeIdentified");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnsupportedUriSchemeIdentified(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_UnsupportedUriSchemeIdentified(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"UnsupportedUriSchemeIdentified");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnsupportedUriSchemeIdentified(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_UnviewableContentIdentified(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"UnviewableContentIdentified");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnviewableContentIdentified(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_UnviewableContentIdentified(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"UnviewableContentIdentified");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnviewableContentIdentified(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_WebResourceRequested(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"WebResourceRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WebResourceRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_WebResourceRequested(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"WebResourceRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.WebResourceRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_AcceleratorKeyPressed(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"AcceleratorKeyPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::Interop::WebViewControl, winrt::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AcceleratorKeyPressed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_AcceleratorKeyPressed(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"AcceleratorKeyPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.AcceleratorKeyPressed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_MoveFocusRequested(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"MoveFocusRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::Interop::WebViewControl, winrt::Windows::Web::UI::Interop::WebViewControlMoveFocusRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoveFocusRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_MoveFocusRequested(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"MoveFocusRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MoveFocusRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_GotFocus(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"GotFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::Interop::WebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GotFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_GotFocus(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"GotFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.GotFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_add_LostFocus(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"LostFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::Interop::WebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LostFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControl_remove_LostFocus(py::wrapper::Windows::Web::UI::Interop::WebViewControl* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControl", L"LostFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LostFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::Interop::WebViewControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::Interop::WebViewControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControl[] = {
        { "add_initialize_script", reinterpret_cast<PyCFunction>(WebViewControl_AddInitializeScript), METH_VARARGS, nullptr },
        { "build_local_stream_uri", reinterpret_cast<PyCFunction>(WebViewControl_BuildLocalStreamUri), METH_VARARGS, nullptr },
        { "capture_preview_to_stream_async", reinterpret_cast<PyCFunction>(WebViewControl_CapturePreviewToStreamAsync), METH_VARARGS, nullptr },
        { "capture_selected_content_to_data_package_async", reinterpret_cast<PyCFunction>(WebViewControl_CaptureSelectedContentToDataPackageAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(WebViewControl_Close), METH_VARARGS, nullptr },
        { "get_deferred_permission_request_by_id", reinterpret_cast<PyCFunction>(WebViewControl_GetDeferredPermissionRequestById), METH_VARARGS, nullptr },
        { "go_back", reinterpret_cast<PyCFunction>(WebViewControl_GoBack), METH_VARARGS, nullptr },
        { "go_forward", reinterpret_cast<PyCFunction>(WebViewControl_GoForward), METH_VARARGS, nullptr },
        { "invoke_script_async", reinterpret_cast<PyCFunction>(WebViewControl_InvokeScriptAsync), METH_VARARGS, nullptr },
        { "move_focus", reinterpret_cast<PyCFunction>(WebViewControl_MoveFocus), METH_VARARGS, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(WebViewControl_Navigate), METH_VARARGS, nullptr },
        { "navigate_to_local_stream_uri", reinterpret_cast<PyCFunction>(WebViewControl_NavigateToLocalStreamUri), METH_VARARGS, nullptr },
        { "navigate_to_string", reinterpret_cast<PyCFunction>(WebViewControl_NavigateToString), METH_VARARGS, nullptr },
        { "navigate_with_http_request_message", reinterpret_cast<PyCFunction>(WebViewControl_NavigateWithHttpRequestMessage), METH_VARARGS, nullptr },
        { "refresh", reinterpret_cast<PyCFunction>(WebViewControl_Refresh), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(WebViewControl_Stop), METH_VARARGS, nullptr },
        { "add_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(WebViewControl_add_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "remove_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(WebViewControl_remove_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "add_content_loading", reinterpret_cast<PyCFunction>(WebViewControl_add_ContentLoading), METH_O, nullptr },
        { "remove_content_loading", reinterpret_cast<PyCFunction>(WebViewControl_remove_ContentLoading), METH_O, nullptr },
        { "add_dom_content_loaded", reinterpret_cast<PyCFunction>(WebViewControl_add_DOMContentLoaded), METH_O, nullptr },
        { "remove_dom_content_loaded", reinterpret_cast<PyCFunction>(WebViewControl_remove_DOMContentLoaded), METH_O, nullptr },
        { "add_frame_content_loading", reinterpret_cast<PyCFunction>(WebViewControl_add_FrameContentLoading), METH_O, nullptr },
        { "remove_frame_content_loading", reinterpret_cast<PyCFunction>(WebViewControl_remove_FrameContentLoading), METH_O, nullptr },
        { "add_frame_dom_content_loaded", reinterpret_cast<PyCFunction>(WebViewControl_add_FrameDOMContentLoaded), METH_O, nullptr },
        { "remove_frame_dom_content_loaded", reinterpret_cast<PyCFunction>(WebViewControl_remove_FrameDOMContentLoaded), METH_O, nullptr },
        { "add_frame_navigation_completed", reinterpret_cast<PyCFunction>(WebViewControl_add_FrameNavigationCompleted), METH_O, nullptr },
        { "remove_frame_navigation_completed", reinterpret_cast<PyCFunction>(WebViewControl_remove_FrameNavigationCompleted), METH_O, nullptr },
        { "add_frame_navigation_starting", reinterpret_cast<PyCFunction>(WebViewControl_add_FrameNavigationStarting), METH_O, nullptr },
        { "remove_frame_navigation_starting", reinterpret_cast<PyCFunction>(WebViewControl_remove_FrameNavigationStarting), METH_O, nullptr },
        { "add_long_running_script_detected", reinterpret_cast<PyCFunction>(WebViewControl_add_LongRunningScriptDetected), METH_O, nullptr },
        { "remove_long_running_script_detected", reinterpret_cast<PyCFunction>(WebViewControl_remove_LongRunningScriptDetected), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(WebViewControl_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(WebViewControl_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_starting", reinterpret_cast<PyCFunction>(WebViewControl_add_NavigationStarting), METH_O, nullptr },
        { "remove_navigation_starting", reinterpret_cast<PyCFunction>(WebViewControl_remove_NavigationStarting), METH_O, nullptr },
        { "add_new_window_requested", reinterpret_cast<PyCFunction>(WebViewControl_add_NewWindowRequested), METH_O, nullptr },
        { "remove_new_window_requested", reinterpret_cast<PyCFunction>(WebViewControl_remove_NewWindowRequested), METH_O, nullptr },
        { "add_permission_requested", reinterpret_cast<PyCFunction>(WebViewControl_add_PermissionRequested), METH_O, nullptr },
        { "remove_permission_requested", reinterpret_cast<PyCFunction>(WebViewControl_remove_PermissionRequested), METH_O, nullptr },
        { "add_script_notify", reinterpret_cast<PyCFunction>(WebViewControl_add_ScriptNotify), METH_O, nullptr },
        { "remove_script_notify", reinterpret_cast<PyCFunction>(WebViewControl_remove_ScriptNotify), METH_O, nullptr },
        { "add_unsafe_content_warning_displaying", reinterpret_cast<PyCFunction>(WebViewControl_add_UnsafeContentWarningDisplaying), METH_O, nullptr },
        { "remove_unsafe_content_warning_displaying", reinterpret_cast<PyCFunction>(WebViewControl_remove_UnsafeContentWarningDisplaying), METH_O, nullptr },
        { "add_unsupported_uri_scheme_identified", reinterpret_cast<PyCFunction>(WebViewControl_add_UnsupportedUriSchemeIdentified), METH_O, nullptr },
        { "remove_unsupported_uri_scheme_identified", reinterpret_cast<PyCFunction>(WebViewControl_remove_UnsupportedUriSchemeIdentified), METH_O, nullptr },
        { "add_unviewable_content_identified", reinterpret_cast<PyCFunction>(WebViewControl_add_UnviewableContentIdentified), METH_O, nullptr },
        { "remove_unviewable_content_identified", reinterpret_cast<PyCFunction>(WebViewControl_remove_UnviewableContentIdentified), METH_O, nullptr },
        { "add_web_resource_requested", reinterpret_cast<PyCFunction>(WebViewControl_add_WebResourceRequested), METH_O, nullptr },
        { "remove_web_resource_requested", reinterpret_cast<PyCFunction>(WebViewControl_remove_WebResourceRequested), METH_O, nullptr },
        { "add_accelerator_key_pressed", reinterpret_cast<PyCFunction>(WebViewControl_add_AcceleratorKeyPressed), METH_O, nullptr },
        { "remove_accelerator_key_pressed", reinterpret_cast<PyCFunction>(WebViewControl_remove_AcceleratorKeyPressed), METH_O, nullptr },
        { "add_move_focus_requested", reinterpret_cast<PyCFunction>(WebViewControl_add_MoveFocusRequested), METH_O, nullptr },
        { "remove_move_focus_requested", reinterpret_cast<PyCFunction>(WebViewControl_remove_MoveFocusRequested), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(WebViewControl_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(WebViewControl_remove_GotFocus), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(WebViewControl_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(WebViewControl_remove_LostFocus), METH_O, nullptr },
        { "_assign_array_", _assign_array_WebViewControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebViewControl[] = {
        { "scale", reinterpret_cast<getter>(WebViewControl_get_Scale), reinterpret_cast<setter>(WebViewControl_put_Scale), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(WebViewControl_get_IsVisible), reinterpret_cast<setter>(WebViewControl_put_IsVisible), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(WebViewControl_get_Bounds), reinterpret_cast<setter>(WebViewControl_put_Bounds), nullptr, nullptr },
        { "process", reinterpret_cast<getter>(WebViewControl_get_Process), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(WebViewControl_get_Source), reinterpret_cast<setter>(WebViewControl_put_Source), nullptr, nullptr },
        { "default_background_color", reinterpret_cast<getter>(WebViewControl_get_DefaultBackgroundColor), reinterpret_cast<setter>(WebViewControl_put_DefaultBackgroundColor), nullptr, nullptr },
        { "can_go_back", reinterpret_cast<getter>(WebViewControl_get_CanGoBack), nullptr, nullptr, nullptr },
        { "can_go_forward", reinterpret_cast<getter>(WebViewControl_get_CanGoForward), nullptr, nullptr, nullptr },
        { "contains_full_screen_element", reinterpret_cast<getter>(WebViewControl_get_ContainsFullScreenElement), nullptr, nullptr, nullptr },
        { "deferred_permission_requests", reinterpret_cast<getter>(WebViewControl_get_DeferredPermissionRequests), nullptr, nullptr, nullptr },
        { "document_title", reinterpret_cast<getter>(WebViewControl_get_DocumentTitle), nullptr, nullptr, nullptr },
        { "settings", reinterpret_cast<getter>(WebViewControl_get_Settings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebViewControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControl) },
        { }};

    static PyType_Spec type_spec_WebViewControl = {
        "winrt._winrt_windows_web_ui_interop.WebViewControl",
        sizeof(py::wrapper::Windows::Web::UI::Interop::WebViewControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControl};

    // ----- WebViewControlAcceleratorKeyPressedEventArgs class --------------------

    static PyObject* _new_WebViewControlAcceleratorKeyPressedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlAcceleratorKeyPressedEventArgs(py::wrapper::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlAcceleratorKeyPressedEventArgs_get_Handled(py::wrapper::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlAcceleratorKeyPressedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlAcceleratorKeyPressedEventArgs_put_Handled(py::wrapper::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlAcceleratorKeyPressedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlAcceleratorKeyPressedEventArgs_get_EventType(py::wrapper::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlAcceleratorKeyPressedEventArgs", L"EventType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EventType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlAcceleratorKeyPressedEventArgs_get_KeyStatus(py::wrapper::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlAcceleratorKeyPressedEventArgs", L"KeyStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlAcceleratorKeyPressedEventArgs_get_RoutingStage(py::wrapper::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlAcceleratorKeyPressedEventArgs", L"RoutingStage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoutingStage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlAcceleratorKeyPressedEventArgs_get_VirtualKey(py::wrapper::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlAcceleratorKeyPressedEventArgs", L"VirtualKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VirtualKey();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlAcceleratorKeyPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlAcceleratorKeyPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlAcceleratorKeyPressedEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlAcceleratorKeyPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlAcceleratorKeyPressedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebViewControlAcceleratorKeyPressedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(WebViewControlAcceleratorKeyPressedEventArgs_get_Handled), reinterpret_cast<setter>(WebViewControlAcceleratorKeyPressedEventArgs_put_Handled), nullptr, nullptr },
        { "event_type", reinterpret_cast<getter>(WebViewControlAcceleratorKeyPressedEventArgs_get_EventType), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(WebViewControlAcceleratorKeyPressedEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "routing_stage", reinterpret_cast<getter>(WebViewControlAcceleratorKeyPressedEventArgs_get_RoutingStage), nullptr, nullptr, nullptr },
        { "virtual_key", reinterpret_cast<getter>(WebViewControlAcceleratorKeyPressedEventArgs_get_VirtualKey), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebViewControlAcceleratorKeyPressedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlAcceleratorKeyPressedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlAcceleratorKeyPressedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlAcceleratorKeyPressedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlAcceleratorKeyPressedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebViewControlAcceleratorKeyPressedEventArgs = {
        "winrt._winrt_windows_web_ui_interop.WebViewControlAcceleratorKeyPressedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::Interop::WebViewControlAcceleratorKeyPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlAcceleratorKeyPressedEventArgs};

    // ----- WebViewControlMoveFocusRequestedEventArgs class --------------------

    static PyObject* _new_WebViewControlMoveFocusRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::UI::Interop::WebViewControlMoveFocusRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::UI::Interop::WebViewControlMoveFocusRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebViewControlMoveFocusRequestedEventArgs(py::wrapper::Windows::Web::UI::Interop::WebViewControlMoveFocusRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlMoveFocusRequestedEventArgs_get_Reason(py::wrapper::Windows::Web::UI::Interop::WebViewControlMoveFocusRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlMoveFocusRequestedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlMoveFocusRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::Interop::WebViewControlMoveFocusRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlMoveFocusRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::Interop::WebViewControlMoveFocusRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlMoveFocusRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_WebViewControlMoveFocusRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlMoveFocusRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebViewControlMoveFocusRequestedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(WebViewControlMoveFocusRequestedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebViewControlMoveFocusRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlMoveFocusRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlMoveFocusRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlMoveFocusRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlMoveFocusRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebViewControlMoveFocusRequestedEventArgs = {
        "winrt._winrt_windows_web_ui_interop.WebViewControlMoveFocusRequestedEventArgs",
        sizeof(py::wrapper::Windows::Web::UI::Interop::WebViewControlMoveFocusRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlMoveFocusRequestedEventArgs};

    // ----- WebViewControlProcess class --------------------

    static PyObject* _new_WebViewControlProcess(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::UI::Interop::WebViewControlProcessOptions>(args, 0);

                winrt::Windows::Web::UI::Interop::WebViewControlProcess instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::UI::Interop::WebViewControlProcess instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebViewControlProcess(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlProcess_CreateWebViewControlAsync(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControlProcess", L"CreateWebViewControlAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateWebViewControlAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlProcess_GetWebViewControls(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControlProcess", L"GetWebViewControls", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetWebViewControls();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlProcess_Terminate(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.UI.Interop.WebViewControlProcess", L"Terminate", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Terminate();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebViewControlProcess_get_EnterpriseId(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlProcess", L"EnterpriseId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EnterpriseId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlProcess_get_IsPrivateNetworkClientServerCapabilityEnabled(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlProcess", L"IsPrivateNetworkClientServerCapabilityEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPrivateNetworkClientServerCapabilityEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlProcess_get_ProcessId(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlProcess", L"ProcessId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProcessId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlProcess_add_ProcessExited(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControlProcess", L"ProcessExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::Interop::WebViewControlProcess, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProcessExited(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebViewControlProcess_remove_ProcessExited(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.UI.Interop.WebViewControlProcess", L"ProcessExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProcessExited(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebViewControlProcess(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::Interop::WebViewControlProcess>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlProcess(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::Interop::WebViewControlProcess>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlProcess[] = {
        { "create_web_view_control_async", reinterpret_cast<PyCFunction>(WebViewControlProcess_CreateWebViewControlAsync), METH_VARARGS, nullptr },
        { "get_web_view_controls", reinterpret_cast<PyCFunction>(WebViewControlProcess_GetWebViewControls), METH_VARARGS, nullptr },
        { "terminate", reinterpret_cast<PyCFunction>(WebViewControlProcess_Terminate), METH_VARARGS, nullptr },
        { "add_process_exited", reinterpret_cast<PyCFunction>(WebViewControlProcess_add_ProcessExited), METH_O, nullptr },
        { "remove_process_exited", reinterpret_cast<PyCFunction>(WebViewControlProcess_remove_ProcessExited), METH_O, nullptr },
        { "_assign_array_", _assign_array_WebViewControlProcess, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlProcess), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebViewControlProcess[] = {
        { "enterprise_id", reinterpret_cast<getter>(WebViewControlProcess_get_EnterpriseId), nullptr, nullptr, nullptr },
        { "is_private_network_client_server_capability_enabled", reinterpret_cast<getter>(WebViewControlProcess_get_IsPrivateNetworkClientServerCapabilityEnabled), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(WebViewControlProcess_get_ProcessId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebViewControlProcess[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlProcess) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlProcess) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlProcess) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlProcess) },
        { }};

    static PyType_Spec type_spec_WebViewControlProcess = {
        "winrt._winrt_windows_web_ui_interop.WebViewControlProcess",
        sizeof(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcess),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlProcess};

    // ----- WebViewControlProcessOptions class --------------------

    static PyObject* _new_WebViewControlProcessOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::UI::Interop::WebViewControlProcessOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebViewControlProcessOptions(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcessOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebViewControlProcessOptions_get_PrivateNetworkClientServerCapability(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcessOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlProcessOptions", L"PrivateNetworkClientServerCapability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrivateNetworkClientServerCapability();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlProcessOptions_put_PrivateNetworkClientServerCapability(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcessOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlProcessOptions", L"PrivateNetworkClientServerCapability");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::UI::Interop::WebViewControlProcessCapabilityState>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrivateNetworkClientServerCapability(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebViewControlProcessOptions_get_EnterpriseId(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcessOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlProcessOptions", L"EnterpriseId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EnterpriseId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebViewControlProcessOptions_put_EnterpriseId(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcessOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.UI.Interop.WebViewControlProcessOptions", L"EnterpriseId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.EnterpriseId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WebViewControlProcessOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::UI::Interop::WebViewControlProcessOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebViewControlProcessOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::UI::Interop::WebViewControlProcessOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebViewControlProcessOptions[] = {
        { "_assign_array_", _assign_array_WebViewControlProcessOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebViewControlProcessOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebViewControlProcessOptions[] = {
        { "private_network_client_server_capability", reinterpret_cast<getter>(WebViewControlProcessOptions_get_PrivateNetworkClientServerCapability), reinterpret_cast<setter>(WebViewControlProcessOptions_put_PrivateNetworkClientServerCapability), nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(WebViewControlProcessOptions_get_EnterpriseId), reinterpret_cast<setter>(WebViewControlProcessOptions_put_EnterpriseId), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebViewControlProcessOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebViewControlProcessOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebViewControlProcessOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebViewControlProcessOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebViewControlProcessOptions) },
        { }};

    static PyType_Spec type_spec_WebViewControlProcessOptions = {
        "winrt._winrt_windows_web_ui_interop.WebViewControlProcessOptions",
        sizeof(py::wrapper::Windows::Web::UI::Interop::WebViewControlProcessOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebViewControlProcessOptions};

    // ----- Windows.Web.UI.Interop Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Web.UI.Interop");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_web_ui_interop",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Web::UI::Interop

PyMODINIT_FUNC PyInit__winrt_windows_web_ui_interop(void) noexcept
{
    using namespace py::cpp::Windows::Web::UI::Interop;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle WebViewControl_type{py::register_python_type(module.get(), &type_spec_WebViewControl, object_bases.get(), inspectable_meta_type)};
    if (!WebViewControl_type)
    {
        return nullptr;
    }

    py::pytype_handle WebViewControlAcceleratorKeyPressedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebViewControlAcceleratorKeyPressedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WebViewControlAcceleratorKeyPressedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebViewControlMoveFocusRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebViewControlMoveFocusRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WebViewControlMoveFocusRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebViewControlProcess_type{py::register_python_type(module.get(), &type_spec_WebViewControlProcess, object_bases.get(), inspectable_meta_type)};
    if (!WebViewControlProcess_type)
    {
        return nullptr;
    }

    py::pytype_handle WebViewControlProcessOptions_type{py::register_python_type(module.get(), &type_spec_WebViewControlProcessOptions, object_bases.get(), inspectable_meta_type)};
    if (!WebViewControlProcessOptions_type)
    {
        return nullptr;
    }


    return module.detach();
}
