// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.UI.Xaml.Data.h"

namespace py::cpp::Windows::UI::Xaml::Data
{
    // ----- Binding class --------------------

    struct PyWinrtBinding;
    using BasePyWinrtBinding = winrt::Windows::UI::Xaml::Data::BindingT<PyWinrtBinding, py::IPywinrtObject>;

    struct PyWinrtBinding : py::py_obj_ref, BasePyWinrtBinding
    {
        PyWinrtBinding(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtBinding() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtBinding* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_Binding(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Data::Binding>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtBinding>(self.get());

                    auto obj = py::make_py_obj<PyWinrtBinding>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Data::Binding instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Binding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Binding_get_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_RelativeSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"RelativeSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().RelativeSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_RelativeSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"RelativeSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::RelativeSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().RelativeSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_Path(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_Path(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::PropertyPath>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().Path(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_Mode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().Mode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_Mode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::BindingMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().Mode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_ElementName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ElementName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().ElementName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_ElementName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ElementName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().ElementName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_ConverterParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ConverterParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().ConverterParameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_ConverterParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ConverterParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().ConverterParameter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_ConverterLanguage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ConverterLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().ConverterLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_ConverterLanguage(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"ConverterLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().ConverterLanguage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_Converter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Converter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().Converter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_Converter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"Converter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::IValueConverter>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().Converter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_UpdateSourceTrigger(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"UpdateSourceTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().UpdateSourceTrigger();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_UpdateSourceTrigger(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"UpdateSourceTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::UpdateSourceTrigger>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().UpdateSourceTrigger(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_TargetNullValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"TargetNullValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().TargetNullValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_TargetNullValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"TargetNullValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().TargetNullValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Binding_get_FallbackValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"FallbackValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().FallbackValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Binding_put_FallbackValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.Binding", L"FallbackValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::Binding>().FallbackValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Binding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::Binding>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Binding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::Binding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Binding[] = {
        { "_assign_array_", _assign_array_Binding, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Binding), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Binding[] = {
        { "source", reinterpret_cast<getter>(Binding_get_Source), reinterpret_cast<setter>(Binding_put_Source), nullptr, nullptr },
        { "relative_source", reinterpret_cast<getter>(Binding_get_RelativeSource), reinterpret_cast<setter>(Binding_put_RelativeSource), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(Binding_get_Path), reinterpret_cast<setter>(Binding_put_Path), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(Binding_get_Mode), reinterpret_cast<setter>(Binding_put_Mode), nullptr, nullptr },
        { "element_name", reinterpret_cast<getter>(Binding_get_ElementName), reinterpret_cast<setter>(Binding_put_ElementName), nullptr, nullptr },
        { "converter_parameter", reinterpret_cast<getter>(Binding_get_ConverterParameter), reinterpret_cast<setter>(Binding_put_ConverterParameter), nullptr, nullptr },
        { "converter_language", reinterpret_cast<getter>(Binding_get_ConverterLanguage), reinterpret_cast<setter>(Binding_put_ConverterLanguage), nullptr, nullptr },
        { "converter", reinterpret_cast<getter>(Binding_get_Converter), reinterpret_cast<setter>(Binding_put_Converter), nullptr, nullptr },
        { "update_source_trigger", reinterpret_cast<getter>(Binding_get_UpdateSourceTrigger), reinterpret_cast<setter>(Binding_put_UpdateSourceTrigger), nullptr, nullptr },
        { "target_null_value", reinterpret_cast<getter>(Binding_get_TargetNullValue), reinterpret_cast<setter>(Binding_put_TargetNullValue), nullptr, nullptr },
        { "fallback_value", reinterpret_cast<getter>(Binding_get_FallbackValue), reinterpret_cast<setter>(Binding_put_FallbackValue), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Binding[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Binding) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Binding) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Binding) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Binding) },
        { }};

    static PyType_Spec type_spec_Binding = {
        "winrt._winrt_windows_ui_xaml_data.Binding",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Binding};

    static PyGetSetDef getset_Binding_Static[] = {
        { }};

    static PyMethodDef methods_Binding_Static[] = {
        { }};

    static PyType_Slot type_slots_Binding_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Binding_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Binding_Static) },
        { }
    };

    static PyType_Spec type_spec_Binding_Static = {
        "winrt._winrt_windows_ui_xaml_data.Binding_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Binding_Static};

    // ----- BindingBase class --------------------

    struct PyWinrtBindingBase;
    using BasePyWinrtBindingBase = winrt::Windows::UI::Xaml::Data::BindingBaseT<PyWinrtBindingBase, py::IPywinrtObject>;

    struct PyWinrtBindingBase : py::py_obj_ref, BasePyWinrtBindingBase
    {
        PyWinrtBindingBase(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtBindingBase() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtBindingBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_BindingBase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Data::BindingBase>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtBindingBase>(self.get());

                    auto obj = py::make_py_obj<PyWinrtBindingBase>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Data::BindingBase instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BindingBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BindingBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::BindingBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::BindingBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingBase[] = {
        { "_assign_array_", _assign_array_BindingBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingBase), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BindingBase[] = {
        { }};

    static PyType_Slot _type_slots_BindingBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingBase) },
        { }};

    static PyType_Spec type_spec_BindingBase = {
        "winrt._winrt_windows_ui_xaml_data.BindingBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BindingBase};

    static PyGetSetDef getset_BindingBase_Static[] = {
        { }};

    static PyMethodDef methods_BindingBase_Static[] = {
        { }};

    static PyType_Slot type_slots_BindingBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BindingBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BindingBase_Static) },
        { }
    };

    static PyType_Spec type_spec_BindingBase_Static = {
        "winrt._winrt_windows_ui_xaml_data.BindingBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BindingBase_Static};

    // ----- BindingExpression class --------------------

    static PyObject* _new_BindingExpression(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::BindingExpression>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::BindingExpression>::type_name);
        return nullptr;
    }

    static void _dealloc_BindingExpression(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BindingExpression_UpdateSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.BindingExpression", L"UpdateSource", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Windows::UI::Xaml::Data::BindingExpression>().UpdateSource();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BindingExpression_get_DataItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.BindingExpression", L"DataItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::BindingExpression>().DataItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BindingExpression_get_ParentBinding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.BindingExpression", L"ParentBinding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::BindingExpression>().ParentBinding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BindingExpression(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::BindingExpression>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingExpression(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::BindingExpression>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingExpression[] = {
        { "update_source", reinterpret_cast<PyCFunction>(BindingExpression_UpdateSource), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BindingExpression, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingExpression), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BindingExpression[] = {
        { "data_item", reinterpret_cast<getter>(BindingExpression_get_DataItem), nullptr, nullptr, nullptr },
        { "parent_binding", reinterpret_cast<getter>(BindingExpression_get_ParentBinding), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BindingExpression[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingExpression) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingExpression) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingExpression) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingExpression) },
        { }};

    static PyType_Spec type_spec_BindingExpression = {
        "winrt._winrt_windows_ui_xaml_data.BindingExpression",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BindingExpression};

    static PyGetSetDef getset_BindingExpression_Static[] = {
        { }};

    static PyMethodDef methods_BindingExpression_Static[] = {
        { }};

    static PyType_Slot type_slots_BindingExpression_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BindingExpression_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BindingExpression_Static) },
        { }
    };

    static PyType_Spec type_spec_BindingExpression_Static = {
        "winrt._winrt_windows_ui_xaml_data.BindingExpression_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BindingExpression_Static};

    // ----- BindingExpressionBase class --------------------

    static PyObject* _new_BindingExpressionBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::BindingExpressionBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::BindingExpressionBase>::type_name);
        return nullptr;
    }

    static void _dealloc_BindingExpressionBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BindingExpressionBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::BindingExpressionBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingExpressionBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::BindingExpressionBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingExpressionBase[] = {
        { "_assign_array_", _assign_array_BindingExpressionBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingExpressionBase), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BindingExpressionBase[] = {
        { }};

    static PyType_Slot _type_slots_BindingExpressionBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingExpressionBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingExpressionBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingExpressionBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingExpressionBase) },
        { }};

    static PyType_Spec type_spec_BindingExpressionBase = {
        "winrt._winrt_windows_ui_xaml_data.BindingExpressionBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BindingExpressionBase};

    static PyGetSetDef getset_BindingExpressionBase_Static[] = {
        { }};

    static PyMethodDef methods_BindingExpressionBase_Static[] = {
        { }};

    static PyType_Slot type_slots_BindingExpressionBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BindingExpressionBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BindingExpressionBase_Static) },
        { }
    };

    static PyType_Spec type_spec_BindingExpressionBase_Static = {
        "winrt._winrt_windows_ui_xaml_data.BindingExpressionBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BindingExpressionBase_Static};

    // ----- BindingOperations class --------------------

    static PyObject* _new_BindingOperations(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::BindingOperations>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::BindingOperations>::type_name);
        return nullptr;
    }

    static void _dealloc_BindingOperations(py::wrapper::Windows::UI::Xaml::Data::BindingOperations* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BindingOperations_SetBinding(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.BindingOperations", L"SetBinding", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Data::BindingBase>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Windows::UI::Xaml::Data::BindingOperations::SetBinding(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BindingOperations(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::BindingOperations>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingOperations(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::BindingOperations>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingOperations[] = {
        { "_assign_array_", _assign_array_BindingOperations, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingOperations), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BindingOperations[] = {
        { }};

    static PyType_Slot _type_slots_BindingOperations[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingOperations) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingOperations) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingOperations) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingOperations) },
        { }};

    static PyType_Spec type_spec_BindingOperations = {
        "winrt._winrt_windows_ui_xaml_data.BindingOperations",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::BindingOperations),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BindingOperations};

    static PyGetSetDef getset_BindingOperations_Static[] = {
        { }};

    static PyMethodDef methods_BindingOperations_Static[] = {
        { "set_binding", reinterpret_cast<PyCFunction>(BindingOperations_SetBinding), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_BindingOperations_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BindingOperations_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BindingOperations_Static) },
        { }
    };

    static PyType_Spec type_spec_BindingOperations_Static = {
        "winrt._winrt_windows_ui_xaml_data.BindingOperations_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BindingOperations_Static};

    // ----- CollectionViewSource class --------------------

    static PyObject* _new_CollectionViewSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Data::CollectionViewSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CollectionViewSource(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CollectionViewSource_get_Source(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CollectionViewSource_put_Source(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CollectionViewSource_get_ItemsPath(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"ItemsPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemsPath();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CollectionViewSource_put_ItemsPath(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"ItemsPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::PropertyPath>(arg);

            {
                auto _gil = release_gil();
                self->obj.ItemsPath(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CollectionViewSource_get_IsSourceGrouped(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"IsSourceGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSourceGrouped();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CollectionViewSource_put_IsSourceGrouped(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"IsSourceGrouped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSourceGrouped(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CollectionViewSource_get_View(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"View");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.View();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CollectionViewSource_get_IsSourceGroupedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"IsSourceGroupedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Data::CollectionViewSource::IsSourceGroupedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CollectionViewSource_get_ItemsPathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"ItemsPathProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Data::CollectionViewSource::ItemsPathProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CollectionViewSource_get_SourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"SourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Data::CollectionViewSource::SourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CollectionViewSource_get_ViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CollectionViewSource", L"ViewProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Data::CollectionViewSource::ViewProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CollectionViewSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::CollectionViewSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CollectionViewSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::CollectionViewSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CollectionViewSource[] = {
        { "_assign_array_", _assign_array_CollectionViewSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CollectionViewSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CollectionViewSource[] = {
        { "source", reinterpret_cast<getter>(CollectionViewSource_get_Source), reinterpret_cast<setter>(CollectionViewSource_put_Source), nullptr, nullptr },
        { "items_path", reinterpret_cast<getter>(CollectionViewSource_get_ItemsPath), reinterpret_cast<setter>(CollectionViewSource_put_ItemsPath), nullptr, nullptr },
        { "is_source_grouped", reinterpret_cast<getter>(CollectionViewSource_get_IsSourceGrouped), reinterpret_cast<setter>(CollectionViewSource_put_IsSourceGrouped), nullptr, nullptr },
        { "view", reinterpret_cast<getter>(CollectionViewSource_get_View), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CollectionViewSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CollectionViewSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CollectionViewSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CollectionViewSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CollectionViewSource) },
        { }};

    static PyType_Spec type_spec_CollectionViewSource = {
        "winrt._winrt_windows_ui_xaml_data.CollectionViewSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::CollectionViewSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CollectionViewSource};

    static PyGetSetDef getset_CollectionViewSource_Static[] = {
        { "is_source_grouped_property", reinterpret_cast<getter>(CollectionViewSource_get_IsSourceGroupedProperty), nullptr, nullptr, nullptr },
        { "items_path_property", reinterpret_cast<getter>(CollectionViewSource_get_ItemsPathProperty), nullptr, nullptr, nullptr },
        { "source_property", reinterpret_cast<getter>(CollectionViewSource_get_SourceProperty), nullptr, nullptr, nullptr },
        { "view_property", reinterpret_cast<getter>(CollectionViewSource_get_ViewProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_CollectionViewSource_Static[] = {
        { }};

    static PyType_Slot type_slots_CollectionViewSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CollectionViewSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CollectionViewSource_Static) },
        { }
    };

    static PyType_Spec type_spec_CollectionViewSource_Static = {
        "winrt._winrt_windows_ui_xaml_data.CollectionViewSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CollectionViewSource_Static};

    // ----- CurrentChangingEventArgs class --------------------

    struct PyWinrtCurrentChangingEventArgs;
    using BasePyWinrtCurrentChangingEventArgs = winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgsT<PyWinrtCurrentChangingEventArgs, py::IPywinrtObject>;

    struct PyWinrtCurrentChangingEventArgs : py::py_obj_ref, BasePyWinrtCurrentChangingEventArgs
    {
        PyWinrtCurrentChangingEventArgs(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCurrentChangingEventArgs() {}
        PyWinrtCurrentChangingEventArgs(PyObject* py_obj, bool isCancelable) : py::py_obj_ref(py_obj), BasePyWinrtCurrentChangingEventArgs(isCancelable) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtCurrentChangingEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_CurrentChangingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtCurrentChangingEventArgs>(self.get());

                    auto obj = py::make_py_obj<PyWinrtCurrentChangingEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtCurrentChangingEventArgs>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtCurrentChangingEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CurrentChangingEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CurrentChangingEventArgs_get_Cancel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CurrentChangingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs>().Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrentChangingEventArgs_put_Cancel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CurrentChangingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs>().Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrentChangingEventArgs_get_IsCancelable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.CurrentChangingEventArgs", L"IsCancelable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs>().IsCancelable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CurrentChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CurrentChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::CurrentChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrentChangingEventArgs[] = {
        { "_assign_array_", _assign_array_CurrentChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrentChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CurrentChangingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(CurrentChangingEventArgs_get_Cancel), reinterpret_cast<setter>(CurrentChangingEventArgs_put_Cancel), nullptr, nullptr },
        { "is_cancelable", reinterpret_cast<getter>(CurrentChangingEventArgs_get_IsCancelable), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CurrentChangingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrentChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CurrentChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrentChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrentChangingEventArgs) },
        { }};

    static PyType_Spec type_spec_CurrentChangingEventArgs = {
        "winrt._winrt_windows_ui_xaml_data.CurrentChangingEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CurrentChangingEventArgs};

    static PyGetSetDef getset_CurrentChangingEventArgs_Static[] = {
        { }};

    static PyMethodDef methods_CurrentChangingEventArgs_Static[] = {
        { }};

    static PyType_Slot type_slots_CurrentChangingEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CurrentChangingEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CurrentChangingEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_CurrentChangingEventArgs_Static = {
        "winrt._winrt_windows_ui_xaml_data.CurrentChangingEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CurrentChangingEventArgs_Static};

    // ----- ItemIndexRange class --------------------

    struct PyWinrtItemIndexRange;
    using BasePyWinrtItemIndexRange = winrt::Windows::UI::Xaml::Data::ItemIndexRangeT<PyWinrtItemIndexRange, py::IPywinrtObject>;

    struct PyWinrtItemIndexRange : py::py_obj_ref, BasePyWinrtItemIndexRange
    {
        PyWinrtItemIndexRange(PyObject* py_obj, int32_t firstIndex, uint32_t length) : py::py_obj_ref(py_obj), BasePyWinrtItemIndexRange(firstIndex, length) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtItemIndexRange* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ItemIndexRange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Data::ItemIndexRange>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtItemIndexRange>(self.get(), param0, param1);

                    auto obj = py::make_py_obj<PyWinrtItemIndexRange>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Data::ItemIndexRange instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemIndexRange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemIndexRange_get_FirstIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ItemIndexRange", L"FirstIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::ItemIndexRange>().FirstIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemIndexRange_get_LastIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ItemIndexRange", L"LastIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::ItemIndexRange>().LastIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemIndexRange_get_Length(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ItemIndexRange", L"Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::ItemIndexRange>().Length();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemIndexRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ItemIndexRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemIndexRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ItemIndexRange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemIndexRange[] = {
        { "_assign_array_", _assign_array_ItemIndexRange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemIndexRange), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ItemIndexRange[] = {
        { "first_index", reinterpret_cast<getter>(ItemIndexRange_get_FirstIndex), nullptr, nullptr, nullptr },
        { "last_index", reinterpret_cast<getter>(ItemIndexRange_get_LastIndex), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(ItemIndexRange_get_Length), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ItemIndexRange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemIndexRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemIndexRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemIndexRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemIndexRange) },
        { }};

    static PyType_Spec type_spec_ItemIndexRange = {
        "winrt._winrt_windows_ui_xaml_data.ItemIndexRange",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ItemIndexRange};

    static PyGetSetDef getset_ItemIndexRange_Static[] = {
        { }};

    static PyMethodDef methods_ItemIndexRange_Static[] = {
        { }};

    static PyType_Slot type_slots_ItemIndexRange_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemIndexRange_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemIndexRange_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemIndexRange_Static = {
        "winrt._winrt_windows_ui_xaml_data.ItemIndexRange_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ItemIndexRange_Static};

    // ----- PropertyChangedEventArgs class --------------------

    struct PyWinrtPropertyChangedEventArgs;
    using BasePyWinrtPropertyChangedEventArgs = winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgsT<PyWinrtPropertyChangedEventArgs, py::IPywinrtObject>;

    struct PyWinrtPropertyChangedEventArgs : py::py_obj_ref, BasePyWinrtPropertyChangedEventArgs
    {
        PyWinrtPropertyChangedEventArgs(PyObject* py_obj, winrt::hstring name) : py::py_obj_ref(py_obj), BasePyWinrtPropertyChangedEventArgs(name) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPropertyChangedEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_PropertyChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtPropertyChangedEventArgs>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtPropertyChangedEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgs instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PropertyChangedEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PropertyChangedEventArgs_get_PropertyName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.PropertyChangedEventArgs", L"PropertyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgs>().PropertyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::PropertyChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PropertyChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PropertyChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PropertyChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PropertyChangedEventArgs[] = {
        { "property_name", reinterpret_cast<getter>(PropertyChangedEventArgs_get_PropertyName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PropertyChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PropertyChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PropertyChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PropertyChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PropertyChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_PropertyChangedEventArgs = {
        "winrt._winrt_windows_ui_xaml_data.PropertyChangedEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PropertyChangedEventArgs};

    static PyGetSetDef getset_PropertyChangedEventArgs_Static[] = {
        { }};

    static PyMethodDef methods_PropertyChangedEventArgs_Static[] = {
        { }};

    static PyType_Slot type_slots_PropertyChangedEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PropertyChangedEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PropertyChangedEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_PropertyChangedEventArgs_Static = {
        "winrt._winrt_windows_ui_xaml_data.PropertyChangedEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PropertyChangedEventArgs_Static};

    // ----- RelativeSource class --------------------

    struct PyWinrtRelativeSource;
    using BasePyWinrtRelativeSource = winrt::Windows::UI::Xaml::Data::RelativeSourceT<PyWinrtRelativeSource, py::IPywinrtObject>;

    struct PyWinrtRelativeSource : py::py_obj_ref, BasePyWinrtRelativeSource
    {
        PyWinrtRelativeSource(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRelativeSource() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRelativeSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_RelativeSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Data::RelativeSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRelativeSource>(self.get());

                    auto obj = py::make_py_obj<PyWinrtRelativeSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Data::RelativeSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RelativeSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RelativeSource_get_Mode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.RelativeSource", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Data::RelativeSource>().Mode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RelativeSource_put_Mode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.RelativeSource", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::RelativeSourceMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Data::RelativeSource>().Mode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RelativeSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::RelativeSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RelativeSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::RelativeSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RelativeSource[] = {
        { "_assign_array_", _assign_array_RelativeSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RelativeSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RelativeSource[] = {
        { "mode", reinterpret_cast<getter>(RelativeSource_get_Mode), reinterpret_cast<setter>(RelativeSource_put_Mode), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RelativeSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RelativeSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RelativeSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RelativeSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RelativeSource) },
        { }};

    static PyType_Spec type_spec_RelativeSource = {
        "winrt._winrt_windows_ui_xaml_data.RelativeSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RelativeSource};

    static PyGetSetDef getset_RelativeSource_Static[] = {
        { }};

    static PyMethodDef methods_RelativeSource_Static[] = {
        { }};

    static PyType_Slot type_slots_RelativeSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RelativeSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RelativeSource_Static) },
        { }
    };

    static PyType_Spec type_spec_RelativeSource_Static = {
        "winrt._winrt_windows_ui_xaml_data.RelativeSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RelativeSource_Static};

    // ----- ICollectionView interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICollectionView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionView>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICollectionView_Append(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Append(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_Clear(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_First(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IIterable`1", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_GetAt(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_GetMany(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IInspectable, true>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_GetView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_IndexOf(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                uint32_t param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IndexOf(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_InsertAt(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.InsertAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_LoadMoreItemsAsync(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"LoadMoreItemsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.LoadMoreItemsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentTo(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentTo", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveCurrentTo(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToFirst(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToFirst", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveCurrentToFirst();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToLast(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToLast", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveCurrentToLast();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToNext(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToNext", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveCurrentToNext();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToPosition(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToPosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveCurrentToPosition(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_MoveCurrentToPrevious(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"MoveCurrentToPrevious", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveCurrentToPrevious();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_RemoveAt(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAt(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAtEnd();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_ReplaceAll(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IInspectable, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ReplaceAll(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_SetAt(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Collections.IVector`1", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_CollectionGroups(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CollectionGroups");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CollectionGroups();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_CurrentItem(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_CurrentPosition(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_HasMoreItems(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"HasMoreItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasMoreItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_IsCurrentAfterLast(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"IsCurrentAfterLast");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCurrentAfterLast();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_IsCurrentBeforeFirst(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"IsCurrentBeforeFirst");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCurrentBeforeFirst();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_get_Size(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Collections.IVector`1", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_add_CurrentChanged(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_remove_CurrentChanged(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CurrentChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_add_CurrentChanging(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::CurrentChangingEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentChanging(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_remove_CurrentChanging(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.ICollectionView", L"CurrentChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CurrentChanging(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_add_VectorChanged(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Collections.IObservableVector`1", L"VectorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VectorChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionView_remove_VectorChanged(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Collections.IObservableVector`1", L"VectorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VectorChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetAt(static_cast<uint32_t>(i));
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_ICollectionView(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            auto size = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.Size();
            }();
            if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Foundation::IInspectable> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Foundation::IInspectable>::get());

            auto count = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetMany(static_cast<uint32_t>(start), items);
            }();

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_ICollectionView(py::wrapper::Windows::UI::Xaml::Data::ICollectionView* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                auto _gil = py::release_gil();
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                auto _value = py::convert_to<winrt::Windows::Foundation::IInspectable>(value);
                {
                    auto _gil = py::release_gil();
                    self->obj.SetAt(static_cast<uint32_t>(i), _value);
                }
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ICollectionView[] = {
        { "append", reinterpret_cast<PyCFunction>(ICollectionView_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(ICollectionView_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ICollectionView_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(ICollectionView_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(ICollectionView_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ICollectionView_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(ICollectionView_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(ICollectionView_InsertAt), METH_VARARGS, nullptr },
        { "load_more_items_async", reinterpret_cast<PyCFunction>(ICollectionView_LoadMoreItemsAsync), METH_VARARGS, nullptr },
        { "move_current_to", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentTo), METH_VARARGS, nullptr },
        { "move_current_to_first", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToFirst), METH_VARARGS, nullptr },
        { "move_current_to_last", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToLast), METH_VARARGS, nullptr },
        { "move_current_to_next", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToNext), METH_VARARGS, nullptr },
        { "move_current_to_position", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToPosition), METH_VARARGS, nullptr },
        { "move_current_to_previous", reinterpret_cast<PyCFunction>(ICollectionView_MoveCurrentToPrevious), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(ICollectionView_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(ICollectionView_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(ICollectionView_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(ICollectionView_SetAt), METH_VARARGS, nullptr },
        { "add_current_changed", reinterpret_cast<PyCFunction>(ICollectionView_add_CurrentChanged), METH_O, nullptr },
        { "remove_current_changed", reinterpret_cast<PyCFunction>(ICollectionView_remove_CurrentChanged), METH_O, nullptr },
        { "add_current_changing", reinterpret_cast<PyCFunction>(ICollectionView_add_CurrentChanging), METH_O, nullptr },
        { "remove_current_changing", reinterpret_cast<PyCFunction>(ICollectionView_remove_CurrentChanging), METH_O, nullptr },
        { "add_vector_changed", reinterpret_cast<PyCFunction>(ICollectionView_add_VectorChanged), METH_O, nullptr },
        { "remove_vector_changed", reinterpret_cast<PyCFunction>(ICollectionView_remove_VectorChanged), METH_O, nullptr },
        { }};

    static PyGetSetDef _getset_ICollectionView[] = {
        { "collection_groups", reinterpret_cast<getter>(ICollectionView_get_CollectionGroups), nullptr, nullptr, nullptr },
        { "current_item", reinterpret_cast<getter>(ICollectionView_get_CurrentItem), nullptr, nullptr, nullptr },
        { "current_position", reinterpret_cast<getter>(ICollectionView_get_CurrentPosition), nullptr, nullptr, nullptr },
        { "has_more_items", reinterpret_cast<getter>(ICollectionView_get_HasMoreItems), nullptr, nullptr, nullptr },
        { "is_current_after_last", reinterpret_cast<getter>(ICollectionView_get_IsCurrentAfterLast), nullptr, nullptr, nullptr },
        { "is_current_before_first", reinterpret_cast<getter>(ICollectionView_get_IsCurrentBeforeFirst), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(ICollectionView_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ICollectionView[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICollectionView) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICollectionView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICollectionView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICollectionView) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ICollectionView) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_ICollectionView) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_ICollectionView) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_ICollectionView) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_ICollectionView) },
        { }};

    static PyType_Spec type_spec_ICollectionView = {
        "winrt._winrt_windows_ui_xaml_data._ICollectionView",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICollectionView),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICollectionView};

    struct ImplementsICollectionView : py::ImplementsInterfaceT<ImplementsICollectionView, winrt::Windows::UI::Xaml::Data::ICollectionView>
    {
        ImplementsICollectionView() = delete;
        ImplementsICollectionView(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICollectionView, winrt::Windows::UI::Xaml::Data::ICollectionView>(py_obj, runtime_class)
        {
        }

        auto Append(winrt::Windows::Foundation::IInspectable const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "append")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Clear()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "clear")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto First()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "first")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::IInspectable>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetAt(uint32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_at")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetMany(uint32_t param0, winrt::array_view<winrt::Windows::Foundation::IInspectable> param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_many")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetView()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_view")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IndexOf(winrt::Windows::Foundation::IInspectable const& param0, uint32_t& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "index_of")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<uint32_t>(return_value.get(), 1);

                return py::convert_to<bool>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto InsertAt(uint32_t param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "insert_at")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LoadMoreItemsAsync(uint32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "load_more_items_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveCurrentTo(winrt::Windows::Foundation::IInspectable const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_current_to")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveCurrentToFirst()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_current_to_first")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveCurrentToLast()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_current_to_last")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveCurrentToNext()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_current_to_next")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveCurrentToPosition(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_current_to_position")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveCurrentToPrevious()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_current_to_previous")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveAt(uint32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_at")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveAtEnd()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_at_end")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ReplaceAll(winrt::array_view<winrt::Windows::Foundation::IInspectable const> param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "replace_all")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetAt(uint32_t param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_at")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CollectionGroups()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "collection_groups")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IObservableVector<winrt::Windows::Foundation::IInspectable>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CurrentItem()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "current_item")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CurrentPosition()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "current_position")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HasMoreItems()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "has_more_items")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsCurrentAfterLast()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_current_after_last")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsCurrentBeforeFirst()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_current_before_first")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Size()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "size")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CurrentChanged(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_current_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CurrentChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_current_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CurrentChanging(winrt::Windows::UI::Xaml::Data::CurrentChangingEventHandler const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_current_changing")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CurrentChanging(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_current_changing")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VectorChanged(winrt::Windows::Foundation::Collections::VectorChangedEventHandler<winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_vector_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VectorChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_vector_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICollectionView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICollectionView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICollectionView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICollectionView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICollectionView(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::ICollectionView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICollectionView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICollectionView>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICollectionView[] = {
        { "_assign_array_", _assign_array_ICollectionView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICollectionView), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICollectionView), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICollectionView), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICollectionView[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICollectionView) },
        { }};

    static PyType_Spec type_spec_ImplementsICollectionView = {
        "winrt._winrt_windows_ui_xaml_data.ICollectionView",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICollectionView};

    // ----- ICollectionViewFactory interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICollectionViewFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICollectionViewFactory(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICollectionViewFactory_CreateView(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICollectionViewFactory", L"CreateView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICollectionViewFactory[] = {
        { "create_view", reinterpret_cast<PyCFunction>(ICollectionViewFactory_CreateView), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ICollectionViewFactory[] = {
        { }};

    static PyType_Slot _type_slots_ICollectionViewFactory[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICollectionViewFactory) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICollectionViewFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICollectionViewFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICollectionViewFactory) },
        { }};

    static PyType_Spec type_spec_ICollectionViewFactory = {
        "winrt._winrt_windows_ui_xaml_data._ICollectionViewFactory",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewFactory),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICollectionViewFactory};

    struct ImplementsICollectionViewFactory : py::ImplementsInterfaceT<ImplementsICollectionViewFactory, winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>
    {
        ImplementsICollectionViewFactory() = delete;
        ImplementsICollectionViewFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICollectionViewFactory, winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>(py_obj, runtime_class)
        {
        }

        auto CreateView()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_view")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Data::ICollectionView>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICollectionViewFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICollectionViewFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICollectionViewFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::ICollectionViewFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICollectionViewFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICollectionViewFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICollectionViewFactory[] = {
        { "_assign_array_", _assign_array_ICollectionViewFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICollectionViewFactory), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICollectionViewFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICollectionViewFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICollectionViewFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICollectionViewFactory) },
        { }};

    static PyType_Spec type_spec_ImplementsICollectionViewFactory = {
        "winrt._winrt_windows_ui_xaml_data.ICollectionViewFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICollectionViewFactory};

    // ----- ICollectionViewGroup interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICollectionViewGroup(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICollectionViewGroup(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICollectionViewGroup_get_Group(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionViewGroup", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Group();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICollectionViewGroup_get_GroupItems(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICollectionViewGroup", L"GroupItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GroupItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICollectionViewGroup[] = {
        { }};

    static PyGetSetDef _getset_ICollectionViewGroup[] = {
        { "group", reinterpret_cast<getter>(ICollectionViewGroup_get_Group), nullptr, nullptr, nullptr },
        { "group_items", reinterpret_cast<getter>(ICollectionViewGroup_get_GroupItems), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ICollectionViewGroup[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICollectionViewGroup) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICollectionViewGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICollectionViewGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICollectionViewGroup) },
        { }};

    static PyType_Spec type_spec_ICollectionViewGroup = {
        "winrt._winrt_windows_ui_xaml_data._ICollectionViewGroup",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICollectionViewGroup),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICollectionViewGroup};

    struct ImplementsICollectionViewGroup : py::ImplementsInterfaceT<ImplementsICollectionViewGroup, winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>
    {
        ImplementsICollectionViewGroup() = delete;
        ImplementsICollectionViewGroup(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICollectionViewGroup, winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>(py_obj, runtime_class)
        {
        }

        auto Group()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "group")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GroupItems()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "group_items")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IObservableVector<winrt::Windows::Foundation::IInspectable>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICollectionViewGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICollectionViewGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICollectionViewGroup(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::ICollectionViewGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICollectionViewGroup(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICollectionViewGroup>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICollectionViewGroup[] = {
        { "_assign_array_", _assign_array_ICollectionViewGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICollectionViewGroup), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICollectionViewGroup), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICollectionViewGroup), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICollectionViewGroup[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICollectionViewGroup) },
        { }};

    static PyType_Spec type_spec_ImplementsICollectionViewGroup = {
        "winrt._winrt_windows_ui_xaml_data.ICollectionViewGroup",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICollectionViewGroup};

    // ----- ICustomProperty interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICustomProperty(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICustomProperty>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICustomProperty>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICustomProperty(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomProperty_GetIndexedValue(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"GetIndexedValue", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIndexedValue(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_GetValue(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"GetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetValue(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_SetIndexedValue(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"SetIndexedValue", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.SetIndexedValue(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_SetValue(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"SetValue", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetValue(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_get_CanRead(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"CanRead");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanRead();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_get_CanWrite(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"CanWrite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanWrite();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_get_Name(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICustomProperty_get_Type(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomProperty", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomProperty[] = {
        { "get_indexed_value", reinterpret_cast<PyCFunction>(ICustomProperty_GetIndexedValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(ICustomProperty_GetValue), METH_VARARGS, nullptr },
        { "set_indexed_value", reinterpret_cast<PyCFunction>(ICustomProperty_SetIndexedValue), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(ICustomProperty_SetValue), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ICustomProperty[] = {
        { "can_read", reinterpret_cast<getter>(ICustomProperty_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(ICustomProperty_get_CanWrite), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ICustomProperty_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ICustomProperty_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ICustomProperty[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomProperty) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomProperty) },
        { }};

    static PyType_Spec type_spec_ICustomProperty = {
        "winrt._winrt_windows_ui_xaml_data._ICustomProperty",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICustomProperty),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICustomProperty};

    struct ImplementsICustomProperty : py::ImplementsInterfaceT<ImplementsICustomProperty, winrt::Windows::UI::Xaml::Data::ICustomProperty>
    {
        ImplementsICustomProperty() = delete;
        ImplementsICustomProperty(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICustomProperty, winrt::Windows::UI::Xaml::Data::ICustomProperty>(py_obj, runtime_class)
        {
        }

        auto GetIndexedValue(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_indexed_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetValue(winrt::Windows::Foundation::IInspectable const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetIndexedValue(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::Foundation::IInspectable const& param1, winrt::Windows::Foundation::IInspectable const& param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_indexed_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetValue(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanRead()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_read")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanWrite()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_write")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Type()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICustomProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICustomProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICustomProperty(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::ICustomProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICustomProperty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICustomProperty>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICustomProperty[] = {
        { "_assign_array_", _assign_array_ICustomProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomProperty), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICustomProperty), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICustomProperty), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICustomProperty[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICustomProperty) },
        { }};

    static PyType_Spec type_spec_ImplementsICustomProperty = {
        "winrt._winrt_windows_ui_xaml_data.ICustomProperty",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICustomProperty};

    // ----- ICustomPropertyProvider interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICustomPropertyProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICustomPropertyProvider(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomPropertyProvider_GetCustomProperty(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomPropertyProvider", L"GetCustomProperty", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCustomProperty(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomPropertyProvider_GetIndexedProperty(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomPropertyProvider", L"GetIndexedProperty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIndexedProperty(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomPropertyProvider_GetStringRepresentation(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ICustomPropertyProvider", L"GetStringRepresentation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStringRepresentation();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomPropertyProvider_get_Type(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ICustomPropertyProvider", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomPropertyProvider[] = {
        { "get_custom_property", reinterpret_cast<PyCFunction>(ICustomPropertyProvider_GetCustomProperty), METH_VARARGS, nullptr },
        { "get_indexed_property", reinterpret_cast<PyCFunction>(ICustomPropertyProvider_GetIndexedProperty), METH_VARARGS, nullptr },
        { "get_string_representation", reinterpret_cast<PyCFunction>(ICustomPropertyProvider_GetStringRepresentation), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ICustomPropertyProvider[] = {
        { "type", reinterpret_cast<getter>(ICustomPropertyProvider_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ICustomPropertyProvider[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomPropertyProvider) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomPropertyProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomPropertyProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomPropertyProvider) },
        { }};

    static PyType_Spec type_spec_ICustomPropertyProvider = {
        "winrt._winrt_windows_ui_xaml_data._ICustomPropertyProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ICustomPropertyProvider),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICustomPropertyProvider};

    struct ImplementsICustomPropertyProvider : py::ImplementsInterfaceT<ImplementsICustomPropertyProvider, winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>
    {
        ImplementsICustomPropertyProvider() = delete;
        ImplementsICustomPropertyProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICustomPropertyProvider, winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>(py_obj, runtime_class)
        {
        }

        auto GetCustomProperty(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_custom_property")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Data::ICustomProperty>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetIndexedProperty(winrt::hstring const& param0, winrt::Windows::UI::Xaml::Interop::TypeName param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_indexed_property")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Data::ICustomProperty>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetStringRepresentation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_string_representation")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Type()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICustomPropertyProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomPropertyProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICustomPropertyProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::ICustomPropertyProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICustomPropertyProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICustomPropertyProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICustomPropertyProvider[] = {
        { "_assign_array_", _assign_array_ICustomPropertyProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomPropertyProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICustomPropertyProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICustomPropertyProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICustomPropertyProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICustomPropertyProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsICustomPropertyProvider = {
        "winrt._winrt_windows_ui_xaml_data.ICustomPropertyProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICustomPropertyProvider};

    // ----- IItemsRangeInfo interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IItemsRangeInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IItemsRangeInfo(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IItemsRangeInfo_Close(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IItemsRangeInfo_RangesChanged(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.IItemsRangeInfo", L"RangesChanged", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Xaml::Data::ItemIndexRange>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.RangesChanged(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _enter_IItemsRangeInfo(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IItemsRangeInfo(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IItemsRangeInfo[] = {
        { "close", reinterpret_cast<PyCFunction>(IItemsRangeInfo_Close), METH_VARARGS, nullptr },
        { "ranges_changed", reinterpret_cast<PyCFunction>(IItemsRangeInfo_RangesChanged), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IItemsRangeInfo), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IItemsRangeInfo), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IItemsRangeInfo[] = {
        { }};

    static PyType_Slot _type_slots_IItemsRangeInfo[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IItemsRangeInfo) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IItemsRangeInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IItemsRangeInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IItemsRangeInfo) },
        { }};

    static PyType_Spec type_spec_IItemsRangeInfo = {
        "winrt._winrt_windows_ui_xaml_data._IItemsRangeInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::IItemsRangeInfo),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IItemsRangeInfo};

    struct ImplementsIItemsRangeInfo : py::ImplementsInterfaceT<ImplementsIItemsRangeInfo, winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>
    {
        ImplementsIItemsRangeInfo() = delete;
        ImplementsIItemsRangeInfo(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIItemsRangeInfo, winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RangesChanged(winrt::Windows::UI::Xaml::Data::ItemIndexRange const& param0, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Xaml::Data::ItemIndexRange> const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "ranges_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IItemsRangeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IItemsRangeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIItemsRangeInfo(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::IItemsRangeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIItemsRangeInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIItemsRangeInfo>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIItemsRangeInfo[] = {
        { "_assign_array_", _assign_array_IItemsRangeInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IItemsRangeInfo), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIItemsRangeInfo), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIItemsRangeInfo), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIItemsRangeInfo[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIItemsRangeInfo) },
        { }};

    static PyType_Spec type_spec_ImplementsIItemsRangeInfo = {
        "winrt._winrt_windows_ui_xaml_data.IItemsRangeInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIItemsRangeInfo};

    // ----- INotifyPropertyChanged interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_INotifyPropertyChanged(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_INotifyPropertyChanged(py::wrapper::Windows::UI::Xaml::Data::INotifyPropertyChanged* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INotifyPropertyChanged_add_PropertyChanged(py::wrapper::Windows::UI::Xaml::Data::INotifyPropertyChanged* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.INotifyPropertyChanged", L"PropertyChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::PropertyChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PropertyChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INotifyPropertyChanged_remove_PropertyChanged(py::wrapper::Windows::UI::Xaml::Data::INotifyPropertyChanged* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Data.INotifyPropertyChanged", L"PropertyChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PropertyChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INotifyPropertyChanged[] = {
        { "add_property_changed", reinterpret_cast<PyCFunction>(INotifyPropertyChanged_add_PropertyChanged), METH_O, nullptr },
        { "remove_property_changed", reinterpret_cast<PyCFunction>(INotifyPropertyChanged_remove_PropertyChanged), METH_O, nullptr },
        { }};

    static PyGetSetDef _getset_INotifyPropertyChanged[] = {
        { }};

    static PyType_Slot _type_slots_INotifyPropertyChanged[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_INotifyPropertyChanged) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INotifyPropertyChanged) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INotifyPropertyChanged) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INotifyPropertyChanged) },
        { }};

    static PyType_Spec type_spec_INotifyPropertyChanged = {
        "winrt._winrt_windows_ui_xaml_data._INotifyPropertyChanged",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::INotifyPropertyChanged),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_INotifyPropertyChanged};

    struct ImplementsINotifyPropertyChanged : py::ImplementsInterfaceT<ImplementsINotifyPropertyChanged, winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>
    {
        ImplementsINotifyPropertyChanged() = delete;
        ImplementsINotifyPropertyChanged(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsINotifyPropertyChanged, winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>(py_obj, runtime_class)
        {
        }

        auto PropertyChanged(winrt::Windows::UI::Xaml::Data::PropertyChangedEventHandler const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_property_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PropertyChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_property_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_INotifyPropertyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INotifyPropertyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsINotifyPropertyChanged(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::INotifyPropertyChanged>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsINotifyPropertyChanged(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsINotifyPropertyChanged>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsINotifyPropertyChanged[] = {
        { "_assign_array_", _assign_array_INotifyPropertyChanged, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INotifyPropertyChanged), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsINotifyPropertyChanged), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsINotifyPropertyChanged), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsINotifyPropertyChanged[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsINotifyPropertyChanged) },
        { }};

    static PyType_Spec type_spec_ImplementsINotifyPropertyChanged = {
        "winrt._winrt_windows_ui_xaml_data.INotifyPropertyChanged",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsINotifyPropertyChanged};

    // ----- ISelectionInfo interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ISelectionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ISelectionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ISelectionInfo>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ISelectionInfo(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISelectionInfo_DeselectRange(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISelectionInfo", L"DeselectRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DeselectRange(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionInfo_GetSelectedRanges(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISelectionInfo", L"GetSelectedRanges", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSelectedRanges();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionInfo_IsSelected(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISelectionInfo", L"IsSelected", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsSelected(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionInfo_SelectRange(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISelectionInfo", L"SelectRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SelectRange(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISelectionInfo[] = {
        { "deselect_range", reinterpret_cast<PyCFunction>(ISelectionInfo_DeselectRange), METH_VARARGS, nullptr },
        { "get_selected_ranges", reinterpret_cast<PyCFunction>(ISelectionInfo_GetSelectedRanges), METH_VARARGS, nullptr },
        { "is_selected", reinterpret_cast<PyCFunction>(ISelectionInfo_IsSelected), METH_VARARGS, nullptr },
        { "select_range", reinterpret_cast<PyCFunction>(ISelectionInfo_SelectRange), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISelectionInfo[] = {
        { }};

    static PyType_Slot _type_slots_ISelectionInfo[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ISelectionInfo) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISelectionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISelectionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISelectionInfo) },
        { }};

    static PyType_Spec type_spec_ISelectionInfo = {
        "winrt._winrt_windows_ui_xaml_data._ISelectionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ISelectionInfo),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ISelectionInfo};

    struct ImplementsISelectionInfo : py::ImplementsInterfaceT<ImplementsISelectionInfo, winrt::Windows::UI::Xaml::Data::ISelectionInfo>
    {
        ImplementsISelectionInfo() = delete;
        ImplementsISelectionInfo(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISelectionInfo, winrt::Windows::UI::Xaml::Data::ISelectionInfo>(py_obj, runtime_class)
        {
        }

        auto DeselectRange(winrt::Windows::UI::Xaml::Data::ItemIndexRange const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "deselect_range")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetSelectedRanges()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_selected_ranges")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Xaml::Data::ItemIndexRange>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsSelected(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_selected")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SelectRange(winrt::Windows::UI::Xaml::Data::ItemIndexRange const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "select_range")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISelectionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ISelectionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISelectionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ISelectionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISelectionInfo(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::ISelectionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISelectionInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISelectionInfo>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISelectionInfo[] = {
        { "_assign_array_", _assign_array_ISelectionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISelectionInfo), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISelectionInfo), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISelectionInfo), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISelectionInfo[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISelectionInfo) },
        { }};

    static PyType_Spec type_spec_ImplementsISelectionInfo = {
        "winrt._winrt_windows_ui_xaml_data.ISelectionInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsISelectionInfo};

    // ----- ISupportIncrementalLoading interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ISupportIncrementalLoading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ISupportIncrementalLoading(py::wrapper::Windows::UI::Xaml::Data::ISupportIncrementalLoading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISupportIncrementalLoading_LoadMoreItemsAsync(py::wrapper::Windows::UI::Xaml::Data::ISupportIncrementalLoading* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.ISupportIncrementalLoading", L"LoadMoreItemsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.LoadMoreItemsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISupportIncrementalLoading_get_HasMoreItems(py::wrapper::Windows::UI::Xaml::Data::ISupportIncrementalLoading* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Data.ISupportIncrementalLoading", L"HasMoreItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasMoreItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISupportIncrementalLoading[] = {
        { "load_more_items_async", reinterpret_cast<PyCFunction>(ISupportIncrementalLoading_LoadMoreItemsAsync), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISupportIncrementalLoading[] = {
        { "has_more_items", reinterpret_cast<getter>(ISupportIncrementalLoading_get_HasMoreItems), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISupportIncrementalLoading[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ISupportIncrementalLoading) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISupportIncrementalLoading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISupportIncrementalLoading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISupportIncrementalLoading) },
        { }};

    static PyType_Spec type_spec_ISupportIncrementalLoading = {
        "winrt._winrt_windows_ui_xaml_data._ISupportIncrementalLoading",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::ISupportIncrementalLoading),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ISupportIncrementalLoading};

    struct ImplementsISupportIncrementalLoading : py::ImplementsInterfaceT<ImplementsISupportIncrementalLoading, winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>
    {
        ImplementsISupportIncrementalLoading() = delete;
        ImplementsISupportIncrementalLoading(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISupportIncrementalLoading, winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>(py_obj, runtime_class)
        {
        }

        auto LoadMoreItemsAsync(uint32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "load_more_items_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HasMoreItems()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "has_more_items")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISupportIncrementalLoading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISupportIncrementalLoading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISupportIncrementalLoading(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::ISupportIncrementalLoading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISupportIncrementalLoading(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISupportIncrementalLoading>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISupportIncrementalLoading[] = {
        { "_assign_array_", _assign_array_ISupportIncrementalLoading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISupportIncrementalLoading), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISupportIncrementalLoading), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISupportIncrementalLoading), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISupportIncrementalLoading[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISupportIncrementalLoading) },
        { }};

    static PyType_Spec type_spec_ImplementsISupportIncrementalLoading = {
        "winrt._winrt_windows_ui_xaml_data.ISupportIncrementalLoading",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsISupportIncrementalLoading};

    // ----- IValueConverter interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IValueConverter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Data::IValueConverter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Data::IValueConverter>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IValueConverter(py::wrapper::Windows::UI::Xaml::Data::IValueConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IValueConverter_Convert(py::wrapper::Windows::UI::Xaml::Data::IValueConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.IValueConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Convert(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IValueConverter_ConvertBack(py::wrapper::Windows::UI::Xaml::Data::IValueConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Data.IValueConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertBack(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IValueConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(IValueConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(IValueConverter_ConvertBack), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IValueConverter[] = {
        { }};

    static PyType_Slot _type_slots_IValueConverter[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IValueConverter) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IValueConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IValueConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IValueConverter) },
        { }};

    static PyType_Spec type_spec_IValueConverter = {
        "winrt._winrt_windows_ui_xaml_data._IValueConverter",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::IValueConverter),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IValueConverter};

    struct ImplementsIValueConverter : py::ImplementsInterfaceT<ImplementsIValueConverter, winrt::Windows::UI::Xaml::Data::IValueConverter>
    {
        ImplementsIValueConverter() = delete;
        ImplementsIValueConverter(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIValueConverter, winrt::Windows::UI::Xaml::Data::IValueConverter>(py_obj, runtime_class)
        {
        }

        auto Convert(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::UI::Xaml::Interop::TypeName param1, winrt::Windows::Foundation::IInspectable const& param2, winrt::hstring const& param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "convert")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ConvertBack(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::UI::Xaml::Interop::TypeName param1, winrt::Windows::Foundation::IInspectable const& param2, winrt::hstring const& param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "convert_back")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IValueConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::IValueConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IValueConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Data::IValueConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIValueConverter(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Data::IValueConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIValueConverter(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIValueConverter>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIValueConverter[] = {
        { "_assign_array_", _assign_array_IValueConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IValueConverter), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIValueConverter), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIValueConverter), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIValueConverter[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIValueConverter) },
        { }};

    static PyType_Spec type_spec_ImplementsIValueConverter = {
        "winrt._winrt_windows_ui_xaml_data.IValueConverter",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIValueConverter};

    // ----- LoadMoreItemsResult struct --------------------

    winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult LoadMoreItemsResult_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 1)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult result{};

        result.Count = py::convert_to<uint32_t>(tuple, 0);

        return result;
    }

    PyObject* _new_LoadMoreItemsResult(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint32_t _Count{};

        static const char* kwlist[] = {"count", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|I", const_cast<char**>(kwlist), &_Count))
        {
            return nullptr;
        }

        try
        {
            self->obj.Count = _Count;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_LoadMoreItemsResult(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LoadMoreItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_LoadMoreItemsResult(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint32_t _Count{self->obj.Count};

            static const char* kwlist[] = {"count", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$I", const_cast<char**>(kwlist), &_Count))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Count = _Count;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoadMoreItemsResult[] = {
        { "_assign_array_", _assign_array_LoadMoreItemsResult, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_LoadMoreItemsResult)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* LoadMoreItemsResult_get_Count(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Count);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_LoadMoreItemsResult[] = {
        { "count", reinterpret_cast<getter>(LoadMoreItemsResult_get_Count), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_LoadMoreItemsResult(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::Xaml::Data::LoadMoreItemsResult>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_LoadMoreItemsResult(PyObject* self) noexcept
    {
        py::pyobj_handle Count{PyObject_GetAttrString(self, "count")};
        if (!Count)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("LoadMoreItemsResult(count=%R)", Count.get());
    }

    static PyType_Slot _type_slots_LoadMoreItemsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoadMoreItemsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoadMoreItemsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoadMoreItemsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoadMoreItemsResult) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_LoadMoreItemsResult) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_LoadMoreItemsResult) },
        { }};

    static PyType_Spec type_spec_LoadMoreItemsResult = {
        "winrt._winrt_windows_ui_xaml_data.LoadMoreItemsResult",
        sizeof(py::wrapper::Windows::UI::Xaml::Data::LoadMoreItemsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoadMoreItemsResult};

    // ----- Windows.UI.Xaml.Data Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Data");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_data",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Data

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_data(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Data;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml")};
    if (!windows_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_DependencyObject_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "DependencyObject")};
    if (!windows_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle BindingBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!BindingBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BindingBase_Static{PyType_FromSpecWithBases(&type_spec_BindingBase_Static, BindingBase_Static_bases.get())};
    if (!type_BindingBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BindingBase_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!BindingBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle BindingBase_type{py::register_python_type(module.get(), &type_spec_BindingBase, BindingBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_BindingBase_Static.get()))};
    if (!BindingBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle Binding_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(BindingBase_type.get())))};
    if (!Binding_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Binding_Static{PyType_FromSpecWithBases(&type_spec_Binding_Static, Binding_Static_bases.get())};
    if (!type_Binding_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Binding_bases{PyTuple_Pack(1, BindingBase_type.get())};
    if (!Binding_bases)
    {
        return nullptr;
    }

    py::pytype_handle Binding_type{py::register_python_type(module.get(), &type_spec_Binding, Binding_bases.get(), reinterpret_cast<PyTypeObject*>(type_Binding_Static.get()))};
    if (!Binding_type)
    {
        return nullptr;
    }

    py::pyobj_handle BindingExpressionBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!BindingExpressionBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BindingExpressionBase_Static{PyType_FromSpecWithBases(&type_spec_BindingExpressionBase_Static, BindingExpressionBase_Static_bases.get())};
    if (!type_BindingExpressionBase_Static)
    {
        return nullptr;
    }

    py::pytype_handle BindingExpressionBase_type{py::register_python_type(module.get(), &type_spec_BindingExpressionBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BindingExpressionBase_Static.get()))};
    if (!BindingExpressionBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle BindingExpression_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(BindingExpressionBase_type.get())))};
    if (!BindingExpression_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BindingExpression_Static{PyType_FromSpecWithBases(&type_spec_BindingExpression_Static, BindingExpression_Static_bases.get())};
    if (!type_BindingExpression_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BindingExpression_bases{PyTuple_Pack(1, BindingExpressionBase_type.get())};
    if (!BindingExpression_bases)
    {
        return nullptr;
    }

    py::pytype_handle BindingExpression_type{py::register_python_type(module.get(), &type_spec_BindingExpression, BindingExpression_bases.get(), reinterpret_cast<PyTypeObject*>(type_BindingExpression_Static.get()))};
    if (!BindingExpression_type)
    {
        return nullptr;
    }

    py::pyobj_handle BindingOperations_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!BindingOperations_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BindingOperations_Static{PyType_FromSpecWithBases(&type_spec_BindingOperations_Static, BindingOperations_Static_bases.get())};
    if (!type_BindingOperations_Static)
    {
        return nullptr;
    }

    py::pytype_handle BindingOperations_type{py::register_python_type(module.get(), &type_spec_BindingOperations, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BindingOperations_Static.get()))};
    if (!BindingOperations_type)
    {
        return nullptr;
    }

    py::pyobj_handle CollectionViewSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!CollectionViewSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CollectionViewSource_Static{PyType_FromSpecWithBases(&type_spec_CollectionViewSource_Static, CollectionViewSource_Static_bases.get())};
    if (!type_CollectionViewSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CollectionViewSource_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!CollectionViewSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle CollectionViewSource_type{py::register_python_type(module.get(), &type_spec_CollectionViewSource, CollectionViewSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_CollectionViewSource_Static.get()))};
    if (!CollectionViewSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle CurrentChangingEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!CurrentChangingEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CurrentChangingEventArgs_Static{PyType_FromSpecWithBases(&type_spec_CurrentChangingEventArgs_Static, CurrentChangingEventArgs_Static_bases.get())};
    if (!type_CurrentChangingEventArgs_Static)
    {
        return nullptr;
    }

    py::pytype_handle CurrentChangingEventArgs_type{py::register_python_type(module.get(), &type_spec_CurrentChangingEventArgs, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CurrentChangingEventArgs_Static.get()))};
    if (!CurrentChangingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ItemIndexRange_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ItemIndexRange_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemIndexRange_Static{PyType_FromSpecWithBases(&type_spec_ItemIndexRange_Static, ItemIndexRange_Static_bases.get())};
    if (!type_ItemIndexRange_Static)
    {
        return nullptr;
    }

    py::pytype_handle ItemIndexRange_type{py::register_python_type(module.get(), &type_spec_ItemIndexRange, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemIndexRange_Static.get()))};
    if (!ItemIndexRange_type)
    {
        return nullptr;
    }

    py::pyobj_handle PropertyChangedEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PropertyChangedEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PropertyChangedEventArgs_Static{PyType_FromSpecWithBases(&type_spec_PropertyChangedEventArgs_Static, PropertyChangedEventArgs_Static_bases.get())};
    if (!type_PropertyChangedEventArgs_Static)
    {
        return nullptr;
    }

    py::pytype_handle PropertyChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PropertyChangedEventArgs, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PropertyChangedEventArgs_Static.get()))};
    if (!PropertyChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RelativeSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!RelativeSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RelativeSource_Static{PyType_FromSpecWithBases(&type_spec_RelativeSource_Static, RelativeSource_Static_bases.get())};
    if (!type_RelativeSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RelativeSource_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!RelativeSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle RelativeSource_type{py::register_python_type(module.get(), &type_spec_RelativeSource, RelativeSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_RelativeSource_Static.get()))};
    if (!RelativeSource_type)
    {
        return nullptr;
    }

    py::pytype_handle ICollectionView_type{py::register_python_type(module.get(), &type_spec_ICollectionView, object_bases.get(), nullptr)};
    if (!ICollectionView_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICollectionView_type{py::register_python_type(module.get(), &type_spec_ImplementsICollectionView, nullptr, inspectable_meta_type)};
    if (!ImplementsICollectionView_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICollectionView_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ICollectionViewFactory_type{py::register_python_type(module.get(), &type_spec_ICollectionViewFactory, object_bases.get(), nullptr)};
    if (!ICollectionViewFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICollectionViewFactory_type{py::register_python_type(module.get(), &type_spec_ImplementsICollectionViewFactory, nullptr, inspectable_meta_type)};
    if (!ImplementsICollectionViewFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICollectionViewFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ICollectionViewGroup_type{py::register_python_type(module.get(), &type_spec_ICollectionViewGroup, object_bases.get(), nullptr)};
    if (!ICollectionViewGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICollectionViewGroup_type{py::register_python_type(module.get(), &type_spec_ImplementsICollectionViewGroup, nullptr, inspectable_meta_type)};
    if (!ImplementsICollectionViewGroup_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICollectionViewGroup_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ICustomProperty_type{py::register_python_type(module.get(), &type_spec_ICustomProperty, object_bases.get(), nullptr)};
    if (!ICustomProperty_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICustomProperty_type{py::register_python_type(module.get(), &type_spec_ImplementsICustomProperty, nullptr, inspectable_meta_type)};
    if (!ImplementsICustomProperty_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICustomProperty_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ICustomPropertyProvider_type{py::register_python_type(module.get(), &type_spec_ICustomPropertyProvider, object_bases.get(), nullptr)};
    if (!ICustomPropertyProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICustomPropertyProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsICustomPropertyProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsICustomPropertyProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICustomPropertyProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IItemsRangeInfo_type{py::register_python_type(module.get(), &type_spec_IItemsRangeInfo, object_bases.get(), nullptr)};
    if (!IItemsRangeInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIItemsRangeInfo_type{py::register_python_type(module.get(), &type_spec_ImplementsIItemsRangeInfo, nullptr, inspectable_meta_type)};
    if (!ImplementsIItemsRangeInfo_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIItemsRangeInfo_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle INotifyPropertyChanged_type{py::register_python_type(module.get(), &type_spec_INotifyPropertyChanged, object_bases.get(), nullptr)};
    if (!INotifyPropertyChanged_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsINotifyPropertyChanged_type{py::register_python_type(module.get(), &type_spec_ImplementsINotifyPropertyChanged, nullptr, inspectable_meta_type)};
    if (!ImplementsINotifyPropertyChanged_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsINotifyPropertyChanged_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISelectionInfo_type{py::register_python_type(module.get(), &type_spec_ISelectionInfo, object_bases.get(), nullptr)};
    if (!ISelectionInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISelectionInfo_type{py::register_python_type(module.get(), &type_spec_ImplementsISelectionInfo, nullptr, inspectable_meta_type)};
    if (!ImplementsISelectionInfo_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISelectionInfo_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISupportIncrementalLoading_type{py::register_python_type(module.get(), &type_spec_ISupportIncrementalLoading, object_bases.get(), nullptr)};
    if (!ISupportIncrementalLoading_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISupportIncrementalLoading_type{py::register_python_type(module.get(), &type_spec_ImplementsISupportIncrementalLoading, nullptr, inspectable_meta_type)};
    if (!ImplementsISupportIncrementalLoading_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISupportIncrementalLoading_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IValueConverter_type{py::register_python_type(module.get(), &type_spec_IValueConverter, object_bases.get(), nullptr)};
    if (!IValueConverter_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIValueConverter_type{py::register_python_type(module.get(), &type_spec_ImplementsIValueConverter, nullptr, inspectable_meta_type)};
    if (!ImplementsIValueConverter_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIValueConverter_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle LoadMoreItemsResult_type{py::register_python_type(module.get(), &type_spec_LoadMoreItemsResult, nullptr, nullptr)};
    if (!LoadMoreItemsResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoadMoreItemsResult_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(LoadMoreItemsResult_from_tuple),"winrt._winrt_windows_ui_xaml_data.LoadMoreItemsResult_from_tuple", nullptr)};
    if (!LoadMoreItemsResult_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "LoadMoreItemsResult_from_tuple", LoadMoreItemsResult_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
