// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.ApplicationModel.Calls.Background.h"

namespace py::cpp::Windows::ApplicationModel::Calls::Background
{
    // ----- PhoneCallBlockedTriggerDetails class --------------------

    static PyObject* _new_PhoneCallBlockedTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallBlockedTriggerDetails(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallBlockedTriggerDetails_get_CallBlockedReason(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneCallBlockedTriggerDetails", L"CallBlockedReason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallBlockedReason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlockedTriggerDetails_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneCallBlockedTriggerDetails", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlockedTriggerDetails_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneCallBlockedTriggerDetails", L"PhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallBlockedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallBlockedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallBlockedTriggerDetails[] = {
        { "_assign_array_", _assign_array_PhoneCallBlockedTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallBlockedTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhoneCallBlockedTriggerDetails[] = {
        { "call_blocked_reason", reinterpret_cast<getter>(PhoneCallBlockedTriggerDetails_get_CallBlockedReason), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneCallBlockedTriggerDetails_get_LineId), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PhoneCallBlockedTriggerDetails_get_PhoneNumber), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhoneCallBlockedTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallBlockedTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallBlockedTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallBlockedTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallBlockedTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PhoneCallBlockedTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_calls_background.PhoneCallBlockedTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallBlockedTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallBlockedTriggerDetails};

    // ----- PhoneCallOriginDataRequestTriggerDetails class --------------------

    static PyObject* _new_PhoneCallOriginDataRequestTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneCallOriginDataRequestTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneCallOriginDataRequestTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallOriginDataRequestTriggerDetails(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallOriginDataRequestTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallOriginDataRequestTriggerDetails_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallOriginDataRequestTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneCallOriginDataRequestTriggerDetails", L"PhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallOriginDataRequestTriggerDetails_get_RequestId(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallOriginDataRequestTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneCallOriginDataRequestTriggerDetails", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallOriginDataRequestTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::Background::PhoneCallOriginDataRequestTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallOriginDataRequestTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::Background::PhoneCallOriginDataRequestTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallOriginDataRequestTriggerDetails[] = {
        { "_assign_array_", _assign_array_PhoneCallOriginDataRequestTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallOriginDataRequestTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhoneCallOriginDataRequestTriggerDetails[] = {
        { "phone_number", reinterpret_cast<getter>(PhoneCallOriginDataRequestTriggerDetails_get_PhoneNumber), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(PhoneCallOriginDataRequestTriggerDetails_get_RequestId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhoneCallOriginDataRequestTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallOriginDataRequestTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallOriginDataRequestTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallOriginDataRequestTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallOriginDataRequestTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PhoneCallOriginDataRequestTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_calls_background.PhoneCallOriginDataRequestTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneCallOriginDataRequestTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallOriginDataRequestTriggerDetails};

    // ----- PhoneIncomingCallDismissedTriggerDetails class --------------------

    static PyObject* _new_PhoneIncomingCallDismissedTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneIncomingCallDismissedTriggerDetails(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneIncomingCallDismissedTriggerDetails_get_DismissalTime(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneIncomingCallDismissedTriggerDetails", L"DismissalTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DismissalTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneIncomingCallDismissedTriggerDetails_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneIncomingCallDismissedTriggerDetails", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneIncomingCallDismissedTriggerDetails_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneIncomingCallDismissedTriggerDetails", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneIncomingCallDismissedTriggerDetails_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneIncomingCallDismissedTriggerDetails", L"PhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneIncomingCallDismissedTriggerDetails_get_Reason(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneIncomingCallDismissedTriggerDetails", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneIncomingCallDismissedTriggerDetails_get_TextReplyMessage(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneIncomingCallDismissedTriggerDetails", L"TextReplyMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextReplyMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneIncomingCallDismissedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneIncomingCallDismissedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneIncomingCallDismissedTriggerDetails[] = {
        { "_assign_array_", _assign_array_PhoneIncomingCallDismissedTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneIncomingCallDismissedTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhoneIncomingCallDismissedTriggerDetails[] = {
        { "dismissal_time", reinterpret_cast<getter>(PhoneIncomingCallDismissedTriggerDetails_get_DismissalTime), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneIncomingCallDismissedTriggerDetails_get_DisplayName), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneIncomingCallDismissedTriggerDetails_get_LineId), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PhoneIncomingCallDismissedTriggerDetails_get_PhoneNumber), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(PhoneIncomingCallDismissedTriggerDetails_get_Reason), nullptr, nullptr, nullptr },
        { "text_reply_message", reinterpret_cast<getter>(PhoneIncomingCallDismissedTriggerDetails_get_TextReplyMessage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhoneIncomingCallDismissedTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneIncomingCallDismissedTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneIncomingCallDismissedTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneIncomingCallDismissedTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneIncomingCallDismissedTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PhoneIncomingCallDismissedTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_calls_background.PhoneIncomingCallDismissedTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallDismissedTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneIncomingCallDismissedTriggerDetails};

    // ----- PhoneIncomingCallNotificationTriggerDetails class --------------------

    static PyObject* _new_PhoneIncomingCallNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneIncomingCallNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneIncomingCallNotificationTriggerDetails_get_CallId(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneIncomingCallNotificationTriggerDetails", L"CallId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneIncomingCallNotificationTriggerDetails_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneIncomingCallNotificationTriggerDetails", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneIncomingCallNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneIncomingCallNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneIncomingCallNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_PhoneIncomingCallNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneIncomingCallNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhoneIncomingCallNotificationTriggerDetails[] = {
        { "call_id", reinterpret_cast<getter>(PhoneIncomingCallNotificationTriggerDetails_get_CallId), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneIncomingCallNotificationTriggerDetails_get_LineId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhoneIncomingCallNotificationTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneIncomingCallNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneIncomingCallNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneIncomingCallNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneIncomingCallNotificationTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PhoneIncomingCallNotificationTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_calls_background.PhoneIncomingCallNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneIncomingCallNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneIncomingCallNotificationTriggerDetails};

    // ----- PhoneLineChangedTriggerDetails class --------------------

    static PyObject* _new_PhoneLineChangedTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLineChangedTriggerDetails(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineChangedTriggerDetails_HasLinePropertyChanged(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.Background.PhoneLineChangedTriggerDetails", L"HasLinePropertyChanged", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::Background::PhoneLineProperties>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.HasLinePropertyChanged(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineChangedTriggerDetails_get_ChangeType(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneLineChangedTriggerDetails", L"ChangeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineChangedTriggerDetails_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneLineChangedTriggerDetails", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineChangedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineChangedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineChangedTriggerDetails[] = {
        { "has_line_property_changed", reinterpret_cast<PyCFunction>(PhoneLineChangedTriggerDetails_HasLinePropertyChanged), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneLineChangedTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineChangedTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhoneLineChangedTriggerDetails[] = {
        { "change_type", reinterpret_cast<getter>(PhoneLineChangedTriggerDetails_get_ChangeType), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneLineChangedTriggerDetails_get_LineId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhoneLineChangedTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineChangedTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineChangedTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineChangedTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineChangedTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PhoneLineChangedTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_calls_background.PhoneLineChangedTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneLineChangedTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineChangedTriggerDetails};

    // ----- PhoneNewVoicemailMessageTriggerDetails class --------------------

    static PyObject* _new_PhoneNewVoicemailMessageTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneNewVoicemailMessageTriggerDetails(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneNewVoicemailMessageTriggerDetails_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneNewVoicemailMessageTriggerDetails", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNewVoicemailMessageTriggerDetails_get_OperatorMessage(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneNewVoicemailMessageTriggerDetails", L"OperatorMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OperatorMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNewVoicemailMessageTriggerDetails_get_VoicemailCount(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.Background.PhoneNewVoicemailMessageTriggerDetails", L"VoicemailCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VoicemailCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneNewVoicemailMessageTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneNewVoicemailMessageTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneNewVoicemailMessageTriggerDetails[] = {
        { "_assign_array_", _assign_array_PhoneNewVoicemailMessageTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneNewVoicemailMessageTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhoneNewVoicemailMessageTriggerDetails[] = {
        { "line_id", reinterpret_cast<getter>(PhoneNewVoicemailMessageTriggerDetails_get_LineId), nullptr, nullptr, nullptr },
        { "operator_message", reinterpret_cast<getter>(PhoneNewVoicemailMessageTriggerDetails_get_OperatorMessage), nullptr, nullptr, nullptr },
        { "voicemail_count", reinterpret_cast<getter>(PhoneNewVoicemailMessageTriggerDetails_get_VoicemailCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhoneNewVoicemailMessageTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneNewVoicemailMessageTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneNewVoicemailMessageTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneNewVoicemailMessageTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneNewVoicemailMessageTriggerDetails) },
        { }};

    static PyType_Spec type_spec_PhoneNewVoicemailMessageTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_calls_background.PhoneNewVoicemailMessageTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::Background::PhoneNewVoicemailMessageTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneNewVoicemailMessageTriggerDetails};

    // ----- Windows.ApplicationModel.Calls.Background Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Calls.Background");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_calls_background",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Calls::Background

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_calls_background(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Calls::Background;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle PhoneCallBlockedTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PhoneCallBlockedTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PhoneCallBlockedTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PhoneCallOriginDataRequestTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PhoneCallOriginDataRequestTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PhoneCallOriginDataRequestTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PhoneIncomingCallDismissedTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PhoneIncomingCallDismissedTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PhoneIncomingCallDismissedTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PhoneIncomingCallNotificationTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PhoneIncomingCallNotificationTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PhoneIncomingCallNotificationTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PhoneLineChangedTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PhoneLineChangedTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PhoneLineChangedTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PhoneNewVoicemailMessageTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PhoneNewVoicemailMessageTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!PhoneNewVoicemailMessageTriggerDetails_type)
    {
        return nullptr;
    }


    return module.detach();
}
