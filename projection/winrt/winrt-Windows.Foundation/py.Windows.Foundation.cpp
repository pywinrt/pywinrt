// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Foundation.h"

namespace py::cpp::Windows::Foundation
{
    // ----- Deferral class --------------------

    static PyObject* _new_Deferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DeferralCompletedHandler>(args, 0);

                winrt::Windows::Foundation::Deferral instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Deferral(py::wrapper::Windows::Foundation::Deferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Deferral_Close(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Deferral", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Deferral_Complete(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Deferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Deferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Deferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Deferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Deferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_Deferral(py::wrapper::Windows::Foundation::Deferral* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_Deferral(py::wrapper::Windows::Foundation::Deferral* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Deferral[] = {
        { "close", reinterpret_cast<PyCFunction>(Deferral_Close), METH_VARARGS, nullptr },
        { "complete", reinterpret_cast<PyCFunction>(Deferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Deferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Deferral), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_Deferral), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_Deferral), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_Deferral[] = {
        { }};

    static PyType_Slot _type_slots_Deferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Deferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Deferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Deferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Deferral) },
        { }};

    static PyType_Spec type_spec_Deferral = {
        "winrt._winrt_windows_foundation.Deferral",
        sizeof(py::wrapper::Windows::Foundation::Deferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Deferral};

    // ----- GuidHelper class --------------------

    static PyObject* _new_GuidHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::GuidHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::GuidHelper>::type_name);
        return nullptr;
    }

    static PyObject* GuidHelper_CreateNewGuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.GuidHelper", L"CreateNewGuid", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::GuidHelper::CreateNewGuid();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.GuidHelper", L"Equals", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::GuidHelper::Equals(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidHelper_get_Empty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.GuidHelper", L"Empty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Foundation::GuidHelper::Empty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidHelper[] = {
        { }};

    static PyGetSetDef _getset_GuidHelper[] = {
        { }};

    static PyType_Slot _type_slots_GuidHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GuidHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GuidHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GuidHelper) },
        { }};

    static PyType_Spec type_spec_GuidHelper = {
        "winrt._winrt_windows_foundation.GuidHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidHelper};

    static PyGetSetDef getset_GuidHelper_Static[] = {
        { "empty", reinterpret_cast<getter>(GuidHelper_get_Empty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_GuidHelper_Static[] = {
        { "create_new_guid", reinterpret_cast<PyCFunction>(GuidHelper_CreateNewGuid), METH_VARARGS, nullptr },
        { "equals", reinterpret_cast<PyCFunction>(GuidHelper_Equals), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_GuidHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GuidHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GuidHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_GuidHelper_Static = {
        "winrt._winrt_windows_foundation.GuidHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GuidHelper_Static};

    // ----- MemoryBuffer class --------------------

    static PyObject* _new_MemoryBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Foundation::MemoryBuffer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MemoryBuffer_Close(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.MemoryBuffer", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.MemoryBuffer", L"CreateReference", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateReference();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::MemoryBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::MemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MemoryBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(MemoryBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(MemoryBuffer_CreateReference), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MemoryBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MemoryBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MemoryBuffer), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MemoryBuffer), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_MemoryBuffer[] = {
        { }};

    static PyType_Slot _type_slots_MemoryBuffer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MemoryBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MemoryBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MemoryBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MemoryBuffer) },
        { }};

    static PyType_Spec type_spec_MemoryBuffer = {
        "winrt._winrt_windows_foundation.MemoryBuffer",
        sizeof(py::wrapper::Windows::Foundation::MemoryBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MemoryBuffer};

    // ----- PropertyValue class --------------------

    static PyObject* _new_PropertyValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::PropertyValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::PropertyValue>::type_name);
        return nullptr;
    }

    static PyObject* PropertyValue_CreateBoolean(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateBoolean", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateBoolean(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateBooleanArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateBooleanArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<bool, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateBooleanArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateChar16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateChar16", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<char16_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateChar16(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateChar16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateChar16Array", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<char16_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateChar16Array(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDateTime", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateDateTime(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDateTimeArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDateTimeArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::DateTime, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateDateTimeArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDouble(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDouble", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateDouble(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDoubleArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateDoubleArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<double, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateDoubleArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateEmpty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateEmpty", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateEmpty();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateGuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateGuid", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateGuid(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateGuidArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateGuidArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::guid, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateGuidArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInspectable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInspectable", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateInspectable(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInspectableArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInspectableArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IInspectable, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateInspectableArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt16", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int16_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateInt16(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt16Array", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateInt16Array(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateInt32(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt32Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt32Array", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateInt32Array(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateInt64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt64Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateInt64Array", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateInt64Array(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreatePoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreatePoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreatePoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreatePointArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreatePointArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreatePointArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateRect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateRect(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateRectArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateRectArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Rect, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateRectArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSingle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSingle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateSingle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSingleArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSingleArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<float, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateSingleArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSize", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateSize(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSizeArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateSizeArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Size, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateSizeArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateString(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateString", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateString(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateStringArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateStringArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateStringArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateTimeSpan", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateTimeSpan(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateTimeSpanArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateTimeSpanArray", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::TimeSpan, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateTimeSpanArray(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt16", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateUInt16(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt16Array", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateUInt16Array(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateUInt32(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt32Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt32Array", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateUInt32Array(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt64", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateUInt64(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt64Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt64Array", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateUInt64Array(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt8(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt8", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateUInt8(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt8Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.PropertyValue", L"CreateUInt8Array", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::PropertyValue::CreateUInt8Array(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PropertyValue[] = {
        { }};

    static PyGetSetDef _getset_PropertyValue[] = {
        { }};

    static PyType_Slot _type_slots_PropertyValue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PropertyValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PropertyValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PropertyValue) },
        { }};

    static PyType_Spec type_spec_PropertyValue = {
        "winrt._winrt_windows_foundation.PropertyValue",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PropertyValue};

    static PyGetSetDef getset_PropertyValue_Static[] = {
        { }};

    static PyMethodDef methods_PropertyValue_Static[] = {
        { "create_boolean", reinterpret_cast<PyCFunction>(PropertyValue_CreateBoolean), METH_VARARGS, nullptr },
        { "create_boolean_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateBooleanArray), METH_VARARGS, nullptr },
        { "create_char16", reinterpret_cast<PyCFunction>(PropertyValue_CreateChar16), METH_VARARGS, nullptr },
        { "create_char16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateChar16Array), METH_VARARGS, nullptr },
        { "create_date_time", reinterpret_cast<PyCFunction>(PropertyValue_CreateDateTime), METH_VARARGS, nullptr },
        { "create_date_time_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateDateTimeArray), METH_VARARGS, nullptr },
        { "create_double", reinterpret_cast<PyCFunction>(PropertyValue_CreateDouble), METH_VARARGS, nullptr },
        { "create_double_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateDoubleArray), METH_VARARGS, nullptr },
        { "create_empty", reinterpret_cast<PyCFunction>(PropertyValue_CreateEmpty), METH_VARARGS, nullptr },
        { "create_guid", reinterpret_cast<PyCFunction>(PropertyValue_CreateGuid), METH_VARARGS, nullptr },
        { "create_guid_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateGuidArray), METH_VARARGS, nullptr },
        { "create_inspectable", reinterpret_cast<PyCFunction>(PropertyValue_CreateInspectable), METH_VARARGS, nullptr },
        { "create_inspectable_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInspectableArray), METH_VARARGS, nullptr },
        { "create_int16", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt16), METH_VARARGS, nullptr },
        { "create_int16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt16Array), METH_VARARGS, nullptr },
        { "create_int32", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt32), METH_VARARGS, nullptr },
        { "create_int32_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt32Array), METH_VARARGS, nullptr },
        { "create_int64", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt64), METH_VARARGS, nullptr },
        { "create_int64_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateInt64Array), METH_VARARGS, nullptr },
        { "create_point", reinterpret_cast<PyCFunction>(PropertyValue_CreatePoint), METH_VARARGS, nullptr },
        { "create_point_array", reinterpret_cast<PyCFunction>(PropertyValue_CreatePointArray), METH_VARARGS, nullptr },
        { "create_rect", reinterpret_cast<PyCFunction>(PropertyValue_CreateRect), METH_VARARGS, nullptr },
        { "create_rect_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateRectArray), METH_VARARGS, nullptr },
        { "create_single", reinterpret_cast<PyCFunction>(PropertyValue_CreateSingle), METH_VARARGS, nullptr },
        { "create_single_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateSingleArray), METH_VARARGS, nullptr },
        { "create_size", reinterpret_cast<PyCFunction>(PropertyValue_CreateSize), METH_VARARGS, nullptr },
        { "create_size_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateSizeArray), METH_VARARGS, nullptr },
        { "create_string", reinterpret_cast<PyCFunction>(PropertyValue_CreateString), METH_VARARGS, nullptr },
        { "create_string_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateStringArray), METH_VARARGS, nullptr },
        { "create_time_span", reinterpret_cast<PyCFunction>(PropertyValue_CreateTimeSpan), METH_VARARGS, nullptr },
        { "create_time_span_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateTimeSpanArray), METH_VARARGS, nullptr },
        { "create_uint16", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt16), METH_VARARGS, nullptr },
        { "create_uint16_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt16Array), METH_VARARGS, nullptr },
        { "create_uint32", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt32), METH_VARARGS, nullptr },
        { "create_uint32_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt32Array), METH_VARARGS, nullptr },
        { "create_uint64", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt64), METH_VARARGS, nullptr },
        { "create_uint64_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt64Array), METH_VARARGS, nullptr },
        { "create_uint8", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt8), METH_VARARGS, nullptr },
        { "create_uint8_array", reinterpret_cast<PyCFunction>(PropertyValue_CreateUInt8Array), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PropertyValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PropertyValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PropertyValue_Static) },
        { }
    };

    static PyType_Spec type_spec_PropertyValue_Static = {
        "winrt._winrt_windows_foundation.PropertyValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PropertyValue_Static};

    // ----- Uri class --------------------

    static PyObject* _new_Uri(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Uri instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Foundation::Uri instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Uri(py::wrapper::Windows::Foundation::Uri* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Uri_CombineUri(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"CombineUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CombineUri(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_Equals(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"Equals", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Equals(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_EscapeComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"EscapeComponent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::Uri::EscapeComponent(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_ToString(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"ToString", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ToString();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_UnescapeComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Uri", L"UnescapeComponent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::Uri::UnescapeComponent(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_get_AbsoluteUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"AbsoluteUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AbsoluteUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_DisplayUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"DisplayUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Domain(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Domain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Domain();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Extension(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Extension");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Extension();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Fragment(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Fragment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Fragment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Host(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Host");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Host();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Password(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Password");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Password();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Path(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Port(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Port");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Port();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Query(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Query");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Query();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_QueryParsed(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"QueryParsed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryParsed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_RawUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"RawUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RawUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_SchemeName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"SchemeName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SchemeName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Suspicious(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"Suspicious");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Suspicious();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_UserName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"UserName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_AbsoluteCanonicalUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"AbsoluteCanonicalUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AbsoluteCanonicalUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_DisplayIri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Uri", L"DisplayIri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayIri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Uri(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Uri>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Uri(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Uri>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_Uri(py::wrapper::Windows::Foundation::Uri* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.ToString();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Uri[] = {
        { "combine_uri", reinterpret_cast<PyCFunction>(Uri_CombineUri), METH_VARARGS, nullptr },
        { "equals", reinterpret_cast<PyCFunction>(Uri_Equals), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(Uri_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Uri, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Uri), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Uri[] = {
        { "absolute_uri", reinterpret_cast<getter>(Uri_get_AbsoluteUri), nullptr, nullptr, nullptr },
        { "display_uri", reinterpret_cast<getter>(Uri_get_DisplayUri), nullptr, nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(Uri_get_Domain), nullptr, nullptr, nullptr },
        { "extension", reinterpret_cast<getter>(Uri_get_Extension), nullptr, nullptr, nullptr },
        { "fragment", reinterpret_cast<getter>(Uri_get_Fragment), nullptr, nullptr, nullptr },
        { "host", reinterpret_cast<getter>(Uri_get_Host), nullptr, nullptr, nullptr },
        { "password", reinterpret_cast<getter>(Uri_get_Password), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(Uri_get_Path), nullptr, nullptr, nullptr },
        { "port", reinterpret_cast<getter>(Uri_get_Port), nullptr, nullptr, nullptr },
        { "query", reinterpret_cast<getter>(Uri_get_Query), nullptr, nullptr, nullptr },
        { "query_parsed", reinterpret_cast<getter>(Uri_get_QueryParsed), nullptr, nullptr, nullptr },
        { "raw_uri", reinterpret_cast<getter>(Uri_get_RawUri), nullptr, nullptr, nullptr },
        { "scheme_name", reinterpret_cast<getter>(Uri_get_SchemeName), nullptr, nullptr, nullptr },
        { "suspicious", reinterpret_cast<getter>(Uri_get_Suspicious), nullptr, nullptr, nullptr },
        { "user_name", reinterpret_cast<getter>(Uri_get_UserName), nullptr, nullptr, nullptr },
        { "absolute_canonical_uri", reinterpret_cast<getter>(Uri_get_AbsoluteCanonicalUri), nullptr, nullptr, nullptr },
        { "display_iri", reinterpret_cast<getter>(Uri_get_DisplayIri), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Uri[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Uri) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Uri) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Uri) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Uri) },
        { Py_tp_str, reinterpret_cast<void*>(_str_Uri) },
        { }};

    static PyType_Spec type_spec_Uri = {
        "winrt._winrt_windows_foundation.Uri",
        sizeof(py::wrapper::Windows::Foundation::Uri),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Uri};

    static PyGetSetDef getset_Uri_Static[] = {
        { }};

    static PyMethodDef methods_Uri_Static[] = {
        { "escape_component", reinterpret_cast<PyCFunction>(Uri_EscapeComponent), METH_VARARGS, nullptr },
        { "unescape_component", reinterpret_cast<PyCFunction>(Uri_UnescapeComponent), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Uri_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Uri_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Uri_Static) },
        { }
    };

    static PyType_Spec type_spec_Uri_Static = {
        "winrt._winrt_windows_foundation.Uri_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Uri_Static};

    // ----- WwwFormUrlDecoder class --------------------

    static PyObject* _new_WwwFormUrlDecoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::WwwFormUrlDecoder instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WwwFormUrlDecoder_First(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetAt(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetFirstValueByName(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetFirstValueByName", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFirstValueByName(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetMany(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry, true>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_IndexOf(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
                uint32_t param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IndexOf(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_get_Size(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoder", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WwwFormUrlDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::WwwFormUrlDecoder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WwwFormUrlDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetAt(static_cast<uint32_t>(i));
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_WwwFormUrlDecoder(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            auto size = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.Size();
            }();
            if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::get());

            auto count = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetMany(static_cast<uint32_t>(start), items);
            }();

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwwFormUrlDecoder[] = {
        { "first", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetAt), METH_VARARGS, nullptr },
        { "get_first_value_by_name", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetFirstValueByName), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(WwwFormUrlDecoder_IndexOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WwwFormUrlDecoder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwwFormUrlDecoder), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WwwFormUrlDecoder[] = {
        { "size", reinterpret_cast<getter>(WwwFormUrlDecoder_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WwwFormUrlDecoder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WwwFormUrlDecoder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WwwFormUrlDecoder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WwwFormUrlDecoder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WwwFormUrlDecoder) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_WwwFormUrlDecoder) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_WwwFormUrlDecoder) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_WwwFormUrlDecoder) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_WwwFormUrlDecoder) },
        { }};

    static PyType_Spec type_spec_WwwFormUrlDecoder = {
        "winrt._winrt_windows_foundation.WwwFormUrlDecoder",
        sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwwFormUrlDecoder};

    // ----- WwwFormUrlDecoderEntry class --------------------

    static PyObject* _new_WwwFormUrlDecoderEntry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::type_name);
        return nullptr;
    }

    static void _dealloc_WwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoderEntry", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.WwwFormUrlDecoderEntry", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwwFormUrlDecoderEntry[] = {
        { "_assign_array_", _assign_array_WwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwwFormUrlDecoderEntry), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WwwFormUrlDecoderEntry[] = {
        { "name", reinterpret_cast<getter>(WwwFormUrlDecoderEntry_get_Name), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WwwFormUrlDecoderEntry_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WwwFormUrlDecoderEntry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WwwFormUrlDecoderEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WwwFormUrlDecoderEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WwwFormUrlDecoderEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WwwFormUrlDecoderEntry) },
        { }};

    static PyType_Spec type_spec_WwwFormUrlDecoderEntry = {
        "winrt._winrt_windows_foundation.WwwFormUrlDecoderEntry",
        sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwwFormUrlDecoderEntry};

    // ----- IAsyncAction interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAsyncAction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IAsyncAction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IAsyncAction>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncAction_Cancel(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_Close(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_GetResults(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncAction", L"GetResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.GetResults();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncAction", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncAction_put_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncAction", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncAction_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Id(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Status(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyObject* get_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* /*unused*/) noexcept
    {
        if (winrt::impl::is_sta_thread())
        {
            PyErr_SetString(PyExc_RuntimeError, "Cannot call blocking method from single-threaded apartment.");
            return nullptr;
        }

        try
        {
            auto _gil = py::release_gil();
            self->obj.get();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }

        Py_RETURN_NONE;
    }

    static PyObject* wait_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* arg) noexcept
    {
        if (winrt::impl::is_sta_thread())
        {
            PyErr_SetString(PyExc_RuntimeError, "Cannot call blocking method from single-threaded apartment.");
            return nullptr;
        }

        auto timeout = PyFloat_AsDouble(arg);
        if (timeout == -1.0 && PyErr_Occurred())
        {
            return nullptr;
        }

        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                auto duration = std::chrono::duration_cast<winrt::Windows::Foundation::TimeSpan>(std::chrono::duration<double>(timeout));
                return self->obj.wait_for(duration);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAsyncAction[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncAction_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncAction_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncAction_GetResults), METH_VARARGS, nullptr },
        { "get", reinterpret_cast<PyCFunction>(get_IAsyncAction), METH_NOARGS, nullptr },
        { "wait", reinterpret_cast<PyCFunction>(wait_IAsyncAction), METH_O, nullptr },
        { }};

    static PyGetSetDef _getset_IAsyncAction[] = {
        { "completed", reinterpret_cast<getter>(IAsyncAction_get_Completed), reinterpret_cast<setter>(IAsyncAction_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncAction_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncAction_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncAction_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAsyncAction[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncAction) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncAction) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncAction) },
        { }};

    static PyType_Spec type_spec_IAsyncAction = {
        "winrt._winrt_windows_foundation._IAsyncAction",
        sizeof(py::wrapper::Windows::Foundation::IAsyncAction),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAsyncAction};

    struct ImplementsIAsyncAction : py::ImplementsInterfaceT<ImplementsIAsyncAction, winrt::Windows::Foundation::IAsyncAction>
    {
        ImplementsIAsyncAction() = delete;
        ImplementsIAsyncAction(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAsyncAction, winrt::Windows::Foundation::IAsyncAction>(py_obj, runtime_class)
        {
        }

        auto Cancel()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "cancel")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetResults()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_results")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Completed()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "completed")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Completed(winrt::Windows::Foundation::AsyncActionCompletedHandler const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "completed", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ErrorCode()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "error_code")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hresult>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Id()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Status()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "status")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::AsyncStatus>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAsyncAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IAsyncAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAsyncAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAsyncAction(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IAsyncAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAsyncAction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAsyncAction>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAsyncAction[] = {
        { "get", reinterpret_cast<PyCFunction>(get_IAsyncAction), METH_NOARGS, nullptr },
        { "wait", reinterpret_cast<PyCFunction>(wait_IAsyncAction), METH_O, nullptr },
        { "_assign_array_", _assign_array_IAsyncAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAsyncAction), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAsyncAction), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAsyncAction), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAsyncAction[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAsyncAction) },
        { }};

    static PyType_Spec type_spec_ImplementsIAsyncAction = {
        "winrt._winrt_windows_foundation.IAsyncAction",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAsyncAction};

    // ----- IAsyncActionWithProgress interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAsyncActionWithProgress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncActionWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->Cancel(args);
    }

    static PyObject* IAsyncActionWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->Close(args);
    }

    static PyObject* IAsyncActionWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->GetResults(args);
    }

    static PyObject* IAsyncActionWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Progress();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncActionWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Progress(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncActionWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Completed();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncActionWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncActionWithProgress`1", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Completed(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncActionWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_ErrorCode();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncActionWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Id();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncActionWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Status();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self) noexcept
    {
        return self->impl->dunder_await();
    }

    static PyObject* get_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* /*unused*/) noexcept
    {
        return self->impl->async_get();
    }

    static PyObject* wait_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg) noexcept
    {
        return self->impl->async_wait(arg);
    }

    static PyMethodDef _methods_IAsyncActionWithProgress[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncActionWithProgress_GetResults), METH_VARARGS, nullptr },
        { "get", reinterpret_cast<PyCFunction>(get_IAsyncActionWithProgress), METH_NOARGS, nullptr },
        { "wait", reinterpret_cast<PyCFunction>(wait_IAsyncActionWithProgress), METH_O, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }};

    static PyGetSetDef _getset_IAsyncActionWithProgress[] = {
        { "progress", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Progress), reinterpret_cast<setter>(IAsyncActionWithProgress_put_Progress), nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Completed), reinterpret_cast<setter>(IAsyncActionWithProgress_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncActionWithProgress_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncActionWithProgress_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAsyncActionWithProgress[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncActionWithProgress) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncActionWithProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncActionWithProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncActionWithProgress) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncActionWithProgress) },
        { }};

    static PyType_Spec type_spec_IAsyncActionWithProgress = {
        "winrt._winrt_windows_foundation._IAsyncActionWithProgress",
        sizeof(py::wrapper::Windows::Foundation::IAsyncActionWithProgress),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAsyncActionWithProgress};

    static PyObject* _guid_ImplementsIAsyncActionWithProgress(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAsyncActionWithProgress(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAsyncActionWithProgress[] = {
        { "get", reinterpret_cast<PyCFunction>(get_IAsyncActionWithProgress), METH_NOARGS, nullptr },
        { "wait", reinterpret_cast<PyCFunction>(wait_IAsyncActionWithProgress), METH_O, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAsyncActionWithProgress), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAsyncActionWithProgress), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAsyncActionWithProgress[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAsyncActionWithProgress) },
        { }};

    static PyType_Spec type_spec_ImplementsIAsyncActionWithProgress = {
        "winrt._winrt_windows_foundation.IAsyncActionWithProgress",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAsyncActionWithProgress};

    // ----- IAsyncInfo interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAsyncInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IAsyncInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IAsyncInfo>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAsyncInfo(py::wrapper::Windows::Foundation::IAsyncInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncInfo_Cancel(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_Close(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IAsyncInfo", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_Id(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_Status(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAsyncInfo[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncInfo_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncInfo_Close), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAsyncInfo[] = {
        { "error_code", reinterpret_cast<getter>(IAsyncInfo_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncInfo_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncInfo_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAsyncInfo[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncInfo) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncInfo) },
        { }};

    static PyType_Spec type_spec_IAsyncInfo = {
        "winrt._winrt_windows_foundation._IAsyncInfo",
        sizeof(py::wrapper::Windows::Foundation::IAsyncInfo),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAsyncInfo};

    struct ImplementsIAsyncInfo : py::ImplementsInterfaceT<ImplementsIAsyncInfo, winrt::Windows::Foundation::IAsyncInfo>
    {
        ImplementsIAsyncInfo() = delete;
        ImplementsIAsyncInfo(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAsyncInfo, winrt::Windows::Foundation::IAsyncInfo>(py_obj, runtime_class)
        {
        }

        auto Cancel()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "cancel")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ErrorCode()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "error_code")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hresult>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Id()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Status()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "status")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::AsyncStatus>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAsyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IAsyncInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAsyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAsyncInfo(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IAsyncInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAsyncInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAsyncInfo>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAsyncInfo[] = {
        { "_assign_array_", _assign_array_IAsyncInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAsyncInfo), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAsyncInfo), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAsyncInfo), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAsyncInfo[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAsyncInfo) },
        { }};

    static PyType_Spec type_spec_ImplementsIAsyncInfo = {
        "winrt._winrt_windows_foundation.IAsyncInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAsyncInfo};

    // ----- IAsyncOperationWithProgress interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAsyncOperationWithProgress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncOperationWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->Cancel(args);
    }

    static PyObject* IAsyncOperationWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->Close(args);
    }

    static PyObject* IAsyncOperationWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->impl->GetResults(args);
    }

    static PyObject* IAsyncOperationWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Progress();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncOperationWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Progress(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncOperationWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Completed();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncOperationWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperationWithProgress`2", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Completed(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncOperationWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_ErrorCode();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncOperationWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Id();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncOperationWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Status();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self) noexcept
    {
        return self->impl->dunder_await();
    }

    static PyObject* get_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* /*unused*/) noexcept
    {
        return self->impl->async_get();
    }

    static PyObject* wait_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg) noexcept
    {
        return self->impl->async_wait(arg);
    }

    static PyMethodDef _methods_IAsyncOperationWithProgress[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncOperationWithProgress_GetResults), METH_VARARGS, nullptr },
        { "get", reinterpret_cast<PyCFunction>(get_IAsyncOperationWithProgress), METH_NOARGS, nullptr },
        { "wait", reinterpret_cast<PyCFunction>(wait_IAsyncOperationWithProgress), METH_O, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }};

    static PyGetSetDef _getset_IAsyncOperationWithProgress[] = {
        { "progress", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Progress), reinterpret_cast<setter>(IAsyncOperationWithProgress_put_Progress), nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Completed), reinterpret_cast<setter>(IAsyncOperationWithProgress_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncOperationWithProgress_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAsyncOperationWithProgress[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncOperationWithProgress) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncOperationWithProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncOperationWithProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncOperationWithProgress) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncOperationWithProgress) },
        { }};

    static PyType_Spec type_spec_IAsyncOperationWithProgress = {
        "winrt._winrt_windows_foundation._IAsyncOperationWithProgress",
        sizeof(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAsyncOperationWithProgress};

    static PyObject* _guid_ImplementsIAsyncOperationWithProgress(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAsyncOperationWithProgress(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAsyncOperationWithProgress[] = {
        { "get", reinterpret_cast<PyCFunction>(get_IAsyncOperationWithProgress), METH_NOARGS, nullptr },
        { "wait", reinterpret_cast<PyCFunction>(wait_IAsyncOperationWithProgress), METH_O, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAsyncOperationWithProgress), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAsyncOperationWithProgress), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAsyncOperationWithProgress[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAsyncOperationWithProgress) },
        { }};

    static PyType_Spec type_spec_ImplementsIAsyncOperationWithProgress = {
        "winrt._winrt_windows_foundation.IAsyncOperationWithProgress",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAsyncOperationWithProgress};

    // ----- IAsyncOperation interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAsyncOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IAsyncOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IAsyncOperation>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAsyncOperation_Cancel(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->impl->Cancel(args);
    }

    static PyObject* IAsyncOperation_Close(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->impl->Close(args);
    }

    static PyObject* IAsyncOperation_GetResults(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->impl->GetResults(args);
    }

    static PyObject* IAsyncOperation_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperation`1", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Completed();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncOperation_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncOperation`1", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            return self->impl->put_Completed(arg);
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncOperation_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_ErrorCode();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncOperation_get_Id(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Id();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncOperation_get_Status(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IAsyncInfo", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Status();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self) noexcept
    {
        return self->impl->dunder_await();
    }

    static PyObject* get_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* /*unused*/) noexcept
    {
        return self->impl->async_get();
    }

    static PyObject* wait_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* arg) noexcept
    {
        return self->impl->async_wait(arg);
    }

    static PyMethodDef _methods_IAsyncOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(IAsyncOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAsyncOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(IAsyncOperation_GetResults), METH_VARARGS, nullptr },
        { "get", reinterpret_cast<PyCFunction>(get_IAsyncOperation), METH_NOARGS, nullptr },
        { "wait", reinterpret_cast<PyCFunction>(wait_IAsyncOperation), METH_O, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }};

    static PyGetSetDef _getset_IAsyncOperation[] = {
        { "completed", reinterpret_cast<getter>(IAsyncOperation_get_Completed), reinterpret_cast<setter>(IAsyncOperation_put_Completed), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(IAsyncOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IAsyncOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(IAsyncOperation_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAsyncOperation[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAsyncOperation) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAsyncOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAsyncOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAsyncOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_IAsyncOperation) },
        { }};

    static PyType_Spec type_spec_IAsyncOperation = {
        "winrt._winrt_windows_foundation._IAsyncOperation",
        sizeof(py::wrapper::Windows::Foundation::IAsyncOperation),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAsyncOperation};

    static PyObject* _guid_ImplementsIAsyncOperation(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAsyncOperation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAsyncOperation[] = {
        { "get", reinterpret_cast<PyCFunction>(get_IAsyncOperation), METH_NOARGS, nullptr },
        { "wait", reinterpret_cast<PyCFunction>(wait_IAsyncOperation), METH_O, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAsyncOperation), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAsyncOperation), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAsyncOperation[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAsyncOperation) },
        { }};

    static PyType_Spec type_spec_ImplementsIAsyncOperation = {
        "winrt._winrt_windows_foundation.IAsyncOperation",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAsyncOperation};

    // ----- IClosable interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IClosable(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IClosable>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IClosable>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IClosable(py::wrapper::Windows::Foundation::IClosable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IClosable_Close(py::wrapper::Windows::Foundation::IClosable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _enter_IClosable(py::wrapper::Windows::Foundation::IClosable* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IClosable(py::wrapper::Windows::Foundation::IClosable* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IClosable[] = {
        { "close", reinterpret_cast<PyCFunction>(IClosable_Close), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IClosable), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IClosable), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IClosable[] = {
        { }};

    static PyType_Slot _type_slots_IClosable[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IClosable) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IClosable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IClosable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IClosable) },
        { }};

    static PyType_Spec type_spec_IClosable = {
        "winrt._winrt_windows_foundation._IClosable",
        sizeof(py::wrapper::Windows::Foundation::IClosable),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IClosable};

    struct ImplementsIClosable : py::ImplementsInterfaceT<ImplementsIClosable, winrt::Windows::Foundation::IClosable>
    {
        ImplementsIClosable() = delete;
        ImplementsIClosable(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIClosable, winrt::Windows::Foundation::IClosable>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IClosable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IClosable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IClosable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IClosable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIClosable(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IClosable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIClosable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIClosable>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIClosable[] = {
        { "_assign_array_", _assign_array_IClosable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IClosable), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIClosable), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIClosable), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIClosable[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIClosable) },
        { }};

    static PyType_Spec type_spec_ImplementsIClosable = {
        "winrt._winrt_windows_foundation.IClosable",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIClosable};

    // ----- IGetActivationFactory interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IGetActivationFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IGetActivationFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IGetActivationFactory>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IGetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGetActivationFactory_GetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IGetActivationFactory", L"GetActivationFactory", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetActivationFactory(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGetActivationFactory[] = {
        { "get_activation_factory", reinterpret_cast<PyCFunction>(IGetActivationFactory_GetActivationFactory), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IGetActivationFactory[] = {
        { }};

    static PyType_Slot _type_slots_IGetActivationFactory[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IGetActivationFactory) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGetActivationFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGetActivationFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGetActivationFactory) },
        { }};

    static PyType_Spec type_spec_IGetActivationFactory = {
        "winrt._winrt_windows_foundation._IGetActivationFactory",
        sizeof(py::wrapper::Windows::Foundation::IGetActivationFactory),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IGetActivationFactory};

    struct ImplementsIGetActivationFactory : py::ImplementsInterfaceT<ImplementsIGetActivationFactory, winrt::Windows::Foundation::IGetActivationFactory>
    {
        ImplementsIGetActivationFactory() = delete;
        ImplementsIGetActivationFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGetActivationFactory, winrt::Windows::Foundation::IGetActivationFactory>(py_obj, runtime_class)
        {
        }

        auto GetActivationFactory(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_activation_factory")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IGetActivationFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IGetActivationFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGetActivationFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IGetActivationFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIGetActivationFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IGetActivationFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGetActivationFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGetActivationFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGetActivationFactory[] = {
        { "_assign_array_", _assign_array_IGetActivationFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGetActivationFactory), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGetActivationFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGetActivationFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIGetActivationFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGetActivationFactory) },
        { }};

    static PyType_Spec type_spec_ImplementsIGetActivationFactory = {
        "winrt._winrt_windows_foundation.IGetActivationFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIGetActivationFactory};

    // ----- IMemoryBuffer interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IMemoryBuffer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IMemoryBuffer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IMemoryBuffer>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMemoryBuffer_Close(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IMemoryBuffer", L"CreateReference", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateReference();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _enter_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMemoryBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(IMemoryBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(IMemoryBuffer_CreateReference), METH_VARARGS, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMemoryBuffer), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IMemoryBuffer), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IMemoryBuffer[] = {
        { }};

    static PyType_Slot _type_slots_IMemoryBuffer[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IMemoryBuffer) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMemoryBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMemoryBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMemoryBuffer) },
        { }};

    static PyType_Spec type_spec_IMemoryBuffer = {
        "winrt._winrt_windows_foundation._IMemoryBuffer",
        sizeof(py::wrapper::Windows::Foundation::IMemoryBuffer),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IMemoryBuffer};

    struct ImplementsIMemoryBuffer : py::ImplementsInterfaceT<ImplementsIMemoryBuffer, winrt::Windows::Foundation::IMemoryBuffer>
    {
        ImplementsIMemoryBuffer() = delete;
        ImplementsIMemoryBuffer(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIMemoryBuffer, winrt::Windows::Foundation::IMemoryBuffer>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateReference()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_reference")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IMemoryBufferReference>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IMemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IMemoryBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIMemoryBuffer(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IMemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIMemoryBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIMemoryBuffer>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIMemoryBuffer[] = {
        { "_assign_array_", _assign_array_IMemoryBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMemoryBuffer), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIMemoryBuffer), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIMemoryBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIMemoryBuffer[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIMemoryBuffer) },
        { }};

    static PyType_Spec type_spec_ImplementsIMemoryBuffer = {
        "winrt._winrt_windows_foundation.IMemoryBuffer",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIMemoryBuffer};

    // ----- IMemoryBufferReference interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IMemoryBufferReference(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IMemoryBufferReference>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IMemoryBufferReference>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMemoryBufferReference_Close(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_get_Capacity(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IMemoryBufferReference", L"Capacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Capacity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_add_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.IMemoryBufferReference", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IMemoryBufferReference, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_remove_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.IMemoryBufferReference", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _get_buffer_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, Py_buffer* view, int flags) noexcept
    {
        try
        {
            return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.Capacity()), 0, flags);
        }
        catch (...)
        {
            view->obj = nullptr;
            PyErr_SetNone(PyExc_BufferError);
            return -1;
        }
    }

    static PyMethodDef _methods_IMemoryBufferReference[] = {
        { "close", reinterpret_cast<PyCFunction>(IMemoryBufferReference_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(IMemoryBufferReference_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(IMemoryBufferReference_remove_Closed), METH_O, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMemoryBufferReference), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IMemoryBufferReference), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IMemoryBufferReference[] = {
        { "capacity", reinterpret_cast<getter>(IMemoryBufferReference_get_Capacity), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IMemoryBufferReference[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IMemoryBufferReference) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMemoryBufferReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMemoryBufferReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMemoryBufferReference) },
        { Py_bf_getbuffer, reinterpret_cast<void*>(_get_buffer_IMemoryBufferReference) },
        { }};

    static PyType_Spec type_spec_IMemoryBufferReference = {
        "winrt._winrt_windows_foundation._IMemoryBufferReference",
        sizeof(py::wrapper::Windows::Foundation::IMemoryBufferReference),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IMemoryBufferReference};

    struct ImplementsIMemoryBufferReference : py::ImplementsInterfaceT<ImplementsIMemoryBufferReference, winrt::Windows::Foundation::IMemoryBufferReference>
    {
        ImplementsIMemoryBufferReference() = delete;
        ImplementsIMemoryBufferReference(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIMemoryBufferReference, winrt::Windows::Foundation::IMemoryBufferReference>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Capacity()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "capacity")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Closed(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IMemoryBufferReference, winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_closed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Closed(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_closed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IMemoryBufferReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IMemoryBufferReference>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMemoryBufferReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBufferReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIMemoryBufferReference(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IMemoryBufferReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIMemoryBufferReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIMemoryBufferReference>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIMemoryBufferReference[] = {
        { "_assign_array_", _assign_array_IMemoryBufferReference, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMemoryBufferReference), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIMemoryBufferReference), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIMemoryBufferReference), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIMemoryBufferReference[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIMemoryBufferReference) },
        { }};

    static PyType_Spec type_spec_ImplementsIMemoryBufferReference = {
        "winrt._winrt_windows_foundation.IMemoryBufferReference",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIMemoryBufferReference};

    // ----- IPropertyValue interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IPropertyValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IPropertyValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IPropertyValue>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IPropertyValue(py::wrapper::Windows::Foundation::IPropertyValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPropertyValue_GetBoolean(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBoolean", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBoolean();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetBooleanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetBooleanArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<bool> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetBooleanArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetChar16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetChar16();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetChar16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetChar16Array", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<char16_t> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetChar16Array(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDateTime(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTime", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDateTime();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDateTimeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDateTimeArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::DateTime> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetDateTimeArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDouble(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDouble", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDouble();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDoubleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetDoubleArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<double> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetDoubleArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetGuid(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuid", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetGuid();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetGuidArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetGuidArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::guid> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetGuidArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInspectableArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInspectableArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::IInspectable> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetInspectableArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetInt16();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt16Array", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<int16_t> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetInt16Array(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetInt32();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt32Array", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<int32_t> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetInt32Array(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetInt64();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetInt64Array", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<int64_t> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetInt64Array(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetPoint(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPoint", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPoint();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetPointArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetPointArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::Point> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetPointArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetRect(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRect", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetRect();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetRectArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetRectArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::Rect> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetRectArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSingle(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSingle();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSingleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSingleArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<float> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetSingleArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSize(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSize", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSize();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSizeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetSizeArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::Size> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetSizeArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetString(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetString", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetString();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetStringArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetStringArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::hstring> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetStringArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetTimeSpan(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpan", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetTimeSpan();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetTimeSpanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetTimeSpanArray", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetTimeSpanArray(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUInt16();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt16Array", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint16_t> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetUInt16Array(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUInt32();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt32Array", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint32_t> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetUInt32Array(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUInt64();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt64Array", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint64_t> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetUInt64Array(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt8(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUInt8();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt8Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IPropertyValue", L"GetUInt8Array", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetUInt8Array(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_get_IsNumericScalar(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsNumericScalar();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_get_Type(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPropertyValue[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IPropertyValue_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IPropertyValue_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IPropertyValue_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IPropertyValue_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IPropertyValue_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IPropertyValue_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IPropertyValue_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IPropertyValue_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IPropertyValue_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IPropertyValue_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IPropertyValue_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IPropertyValue_GetUInt8Array), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPropertyValue[] = {
        { "is_numeric_scalar", reinterpret_cast<getter>(IPropertyValue_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IPropertyValue_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPropertyValue[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IPropertyValue) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPropertyValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPropertyValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPropertyValue) },
        { }};

    static PyType_Spec type_spec_IPropertyValue = {
        "winrt._winrt_windows_foundation._IPropertyValue",
        sizeof(py::wrapper::Windows::Foundation::IPropertyValue),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IPropertyValue};

    struct ImplementsIPropertyValue : py::ImplementsInterfaceT<ImplementsIPropertyValue, winrt::Windows::Foundation::IPropertyValue>
    {
        ImplementsIPropertyValue() = delete;
        ImplementsIPropertyValue(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPropertyValue, winrt::Windows::Foundation::IPropertyValue>(py_obj, runtime_class)
        {
        }

        auto GetBoolean()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_boolean")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetBooleanArray(winrt::com_array<bool>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_boolean_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<bool, false>>(return_value.get(), 0);
                param0 = winrt::com_array<bool>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetChar16()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_char16")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<char16_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetChar16Array(winrt::com_array<char16_t>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_char16_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<char16_t, false>>(return_value.get(), 0);
                param0 = winrt::com_array<char16_t>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetDateTime()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_date_time")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetDateTimeArray(winrt::com_array<winrt::Windows::Foundation::DateTime>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_date_time_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::DateTime, false>>(return_value.get(), 0);
                param0 = winrt::com_array<winrt::Windows::Foundation::DateTime>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetDouble()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_double")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetDoubleArray(winrt::com_array<double>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_double_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<double, false>>(return_value.get(), 0);
                param0 = winrt::com_array<double>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetGuid()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_guid")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetGuidArray(winrt::com_array<winrt::guid>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_guid_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<winrt::guid, false>>(return_value.get(), 0);
                param0 = winrt::com_array<winrt::guid>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetInspectableArray(winrt::com_array<winrt::Windows::Foundation::IInspectable>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_inspectable_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::IInspectable, false>>(return_value.get(), 0);
                param0 = winrt::com_array<winrt::Windows::Foundation::IInspectable>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetInt16()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_int16")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int16_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetInt16Array(winrt::com_array<int16_t>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_int16_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<int16_t, false>>(return_value.get(), 0);
                param0 = winrt::com_array<int16_t>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetInt32()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_int32")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetInt32Array(winrt::com_array<int32_t>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_int32_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<int32_t, false>>(return_value.get(), 0);
                param0 = winrt::com_array<int32_t>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetInt64()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_int64")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int64_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetInt64Array(winrt::com_array<int64_t>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_int64_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<int64_t, false>>(return_value.get(), 0);
                param0 = winrt::com_array<int64_t>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetPoint()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_point")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Point>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetPointArray(winrt::com_array<winrt::Windows::Foundation::Point>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_point_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(return_value.get(), 0);
                param0 = winrt::com_array<winrt::Windows::Foundation::Point>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetRect()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_rect")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Rect>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetRectArray(winrt::com_array<winrt::Windows::Foundation::Rect>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_rect_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Rect, false>>(return_value.get(), 0);
                param0 = winrt::com_array<winrt::Windows::Foundation::Rect>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetSingle()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_single")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<float>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetSingleArray(winrt::com_array<float>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_single_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<float, false>>(return_value.get(), 0);
                param0 = winrt::com_array<float>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetSize()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_size")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Size>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetSizeArray(winrt::com_array<winrt::Windows::Foundation::Size>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_size_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Size, false>>(return_value.get(), 0);
                param0 = winrt::com_array<winrt::Windows::Foundation::Size>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetString()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_string")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetStringArray(winrt::com_array<winrt::hstring>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_string_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<winrt::hstring, false>>(return_value.get(), 0);
                param0 = winrt::com_array<winrt::hstring>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetTimeSpan()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_time_span")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::TimeSpan>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetTimeSpanArray(winrt::com_array<winrt::Windows::Foundation::TimeSpan>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_time_span_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::TimeSpan, false>>(return_value.get(), 0);
                param0 = winrt::com_array<winrt::Windows::Foundation::TimeSpan>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetUInt16()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_uint16")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint16_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetUInt16Array(winrt::com_array<uint16_t>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_uint16_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<uint16_t, false>>(return_value.get(), 0);
                param0 = winrt::com_array<uint16_t>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetUInt32()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_uint32")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetUInt32Array(winrt::com_array<uint32_t>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_uint32_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<uint32_t, false>>(return_value.get(), 0);
                param0 = winrt::com_array<uint32_t>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetUInt64()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_uint64")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint64_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetUInt64Array(winrt::com_array<uint64_t>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_uint64_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<uint64_t, false>>(return_value.get(), 0);
                param0 = winrt::com_array<uint64_t>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetUInt8()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_uint8")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint8_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetUInt8Array(winrt::com_array<uint8_t>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_uint8_array")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(return_value.get(), 0);
                param0 = winrt::com_array<uint8_t>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsNumericScalar()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_numeric_scalar")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Type()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::PropertyType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPropertyValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IPropertyValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPropertyValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IPropertyValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPropertyValue(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IPropertyValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPropertyValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPropertyValue>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPropertyValue[] = {
        { "_assign_array_", _assign_array_IPropertyValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPropertyValue), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPropertyValue), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPropertyValue), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPropertyValue[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPropertyValue) },
        { }};

    static PyType_Spec type_spec_ImplementsIPropertyValue = {
        "winrt._winrt_windows_foundation.IPropertyValue",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIPropertyValue};

    // ----- IReferenceArray interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IReferenceArray(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IReferenceArray>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IReferenceArray>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IReferenceArray(py::wrapper::Windows::Foundation::IReferenceArray* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IReferenceArray_GetBoolean(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetBoolean(args);
    }

    static PyObject* IReferenceArray_GetBooleanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetBooleanArray(args);
    }

    static PyObject* IReferenceArray_GetChar16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetChar16(args);
    }

    static PyObject* IReferenceArray_GetChar16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetChar16Array(args);
    }

    static PyObject* IReferenceArray_GetDateTime(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetDateTime(args);
    }

    static PyObject* IReferenceArray_GetDateTimeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetDateTimeArray(args);
    }

    static PyObject* IReferenceArray_GetDouble(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetDouble(args);
    }

    static PyObject* IReferenceArray_GetDoubleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetDoubleArray(args);
    }

    static PyObject* IReferenceArray_GetGuid(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetGuid(args);
    }

    static PyObject* IReferenceArray_GetGuidArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetGuidArray(args);
    }

    static PyObject* IReferenceArray_GetInspectableArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInspectableArray(args);
    }

    static PyObject* IReferenceArray_GetInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt16(args);
    }

    static PyObject* IReferenceArray_GetInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt16Array(args);
    }

    static PyObject* IReferenceArray_GetInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt32(args);
    }

    static PyObject* IReferenceArray_GetInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt32Array(args);
    }

    static PyObject* IReferenceArray_GetInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt64(args);
    }

    static PyObject* IReferenceArray_GetInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetInt64Array(args);
    }

    static PyObject* IReferenceArray_GetPoint(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetPoint(args);
    }

    static PyObject* IReferenceArray_GetPointArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetPointArray(args);
    }

    static PyObject* IReferenceArray_GetRect(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetRect(args);
    }

    static PyObject* IReferenceArray_GetRectArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetRectArray(args);
    }

    static PyObject* IReferenceArray_GetSingle(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetSingle(args);
    }

    static PyObject* IReferenceArray_GetSingleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetSingleArray(args);
    }

    static PyObject* IReferenceArray_GetSize(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetSize(args);
    }

    static PyObject* IReferenceArray_GetSizeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetSizeArray(args);
    }

    static PyObject* IReferenceArray_GetString(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetString(args);
    }

    static PyObject* IReferenceArray_GetStringArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetStringArray(args);
    }

    static PyObject* IReferenceArray_GetTimeSpan(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetTimeSpan(args);
    }

    static PyObject* IReferenceArray_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetTimeSpanArray(args);
    }

    static PyObject* IReferenceArray_GetUInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt16(args);
    }

    static PyObject* IReferenceArray_GetUInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt16Array(args);
    }

    static PyObject* IReferenceArray_GetUInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt32(args);
    }

    static PyObject* IReferenceArray_GetUInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt32Array(args);
    }

    static PyObject* IReferenceArray_GetUInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt64(args);
    }

    static PyObject* IReferenceArray_GetUInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt64Array(args);
    }

    static PyObject* IReferenceArray_GetUInt8(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt8(args);
    }

    static PyObject* IReferenceArray_GetUInt8Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt8Array(args);
    }

    static PyObject* IReferenceArray_get_Value(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IReferenceArray`1", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Value();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IReferenceArray_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_IsNumericScalar();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IReferenceArray_get_Type(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Type();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IReferenceArray[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IReferenceArray_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IReferenceArray_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IReferenceArray_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IReferenceArray_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IReferenceArray_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IReferenceArray_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IReferenceArray_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IReferenceArray_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IReferenceArray_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IReferenceArray_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IReferenceArray_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IReferenceArray_GetUInt8Array), METH_VARARGS, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }};

    static PyGetSetDef _getset_IReferenceArray[] = {
        { "value", reinterpret_cast<getter>(IReferenceArray_get_Value), nullptr, nullptr, nullptr },
        { "is_numeric_scalar", reinterpret_cast<getter>(IReferenceArray_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IReferenceArray_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IReferenceArray[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IReferenceArray) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IReferenceArray) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IReferenceArray) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IReferenceArray) },
        { }};

    static PyType_Spec type_spec_IReferenceArray = {
        "winrt._winrt_windows_foundation._IReferenceArray",
        sizeof(py::wrapper::Windows::Foundation::IReferenceArray),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IReferenceArray};

    static PyObject* _guid_ImplementsIReferenceArray(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIReferenceArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIReferenceArray[] = {
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIReferenceArray), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIReferenceArray), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIReferenceArray[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIReferenceArray) },
        { }};

    static PyType_Spec type_spec_ImplementsIReferenceArray = {
        "winrt._winrt_windows_foundation.IReferenceArray",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIReferenceArray};

    // ----- IReference interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IReference(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<py::proj::Windows::Foundation::IReference>::type_name);
        py::set_invalid_activation_error(py::py_type<py::proj::Windows::Foundation::IReference>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IReference(py::wrapper::Windows::Foundation::IReference* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        std::destroy_at(&self->impl);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IReference_GetBoolean(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetBoolean(args);
    }

    static PyObject* IReference_GetBooleanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetBooleanArray(args);
    }

    static PyObject* IReference_GetChar16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetChar16(args);
    }

    static PyObject* IReference_GetChar16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetChar16Array(args);
    }

    static PyObject* IReference_GetDateTime(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetDateTime(args);
    }

    static PyObject* IReference_GetDateTimeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetDateTimeArray(args);
    }

    static PyObject* IReference_GetDouble(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetDouble(args);
    }

    static PyObject* IReference_GetDoubleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetDoubleArray(args);
    }

    static PyObject* IReference_GetGuid(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetGuid(args);
    }

    static PyObject* IReference_GetGuidArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetGuidArray(args);
    }

    static PyObject* IReference_GetInspectableArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInspectableArray(args);
    }

    static PyObject* IReference_GetInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt16(args);
    }

    static PyObject* IReference_GetInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt16Array(args);
    }

    static PyObject* IReference_GetInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt32(args);
    }

    static PyObject* IReference_GetInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt32Array(args);
    }

    static PyObject* IReference_GetInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt64(args);
    }

    static PyObject* IReference_GetInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetInt64Array(args);
    }

    static PyObject* IReference_GetPoint(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetPoint(args);
    }

    static PyObject* IReference_GetPointArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetPointArray(args);
    }

    static PyObject* IReference_GetRect(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetRect(args);
    }

    static PyObject* IReference_GetRectArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetRectArray(args);
    }

    static PyObject* IReference_GetSingle(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetSingle(args);
    }

    static PyObject* IReference_GetSingleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetSingleArray(args);
    }

    static PyObject* IReference_GetSize(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetSize(args);
    }

    static PyObject* IReference_GetSizeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetSizeArray(args);
    }

    static PyObject* IReference_GetString(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetString(args);
    }

    static PyObject* IReference_GetStringArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetStringArray(args);
    }

    static PyObject* IReference_GetTimeSpan(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetTimeSpan(args);
    }

    static PyObject* IReference_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetTimeSpanArray(args);
    }

    static PyObject* IReference_GetUInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt16(args);
    }

    static PyObject* IReference_GetUInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt16Array(args);
    }

    static PyObject* IReference_GetUInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt32(args);
    }

    static PyObject* IReference_GetUInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt32Array(args);
    }

    static PyObject* IReference_GetUInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt64(args);
    }

    static PyObject* IReference_GetUInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt64Array(args);
    }

    static PyObject* IReference_GetUInt8(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt8(args);
    }

    static PyObject* IReference_GetUInt8Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->impl->GetUInt8Array(args);
    }

    static PyObject* IReference_get_Value(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IReference`1", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Value();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IReference_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"IsNumericScalar");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_IsNumericScalar();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IReference_get_Type(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IPropertyValue", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return self->impl->get_Type();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IReference[] = {
        { "get_boolean", reinterpret_cast<PyCFunction>(IReference_GetBoolean), METH_VARARGS, nullptr },
        { "get_boolean_array", reinterpret_cast<PyCFunction>(IReference_GetBooleanArray), METH_VARARGS, nullptr },
        { "get_char16", reinterpret_cast<PyCFunction>(IReference_GetChar16), METH_VARARGS, nullptr },
        { "get_char16_array", reinterpret_cast<PyCFunction>(IReference_GetChar16Array), METH_VARARGS, nullptr },
        { "get_date_time", reinterpret_cast<PyCFunction>(IReference_GetDateTime), METH_VARARGS, nullptr },
        { "get_date_time_array", reinterpret_cast<PyCFunction>(IReference_GetDateTimeArray), METH_VARARGS, nullptr },
        { "get_double", reinterpret_cast<PyCFunction>(IReference_GetDouble), METH_VARARGS, nullptr },
        { "get_double_array", reinterpret_cast<PyCFunction>(IReference_GetDoubleArray), METH_VARARGS, nullptr },
        { "get_guid", reinterpret_cast<PyCFunction>(IReference_GetGuid), METH_VARARGS, nullptr },
        { "get_guid_array", reinterpret_cast<PyCFunction>(IReference_GetGuidArray), METH_VARARGS, nullptr },
        { "get_inspectable_array", reinterpret_cast<PyCFunction>(IReference_GetInspectableArray), METH_VARARGS, nullptr },
        { "get_int16", reinterpret_cast<PyCFunction>(IReference_GetInt16), METH_VARARGS, nullptr },
        { "get_int16_array", reinterpret_cast<PyCFunction>(IReference_GetInt16Array), METH_VARARGS, nullptr },
        { "get_int32", reinterpret_cast<PyCFunction>(IReference_GetInt32), METH_VARARGS, nullptr },
        { "get_int32_array", reinterpret_cast<PyCFunction>(IReference_GetInt32Array), METH_VARARGS, nullptr },
        { "get_int64", reinterpret_cast<PyCFunction>(IReference_GetInt64), METH_VARARGS, nullptr },
        { "get_int64_array", reinterpret_cast<PyCFunction>(IReference_GetInt64Array), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(IReference_GetPoint), METH_VARARGS, nullptr },
        { "get_point_array", reinterpret_cast<PyCFunction>(IReference_GetPointArray), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(IReference_GetRect), METH_VARARGS, nullptr },
        { "get_rect_array", reinterpret_cast<PyCFunction>(IReference_GetRectArray), METH_VARARGS, nullptr },
        { "get_single", reinterpret_cast<PyCFunction>(IReference_GetSingle), METH_VARARGS, nullptr },
        { "get_single_array", reinterpret_cast<PyCFunction>(IReference_GetSingleArray), METH_VARARGS, nullptr },
        { "get_size", reinterpret_cast<PyCFunction>(IReference_GetSize), METH_VARARGS, nullptr },
        { "get_size_array", reinterpret_cast<PyCFunction>(IReference_GetSizeArray), METH_VARARGS, nullptr },
        { "get_string", reinterpret_cast<PyCFunction>(IReference_GetString), METH_VARARGS, nullptr },
        { "get_string_array", reinterpret_cast<PyCFunction>(IReference_GetStringArray), METH_VARARGS, nullptr },
        { "get_time_span", reinterpret_cast<PyCFunction>(IReference_GetTimeSpan), METH_VARARGS, nullptr },
        { "get_time_span_array", reinterpret_cast<PyCFunction>(IReference_GetTimeSpanArray), METH_VARARGS, nullptr },
        { "get_uint16", reinterpret_cast<PyCFunction>(IReference_GetUInt16), METH_VARARGS, nullptr },
        { "get_uint16_array", reinterpret_cast<PyCFunction>(IReference_GetUInt16Array), METH_VARARGS, nullptr },
        { "get_uint32", reinterpret_cast<PyCFunction>(IReference_GetUInt32), METH_VARARGS, nullptr },
        { "get_uint32_array", reinterpret_cast<PyCFunction>(IReference_GetUInt32Array), METH_VARARGS, nullptr },
        { "get_uint64", reinterpret_cast<PyCFunction>(IReference_GetUInt64), METH_VARARGS, nullptr },
        { "get_uint64_array", reinterpret_cast<PyCFunction>(IReference_GetUInt64Array), METH_VARARGS, nullptr },
        { "get_uint8", reinterpret_cast<PyCFunction>(IReference_GetUInt8), METH_VARARGS, nullptr },
        { "get_uint8_array", reinterpret_cast<PyCFunction>(IReference_GetUInt8Array), METH_VARARGS, nullptr },
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { }};

    static PyGetSetDef _getset_IReference[] = {
        { "value", reinterpret_cast<getter>(IReference_get_Value), nullptr, nullptr, nullptr },
        { "is_numeric_scalar", reinterpret_cast<getter>(IReference_get_IsNumericScalar), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IReference_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IReference[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IReference) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IReference) },
        { }};

    static PyType_Spec type_spec_IReference = {
        "winrt._winrt_windows_foundation._IReference",
        sizeof(py::wrapper::Windows::Foundation::IReference),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IReference};

    static PyObject* _guid_ImplementsIReference(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            PyErr_SetString(PyExc_NotImplementedError, "Generic types are not supported");
            return nullptr;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIReference[] = {
        { "__class_getitem__", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR("See PEP 585") },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIReference), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIReference), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIReference[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIReference) },
        { }};

    static PyType_Spec type_spec_ImplementsIReference = {
        "winrt._winrt_windows_foundation.IReference",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIReference};

    // ----- IStringable interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStringable(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IStringable>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IStringable>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStringable(py::wrapper::Windows::Foundation::IStringable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStringable_ToString(py::wrapper::Windows::Foundation::IStringable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IStringable", L"ToString", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ToString();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _str_IStringable(py::wrapper::Windows::Foundation::IStringable* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.ToString();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStringable[] = {
        { "to_string", reinterpret_cast<PyCFunction>(IStringable_ToString), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStringable[] = {
        { }};

    static PyType_Slot _type_slots_IStringable[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStringable) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStringable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStringable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStringable) },
        { Py_tp_str, reinterpret_cast<void*>(_str_IStringable) },
        { }};

    static PyType_Spec type_spec_IStringable = {
        "winrt._winrt_windows_foundation._IStringable",
        sizeof(py::wrapper::Windows::Foundation::IStringable),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStringable};

    struct ImplementsIStringable : py::ImplementsInterfaceT<ImplementsIStringable, winrt::Windows::Foundation::IStringable>
    {
        ImplementsIStringable() = delete;
        ImplementsIStringable(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStringable, winrt::Windows::Foundation::IStringable>(py_obj, runtime_class)
        {
        }

        auto ToString()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "to_string")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStringable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IStringable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStringable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IStringable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStringable(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IStringable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStringable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStringable>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStringable[] = {
        { "_assign_array_", _assign_array_IStringable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStringable), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStringable), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStringable), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStringable[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStringable) },
        { }};

    static PyType_Spec type_spec_ImplementsIStringable = {
        "winrt._winrt_windows_foundation.IStringable",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStringable};

    // ----- IWwwFormUrlDecoderEntry interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWwwFormUrlDecoderEntry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IWwwFormUrlDecoderEntry", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.IWwwFormUrlDecoderEntry", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWwwFormUrlDecoderEntry[] = {
        { }};

    static PyGetSetDef _getset_IWwwFormUrlDecoderEntry[] = {
        { "name", reinterpret_cast<getter>(IWwwFormUrlDecoderEntry_get_Name), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IWwwFormUrlDecoderEntry_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IWwwFormUrlDecoderEntry[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWwwFormUrlDecoderEntry) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWwwFormUrlDecoderEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWwwFormUrlDecoderEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWwwFormUrlDecoderEntry) },
        { }};

    static PyType_Spec type_spec_IWwwFormUrlDecoderEntry = {
        "winrt._winrt_windows_foundation._IWwwFormUrlDecoderEntry",
        sizeof(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWwwFormUrlDecoderEntry};

    struct ImplementsIWwwFormUrlDecoderEntry : py::ImplementsInterfaceT<ImplementsIWwwFormUrlDecoderEntry, winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>
    {
        ImplementsIWwwFormUrlDecoderEntry() = delete;
        ImplementsIWwwFormUrlDecoderEntry(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWwwFormUrlDecoderEntry, winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(py_obj, runtime_class)
        {
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Value()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "value")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWwwFormUrlDecoderEntry>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWwwFormUrlDecoderEntry[] = {
        { "_assign_array_", _assign_array_IWwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWwwFormUrlDecoderEntry), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWwwFormUrlDecoderEntry), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWwwFormUrlDecoderEntry), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWwwFormUrlDecoderEntry[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWwwFormUrlDecoderEntry) },
        { }};

    static PyType_Spec type_spec_ImplementsIWwwFormUrlDecoderEntry = {
        "winrt._winrt_windows_foundation.IWwwFormUrlDecoderEntry",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWwwFormUrlDecoderEntry};

    // ----- EventRegistrationToken struct --------------------

    winrt::event_token EventRegistrationToken_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 1)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::event_token result{};

        result.value = py::convert_to<int64_t>(tuple, 0);

        return result;
    }

    PyObject* _new_EventRegistrationToken(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::event_token>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int64_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|L", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            self->obj.value = _Value;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_EventRegistrationToken(py::wrapper::Windows::Foundation::EventRegistrationToken* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_EventRegistrationToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::event_token>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_EventRegistrationToken(py::wrapper::Windows::Foundation::EventRegistrationToken* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int64_t _Value{self->obj.value};

            static const char* kwlist[] = {"value", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$L", const_cast<char**>(kwlist), &_Value))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.value = _Value;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EventRegistrationToken[] = {
        { "_assign_array_", _assign_array_EventRegistrationToken, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_EventRegistrationToken)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* EventRegistrationToken_get_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_EventRegistrationToken[] = {
        { "value", reinterpret_cast<getter>(EventRegistrationToken_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_EventRegistrationToken(py::wrapper::Windows::Foundation::EventRegistrationToken* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::event_token>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_EventRegistrationToken(PyObject* self) noexcept
    {
        py::pyobj_handle Value{PyObject_GetAttrString(self, "value")};
        if (!Value)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("EventRegistrationToken(value=%R)", Value.get());
    }

    static PyType_Slot _type_slots_EventRegistrationToken[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EventRegistrationToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EventRegistrationToken) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EventRegistrationToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EventRegistrationToken) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_EventRegistrationToken) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_EventRegistrationToken) },
        { }};

    static PyType_Spec type_spec_EventRegistrationToken = {
        "winrt._winrt_windows_foundation.EventRegistrationToken",
        sizeof(py::wrapper::Windows::Foundation::EventRegistrationToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EventRegistrationToken};

    // ----- HResult struct --------------------

    winrt::hresult HResult_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 1)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::hresult result{};

        result.value = py::convert_to<int32_t>(tuple, 0);

        return result;
    }

    PyObject* _new_HResult(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::hresult>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int32_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            self->obj.value = _Value;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_HResult(py::wrapper::Windows::Foundation::HResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::hresult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_HResult(py::wrapper::Windows::Foundation::HResult* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int32_t _Value{self->obj.value};

            static const char* kwlist[] = {"value", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$i", const_cast<char**>(kwlist), &_Value))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.value = _Value;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HResult[] = {
        { "_assign_array_", _assign_array_HResult, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_HResult)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* HResult_get_Value(py::wrapper::Windows::Foundation::HResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_HResult[] = {
        { "value", reinterpret_cast<getter>(HResult_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_HResult(py::wrapper::Windows::Foundation::HResult* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::hresult>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_HResult(PyObject* self) noexcept
    {
        py::pyobj_handle Value{PyObject_GetAttrString(self, "value")};
        if (!Value)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("HResult(value=%R)", Value.get());
    }

    static PyType_Slot _type_slots_HResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HResult) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_HResult) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_HResult) },
        { }};

    static PyType_Spec type_spec_HResult = {
        "winrt._winrt_windows_foundation.HResult",
        sizeof(py::wrapper::Windows::Foundation::HResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HResult};

    // ----- Point struct --------------------

    winrt::Windows::Foundation::Point Point_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Point result{};

        result.X = py::convert_to<float>(tuple, 0);
        result.Y = py::convert_to<float>(tuple, 1);

        return result;
    }

    PyObject* _new_Point(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Point>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _X{};
        float _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ff", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            self->obj.X = _X;
            self->obj.Y = _Y;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Point(py::wrapper::Windows::Foundation::Point* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Point(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Point>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Point(py::wrapper::Windows::Foundation::Point* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _X{self->obj.X};
            float _Y{self->obj.Y};

            static const char* kwlist[] = {"x", "y", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ff", const_cast<char**>(kwlist), &_X, &_Y))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.X = _X;
            copy.Y = _Y;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Point(py::wrapper::Windows::Foundation::Point* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.X)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.Y)};
        if (!Y)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Point[] = {
        { "_assign_array_", _assign_array_Point, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Point)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Point), METH_NOARGS, nullptr },
        { }};

    static PyObject* Point_get_X(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Point_get_Y(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Point[] = {
        { "x", reinterpret_cast<getter>(Point_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Point_get_Y), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_Point(py::wrapper::Windows::Foundation::Point* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Point>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Point(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Point(x=%R, y=%R)", X.get(), Y.get());
    }

    static PyType_Slot _type_slots_Point[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Point) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Point) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Point) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Point) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Point) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Point) },
        { }};

    static PyType_Spec type_spec_Point = {
        "winrt._winrt_windows_foundation.Point",
        sizeof(py::wrapper::Windows::Foundation::Point),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Point};

    // ----- Rect struct --------------------

    winrt::Windows::Foundation::Rect Rect_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 4)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Rect result{};

        result.X = py::convert_to<float>(tuple, 0);
        result.Y = py::convert_to<float>(tuple, 1);
        result.Width = py::convert_to<float>(tuple, 2);
        result.Height = py::convert_to<float>(tuple, 3);

        return result;
    }

    PyObject* _new_Rect(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Rect>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _X{};
        float _Y{};
        float _Width{};
        float _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            self->obj.X = _X;
            self->obj.Y = _Y;
            self->obj.Width = _Width;
            self->obj.Height = _Height;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Rect(py::wrapper::Windows::Foundation::Rect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Rect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Rect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Rect(py::wrapper::Windows::Foundation::Rect* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _X{self->obj.X};
            float _Y{self->obj.Y};
            float _Width{self->obj.Width};
            float _Height{self->obj.Height};

            static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.X = _X;
            copy.Y = _Y;
            copy.Width = _Width;
            copy.Height = _Height;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Rect(py::wrapper::Windows::Foundation::Rect* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.X)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.Y)};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Width{convert(self->obj.Width)};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Height{convert(self->obj.Height)};
        if (!Height)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(4)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, Width.detach());
        PyTuple_SET_ITEM(tuple.get(), 3, Height.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Rect[] = {
        { "_assign_array_", _assign_array_Rect, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Rect)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Rect), METH_NOARGS, nullptr },
        { }};

    static PyObject* Rect_get_X(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Rect_get_Y(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Rect_get_Width(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Rect_get_Height(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Rect[] = {
        { "x", reinterpret_cast<getter>(Rect_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(Rect_get_Y), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(Rect_get_Width), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(Rect_get_Height), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_Rect(py::wrapper::Windows::Foundation::Rect* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Rect>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Rect(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Width{PyObject_GetAttrString(self, "width")};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Height{PyObject_GetAttrString(self, "height")};
        if (!Height)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Rect(x=%R, y=%R, width=%R, height=%R)", X.get(), Y.get(), Width.get(), Height.get());
    }

    static PyType_Slot _type_slots_Rect[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Rect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Rect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Rect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Rect) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Rect) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Rect) },
        { }};

    static PyType_Spec type_spec_Rect = {
        "winrt._winrt_windows_foundation.Rect",
        sizeof(py::wrapper::Windows::Foundation::Rect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Rect};

    // ----- Size struct --------------------

    winrt::Windows::Foundation::Size Size_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Foundation::Size result{};

        result.Width = py::convert_to<float>(tuple, 0);
        result.Height = py::convert_to<float>(tuple, 1);

        return result;
    }

    PyObject* _new_Size(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Foundation::Size>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _Width{};
        float _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ff", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            self->obj.Width = _Width;
            self->obj.Height = _Height;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Size(py::wrapper::Windows::Foundation::Size* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Size(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Size>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Size(py::wrapper::Windows::Foundation::Size* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _Width{self->obj.Width};
            float _Height{self->obj.Height};

            static const char* kwlist[] = {"width", "height", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ff", const_cast<char**>(kwlist), &_Width, &_Height))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Width = _Width;
            copy.Height = _Height;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Size(py::wrapper::Windows::Foundation::Size* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle Width{convert(self->obj.Width)};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Height{convert(self->obj.Height)};
        if (!Height)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, Width.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Height.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Size[] = {
        { "_assign_array_", _assign_array_Size, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Size)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Size), METH_NOARGS, nullptr },
        { }};

    static PyObject* Size_get_Width(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Size_get_Height(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Size[] = {
        { "width", reinterpret_cast<getter>(Size_get_Width), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(Size_get_Height), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_Size(py::wrapper::Windows::Foundation::Size* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Foundation::Size>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Size(PyObject* self) noexcept
    {
        py::pyobj_handle Width{PyObject_GetAttrString(self, "width")};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Height{PyObject_GetAttrString(self, "height")};
        if (!Height)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Size(width=%R, height=%R)", Width.get(), Height.get());
    }

    static PyType_Slot _type_slots_Size[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Size) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Size) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Size) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Size) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Size) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Size) },
        { }};

    static PyType_Spec type_spec_Size = {
        "winrt._winrt_windows_foundation.Size",
        sizeof(py::wrapper::Windows::Foundation::Size),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Size};

    // ----- Windows.Foundation Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Foundation");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_foundation",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Foundation

PyMODINIT_FUNC PyInit__winrt_windows_foundation(void) noexcept
{
    using namespace py::cpp::Windows::Foundation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle Deferral_type{py::register_python_type(module.get(), &type_spec_Deferral, object_bases.get(), inspectable_meta_type)};
    if (!Deferral_type)
    {
        return nullptr;
    }

    py::pyobj_handle GuidHelper_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!GuidHelper_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GuidHelper_Static{PyType_FromSpecWithBases(&type_spec_GuidHelper_Static, GuidHelper_Static_bases.get())};
    if (!type_GuidHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle GuidHelper_type{py::register_python_type(module.get(), &type_spec_GuidHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GuidHelper_Static.get()))};
    if (!GuidHelper_type)
    {
        return nullptr;
    }

    py::pytype_handle MemoryBuffer_type{py::register_python_type(module.get(), &type_spec_MemoryBuffer, object_bases.get(), inspectable_meta_type)};
    if (!MemoryBuffer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PropertyValue_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PropertyValue_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PropertyValue_Static{PyType_FromSpecWithBases(&type_spec_PropertyValue_Static, PropertyValue_Static_bases.get())};
    if (!type_PropertyValue_Static)
    {
        return nullptr;
    }

    py::pytype_handle PropertyValue_type{py::register_python_type(module.get(), &type_spec_PropertyValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PropertyValue_Static.get()))};
    if (!PropertyValue_type)
    {
        return nullptr;
    }

    py::pyobj_handle Uri_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!Uri_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Uri_Static{PyType_FromSpecWithBases(&type_spec_Uri_Static, Uri_Static_bases.get())};
    if (!type_Uri_Static)
    {
        return nullptr;
    }

    py::pytype_handle Uri_type{py::register_python_type(module.get(), &type_spec_Uri, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Uri_Static.get()))};
    if (!Uri_type)
    {
        return nullptr;
    }

    py::pytype_handle WwwFormUrlDecoder_type{py::register_python_type(module.get(), &type_spec_WwwFormUrlDecoder, object_bases.get(), inspectable_meta_type)};
    if (!WwwFormUrlDecoder_type)
    {
        return nullptr;
    }

    py::pytype_handle WwwFormUrlDecoderEntry_type{py::register_python_type(module.get(), &type_spec_WwwFormUrlDecoderEntry, object_bases.get(), inspectable_meta_type)};
    if (!WwwFormUrlDecoderEntry_type)
    {
        return nullptr;
    }

    py::pytype_handle IAsyncAction_type{py::register_python_type(module.get(), &type_spec_IAsyncAction, object_bases.get(), nullptr)};
    if (!IAsyncAction_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAsyncAction_type{py::register_python_type(module.get(), &type_spec_ImplementsIAsyncAction, nullptr, inspectable_meta_type)};
    if (!ImplementsIAsyncAction_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAsyncAction_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAsyncActionWithProgress_type{py::register_python_type(module.get(), &type_spec_IAsyncActionWithProgress, object_bases.get(), nullptr)};
    if (!IAsyncActionWithProgress_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAsyncActionWithProgress_type{py::register_python_type(module.get(), &type_spec_ImplementsIAsyncActionWithProgress, nullptr, inspectable_meta_type)};
    if (!ImplementsIAsyncActionWithProgress_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAsyncActionWithProgress_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAsyncInfo_type{py::register_python_type(module.get(), &type_spec_IAsyncInfo, object_bases.get(), nullptr)};
    if (!IAsyncInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAsyncInfo_type{py::register_python_type(module.get(), &type_spec_ImplementsIAsyncInfo, nullptr, inspectable_meta_type)};
    if (!ImplementsIAsyncInfo_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAsyncInfo_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAsyncOperationWithProgress_type{py::register_python_type(module.get(), &type_spec_IAsyncOperationWithProgress, object_bases.get(), nullptr)};
    if (!IAsyncOperationWithProgress_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAsyncOperationWithProgress_type{py::register_python_type(module.get(), &type_spec_ImplementsIAsyncOperationWithProgress, nullptr, inspectable_meta_type)};
    if (!ImplementsIAsyncOperationWithProgress_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAsyncOperationWithProgress_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAsyncOperation_type{py::register_python_type(module.get(), &type_spec_IAsyncOperation, object_bases.get(), nullptr)};
    if (!IAsyncOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAsyncOperation_type{py::register_python_type(module.get(), &type_spec_ImplementsIAsyncOperation, nullptr, inspectable_meta_type)};
    if (!ImplementsIAsyncOperation_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAsyncOperation_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IClosable_type{py::register_python_type(module.get(), &type_spec_IClosable, object_bases.get(), nullptr)};
    if (!IClosable_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIClosable_type{py::register_python_type(module.get(), &type_spec_ImplementsIClosable, nullptr, inspectable_meta_type)};
    if (!ImplementsIClosable_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIClosable_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IGetActivationFactory_type{py::register_python_type(module.get(), &type_spec_IGetActivationFactory, object_bases.get(), nullptr)};
    if (!IGetActivationFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGetActivationFactory_type{py::register_python_type(module.get(), &type_spec_ImplementsIGetActivationFactory, nullptr, inspectable_meta_type)};
    if (!ImplementsIGetActivationFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGetActivationFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IMemoryBuffer_type{py::register_python_type(module.get(), &type_spec_IMemoryBuffer, object_bases.get(), nullptr)};
    if (!IMemoryBuffer_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIMemoryBuffer_type{py::register_python_type(module.get(), &type_spec_ImplementsIMemoryBuffer, nullptr, inspectable_meta_type)};
    if (!ImplementsIMemoryBuffer_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIMemoryBuffer_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IMemoryBufferReference_type{py::register_python_type(module.get(), &type_spec_IMemoryBufferReference, object_bases.get(), nullptr)};
    if (!IMemoryBufferReference_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIMemoryBufferReference_type{py::register_python_type(module.get(), &type_spec_ImplementsIMemoryBufferReference, nullptr, inspectable_meta_type)};
    if (!ImplementsIMemoryBufferReference_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIMemoryBufferReference_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPropertyValue_type{py::register_python_type(module.get(), &type_spec_IPropertyValue, object_bases.get(), nullptr)};
    if (!IPropertyValue_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPropertyValue_type{py::register_python_type(module.get(), &type_spec_ImplementsIPropertyValue, nullptr, inspectable_meta_type)};
    if (!ImplementsIPropertyValue_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPropertyValue_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IReferenceArray_type{py::register_python_type(module.get(), &type_spec_IReferenceArray, object_bases.get(), nullptr)};
    if (!IReferenceArray_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIReferenceArray_type{py::register_python_type(module.get(), &type_spec_ImplementsIReferenceArray, nullptr, inspectable_meta_type)};
    if (!ImplementsIReferenceArray_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIReferenceArray_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IReference_type{py::register_python_type(module.get(), &type_spec_IReference, object_bases.get(), nullptr)};
    if (!IReference_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIReference_type{py::register_python_type(module.get(), &type_spec_ImplementsIReference, nullptr, inspectable_meta_type)};
    if (!ImplementsIReference_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIReference_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStringable_type{py::register_python_type(module.get(), &type_spec_IStringable, object_bases.get(), nullptr)};
    if (!IStringable_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStringable_type{py::register_python_type(module.get(), &type_spec_ImplementsIStringable, nullptr, inspectable_meta_type)};
    if (!ImplementsIStringable_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStringable_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWwwFormUrlDecoderEntry_type{py::register_python_type(module.get(), &type_spec_IWwwFormUrlDecoderEntry, object_bases.get(), nullptr)};
    if (!IWwwFormUrlDecoderEntry_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWwwFormUrlDecoderEntry_type{py::register_python_type(module.get(), &type_spec_ImplementsIWwwFormUrlDecoderEntry, nullptr, inspectable_meta_type)};
    if (!ImplementsIWwwFormUrlDecoderEntry_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWwwFormUrlDecoderEntry_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle EventRegistrationToken_type{py::register_python_type(module.get(), &type_spec_EventRegistrationToken, nullptr, nullptr)};
    if (!EventRegistrationToken_type)
    {
        return nullptr;
    }

    py::pyobj_handle EventRegistrationToken_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(EventRegistrationToken_from_tuple),"winrt._winrt_windows_foundation.EventRegistrationToken_from_tuple", nullptr)};
    if (!EventRegistrationToken_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "EventRegistrationToken_from_tuple", EventRegistrationToken_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle HResult_type{py::register_python_type(module.get(), &type_spec_HResult, nullptr, nullptr)};
    if (!HResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle HResult_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(HResult_from_tuple),"winrt._winrt_windows_foundation.HResult_from_tuple", nullptr)};
    if (!HResult_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "HResult_from_tuple", HResult_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle Point_type{py::register_python_type(module.get(), &type_spec_Point, nullptr, nullptr)};
    if (!Point_type)
    {
        return nullptr;
    }

    py::pyobj_handle Point_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Point_from_tuple),"winrt._winrt_windows_foundation.Point_from_tuple", nullptr)};
    if (!Point_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Point_from_tuple", Point_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle Rect_type{py::register_python_type(module.get(), &type_spec_Rect, nullptr, nullptr)};
    if (!Rect_type)
    {
        return nullptr;
    }

    py::pyobj_handle Rect_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Rect_from_tuple),"winrt._winrt_windows_foundation.Rect_from_tuple", nullptr)};
    if (!Rect_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Rect_from_tuple", Rect_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle Size_type{py::register_python_type(module.get(), &type_spec_Size, nullptr, nullptr)};
    if (!Size_type)
    {
        return nullptr;
    }

    py::pyobj_handle Size_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Size_from_tuple),"winrt._winrt_windows_foundation.Size_from_tuple", nullptr)};
    if (!Size_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Size_from_tuple", Size_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
