// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.UI.StartScreen.h"

namespace py::cpp::Windows::UI::StartScreen
{
    // ----- JumpList class --------------------

    static PyObject* _new_JumpList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::StartScreen::JumpList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::StartScreen::JumpList>::type_name);
        return nullptr;
    }

    static void _dealloc_JumpList(py::wrapper::Windows::UI::StartScreen::JumpList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpList_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpList", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::JumpList::IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpList_LoadCurrentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpList", L"LoadCurrentAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::JumpList::LoadCurrentAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpList_SaveAsync(py::wrapper::Windows::UI::StartScreen::JumpList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpList", L"SaveAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpList_get_SystemGroupKind(py::wrapper::Windows::UI::StartScreen::JumpList* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpList", L"SystemGroupKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemGroupKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpList_put_SystemGroupKind(py::wrapper::Windows::UI::StartScreen::JumpList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpList", L"SystemGroupKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::JumpListSystemGroupKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.SystemGroupKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpList_get_Items(py::wrapper::Windows::UI::StartScreen::JumpList* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpList", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::JumpList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::JumpList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpList[] = {
        { "save_async", reinterpret_cast<PyCFunction>(JumpList_SaveAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JumpList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpList), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_JumpList[] = {
        { "system_group_kind", reinterpret_cast<getter>(JumpList_get_SystemGroupKind), reinterpret_cast<setter>(JumpList_put_SystemGroupKind), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(JumpList_get_Items), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_JumpList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpList) },
        { }};

    static PyType_Spec type_spec_JumpList = {
        "winrt._winrt_windows_ui_startscreen.JumpList",
        sizeof(py::wrapper::Windows::UI::StartScreen::JumpList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpList};

    static PyGetSetDef getset_JumpList_Static[] = {
        { }};

    static PyMethodDef methods_JumpList_Static[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(JumpList_IsSupported), METH_VARARGS, nullptr },
        { "load_current_async", reinterpret_cast<PyCFunction>(JumpList_LoadCurrentAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_JumpList_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JumpList_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JumpList_Static) },
        { }
    };

    static PyType_Spec type_spec_JumpList_Static = {
        "winrt._winrt_windows_ui_startscreen.JumpList_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JumpList_Static};

    // ----- JumpListItem class --------------------

    static PyObject* _new_JumpListItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::StartScreen::JumpListItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::StartScreen::JumpListItem>::type_name);
        return nullptr;
    }

    static void _dealloc_JumpListItem(py::wrapper::Windows::UI::StartScreen::JumpListItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpListItem_CreateSeparator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpListItem", L"CreateSeparator", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::JumpListItem::CreateSeparator();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItem_CreateWithArguments(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpListItem", L"CreateWithArguments", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::JumpListItem::CreateWithArguments(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItem_get_Logo(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItem_put_Logo(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItem_get_GroupName(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GroupName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItem_put_GroupName(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.GroupName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItem_get_DisplayName(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItem_put_DisplayName(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItem_get_Description(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItem_put_Description(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Description(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItem_get_Arguments(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItem_get_Kind(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItem_get_RemovedByUser(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"RemovedByUser");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemovedByUser();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpListItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::JumpListItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpListItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::JumpListItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpListItem[] = {
        { "_assign_array_", _assign_array_JumpListItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpListItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_JumpListItem[] = {
        { "logo", reinterpret_cast<getter>(JumpListItem_get_Logo), reinterpret_cast<setter>(JumpListItem_put_Logo), nullptr, nullptr },
        { "group_name", reinterpret_cast<getter>(JumpListItem_get_GroupName), reinterpret_cast<setter>(JumpListItem_put_GroupName), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(JumpListItem_get_DisplayName), reinterpret_cast<setter>(JumpListItem_put_DisplayName), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(JumpListItem_get_Description), reinterpret_cast<setter>(JumpListItem_put_Description), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(JumpListItem_get_Arguments), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(JumpListItem_get_Kind), nullptr, nullptr, nullptr },
        { "removed_by_user", reinterpret_cast<getter>(JumpListItem_get_RemovedByUser), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_JumpListItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpListItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpListItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpListItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpListItem) },
        { }};

    static PyType_Spec type_spec_JumpListItem = {
        "winrt._winrt_windows_ui_startscreen.JumpListItem",
        sizeof(py::wrapper::Windows::UI::StartScreen::JumpListItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpListItem};

    static PyGetSetDef getset_JumpListItem_Static[] = {
        { }};

    static PyMethodDef methods_JumpListItem_Static[] = {
        { "create_separator", reinterpret_cast<PyCFunction>(JumpListItem_CreateSeparator), METH_VARARGS, nullptr },
        { "create_with_arguments", reinterpret_cast<PyCFunction>(JumpListItem_CreateWithArguments), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_JumpListItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JumpListItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JumpListItem_Static) },
        { }
    };

    static PyType_Spec type_spec_JumpListItem_Static = {
        "winrt._winrt_windows_ui_startscreen.JumpListItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JumpListItem_Static};

    // ----- SecondaryTile class --------------------

    static PyObject* _new_SecondaryTile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::StartScreen::TileSize>(args, 4);

                winrt::Windows::UI::StartScreen::SecondaryTile instance{param0, param1, param2, param3, param4};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::StartScreen::TileOptions>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);

                winrt::Windows::UI::StartScreen::SecondaryTile instance{param0, param1, param2, param3, param4, param5};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::StartScreen::TileOptions>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 6);

                winrt::Windows::UI::StartScreen::SecondaryTile instance{param0, param1, param2, param3, param4, param5, param6};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::StartScreen::SecondaryTile instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::StartScreen::SecondaryTile instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SecondaryTile(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SecondaryTile_Exists(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Exists", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::SecondaryTile::Exists(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"FindAllAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::SecondaryTile::FindAllAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_FindAllForApplicationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"FindAllAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::SecondaryTile::FindAllAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_FindAllForPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"FindAllForPackageAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::SecondaryTile::FindAllForPackageAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestCreateAsync(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestCreateAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestCreateAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestCreateAsyncWithPoint(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestCreateAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestCreateAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestCreateAsyncWithRect(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestCreateForSelectionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestCreateForSelectionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestCreateAsyncWithRectAndPlacement(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestCreateForSelectionAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestCreateForSelectionAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestDeleteAsync(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestDeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestDeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestDeleteAsyncWithPoint(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestDeleteAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestDeleteAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestDeleteAsyncWithRect(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestDeleteForSelectionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestDeleteForSelectionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestDeleteAsyncWithRectAndPlacement(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestDeleteForSelectionAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestDeleteForSelectionAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_UpdateAsync(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"UpdateAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UpdateAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_get_ShortName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"ShortName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShortName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_ShortName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"ShortName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShortName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_TileId(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_TileId(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.TileId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_LockScreenDisplayBadgeAndTileText(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"LockScreenDisplayBadgeAndTileText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LockScreenDisplayBadgeAndTileText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_LockScreenDisplayBadgeAndTileText(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"LockScreenDisplayBadgeAndTileText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.LockScreenDisplayBadgeAndTileText(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_LockScreenBadgeLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"LockScreenBadgeLogo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LockScreenBadgeLogo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_LockScreenBadgeLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"LockScreenBadgeLogo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.LockScreenBadgeLogo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_Arguments(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_Arguments(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Arguments(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_ForegroundText(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"ForegroundText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ForegroundText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_ForegroundText(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"ForegroundText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::ForegroundText>(arg);

            {
                auto _gil = release_gil();
                self->obj.ForegroundText(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_DisplayName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_DisplayName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_BackgroundColor(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BackgroundColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_BackgroundColor(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.BackgroundColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_WideLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"WideLogo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WideLogo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_WideLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"WideLogo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.WideLogo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_TileOptions(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"TileOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileOptions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_TileOptions(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"TileOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::TileOptions>(arg);

            {
                auto _gil = release_gil();
                self->obj.TileOptions(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_SmallLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"SmallLogo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmallLogo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_SmallLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"SmallLogo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.SmallLogo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_RoamingEnabled(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RoamingEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_RoamingEnabled(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RoamingEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.RoamingEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_PhoneticName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"PhoneticName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhoneticName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_PhoneticName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"PhoneticName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.PhoneticName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_VisualElements(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"VisualElements");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VisualElements();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_add_VisualElementsRequested(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.StartScreen.SecondaryTile", L"VisualElementsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::StartScreen::SecondaryTile, winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VisualElementsRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_remove_VisualElementsRequested(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.StartScreen.SecondaryTile", L"VisualElementsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VisualElementsRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SecondaryTile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::SecondaryTile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SecondaryTile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::SecondaryTile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecondaryTile[] = {
        { "request_create_async", reinterpret_cast<PyCFunction>(SecondaryTile_RequestCreateAsync), METH_VARARGS, nullptr },
        { "request_create_async_with_point", reinterpret_cast<PyCFunction>(SecondaryTile_RequestCreateAsyncWithPoint), METH_VARARGS, nullptr },
        { "request_create_async_with_rect", reinterpret_cast<PyCFunction>(SecondaryTile_RequestCreateAsyncWithRect), METH_VARARGS, nullptr },
        { "request_create_async_with_rect_and_placement", reinterpret_cast<PyCFunction>(SecondaryTile_RequestCreateAsyncWithRectAndPlacement), METH_VARARGS, nullptr },
        { "request_delete_async", reinterpret_cast<PyCFunction>(SecondaryTile_RequestDeleteAsync), METH_VARARGS, nullptr },
        { "request_delete_async_with_point", reinterpret_cast<PyCFunction>(SecondaryTile_RequestDeleteAsyncWithPoint), METH_VARARGS, nullptr },
        { "request_delete_async_with_rect", reinterpret_cast<PyCFunction>(SecondaryTile_RequestDeleteAsyncWithRect), METH_VARARGS, nullptr },
        { "request_delete_async_with_rect_and_placement", reinterpret_cast<PyCFunction>(SecondaryTile_RequestDeleteAsyncWithRectAndPlacement), METH_VARARGS, nullptr },
        { "update_async", reinterpret_cast<PyCFunction>(SecondaryTile_UpdateAsync), METH_VARARGS, nullptr },
        { "add_visual_elements_requested", reinterpret_cast<PyCFunction>(SecondaryTile_add_VisualElementsRequested), METH_O, nullptr },
        { "remove_visual_elements_requested", reinterpret_cast<PyCFunction>(SecondaryTile_remove_VisualElementsRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_SecondaryTile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecondaryTile), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SecondaryTile[] = {
        { "short_name", reinterpret_cast<getter>(SecondaryTile_get_ShortName), reinterpret_cast<setter>(SecondaryTile_put_ShortName), nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(SecondaryTile_get_Logo), reinterpret_cast<setter>(SecondaryTile_put_Logo), nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(SecondaryTile_get_TileId), reinterpret_cast<setter>(SecondaryTile_put_TileId), nullptr, nullptr },
        { "lock_screen_display_badge_and_tile_text", reinterpret_cast<getter>(SecondaryTile_get_LockScreenDisplayBadgeAndTileText), reinterpret_cast<setter>(SecondaryTile_put_LockScreenDisplayBadgeAndTileText), nullptr, nullptr },
        { "lock_screen_badge_logo", reinterpret_cast<getter>(SecondaryTile_get_LockScreenBadgeLogo), reinterpret_cast<setter>(SecondaryTile_put_LockScreenBadgeLogo), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(SecondaryTile_get_Arguments), reinterpret_cast<setter>(SecondaryTile_put_Arguments), nullptr, nullptr },
        { "foreground_text", reinterpret_cast<getter>(SecondaryTile_get_ForegroundText), reinterpret_cast<setter>(SecondaryTile_put_ForegroundText), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(SecondaryTile_get_DisplayName), reinterpret_cast<setter>(SecondaryTile_put_DisplayName), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(SecondaryTile_get_BackgroundColor), reinterpret_cast<setter>(SecondaryTile_put_BackgroundColor), nullptr, nullptr },
        { "wide_logo", reinterpret_cast<getter>(SecondaryTile_get_WideLogo), reinterpret_cast<setter>(SecondaryTile_put_WideLogo), nullptr, nullptr },
        { "tile_options", reinterpret_cast<getter>(SecondaryTile_get_TileOptions), reinterpret_cast<setter>(SecondaryTile_put_TileOptions), nullptr, nullptr },
        { "small_logo", reinterpret_cast<getter>(SecondaryTile_get_SmallLogo), reinterpret_cast<setter>(SecondaryTile_put_SmallLogo), nullptr, nullptr },
        { "roaming_enabled", reinterpret_cast<getter>(SecondaryTile_get_RoamingEnabled), reinterpret_cast<setter>(SecondaryTile_put_RoamingEnabled), nullptr, nullptr },
        { "phonetic_name", reinterpret_cast<getter>(SecondaryTile_get_PhoneticName), reinterpret_cast<setter>(SecondaryTile_put_PhoneticName), nullptr, nullptr },
        { "visual_elements", reinterpret_cast<getter>(SecondaryTile_get_VisualElements), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SecondaryTile[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SecondaryTile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SecondaryTile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SecondaryTile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SecondaryTile) },
        { }};

    static PyType_Spec type_spec_SecondaryTile = {
        "winrt._winrt_windows_ui_startscreen.SecondaryTile",
        sizeof(py::wrapper::Windows::UI::StartScreen::SecondaryTile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecondaryTile};

    static PyGetSetDef getset_SecondaryTile_Static[] = {
        { }};

    static PyMethodDef methods_SecondaryTile_Static[] = {
        { "exists", reinterpret_cast<PyCFunction>(SecondaryTile_Exists), METH_VARARGS, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(SecondaryTile_FindAllAsync), METH_VARARGS, nullptr },
        { "find_all_for_application_async", reinterpret_cast<PyCFunction>(SecondaryTile_FindAllForApplicationAsync), METH_VARARGS, nullptr },
        { "find_all_for_package_async", reinterpret_cast<PyCFunction>(SecondaryTile_FindAllForPackageAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SecondaryTile_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SecondaryTile_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SecondaryTile_Static) },
        { }
    };

    static PyType_Spec type_spec_SecondaryTile_Static = {
        "winrt._winrt_windows_ui_startscreen.SecondaryTile_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SecondaryTile_Static};

    // ----- SecondaryTileVisualElements class --------------------

    static PyObject* _new_SecondaryTileVisualElements(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::StartScreen::SecondaryTileVisualElements>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::StartScreen::SecondaryTileVisualElements>::type_name);
        return nullptr;
    }

    static void _dealloc_SecondaryTileVisualElements(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SecondaryTileVisualElements_get_Square150x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square150x150Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Square150x150Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square150x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square150x150Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Square150x150Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_ShowNameOnWide310x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnWide310x150Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowNameOnWide310x150Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_ShowNameOnWide310x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnWide310x150Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowNameOnWide310x150Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_ShowNameOnSquare310x310Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnSquare310x310Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowNameOnSquare310x310Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_ShowNameOnSquare310x310Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnSquare310x310Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowNameOnSquare310x310Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_ShowNameOnSquare150x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnSquare150x150Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowNameOnSquare150x150Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_ShowNameOnSquare150x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnSquare150x150Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowNameOnSquare150x150Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_ForegroundText(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ForegroundText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ForegroundText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_ForegroundText(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ForegroundText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::ForegroundText>(arg);

            {
                auto _gil = release_gil();
                self->obj.ForegroundText(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_BackgroundColor(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BackgroundColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_BackgroundColor(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.BackgroundColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Wide310x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Wide310x150Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Wide310x150Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Wide310x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Wide310x150Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Wide310x150Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square70x70Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square70x70Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Square70x70Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square70x70Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square70x70Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Square70x70Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square310x310Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square310x310Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Square310x310Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square310x310Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square310x310Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Square310x310Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square30x30Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square30x30Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Square30x30Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square30x30Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square30x30Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Square30x30Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square71x71Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square71x71Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Square71x71Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square71x71Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square71x71Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Square71x71Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square44x44Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square44x44Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Square44x44Logo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square44x44Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square44x44Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Square44x44Logo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_MixedRealityModel(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"MixedRealityModel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MixedRealityModel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SecondaryTileVisualElements(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::SecondaryTileVisualElements>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SecondaryTileVisualElements(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::SecondaryTileVisualElements>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecondaryTileVisualElements[] = {
        { "_assign_array_", _assign_array_SecondaryTileVisualElements, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecondaryTileVisualElements), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SecondaryTileVisualElements[] = {
        { "square150x150_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square150x150Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square150x150Logo), nullptr, nullptr },
        { "show_name_on_wide310x150_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_ShowNameOnWide310x150Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_ShowNameOnWide310x150Logo), nullptr, nullptr },
        { "show_name_on_square310x310_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_ShowNameOnSquare310x310Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_ShowNameOnSquare310x310Logo), nullptr, nullptr },
        { "show_name_on_square150x150_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_ShowNameOnSquare150x150Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_ShowNameOnSquare150x150Logo), nullptr, nullptr },
        { "foreground_text", reinterpret_cast<getter>(SecondaryTileVisualElements_get_ForegroundText), reinterpret_cast<setter>(SecondaryTileVisualElements_put_ForegroundText), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(SecondaryTileVisualElements_get_BackgroundColor), reinterpret_cast<setter>(SecondaryTileVisualElements_put_BackgroundColor), nullptr, nullptr },
        { "wide310x150_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Wide310x150Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Wide310x150Logo), nullptr, nullptr },
        { "square70x70_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square70x70Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square70x70Logo), nullptr, nullptr },
        { "square310x310_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square310x310Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square310x310Logo), nullptr, nullptr },
        { "square30x30_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square30x30Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square30x30Logo), nullptr, nullptr },
        { "square71x71_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square71x71Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square71x71Logo), nullptr, nullptr },
        { "square44x44_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square44x44Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square44x44Logo), nullptr, nullptr },
        { "mixed_reality_model", reinterpret_cast<getter>(SecondaryTileVisualElements_get_MixedRealityModel), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SecondaryTileVisualElements[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SecondaryTileVisualElements) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SecondaryTileVisualElements) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SecondaryTileVisualElements) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SecondaryTileVisualElements) },
        { }};

    static PyType_Spec type_spec_SecondaryTileVisualElements = {
        "winrt._winrt_windows_ui_startscreen.SecondaryTileVisualElements",
        sizeof(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecondaryTileVisualElements};

    // ----- StartScreenManager class --------------------

    static PyObject* _new_StartScreenManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::StartScreen::StartScreenManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::StartScreen::StartScreenManager>::type_name);
        return nullptr;
    }

    static void _dealloc_StartScreenManager(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StartScreenManager_ContainsAppListEntryAsync(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"ContainsAppListEntryAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ContainsAppListEntryAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_ContainsSecondaryTileAsync(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"ContainsSecondaryTileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ContainsSecondaryTileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::StartScreenManager::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::StartScreen::StartScreenManager::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_RequestAddAppListEntryAsync(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"RequestAddAppListEntryAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestAddAppListEntryAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_SupportsAppListEntry(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"SupportsAppListEntry", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SupportsAppListEntry(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_TryRemoveSecondaryTileAsync(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"TryRemoveSecondaryTileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryRemoveSecondaryTileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_get_User(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.StartScreenManager", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StartScreenManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::StartScreenManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StartScreenManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::StartScreenManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartScreenManager[] = {
        { "contains_app_list_entry_async", reinterpret_cast<PyCFunction>(StartScreenManager_ContainsAppListEntryAsync), METH_VARARGS, nullptr },
        { "contains_secondary_tile_async", reinterpret_cast<PyCFunction>(StartScreenManager_ContainsSecondaryTileAsync), METH_VARARGS, nullptr },
        { "request_add_app_list_entry_async", reinterpret_cast<PyCFunction>(StartScreenManager_RequestAddAppListEntryAsync), METH_VARARGS, nullptr },
        { "supports_app_list_entry", reinterpret_cast<PyCFunction>(StartScreenManager_SupportsAppListEntry), METH_VARARGS, nullptr },
        { "try_remove_secondary_tile_async", reinterpret_cast<PyCFunction>(StartScreenManager_TryRemoveSecondaryTileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StartScreenManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StartScreenManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StartScreenManager[] = {
        { "user", reinterpret_cast<getter>(StartScreenManager_get_User), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StartScreenManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StartScreenManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StartScreenManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StartScreenManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StartScreenManager) },
        { }};

    static PyType_Spec type_spec_StartScreenManager = {
        "winrt._winrt_windows_ui_startscreen.StartScreenManager",
        sizeof(py::wrapper::Windows::UI::StartScreen::StartScreenManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartScreenManager};

    static PyGetSetDef getset_StartScreenManager_Static[] = {
        { }};

    static PyMethodDef methods_StartScreenManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(StartScreenManager_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(StartScreenManager_GetForUser), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_StartScreenManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StartScreenManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StartScreenManager_Static) },
        { }
    };

    static PyType_Spec type_spec_StartScreenManager_Static = {
        "winrt._winrt_windows_ui_startscreen.StartScreenManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StartScreenManager_Static};

    // ----- TileMixedRealityModel class --------------------

    static PyObject* _new_TileMixedRealityModel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::StartScreen::TileMixedRealityModel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::StartScreen::TileMixedRealityModel>::type_name);
        return nullptr;
    }

    static void _dealloc_TileMixedRealityModel(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileMixedRealityModel_get_Uri(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileMixedRealityModel_put_Uri(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Uri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileMixedRealityModel_get_BoundingBox(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"BoundingBox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BoundingBox();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileMixedRealityModel_put_BoundingBox(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"BoundingBox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Perception::Spatial::SpatialBoundingBox>>(arg);

            {
                auto _gil = release_gil();
                self->obj.BoundingBox(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileMixedRealityModel_get_ActivationBehavior(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"ActivationBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivationBehavior();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileMixedRealityModel_put_ActivationBehavior(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"ActivationBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::TileMixedRealityModelActivationBehavior>(arg);

            {
                auto _gil = release_gil();
                self->obj.ActivationBehavior(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TileMixedRealityModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::TileMixedRealityModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileMixedRealityModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::TileMixedRealityModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileMixedRealityModel[] = {
        { "_assign_array_", _assign_array_TileMixedRealityModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileMixedRealityModel), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TileMixedRealityModel[] = {
        { "uri", reinterpret_cast<getter>(TileMixedRealityModel_get_Uri), reinterpret_cast<setter>(TileMixedRealityModel_put_Uri), nullptr, nullptr },
        { "bounding_box", reinterpret_cast<getter>(TileMixedRealityModel_get_BoundingBox), reinterpret_cast<setter>(TileMixedRealityModel_put_BoundingBox), nullptr, nullptr },
        { "activation_behavior", reinterpret_cast<getter>(TileMixedRealityModel_get_ActivationBehavior), reinterpret_cast<setter>(TileMixedRealityModel_put_ActivationBehavior), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TileMixedRealityModel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileMixedRealityModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileMixedRealityModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileMixedRealityModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileMixedRealityModel) },
        { }};

    static PyType_Spec type_spec_TileMixedRealityModel = {
        "winrt._winrt_windows_ui_startscreen.TileMixedRealityModel",
        sizeof(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileMixedRealityModel};

    // ----- VisualElementsRequest class --------------------

    static PyObject* _new_VisualElementsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::StartScreen::VisualElementsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::StartScreen::VisualElementsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualElementsRequest(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualElementsRequest_GetDeferral(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.VisualElementsRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualElementsRequest_get_AlternateVisualElements(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.VisualElementsRequest", L"AlternateVisualElements");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AlternateVisualElements();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualElementsRequest_get_Deadline(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.VisualElementsRequest", L"Deadline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Deadline();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualElementsRequest_get_VisualElements(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.VisualElementsRequest", L"VisualElements");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VisualElements();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualElementsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::VisualElementsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualElementsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::VisualElementsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualElementsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(VisualElementsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VisualElementsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualElementsRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VisualElementsRequest[] = {
        { "alternate_visual_elements", reinterpret_cast<getter>(VisualElementsRequest_get_AlternateVisualElements), nullptr, nullptr, nullptr },
        { "deadline", reinterpret_cast<getter>(VisualElementsRequest_get_Deadline), nullptr, nullptr, nullptr },
        { "visual_elements", reinterpret_cast<getter>(VisualElementsRequest_get_VisualElements), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_VisualElementsRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualElementsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualElementsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualElementsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualElementsRequest) },
        { }};

    static PyType_Spec type_spec_VisualElementsRequest = {
        "winrt._winrt_windows_ui_startscreen.VisualElementsRequest",
        sizeof(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualElementsRequest};

    // ----- VisualElementsRequestDeferral class --------------------

    static PyObject* _new_VisualElementsRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::StartScreen::VisualElementsRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::StartScreen::VisualElementsRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualElementsRequestDeferral(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualElementsRequestDeferral_Complete(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.VisualElementsRequestDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualElementsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::VisualElementsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualElementsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::VisualElementsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualElementsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(VisualElementsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VisualElementsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualElementsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VisualElementsRequestDeferral[] = {
        { }};

    static PyType_Slot _type_slots_VisualElementsRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualElementsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualElementsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualElementsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualElementsRequestDeferral) },
        { }};

    static PyType_Spec type_spec_VisualElementsRequestDeferral = {
        "winrt._winrt_windows_ui_startscreen.VisualElementsRequestDeferral",
        sizeof(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualElementsRequestDeferral};

    // ----- VisualElementsRequestedEventArgs class --------------------

    static PyObject* _new_VisualElementsRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualElementsRequestedEventArgs(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualElementsRequestedEventArgs_get_Request(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.VisualElementsRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualElementsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualElementsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualElementsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_VisualElementsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualElementsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VisualElementsRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(VisualElementsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_VisualElementsRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualElementsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualElementsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualElementsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualElementsRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_VisualElementsRequestedEventArgs = {
        "winrt._winrt_windows_ui_startscreen.VisualElementsRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualElementsRequestedEventArgs};

    // ----- Windows.UI.StartScreen Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.StartScreen");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_startscreen",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::StartScreen

PyMODINIT_FUNC PyInit__winrt_windows_ui_startscreen(void) noexcept
{
    using namespace py::cpp::Windows::UI::StartScreen;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle JumpList_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!JumpList_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_JumpList_Static{PyType_FromSpecWithBases(&type_spec_JumpList_Static, JumpList_Static_bases.get())};
    if (!type_JumpList_Static)
    {
        return nullptr;
    }

    py::pytype_handle JumpList_type{py::register_python_type(module.get(), &type_spec_JumpList, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_JumpList_Static.get()))};
    if (!JumpList_type)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!JumpListItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_JumpListItem_Static{PyType_FromSpecWithBases(&type_spec_JumpListItem_Static, JumpListItem_Static_bases.get())};
    if (!type_JumpListItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle JumpListItem_type{py::register_python_type(module.get(), &type_spec_JumpListItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_JumpListItem_Static.get()))};
    if (!JumpListItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle SecondaryTile_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SecondaryTile_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SecondaryTile_Static{PyType_FromSpecWithBases(&type_spec_SecondaryTile_Static, SecondaryTile_Static_bases.get())};
    if (!type_SecondaryTile_Static)
    {
        return nullptr;
    }

    py::pytype_handle SecondaryTile_type{py::register_python_type(module.get(), &type_spec_SecondaryTile, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SecondaryTile_Static.get()))};
    if (!SecondaryTile_type)
    {
        return nullptr;
    }

    py::pytype_handle SecondaryTileVisualElements_type{py::register_python_type(module.get(), &type_spec_SecondaryTileVisualElements, object_bases.get(), inspectable_meta_type)};
    if (!SecondaryTileVisualElements_type)
    {
        return nullptr;
    }

    py::pyobj_handle StartScreenManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!StartScreenManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StartScreenManager_Static{PyType_FromSpecWithBases(&type_spec_StartScreenManager_Static, StartScreenManager_Static_bases.get())};
    if (!type_StartScreenManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle StartScreenManager_type{py::register_python_type(module.get(), &type_spec_StartScreenManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StartScreenManager_Static.get()))};
    if (!StartScreenManager_type)
    {
        return nullptr;
    }

    py::pytype_handle TileMixedRealityModel_type{py::register_python_type(module.get(), &type_spec_TileMixedRealityModel, object_bases.get(), inspectable_meta_type)};
    if (!TileMixedRealityModel_type)
    {
        return nullptr;
    }

    py::pytype_handle VisualElementsRequest_type{py::register_python_type(module.get(), &type_spec_VisualElementsRequest, object_bases.get(), inspectable_meta_type)};
    if (!VisualElementsRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle VisualElementsRequestDeferral_type{py::register_python_type(module.get(), &type_spec_VisualElementsRequestDeferral, object_bases.get(), inspectable_meta_type)};
    if (!VisualElementsRequestDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle VisualElementsRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_VisualElementsRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!VisualElementsRequestedEventArgs_type)
    {
        return nullptr;
    }


    return module.detach();
}
