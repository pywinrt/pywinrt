// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.System.Diagnostics.h"

namespace py::cpp::Windows::System::Diagnostics
{
    // ----- DiagnosticActionResult class --------------------

    static PyObject* _new_DiagnosticActionResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::type_name);
        return nullptr;
    }

    static void _dealloc_DiagnosticActionResult(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DiagnosticActionResult_get_ExtendedError(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticActionResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DiagnosticActionResult_get_Results(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticActionResult", L"Results");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Results();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DiagnosticActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::DiagnosticActionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiagnosticActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticActionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticActionResult[] = {
        { "_assign_array_", _assign_array_DiagnosticActionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiagnosticActionResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DiagnosticActionResult[] = {
        { "extended_error", reinterpret_cast<getter>(DiagnosticActionResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "results", reinterpret_cast<getter>(DiagnosticActionResult_get_Results), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DiagnosticActionResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiagnosticActionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiagnosticActionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiagnosticActionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiagnosticActionResult) },
        { }};

    static PyType_Spec type_spec_DiagnosticActionResult = {
        "winrt._winrt_windows_system_diagnostics.DiagnosticActionResult",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticActionResult};

    // ----- DiagnosticInvoker class --------------------

    static PyObject* _new_DiagnosticInvoker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::type_name);
        return nullptr;
    }

    static void _dealloc_DiagnosticInvoker(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DiagnosticInvoker_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"RunDiagnosticActionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Data::Json::JsonObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RunDiagnosticActionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionFromStringAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"RunDiagnosticActionFromStringAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RunDiagnosticActionFromStringAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_get_IsSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"IsSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Diagnostics::DiagnosticInvoker::IsSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DiagnosticInvoker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::DiagnosticInvoker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiagnosticInvoker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticInvoker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticInvoker[] = {
        { "run_diagnostic_action_async", reinterpret_cast<PyCFunction>(DiagnosticInvoker_RunDiagnosticActionAsync), METH_VARARGS, nullptr },
        { "run_diagnostic_action_from_string_async", reinterpret_cast<PyCFunction>(DiagnosticInvoker_RunDiagnosticActionFromStringAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DiagnosticInvoker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiagnosticInvoker), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DiagnosticInvoker[] = {
        { }};

    static PyType_Slot _type_slots_DiagnosticInvoker[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiagnosticInvoker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiagnosticInvoker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiagnosticInvoker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiagnosticInvoker) },
        { }};

    static PyType_Spec type_spec_DiagnosticInvoker = {
        "winrt._winrt_windows_system_diagnostics.DiagnosticInvoker",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticInvoker};

    static PyGetSetDef getset_DiagnosticInvoker_Static[] = {
        { "is_supported", reinterpret_cast<getter>(DiagnosticInvoker_get_IsSupported), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_DiagnosticInvoker_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(DiagnosticInvoker_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(DiagnosticInvoker_GetForUser), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_DiagnosticInvoker_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DiagnosticInvoker_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DiagnosticInvoker_Static) },
        { }
    };

    static PyType_Spec type_spec_DiagnosticInvoker_Static = {
        "winrt._winrt_windows_system_diagnostics.DiagnosticInvoker_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DiagnosticInvoker_Static};

    // ----- ProcessCpuUsage class --------------------

    static PyObject* _new_ProcessCpuUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessCpuUsage", L"GetReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessCpuUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessCpuUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessCpuUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessCpuUsage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProcessCpuUsage[] = {
        { }};

    static PyType_Slot _type_slots_ProcessCpuUsage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessCpuUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessCpuUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessCpuUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessCpuUsage) },
        { }};

    static PyType_Spec type_spec_ProcessCpuUsage = {
        "winrt._winrt_windows_system_diagnostics.ProcessCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsage};

    // ----- ProcessCpuUsageReport class --------------------

    static PyObject* _new_ProcessCpuUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessCpuUsageReport", L"KernelTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KernelTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessCpuUsageReport", L"UserTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessCpuUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessCpuUsageReport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProcessCpuUsageReport[] = {
        { "kernel_time", reinterpret_cast<getter>(ProcessCpuUsageReport_get_KernelTime), nullptr, nullptr, nullptr },
        { "user_time", reinterpret_cast<getter>(ProcessCpuUsageReport_get_UserTime), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProcessCpuUsageReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessCpuUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessCpuUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessCpuUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessCpuUsageReport) },
        { }};

    static PyType_Spec type_spec_ProcessCpuUsageReport = {
        "winrt._winrt_windows_system_diagnostics.ProcessCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsageReport};

    // ----- ProcessDiagnosticInfo class --------------------

    static PyObject* _new_ProcessDiagnosticInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiagnosticInfo_GetAppDiagnosticInfos(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetAppDiagnosticInfos", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAppDiagnosticInfos();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForCurrentProcess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetForCurrentProcess", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForCurrentProcess();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForProcesses(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetForProcesses", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForProcesses();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_TryGetForProcessId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"TryGetForProcessId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::TryGetForProcessId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"CpuUsage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CpuUsage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_DiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"DiskUsage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DiskUsage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ExecutableFileName(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ExecutableFileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExecutableFileName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"MemoryUsage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MemoryUsage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_Parent(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Parent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessId(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ProcessId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProcessId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessStartTime(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ProcessStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProcessStartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_IsPackaged(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"IsPackaged");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPackaged();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiagnosticInfo[] = {
        { "get_app_diagnostic_infos", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetAppDiagnosticInfos), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProcessDiagnosticInfo[] = {
        { "cpu_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_CpuUsage), nullptr, nullptr, nullptr },
        { "disk_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_DiskUsage), nullptr, nullptr, nullptr },
        { "executable_file_name", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ExecutableFileName), nullptr, nullptr, nullptr },
        { "memory_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_MemoryUsage), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_Parent), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ProcessId), nullptr, nullptr, nullptr },
        { "process_start_time", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ProcessStartTime), nullptr, nullptr, nullptr },
        { "is_packaged", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_IsPackaged), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProcessDiagnosticInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiagnosticInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiagnosticInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiagnosticInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiagnosticInfo) },
        { }};

    static PyType_Spec type_spec_ProcessDiagnosticInfo = {
        "winrt._winrt_windows_system_diagnostics.ProcessDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiagnosticInfo};

    static PyGetSetDef getset_ProcessDiagnosticInfo_Static[] = {
        { }};

    static PyMethodDef methods_ProcessDiagnosticInfo_Static[] = {
        { "get_for_current_process", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetForCurrentProcess), METH_VARARGS, nullptr },
        { "get_for_processes", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetForProcesses), METH_VARARGS, nullptr },
        { "try_get_for_process_id", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_TryGetForProcessId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ProcessDiagnosticInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProcessDiagnosticInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProcessDiagnosticInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_ProcessDiagnosticInfo_Static = {
        "winrt._winrt_windows_system_diagnostics.ProcessDiagnosticInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProcessDiagnosticInfo_Static};

    // ----- ProcessDiskUsage class --------------------

    static PyObject* _new_ProcessDiskUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiskUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiskUsage", L"GetReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiskUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiskUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiskUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessDiskUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessDiskUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiskUsage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProcessDiskUsage[] = {
        { }};

    static PyType_Slot _type_slots_ProcessDiskUsage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiskUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiskUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiskUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiskUsage) },
        { }};

    static PyType_Spec type_spec_ProcessDiskUsage = {
        "winrt._winrt_windows_system_diagnostics.ProcessDiskUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsage};

    // ----- ProcessDiskUsageReport class --------------------

    static PyObject* _new_ProcessDiskUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiskUsageReport_get_BytesReadCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"BytesReadCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BytesReadCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_BytesWrittenCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"BytesWrittenCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BytesWrittenCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherBytesCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"OtherBytesCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OtherBytesCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"OtherOperationCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OtherOperationCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_ReadOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"ReadOperationCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReadOperationCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_WriteOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"WriteOperationCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WriteOperationCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiskUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiskUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessDiskUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiskUsageReport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProcessDiskUsageReport[] = {
        { "bytes_read_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_BytesReadCount), nullptr, nullptr, nullptr },
        { "bytes_written_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_BytesWrittenCount), nullptr, nullptr, nullptr },
        { "other_bytes_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_OtherBytesCount), nullptr, nullptr, nullptr },
        { "other_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_OtherOperationCount), nullptr, nullptr, nullptr },
        { "read_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_ReadOperationCount), nullptr, nullptr, nullptr },
        { "write_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_WriteOperationCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProcessDiskUsageReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiskUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiskUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiskUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiskUsageReport) },
        { }};

    static PyType_Spec type_spec_ProcessDiskUsageReport = {
        "winrt._winrt_windows_system_diagnostics.ProcessDiskUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsageReport};

    // ----- ProcessMemoryUsage class --------------------

    static PyObject* _new_ProcessMemoryUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessMemoryUsage", L"GetReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessMemoryUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessMemoryUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryUsage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProcessMemoryUsage[] = {
        { }};

    static PyType_Slot _type_slots_ProcessMemoryUsage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessMemoryUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessMemoryUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessMemoryUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessMemoryUsage) },
        { }};

    static PyType_Spec type_spec_ProcessMemoryUsage = {
        "winrt._winrt_windows_system_diagnostics.ProcessMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsage};

    // ----- ProcessMemoryUsageReport class --------------------

    static PyObject* _new_ProcessMemoryUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"NonPagedPoolSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NonPagedPoolSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFaultCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PageFaultCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PageFaultCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PageFileSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PageFileSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PagedPoolSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PagedPoolSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakNonPagedPoolSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PeakNonPagedPoolSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakPageFileSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PeakPageFileSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakPagedPoolSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PeakPagedPoolSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakVirtualMemorySizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PeakVirtualMemorySizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakWorkingSetSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PeakWorkingSetSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PrivatePageCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PrivatePageCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrivatePageCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"VirtualMemorySizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VirtualMemorySizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_WorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"WorkingSetSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WorkingSetSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessMemoryUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryUsageReport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProcessMemoryUsageReport[] = {
        { "non_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "page_fault_count", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PageFaultCount), nullptr, nullptr, nullptr },
        { "page_file_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PageFileSizeInBytes), nullptr, nullptr, nullptr },
        { "paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_non_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_page_file_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_virtual_memory_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes), nullptr, nullptr, nullptr },
        { "peak_working_set_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes), nullptr, nullptr, nullptr },
        { "private_page_count", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PrivatePageCount), nullptr, nullptr, nullptr },
        { "virtual_memory_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes), nullptr, nullptr, nullptr },
        { "working_set_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_WorkingSetSizeInBytes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProcessMemoryUsageReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessMemoryUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessMemoryUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessMemoryUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessMemoryUsageReport) },
        { }};

    static PyType_Spec type_spec_ProcessMemoryUsageReport = {
        "winrt._winrt_windows_system_diagnostics.ProcessMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsageReport};

    // ----- SystemCpuUsage class --------------------

    static PyObject* _new_SystemCpuUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsage(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemCpuUsage", L"GetReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemCpuUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(SystemCpuUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SystemCpuUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCpuUsage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemCpuUsage[] = {
        { }};

    static PyType_Slot _type_slots_SystemCpuUsage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemCpuUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemCpuUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemCpuUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemCpuUsage) },
        { }};

    static PyType_Spec type_spec_SystemCpuUsage = {
        "winrt._winrt_windows_system_diagnostics.SystemCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsage};

    // ----- SystemCpuUsageReport class --------------------

    static PyObject* _new_SystemCpuUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsageReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemCpuUsageReport_get_IdleTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"IdleTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IdleTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"KernelTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KernelTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"UserTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsageReport[] = {
        { "_assign_array_", _assign_array_SystemCpuUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCpuUsageReport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemCpuUsageReport[] = {
        { "idle_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_IdleTime), nullptr, nullptr, nullptr },
        { "kernel_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_KernelTime), nullptr, nullptr, nullptr },
        { "user_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_UserTime), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemCpuUsageReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemCpuUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemCpuUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemCpuUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemCpuUsageReport) },
        { }};

    static PyType_Spec type_spec_SystemCpuUsageReport = {
        "winrt._winrt_windows_system_diagnostics.SystemCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsageReport};

    // ----- SystemDiagnosticInfo class --------------------

    static PyObject* _new_SystemDiagnosticInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemDiagnosticInfo_GetForCurrentSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"GetForCurrentSystem", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::GetForCurrentSystem();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_IsArchitectureSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"IsArchitectureSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::ProcessorArchitecture>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::IsArchitectureSupported(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"CpuUsage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CpuUsage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"MemoryUsage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MemoryUsage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_PreferredArchitecture(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"PreferredArchitecture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::PreferredArchitecture();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDiagnosticInfo[] = {
        { "_assign_array_", _assign_array_SystemDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemDiagnosticInfo[] = {
        { "cpu_usage", reinterpret_cast<getter>(SystemDiagnosticInfo_get_CpuUsage), nullptr, nullptr, nullptr },
        { "memory_usage", reinterpret_cast<getter>(SystemDiagnosticInfo_get_MemoryUsage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemDiagnosticInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemDiagnosticInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemDiagnosticInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemDiagnosticInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemDiagnosticInfo) },
        { }};

    static PyType_Spec type_spec_SystemDiagnosticInfo = {
        "winrt._winrt_windows_system_diagnostics.SystemDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDiagnosticInfo};

    static PyGetSetDef getset_SystemDiagnosticInfo_Static[] = {
        { "preferred_architecture", reinterpret_cast<getter>(SystemDiagnosticInfo_get_PreferredArchitecture), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SystemDiagnosticInfo_Static[] = {
        { "get_for_current_system", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_GetForCurrentSystem), METH_VARARGS, nullptr },
        { "is_architecture_supported", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_IsArchitectureSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SystemDiagnosticInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemDiagnosticInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemDiagnosticInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemDiagnosticInfo_Static = {
        "winrt._winrt_windows_system_diagnostics.SystemDiagnosticInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemDiagnosticInfo_Static};

    // ----- SystemMemoryUsage class --------------------

    static PyObject* _new_SystemMemoryUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemMemoryUsage", L"GetReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemMemoryUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(SystemMemoryUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SystemMemoryUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMemoryUsage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemMemoryUsage[] = {
        { }};

    static PyType_Slot _type_slots_SystemMemoryUsage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMemoryUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMemoryUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMemoryUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMemoryUsage) },
        { }};

    static PyType_Spec type_spec_SystemMemoryUsage = {
        "winrt._winrt_windows_system_diagnostics.SystemMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsage};

    // ----- SystemMemoryUsageReport class --------------------

    static PyObject* _new_SystemMemoryUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMemoryUsageReport_get_AvailableSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"AvailableSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AvailableSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_CommittedSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"CommittedSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CommittedSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"TotalPhysicalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TotalPhysicalSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsageReport[] = {
        { "_assign_array_", _assign_array_SystemMemoryUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMemoryUsageReport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemMemoryUsageReport[] = {
        { "available_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_AvailableSizeInBytes), nullptr, nullptr, nullptr },
        { "committed_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_CommittedSizeInBytes), nullptr, nullptr, nullptr },
        { "total_physical_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemMemoryUsageReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMemoryUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMemoryUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMemoryUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMemoryUsageReport) },
        { }};

    static PyType_Spec type_spec_SystemMemoryUsageReport = {
        "winrt._winrt_windows_system_diagnostics.SystemMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsageReport};

    // ----- Windows.System.Diagnostics Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.System.Diagnostics");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_system_diagnostics",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::System::Diagnostics

PyMODINIT_FUNC PyInit__winrt_windows_system_diagnostics(void) noexcept
{
    using namespace py::cpp::Windows::System::Diagnostics;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle DiagnosticActionResult_type{py::register_python_type(module.get(), &type_spec_DiagnosticActionResult, object_bases.get(), inspectable_meta_type)};
    if (!DiagnosticActionResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle DiagnosticInvoker_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!DiagnosticInvoker_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DiagnosticInvoker_Static{PyType_FromSpecWithBases(&type_spec_DiagnosticInvoker_Static, DiagnosticInvoker_Static_bases.get())};
    if (!type_DiagnosticInvoker_Static)
    {
        return nullptr;
    }

    py::pytype_handle DiagnosticInvoker_type{py::register_python_type(module.get(), &type_spec_DiagnosticInvoker, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DiagnosticInvoker_Static.get()))};
    if (!DiagnosticInvoker_type)
    {
        return nullptr;
    }

    py::pytype_handle ProcessCpuUsage_type{py::register_python_type(module.get(), &type_spec_ProcessCpuUsage, object_bases.get(), inspectable_meta_type)};
    if (!ProcessCpuUsage_type)
    {
        return nullptr;
    }

    py::pytype_handle ProcessCpuUsageReport_type{py::register_python_type(module.get(), &type_spec_ProcessCpuUsageReport, object_bases.get(), inspectable_meta_type)};
    if (!ProcessCpuUsageReport_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProcessDiagnosticInfo_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ProcessDiagnosticInfo_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProcessDiagnosticInfo_Static{PyType_FromSpecWithBases(&type_spec_ProcessDiagnosticInfo_Static, ProcessDiagnosticInfo_Static_bases.get())};
    if (!type_ProcessDiagnosticInfo_Static)
    {
        return nullptr;
    }

    py::pytype_handle ProcessDiagnosticInfo_type{py::register_python_type(module.get(), &type_spec_ProcessDiagnosticInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProcessDiagnosticInfo_Static.get()))};
    if (!ProcessDiagnosticInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ProcessDiskUsage_type{py::register_python_type(module.get(), &type_spec_ProcessDiskUsage, object_bases.get(), inspectable_meta_type)};
    if (!ProcessDiskUsage_type)
    {
        return nullptr;
    }

    py::pytype_handle ProcessDiskUsageReport_type{py::register_python_type(module.get(), &type_spec_ProcessDiskUsageReport, object_bases.get(), inspectable_meta_type)};
    if (!ProcessDiskUsageReport_type)
    {
        return nullptr;
    }

    py::pytype_handle ProcessMemoryUsage_type{py::register_python_type(module.get(), &type_spec_ProcessMemoryUsage, object_bases.get(), inspectable_meta_type)};
    if (!ProcessMemoryUsage_type)
    {
        return nullptr;
    }

    py::pytype_handle ProcessMemoryUsageReport_type{py::register_python_type(module.get(), &type_spec_ProcessMemoryUsageReport, object_bases.get(), inspectable_meta_type)};
    if (!ProcessMemoryUsageReport_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemCpuUsage_type{py::register_python_type(module.get(), &type_spec_SystemCpuUsage, object_bases.get(), inspectable_meta_type)};
    if (!SystemCpuUsage_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemCpuUsageReport_type{py::register_python_type(module.get(), &type_spec_SystemCpuUsageReport, object_bases.get(), inspectable_meta_type)};
    if (!SystemCpuUsageReport_type)
    {
        return nullptr;
    }

    py::pyobj_handle SystemDiagnosticInfo_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SystemDiagnosticInfo_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemDiagnosticInfo_Static{PyType_FromSpecWithBases(&type_spec_SystemDiagnosticInfo_Static, SystemDiagnosticInfo_Static_bases.get())};
    if (!type_SystemDiagnosticInfo_Static)
    {
        return nullptr;
    }

    py::pytype_handle SystemDiagnosticInfo_type{py::register_python_type(module.get(), &type_spec_SystemDiagnosticInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemDiagnosticInfo_Static.get()))};
    if (!SystemDiagnosticInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemMemoryUsage_type{py::register_python_type(module.get(), &type_spec_SystemMemoryUsage, object_bases.get(), inspectable_meta_type)};
    if (!SystemMemoryUsage_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemMemoryUsageReport_type{py::register_python_type(module.get(), &type_spec_SystemMemoryUsageReport, object_bases.get(), inspectable_meta_type)};
    if (!SystemMemoryUsageReport_type)
    {
        return nullptr;
    }


    return module.detach();
}
