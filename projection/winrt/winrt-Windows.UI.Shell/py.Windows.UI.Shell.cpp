// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.0.0

#include "py.Windows.UI.Shell.h"

namespace py::cpp::Windows::UI::Shell
{
    // ----- AdaptiveCardBuilder class --------------------

    static PyObject* _new_AdaptiveCardBuilder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::AdaptiveCardBuilder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::AdaptiveCardBuilder>::type_name);
        return nullptr;
    }

    static PyObject* AdaptiveCardBuilder_CreateAdaptiveCardFromJson(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.AdaptiveCardBuilder", L"CreateAdaptiveCardFromJson", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::AdaptiveCardBuilder::CreateAdaptiveCardFromJson(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveCardBuilder[] = {
        { }};

    static PyGetSetDef _getset_AdaptiveCardBuilder[] = {
        { }};

    static PyType_Slot _type_slots_AdaptiveCardBuilder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveCardBuilder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveCardBuilder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveCardBuilder) },
        { }};

    static PyType_Spec type_spec_AdaptiveCardBuilder = {
        "winrt._winrt_windows_ui_shell.AdaptiveCardBuilder",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveCardBuilder};

    static PyGetSetDef getset_AdaptiveCardBuilder_Static[] = {
        { }};

    static PyMethodDef methods_AdaptiveCardBuilder_Static[] = {
        { "create_adaptive_card_from_json", reinterpret_cast<PyCFunction>(AdaptiveCardBuilder_CreateAdaptiveCardFromJson), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AdaptiveCardBuilder_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AdaptiveCardBuilder_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AdaptiveCardBuilder_Static) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveCardBuilder_Static = {
        "winrt._winrt_windows_ui_shell.AdaptiveCardBuilder_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AdaptiveCardBuilder_Static};

    // ----- FocusSession class --------------------

    static PyObject* _new_FocusSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::FocusSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::FocusSession>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusSession(py::wrapper::Windows::UI::Shell::FocusSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusSession_End(py::wrapper::Windows::UI::Shell::FocusSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSession", L"End", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.End();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSession_get_Id(py::wrapper::Windows::UI::Shell::FocusSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.FocusSession", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::FocusSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::FocusSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSession[] = {
        { "end", reinterpret_cast<PyCFunction>(FocusSession_End), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FocusSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusSession[] = {
        { "id", reinterpret_cast<getter>(FocusSession_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FocusSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusSession) },
        { }};

    static PyType_Spec type_spec_FocusSession = {
        "winrt._winrt_windows_ui_shell.FocusSession",
        sizeof(py::wrapper::Windows::UI::Shell::FocusSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSession};

    // ----- FocusSessionManager class --------------------

    static PyObject* _new_FocusSessionManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::FocusSessionManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::FocusSessionManager>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusSessionManager(py::wrapper::Windows::UI::Shell::FocusSessionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusSessionManager_DeactivateFocus(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"DeactivateFocus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.DeactivateFocus();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::FocusSessionManager::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_GetSession(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"GetSession", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSession(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_TryStartFocusSession(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"TryStartFocusSession", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryStartFocusSession();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_TryStartFocusSession2(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.FocusSessionManager", L"TryStartFocusSession", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryStartFocusSession(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_get_IsFocusActive(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.FocusSessionManager", L"IsFocusActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFocusActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_get_IsSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.FocusSessionManager", L"IsSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Shell::FocusSessionManager::IsSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_add_IsFocusActiveChanged(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.FocusSessionManager", L"IsFocusActiveChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::FocusSessionManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFocusActiveChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_remove_IsFocusActiveChanged(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.FocusSessionManager", L"IsFocusActiveChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsFocusActiveChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::FocusSessionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::FocusSessionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSessionManager[] = {
        { "deactivate_focus", reinterpret_cast<PyCFunction>(FocusSessionManager_DeactivateFocus), METH_VARARGS, nullptr },
        { "get_session", reinterpret_cast<PyCFunction>(FocusSessionManager_GetSession), METH_VARARGS, nullptr },
        { "try_start_focus_session", reinterpret_cast<PyCFunction>(FocusSessionManager_TryStartFocusSession), METH_VARARGS, nullptr },
        { "try_start_focus_session2", reinterpret_cast<PyCFunction>(FocusSessionManager_TryStartFocusSession2), METH_VARARGS, nullptr },
        { "add_is_focus_active_changed", reinterpret_cast<PyCFunction>(FocusSessionManager_add_IsFocusActiveChanged), METH_O, nullptr },
        { "remove_is_focus_active_changed", reinterpret_cast<PyCFunction>(FocusSessionManager_remove_IsFocusActiveChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_FocusSessionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusSessionManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusSessionManager[] = {
        { "is_focus_active", reinterpret_cast<getter>(FocusSessionManager_get_IsFocusActive), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FocusSessionManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusSessionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusSessionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusSessionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusSessionManager) },
        { }};

    static PyType_Spec type_spec_FocusSessionManager = {
        "winrt._winrt_windows_ui_shell.FocusSessionManager",
        sizeof(py::wrapper::Windows::UI::Shell::FocusSessionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSessionManager};

    static PyGetSetDef getset_FocusSessionManager_Static[] = {
        { "is_supported", reinterpret_cast<getter>(FocusSessionManager_get_IsSupported), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_FocusSessionManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(FocusSessionManager_GetDefault), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_FocusSessionManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FocusSessionManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FocusSessionManager_Static) },
        { }
    };

    static PyType_Spec type_spec_FocusSessionManager_Static = {
        "winrt._winrt_windows_ui_shell.FocusSessionManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FocusSessionManager_Static};

    // ----- SecurityAppManager class --------------------

    static PyObject* _new_SecurityAppManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Shell::SecurityAppManager instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SecurityAppManager(py::wrapper::Windows::UI::Shell::SecurityAppManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SecurityAppManager_Register(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.SecurityAppManager", L"Register", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Register(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecurityAppManager_Unregister(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.SecurityAppManager", L"Unregister", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Unregister(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecurityAppManager_UpdateState(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.SecurityAppManager", L"UpdateState", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppState>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppSubstatus>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                {
                    auto _gil = release_gil();
                    self->obj.UpdateState(param0, param1, param2, param3, param4);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SecurityAppManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::SecurityAppManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SecurityAppManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::SecurityAppManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecurityAppManager[] = {
        { "register", reinterpret_cast<PyCFunction>(SecurityAppManager_Register), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(SecurityAppManager_Unregister), METH_VARARGS, nullptr },
        { "update_state", reinterpret_cast<PyCFunction>(SecurityAppManager_UpdateState), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SecurityAppManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecurityAppManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SecurityAppManager[] = {
        { }};

    static PyType_Slot _type_slots_SecurityAppManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SecurityAppManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SecurityAppManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SecurityAppManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SecurityAppManager) },
        { }};

    static PyType_Spec type_spec_SecurityAppManager = {
        "winrt._winrt_windows_ui_shell.SecurityAppManager",
        sizeof(py::wrapper::Windows::UI::Shell::SecurityAppManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecurityAppManager};

    // ----- ShareWindowCommandEventArgs class --------------------

    static PyObject* _new_ShareWindowCommandEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareWindowCommandEventArgs(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareWindowCommandEventArgs_get_Command(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.ShareWindowCommandEventArgs", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Command();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareWindowCommandEventArgs_put_Command(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.ShareWindowCommandEventArgs", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Shell::ShareWindowCommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.Command(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ShareWindowCommandEventArgs_get_WindowId(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.ShareWindowCommandEventArgs", L"WindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WindowId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareWindowCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareWindowCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareWindowCommandEventArgs[] = {
        { "_assign_array_", _assign_array_ShareWindowCommandEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareWindowCommandEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ShareWindowCommandEventArgs[] = {
        { "command", reinterpret_cast<getter>(ShareWindowCommandEventArgs_get_Command), reinterpret_cast<setter>(ShareWindowCommandEventArgs_put_Command), nullptr, nullptr },
        { "window_id", reinterpret_cast<getter>(ShareWindowCommandEventArgs_get_WindowId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ShareWindowCommandEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareWindowCommandEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareWindowCommandEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareWindowCommandEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareWindowCommandEventArgs) },
        { }};

    static PyType_Spec type_spec_ShareWindowCommandEventArgs = {
        "winrt._winrt_windows_ui_shell.ShareWindowCommandEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareWindowCommandEventArgs};

    // ----- ShareWindowCommandSource class --------------------

    static PyObject* _new_ShareWindowCommandSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::ShareWindowCommandSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::ShareWindowCommandSource>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareWindowCommandSource(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareWindowCommandSource_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::ShareWindowCommandSource::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_ReportCommandChanged(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"ReportCommandChanged", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ReportCommandChanged();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_Start(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_Stop(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_add_CommandInvoked(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"CommandInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::ShareWindowCommandSource, winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CommandInvoked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_remove_CommandInvoked(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"CommandInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CommandInvoked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_add_CommandRequested(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"CommandRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::ShareWindowCommandSource, winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CommandRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_remove_CommandRequested(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.ShareWindowCommandSource", L"CommandRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CommandRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareWindowCommandSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::ShareWindowCommandSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareWindowCommandSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::ShareWindowCommandSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareWindowCommandSource[] = {
        { "report_command_changed", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_ReportCommandChanged), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_Stop), METH_VARARGS, nullptr },
        { "add_command_invoked", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_add_CommandInvoked), METH_O, nullptr },
        { "remove_command_invoked", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_remove_CommandInvoked), METH_O, nullptr },
        { "add_command_requested", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_add_CommandRequested), METH_O, nullptr },
        { "remove_command_requested", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_remove_CommandRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_ShareWindowCommandSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareWindowCommandSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ShareWindowCommandSource[] = {
        { }};

    static PyType_Slot _type_slots_ShareWindowCommandSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareWindowCommandSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareWindowCommandSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareWindowCommandSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareWindowCommandSource) },
        { }};

    static PyType_Spec type_spec_ShareWindowCommandSource = {
        "winrt._winrt_windows_ui_shell.ShareWindowCommandSource",
        sizeof(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareWindowCommandSource};

    static PyGetSetDef getset_ShareWindowCommandSource_Static[] = {
        { }};

    static PyMethodDef methods_ShareWindowCommandSource_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_GetForCurrentView), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ShareWindowCommandSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ShareWindowCommandSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ShareWindowCommandSource_Static) },
        { }
    };

    static PyType_Spec type_spec_ShareWindowCommandSource_Static = {
        "winrt._winrt_windows_ui_shell.ShareWindowCommandSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ShareWindowCommandSource_Static};

    // ----- TaskbarManager class --------------------

    static PyObject* _new_TaskbarManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::TaskbarManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::TaskbarManager>::type_name);
        return nullptr;
    }

    static void _dealloc_TaskbarManager(py::wrapper::Windows::UI::Shell::TaskbarManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TaskbarManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::TaskbarManager::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsAppListEntryPinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"IsAppListEntryPinnedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsAppListEntryPinnedAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsCurrentAppPinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"IsCurrentAppPinnedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsCurrentAppPinnedAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsSecondaryTilePinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"IsSecondaryTilePinnedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsSecondaryTilePinnedAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinAppListEntryAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"RequestPinAppListEntryAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPinAppListEntryAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinCurrentAppAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"RequestPinCurrentAppAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPinCurrentAppAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinSecondaryTileAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"RequestPinSecondaryTileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::SecondaryTile>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPinSecondaryTileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_TryUnpinSecondaryTileAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.TaskbarManager", L"TryUnpinSecondaryTileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUnpinSecondaryTileAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_get_IsPinningAllowed(py::wrapper::Windows::UI::Shell::TaskbarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.TaskbarManager", L"IsPinningAllowed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPinningAllowed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_get_IsSupported(py::wrapper::Windows::UI::Shell::TaskbarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.TaskbarManager", L"IsSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TaskbarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::TaskbarManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TaskbarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::TaskbarManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TaskbarManager[] = {
        { "is_app_list_entry_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsAppListEntryPinnedAsync), METH_VARARGS, nullptr },
        { "is_current_app_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsCurrentAppPinnedAsync), METH_VARARGS, nullptr },
        { "is_secondary_tile_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsSecondaryTilePinnedAsync), METH_VARARGS, nullptr },
        { "request_pin_app_list_entry_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinAppListEntryAsync), METH_VARARGS, nullptr },
        { "request_pin_current_app_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinCurrentAppAsync), METH_VARARGS, nullptr },
        { "request_pin_secondary_tile_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinSecondaryTileAsync), METH_VARARGS, nullptr },
        { "try_unpin_secondary_tile_async", reinterpret_cast<PyCFunction>(TaskbarManager_TryUnpinSecondaryTileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TaskbarManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TaskbarManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TaskbarManager[] = {
        { "is_pinning_allowed", reinterpret_cast<getter>(TaskbarManager_get_IsPinningAllowed), nullptr, nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(TaskbarManager_get_IsSupported), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TaskbarManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TaskbarManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TaskbarManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TaskbarManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TaskbarManager) },
        { }};

    static PyType_Spec type_spec_TaskbarManager = {
        "winrt._winrt_windows_ui_shell.TaskbarManager",
        sizeof(py::wrapper::Windows::UI::Shell::TaskbarManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TaskbarManager};

    static PyGetSetDef getset_TaskbarManager_Static[] = {
        { }};

    static PyMethodDef methods_TaskbarManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(TaskbarManager_GetDefault), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_TaskbarManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TaskbarManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TaskbarManager_Static) },
        { }
    };

    static PyType_Spec type_spec_TaskbarManager_Static = {
        "winrt._winrt_windows_ui_shell.TaskbarManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TaskbarManager_Static};

    // ----- WindowTab class --------------------

    static PyObject* _new_WindowTab(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Shell::WindowTab instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowTab(py::wrapper::Windows::UI::Shell::WindowTab* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTab_ReportThumbnailAvailable(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTab", L"ReportThumbnailAvailable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ReportThumbnailAvailable();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTab_get_TreatAsSecondaryTileId(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"TreatAsSecondaryTileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TreatAsSecondaryTileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_TreatAsSecondaryTileId(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"TreatAsSecondaryTileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.TreatAsSecondaryTileId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTab_get_Title(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_Title(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTab_get_Tag(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_Tag(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTab_get_Icon(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Icon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_Icon(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTabIcon>(arg);

            {
                auto _gil = release_gil();
                self->obj.Icon(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTab_get_Group(py::wrapper::Windows::UI::Shell::WindowTab* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Group();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTab_put_Group(py::wrapper::Windows::UI::Shell::WindowTab* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTab", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTabGroup>(arg);

            {
                auto _gil = release_gil();
                self->obj.Group(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WindowTab(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTab>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTab(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTab>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTab[] = {
        { "report_thumbnail_available", reinterpret_cast<PyCFunction>(WindowTab_ReportThumbnailAvailable), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowTab, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTab), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTab[] = {
        { "treat_as_secondary_tile_id", reinterpret_cast<getter>(WindowTab_get_TreatAsSecondaryTileId), reinterpret_cast<setter>(WindowTab_put_TreatAsSecondaryTileId), nullptr, nullptr },
        { "title", reinterpret_cast<getter>(WindowTab_get_Title), reinterpret_cast<setter>(WindowTab_put_Title), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(WindowTab_get_Tag), reinterpret_cast<setter>(WindowTab_put_Tag), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(WindowTab_get_Icon), reinterpret_cast<setter>(WindowTab_put_Icon), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(WindowTab_get_Group), reinterpret_cast<setter>(WindowTab_put_Group), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowTab[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTab) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTab) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTab) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTab) },
        { }};

    static PyType_Spec type_spec_WindowTab = {
        "winrt._winrt_windows_ui_shell.WindowTab",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTab),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTab};

    // ----- WindowTabCloseRequestedEventArgs class --------------------

    static PyObject* _new_WindowTabCloseRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabCloseRequestedEventArgs(py::wrapper::Windows::UI::Shell::WindowTabCloseRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabCloseRequestedEventArgs_get_Tab(py::wrapper::Windows::UI::Shell::WindowTabCloseRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabCloseRequestedEventArgs", L"Tab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabCloseRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabCloseRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabCloseRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowTabCloseRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabCloseRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTabCloseRequestedEventArgs[] = {
        { "tab", reinterpret_cast<getter>(WindowTabCloseRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowTabCloseRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabCloseRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabCloseRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabCloseRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabCloseRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowTabCloseRequestedEventArgs = {
        "winrt._winrt_windows_ui_shell.WindowTabCloseRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabCloseRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabCloseRequestedEventArgs};

    // ----- WindowTabCollection class --------------------

    static PyObject* _new_WindowTabCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabCollection_Append(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Append(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_Clear(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_First(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_GetAt(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_GetMany(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Shell::WindowTab, true>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_GetView(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_IndexOf(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 0);
                uint32_t param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IndexOf(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_InsertAt(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.InsertAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_MoveTab(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"MoveTab", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.MoveTab(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_RemoveAt(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAt(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_RemoveAtEnd(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAtEnd();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_ReplaceAll(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Shell::WindowTab, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ReplaceAll(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_SetAt(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabCollection_get_Size(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetAt(static_cast<uint32_t>(i));
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_WindowTabCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            auto size = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.Size();
            }();
            if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Shell::WindowTab> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Shell::WindowTab>::get());

            auto count = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetMany(static_cast<uint32_t>(start), items);
            }();

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_WindowTabCollection(py::wrapper::Windows::UI::Shell::WindowTabCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                auto _gil = py::release_gil();
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                auto _value = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(value);
                {
                    auto _gil = py::release_gil();
                    self->obj.SetAt(static_cast<uint32_t>(i), _value);
                }
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_WindowTabCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(WindowTabCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(WindowTabCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(WindowTabCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(WindowTabCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(WindowTabCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(WindowTabCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(WindowTabCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(WindowTabCollection_InsertAt), METH_VARARGS, nullptr },
        { "move_tab", reinterpret_cast<PyCFunction>(WindowTabCollection_MoveTab), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(WindowTabCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(WindowTabCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(WindowTabCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(WindowTabCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowTabCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTabCollection[] = {
        { "size", reinterpret_cast<getter>(WindowTabCollection_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowTabCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_WindowTabCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_WindowTabCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_WindowTabCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_WindowTabCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_WindowTabCollection) },
        { }};

    static PyType_Spec type_spec_WindowTabCollection = {
        "winrt._winrt_windows_ui_shell.WindowTabCollection",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabCollection};

    // ----- WindowTabGroup class --------------------

    static PyObject* _new_WindowTabGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Shell::WindowTabGroup instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowTabGroup(py::wrapper::Windows::UI::Shell::WindowTabGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabGroup_get_Title(py::wrapper::Windows::UI::Shell::WindowTabGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabGroup", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTabGroup_put_Title(py::wrapper::Windows::UI::Shell::WindowTabGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabGroup", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTabGroup_get_Icon(py::wrapper::Windows::UI::Shell::WindowTabGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabGroup", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Icon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTabGroup_put_Icon(py::wrapper::Windows::UI::Shell::WindowTabGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabGroup", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTabIcon>(arg);

            {
                auto _gil = release_gil();
                self->obj.Icon(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WindowTabGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabGroup[] = {
        { "_assign_array_", _assign_array_WindowTabGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabGroup), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTabGroup[] = {
        { "title", reinterpret_cast<getter>(WindowTabGroup_get_Title), reinterpret_cast<setter>(WindowTabGroup_put_Title), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(WindowTabGroup_get_Icon), reinterpret_cast<setter>(WindowTabGroup_put_Icon), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowTabGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabGroup) },
        { }};

    static PyType_Spec type_spec_WindowTabGroup = {
        "winrt._winrt_windows_ui_shell.WindowTabGroup",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabGroup};

    // ----- WindowTabIcon class --------------------

    static PyObject* _new_WindowTabIcon(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabIcon>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabIcon>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabIcon(py::wrapper::Windows::UI::Shell::WindowTabIcon* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabIcon_CreateFromFontGlyph(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabIcon", L"CreateFromFontGlyph", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::WindowTabIcon::CreateFromFontGlyph(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabIcon_CreateFromFontGlyphWithUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabIcon", L"CreateFromFontGlyph", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::WindowTabIcon::CreateFromFontGlyph(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabIcon_CreateFromImage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabIcon", L"CreateFromImage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::WindowTabIcon::CreateFromImage(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabIcon>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabIcon>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabIcon[] = {
        { "_assign_array_", _assign_array_WindowTabIcon, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabIcon), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTabIcon[] = {
        { }};

    static PyType_Slot _type_slots_WindowTabIcon[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabIcon) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabIcon) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabIcon) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabIcon) },
        { }};

    static PyType_Spec type_spec_WindowTabIcon = {
        "winrt._winrt_windows_ui_shell.WindowTabIcon",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabIcon),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabIcon};

    static PyGetSetDef getset_WindowTabIcon_Static[] = {
        { }};

    static PyMethodDef methods_WindowTabIcon_Static[] = {
        { "create_from_font_glyph", reinterpret_cast<PyCFunction>(WindowTabIcon_CreateFromFontGlyph), METH_VARARGS, nullptr },
        { "create_from_font_glyph_with_uri", reinterpret_cast<PyCFunction>(WindowTabIcon_CreateFromFontGlyphWithUri), METH_VARARGS, nullptr },
        { "create_from_image", reinterpret_cast<PyCFunction>(WindowTabIcon_CreateFromImage), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_WindowTabIcon_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowTabIcon_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowTabIcon_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowTabIcon_Static = {
        "winrt._winrt_windows_ui_shell.WindowTabIcon_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowTabIcon_Static};

    // ----- WindowTabManager class --------------------

    static PyObject* _new_WindowTabManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabManager>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabManager(py::wrapper::Windows::UI::Shell::WindowTabManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabManager_GetForWindow(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabManager", L"GetForWindow", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::WindowId>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::WindowTabManager::GetForWindow(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabManager", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::WindowTabManager::IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_IsTabTearOutSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabManager", L"IsTabTearOutSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Shell::WindowTabManager::IsTabTearOutSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_SetActiveTab(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabManager", L"SetActiveTab", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::WindowTab>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetActiveTab(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_get_Tabs(py::wrapper::Windows::UI::Shell::WindowTabManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabManager", L"Tabs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tabs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_add_TabCloseRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabCloseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::WindowTabManager, winrt::Windows::UI::Shell::WindowTabCloseRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TabCloseRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_remove_TabCloseRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabCloseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TabCloseRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_add_TabSwitchRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabSwitchRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::WindowTabManager, winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TabSwitchRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_remove_TabSwitchRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabSwitchRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TabSwitchRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_add_TabTearOutRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabTearOutRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::WindowTabManager, winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TabTearOutRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_remove_TabTearOutRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabTearOutRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TabTearOutRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_add_TabThumbnailRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabThumbnailRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::WindowTabManager, winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TabThumbnailRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabManager_remove_TabThumbnailRequested(py::wrapper::Windows::UI::Shell::WindowTabManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Shell.WindowTabManager", L"TabThumbnailRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TabThumbnailRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabManager[] = {
        { "set_active_tab", reinterpret_cast<PyCFunction>(WindowTabManager_SetActiveTab), METH_VARARGS, nullptr },
        { "add_tab_close_requested", reinterpret_cast<PyCFunction>(WindowTabManager_add_TabCloseRequested), METH_O, nullptr },
        { "remove_tab_close_requested", reinterpret_cast<PyCFunction>(WindowTabManager_remove_TabCloseRequested), METH_O, nullptr },
        { "add_tab_switch_requested", reinterpret_cast<PyCFunction>(WindowTabManager_add_TabSwitchRequested), METH_O, nullptr },
        { "remove_tab_switch_requested", reinterpret_cast<PyCFunction>(WindowTabManager_remove_TabSwitchRequested), METH_O, nullptr },
        { "add_tab_tear_out_requested", reinterpret_cast<PyCFunction>(WindowTabManager_add_TabTearOutRequested), METH_O, nullptr },
        { "remove_tab_tear_out_requested", reinterpret_cast<PyCFunction>(WindowTabManager_remove_TabTearOutRequested), METH_O, nullptr },
        { "add_tab_thumbnail_requested", reinterpret_cast<PyCFunction>(WindowTabManager_add_TabThumbnailRequested), METH_O, nullptr },
        { "remove_tab_thumbnail_requested", reinterpret_cast<PyCFunction>(WindowTabManager_remove_TabThumbnailRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_WindowTabManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTabManager[] = {
        { "tabs", reinterpret_cast<getter>(WindowTabManager_get_Tabs), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowTabManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabManager) },
        { }};

    static PyType_Spec type_spec_WindowTabManager = {
        "winrt._winrt_windows_ui_shell.WindowTabManager",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabManager};

    static PyGetSetDef getset_WindowTabManager_Static[] = {
        { }};

    static PyMethodDef methods_WindowTabManager_Static[] = {
        { "get_for_window", reinterpret_cast<PyCFunction>(WindowTabManager_GetForWindow), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(WindowTabManager_IsSupported), METH_VARARGS, nullptr },
        { "is_tab_tear_out_supported", reinterpret_cast<PyCFunction>(WindowTabManager_IsTabTearOutSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_WindowTabManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowTabManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowTabManager_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowTabManager_Static = {
        "winrt._winrt_windows_ui_shell.WindowTabManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowTabManager_Static};

    // ----- WindowTabSwitchRequestedEventArgs class --------------------

    static PyObject* _new_WindowTabSwitchRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabSwitchRequestedEventArgs(py::wrapper::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabSwitchRequestedEventArgs_get_Tab(py::wrapper::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabSwitchRequestedEventArgs", L"Tab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabSwitchRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabSwitchRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabSwitchRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowTabSwitchRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabSwitchRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTabSwitchRequestedEventArgs[] = {
        { "tab", reinterpret_cast<getter>(WindowTabSwitchRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowTabSwitchRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabSwitchRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabSwitchRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabSwitchRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabSwitchRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowTabSwitchRequestedEventArgs = {
        "winrt._winrt_windows_ui_shell.WindowTabSwitchRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabSwitchRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabSwitchRequestedEventArgs};

    // ----- WindowTabTearOutRequestedEventArgs class --------------------

    static PyObject* _new_WindowTabTearOutRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabTearOutRequestedEventArgs(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabTearOutRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabTearOutRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabTearOutRequestedEventArgs_get_WindowId(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabTearOutRequestedEventArgs", L"WindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WindowId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTabTearOutRequestedEventArgs_put_WindowId(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabTearOutRequestedEventArgs", L"WindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.WindowId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTabTearOutRequestedEventArgs_get_Tab(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabTearOutRequestedEventArgs", L"Tab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabTearOutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabTearOutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabTearOutRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WindowTabTearOutRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowTabTearOutRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabTearOutRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTabTearOutRequestedEventArgs[] = {
        { "window_id", reinterpret_cast<getter>(WindowTabTearOutRequestedEventArgs_get_WindowId), reinterpret_cast<setter>(WindowTabTearOutRequestedEventArgs_put_WindowId), nullptr, nullptr },
        { "tab", reinterpret_cast<getter>(WindowTabTearOutRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowTabTearOutRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabTearOutRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabTearOutRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabTearOutRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabTearOutRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowTabTearOutRequestedEventArgs = {
        "winrt._winrt_windows_ui_shell.WindowTabTearOutRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabTearOutRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabTearOutRequestedEventArgs};

    // ----- WindowTabThumbnailRequestedEventArgs class --------------------

    static PyObject* _new_WindowTabThumbnailRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowTabThumbnailRequestedEventArgs(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_get_Image(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"Image");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Image();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowTabThumbnailRequestedEventArgs_put_Image(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"Image");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.Image(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_get_IsCompositedOnWindow(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"IsCompositedOnWindow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCompositedOnWindow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_get_RequestedSize(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"RequestedSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestedSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowTabThumbnailRequestedEventArgs_get_Tab(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Shell.WindowTabThumbnailRequestedEventArgs", L"Tab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowTabThumbnailRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowTabThumbnailRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowTabThumbnailRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WindowTabThumbnailRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowTabThumbnailRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowTabThumbnailRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowTabThumbnailRequestedEventArgs[] = {
        { "image", reinterpret_cast<getter>(WindowTabThumbnailRequestedEventArgs_get_Image), reinterpret_cast<setter>(WindowTabThumbnailRequestedEventArgs_put_Image), nullptr, nullptr },
        { "is_composited_on_window", reinterpret_cast<getter>(WindowTabThumbnailRequestedEventArgs_get_IsCompositedOnWindow), nullptr, nullptr, nullptr },
        { "requested_size", reinterpret_cast<getter>(WindowTabThumbnailRequestedEventArgs_get_RequestedSize), nullptr, nullptr, nullptr },
        { "tab", reinterpret_cast<getter>(WindowTabThumbnailRequestedEventArgs_get_Tab), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowTabThumbnailRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowTabThumbnailRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowTabThumbnailRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowTabThumbnailRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowTabThumbnailRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowTabThumbnailRequestedEventArgs = {
        "winrt._winrt_windows_ui_shell.WindowTabThumbnailRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::WindowTabThumbnailRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowTabThumbnailRequestedEventArgs};

    // ----- IAdaptiveCard interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAdaptiveCard(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::IAdaptiveCard>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::IAdaptiveCard>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAdaptiveCard(py::wrapper::Windows::UI::Shell::IAdaptiveCard* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAdaptiveCard_ToJson(py::wrapper::Windows::UI::Shell::IAdaptiveCard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.IAdaptiveCard", L"ToJson", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ToJson();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveCard[] = {
        { "to_json", reinterpret_cast<PyCFunction>(IAdaptiveCard_ToJson), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAdaptiveCard[] = {
        { }};

    static PyType_Slot _type_slots_IAdaptiveCard[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAdaptiveCard) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAdaptiveCard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAdaptiveCard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAdaptiveCard) },
        { }};

    static PyType_Spec type_spec_IAdaptiveCard = {
        "winrt._winrt_windows_ui_shell._IAdaptiveCard",
        sizeof(py::wrapper::Windows::UI::Shell::IAdaptiveCard),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAdaptiveCard};

    struct ImplementsIAdaptiveCard : py::ImplementsInterfaceT<ImplementsIAdaptiveCard, winrt::Windows::UI::Shell::IAdaptiveCard>
    {
        ImplementsIAdaptiveCard() = delete;
        ImplementsIAdaptiveCard(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAdaptiveCard, winrt::Windows::UI::Shell::IAdaptiveCard>(py_obj, runtime_class)
        {
        }

        auto ToJson()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "to_json")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAdaptiveCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::IAdaptiveCard>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAdaptiveCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::IAdaptiveCard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAdaptiveCard(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Shell::IAdaptiveCard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAdaptiveCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAdaptiveCard>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAdaptiveCard[] = {
        { "_assign_array_", _assign_array_IAdaptiveCard, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAdaptiveCard), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAdaptiveCard), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAdaptiveCard), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAdaptiveCard[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAdaptiveCard) },
        { }};

    static PyType_Spec type_spec_ImplementsIAdaptiveCard = {
        "winrt._winrt_windows_ui_shell.IAdaptiveCard",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAdaptiveCard};

    // ----- IAdaptiveCardBuilderStatics interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAdaptiveCardBuilderStatics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAdaptiveCardBuilderStatics(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAdaptiveCardBuilderStatics_CreateAdaptiveCardFromJson(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Shell.IAdaptiveCardBuilderStatics", L"CreateAdaptiveCardFromJson", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateAdaptiveCardFromJson(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveCardBuilderStatics[] = {
        { "create_adaptive_card_from_json", reinterpret_cast<PyCFunction>(IAdaptiveCardBuilderStatics_CreateAdaptiveCardFromJson), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IAdaptiveCardBuilderStatics[] = {
        { }};

    static PyType_Slot _type_slots_IAdaptiveCardBuilderStatics[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAdaptiveCardBuilderStatics) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAdaptiveCardBuilderStatics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAdaptiveCardBuilderStatics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAdaptiveCardBuilderStatics) },
        { }};

    static PyType_Spec type_spec_IAdaptiveCardBuilderStatics = {
        "winrt._winrt_windows_ui_shell._IAdaptiveCardBuilderStatics",
        sizeof(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAdaptiveCardBuilderStatics};

    struct ImplementsIAdaptiveCardBuilderStatics : py::ImplementsInterfaceT<ImplementsIAdaptiveCardBuilderStatics, winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>
    {
        ImplementsIAdaptiveCardBuilderStatics() = delete;
        ImplementsIAdaptiveCardBuilderStatics(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAdaptiveCardBuilderStatics, winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>(py_obj, runtime_class)
        {
        }

        auto CreateAdaptiveCardFromJson(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_adaptive_card_from_json")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Shell::IAdaptiveCard>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAdaptiveCardBuilderStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAdaptiveCardBuilderStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAdaptiveCardBuilderStatics(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAdaptiveCardBuilderStatics(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAdaptiveCardBuilderStatics>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAdaptiveCardBuilderStatics[] = {
        { "_assign_array_", _assign_array_IAdaptiveCardBuilderStatics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAdaptiveCardBuilderStatics), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAdaptiveCardBuilderStatics), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAdaptiveCardBuilderStatics), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAdaptiveCardBuilderStatics[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAdaptiveCardBuilderStatics) },
        { }};

    static PyType_Spec type_spec_ImplementsIAdaptiveCardBuilderStatics = {
        "winrt._winrt_windows_ui_shell.IAdaptiveCardBuilderStatics",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAdaptiveCardBuilderStatics};

    // ----- Windows.UI.Shell Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Shell");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_shell",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Shell

PyMODINIT_FUNC PyInit__winrt_windows_ui_shell(void) noexcept
{
    using namespace py::cpp::Windows::UI::Shell;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle AdaptiveCardBuilder_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AdaptiveCardBuilder_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AdaptiveCardBuilder_Static{PyType_FromSpecWithBases(&type_spec_AdaptiveCardBuilder_Static, AdaptiveCardBuilder_Static_bases.get())};
    if (!type_AdaptiveCardBuilder_Static)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveCardBuilder_type{py::register_python_type(module.get(), &type_spec_AdaptiveCardBuilder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AdaptiveCardBuilder_Static.get()))};
    if (!AdaptiveCardBuilder_type)
    {
        return nullptr;
    }

    py::pytype_handle FocusSession_type{py::register_python_type(module.get(), &type_spec_FocusSession, object_bases.get(), inspectable_meta_type)};
    if (!FocusSession_type)
    {
        return nullptr;
    }

    py::pyobj_handle FocusSessionManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!FocusSessionManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FocusSessionManager_Static{PyType_FromSpecWithBases(&type_spec_FocusSessionManager_Static, FocusSessionManager_Static_bases.get())};
    if (!type_FocusSessionManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle FocusSessionManager_type{py::register_python_type(module.get(), &type_spec_FocusSessionManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FocusSessionManager_Static.get()))};
    if (!FocusSessionManager_type)
    {
        return nullptr;
    }

    py::pytype_handle SecurityAppManager_type{py::register_python_type(module.get(), &type_spec_SecurityAppManager, object_bases.get(), inspectable_meta_type)};
    if (!SecurityAppManager_type)
    {
        return nullptr;
    }

    py::pytype_handle ShareWindowCommandEventArgs_type{py::register_python_type(module.get(), &type_spec_ShareWindowCommandEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ShareWindowCommandEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ShareWindowCommandSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ShareWindowCommandSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ShareWindowCommandSource_Static{PyType_FromSpecWithBases(&type_spec_ShareWindowCommandSource_Static, ShareWindowCommandSource_Static_bases.get())};
    if (!type_ShareWindowCommandSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle ShareWindowCommandSource_type{py::register_python_type(module.get(), &type_spec_ShareWindowCommandSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ShareWindowCommandSource_Static.get()))};
    if (!ShareWindowCommandSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle TaskbarManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!TaskbarManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TaskbarManager_Static{PyType_FromSpecWithBases(&type_spec_TaskbarManager_Static, TaskbarManager_Static_bases.get())};
    if (!type_TaskbarManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle TaskbarManager_type{py::register_python_type(module.get(), &type_spec_TaskbarManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TaskbarManager_Static.get()))};
    if (!TaskbarManager_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowTab_type{py::register_python_type(module.get(), &type_spec_WindowTab, object_bases.get(), inspectable_meta_type)};
    if (!WindowTab_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowTabCloseRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowTabCloseRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowTabCloseRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowTabCollection_type{py::register_python_type(module.get(), &type_spec_WindowTabCollection, object_bases.get(), inspectable_meta_type)};
    if (!WindowTabCollection_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowTabGroup_type{py::register_python_type(module.get(), &type_spec_WindowTabGroup, object_bases.get(), inspectable_meta_type)};
    if (!WindowTabGroup_type)
    {
        return nullptr;
    }

    py::pyobj_handle WindowTabIcon_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!WindowTabIcon_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowTabIcon_Static{PyType_FromSpecWithBases(&type_spec_WindowTabIcon_Static, WindowTabIcon_Static_bases.get())};
    if (!type_WindowTabIcon_Static)
    {
        return nullptr;
    }

    py::pytype_handle WindowTabIcon_type{py::register_python_type(module.get(), &type_spec_WindowTabIcon, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowTabIcon_Static.get()))};
    if (!WindowTabIcon_type)
    {
        return nullptr;
    }

    py::pyobj_handle WindowTabManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!WindowTabManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowTabManager_Static{PyType_FromSpecWithBases(&type_spec_WindowTabManager_Static, WindowTabManager_Static_bases.get())};
    if (!type_WindowTabManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle WindowTabManager_type{py::register_python_type(module.get(), &type_spec_WindowTabManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowTabManager_Static.get()))};
    if (!WindowTabManager_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowTabSwitchRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowTabSwitchRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowTabSwitchRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowTabTearOutRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowTabTearOutRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowTabTearOutRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowTabThumbnailRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowTabThumbnailRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowTabThumbnailRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IAdaptiveCard_type{py::register_python_type(module.get(), &type_spec_IAdaptiveCard, object_bases.get(), nullptr)};
    if (!IAdaptiveCard_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAdaptiveCard_type{py::register_python_type(module.get(), &type_spec_ImplementsIAdaptiveCard, nullptr, inspectable_meta_type)};
    if (!ImplementsIAdaptiveCard_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAdaptiveCard_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAdaptiveCardBuilderStatics_type{py::register_python_type(module.get(), &type_spec_IAdaptiveCardBuilderStatics, object_bases.get(), nullptr)};
    if (!IAdaptiveCardBuilderStatics_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAdaptiveCardBuilderStatics_type{py::register_python_type(module.get(), &type_spec_ImplementsIAdaptiveCardBuilderStatics, nullptr, inspectable_meta_type)};
    if (!ImplementsIAdaptiveCardBuilderStatics_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAdaptiveCardBuilderStatics_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
