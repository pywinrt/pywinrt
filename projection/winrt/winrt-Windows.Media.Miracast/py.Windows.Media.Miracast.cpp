// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Media.Miracast.h"

namespace py::cpp::Windows::Media::Miracast
{
    // ----- MiracastReceiver class --------------------

    static PyObject* _new_MiracastReceiver(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Miracast::MiracastReceiver instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MiracastReceiver(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiver_ClearKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"ClearKnownTransmitters", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ClearKnownTransmitters();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_CreateSession(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"CreateSession", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::CoreApplicationView>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateSession(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_CreateSessionAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"CreateSessionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::CoreApplicationView>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateSessionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_DisconnectAllAndApplySettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"DisconnectAllAndApplySettings", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverSettings>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DisconnectAllAndApplySettings(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_DisconnectAllAndApplySettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"DisconnectAllAndApplySettingsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverSettings>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DisconnectAllAndApplySettingsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetCurrentSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetCurrentSettings", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentSettings();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetCurrentSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetCurrentSettingsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentSettingsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetDefaultSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetDefaultSettings", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDefaultSettings();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetStatus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStatus();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetStatusAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetStatusAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStatusAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_RemoveKnownTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"RemoveKnownTransmitter", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastTransmitter>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveKnownTransmitter(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_add_StatusChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiver", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_remove_StatusChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiver", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiver>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiver[] = {
        { "clear_known_transmitters", reinterpret_cast<PyCFunction>(MiracastReceiver_ClearKnownTransmitters), METH_VARARGS, nullptr },
        { "create_session", reinterpret_cast<PyCFunction>(MiracastReceiver_CreateSession), METH_VARARGS, nullptr },
        { "create_session_async", reinterpret_cast<PyCFunction>(MiracastReceiver_CreateSessionAsync), METH_VARARGS, nullptr },
        { "disconnect_all_and_apply_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_DisconnectAllAndApplySettings), METH_VARARGS, nullptr },
        { "disconnect_all_and_apply_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiver_DisconnectAllAndApplySettingsAsync), METH_VARARGS, nullptr },
        { "get_current_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_GetCurrentSettings), METH_VARARGS, nullptr },
        { "get_current_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiver_GetCurrentSettingsAsync), METH_VARARGS, nullptr },
        { "get_default_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_GetDefaultSettings), METH_VARARGS, nullptr },
        { "get_status", reinterpret_cast<PyCFunction>(MiracastReceiver_GetStatus), METH_VARARGS, nullptr },
        { "get_status_async", reinterpret_cast<PyCFunction>(MiracastReceiver_GetStatusAsync), METH_VARARGS, nullptr },
        { "remove_known_transmitter", reinterpret_cast<PyCFunction>(MiracastReceiver_RemoveKnownTransmitter), METH_VARARGS, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(MiracastReceiver_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(MiracastReceiver_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiver, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiver), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiver[] = {
        { }};

    static PyType_Slot _type_slots_MiracastReceiver[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiver) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiver) },
        { }};

    static PyType_Spec type_spec_MiracastReceiver = {
        "winrt._winrt_windows_media_miracast.MiracastReceiver",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiver};

    // ----- MiracastReceiverApplySettingsResult class --------------------

    static PyObject* _new_MiracastReceiverApplySettingsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverApplySettingsResult(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverApplySettingsResult_get_ExtendedError(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverApplySettingsResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverApplySettingsResult_get_Status(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverApplySettingsResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverApplySettingsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverApplySettingsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverApplySettingsResult[] = {
        { "_assign_array_", _assign_array_MiracastReceiverApplySettingsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverApplySettingsResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverApplySettingsResult[] = {
        { "extended_error", reinterpret_cast<getter>(MiracastReceiverApplySettingsResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MiracastReceiverApplySettingsResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverApplySettingsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverApplySettingsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverApplySettingsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverApplySettingsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverApplySettingsResult) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverApplySettingsResult = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverApplySettingsResult",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverApplySettingsResult};

    // ----- MiracastReceiverConnection class --------------------

    static PyObject* _new_MiracastReceiverConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverConnection_Close(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Disconnect(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Disconnect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectReason>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Disconnect(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_DisconnectWithMessage(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Disconnect", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectReason>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Disconnect(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Pause(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Pause", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Pause();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_PauseAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"PauseAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.PauseAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Resume(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Resume", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Resume();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_ResumeAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"ResumeAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ResumeAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_CursorImageChannel(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"CursorImageChannel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CursorImageChannel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_InputDevices(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"InputDevices");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputDevices();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_StreamControl(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"StreamControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StreamControl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_Transmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Transmitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Transmitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Close), METH_VARARGS, nullptr },
        { "disconnect", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Disconnect), METH_VARARGS, nullptr },
        { "disconnect_with_message", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_DisconnectWithMessage), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Pause), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_PauseAsync), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Resume), METH_VARARGS, nullptr },
        { "resume_async", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_ResumeAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MiracastReceiverConnection), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MiracastReceiverConnection), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverConnection[] = {
        { "cursor_image_channel", reinterpret_cast<getter>(MiracastReceiverConnection_get_CursorImageChannel), nullptr, nullptr, nullptr },
        { "input_devices", reinterpret_cast<getter>(MiracastReceiverConnection_get_InputDevices), nullptr, nullptr, nullptr },
        { "stream_control", reinterpret_cast<getter>(MiracastReceiverConnection_get_StreamControl), nullptr, nullptr, nullptr },
        { "transmitter", reinterpret_cast<getter>(MiracastReceiverConnection_get_Transmitter), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverConnection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverConnection) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverConnection = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverConnection",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverConnection};

    // ----- MiracastReceiverConnectionCreatedEventArgs class --------------------

    static PyObject* _new_MiracastReceiverConnectionCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverConnectionCreatedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_GetDeferral(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"Connection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Connection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_get_Pin(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"Pin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Pin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverConnectionCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverConnectionCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverConnectionCreatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MiracastReceiverConnectionCreatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverConnectionCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverConnectionCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverConnectionCreatedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverConnectionCreatedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { "pin", reinterpret_cast<getter>(MiracastReceiverConnectionCreatedEventArgs_get_Pin), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverConnectionCreatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverConnectionCreatedEventArgs) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverConnectionCreatedEventArgs = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverConnectionCreatedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverConnectionCreatedEventArgs};

    // ----- MiracastReceiverCursorImageChannel class --------------------

    static PyObject* _new_MiracastReceiverCursorImageChannel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverCursorImageChannel(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_ImageStream(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImageStream();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"MaxImageSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxImageSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_Position(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_add_ImageStreamChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStreamChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImageStreamChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_remove_ImageStreamChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStreamChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ImageStreamChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_add_PositionChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"PositionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_remove_PositionChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"PositionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverCursorImageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverCursorImageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverCursorImageChannel[] = {
        { "add_image_stream_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_add_ImageStreamChanged), METH_O, nullptr },
        { "remove_image_stream_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_remove_ImageStreamChanged), METH_O, nullptr },
        { "add_position_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_add_PositionChanged), METH_O, nullptr },
        { "remove_position_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_remove_PositionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverCursorImageChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverCursorImageChannel), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverCursorImageChannel[] = {
        { "image_stream", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_ImageStream), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_IsEnabled), nullptr, nullptr, nullptr },
        { "max_image_size", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_MaxImageSize), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverCursorImageChannel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverCursorImageChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverCursorImageChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverCursorImageChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverCursorImageChannel) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverCursorImageChannel = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverCursorImageChannel",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverCursorImageChannel};

    // ----- MiracastReceiverCursorImageChannelSettings class --------------------

    static PyObject* _new_MiracastReceiverCursorImageChannelSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverCursorImageChannelSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverCursorImageChannelSettings_get_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"MaxImageSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxImageSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverCursorImageChannelSettings_put_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"MaxImageSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);

            {
                auto _gil = release_gil();
                self->obj.MaxImageSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannelSettings_get_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverCursorImageChannelSettings_put_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverCursorImageChannelSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverCursorImageChannelSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverCursorImageChannelSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverCursorImageChannelSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverCursorImageChannelSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverCursorImageChannelSettings[] = {
        { "max_image_size", reinterpret_cast<getter>(MiracastReceiverCursorImageChannelSettings_get_MaxImageSize), reinterpret_cast<setter>(MiracastReceiverCursorImageChannelSettings_put_MaxImageSize), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MiracastReceiverCursorImageChannelSettings_get_IsEnabled), reinterpret_cast<setter>(MiracastReceiverCursorImageChannelSettings_put_IsEnabled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverCursorImageChannelSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverCursorImageChannelSettings) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverCursorImageChannelSettings = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverCursorImageChannelSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverCursorImageChannelSettings};

    // ----- MiracastReceiverDisconnectedEventArgs class --------------------

    static PyObject* _new_MiracastReceiverDisconnectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverDisconnectedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverDisconnectedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverDisconnectedEventArgs", L"Connection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Connection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverDisconnectedEventArgs[] = {
        { "_assign_array_", _assign_array_MiracastReceiverDisconnectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverDisconnectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverDisconnectedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverDisconnectedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverDisconnectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverDisconnectedEventArgs) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverDisconnectedEventArgs = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverDisconnectedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverDisconnectedEventArgs};

    // ----- MiracastReceiverGameControllerDevice class --------------------

    static PyObject* _new_MiracastReceiverGameControllerDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverGameControllerDevice(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"TransmitInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransmitInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverGameControllerDevice_put_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"TransmitInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.TransmitInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_Mode(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Mode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverGameControllerDevice_put_Mode(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDeviceUsageMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.Mode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_IsRequestedByTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"IsRequestedByTransmitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRequestedByTransmitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_IsTransmittingInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"IsTransmittingInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTransmittingInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_add_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Changed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_remove_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Changed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverGameControllerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverGameControllerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverGameControllerDevice[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(MiracastReceiverGameControllerDevice_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MiracastReceiverGameControllerDevice_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverGameControllerDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverGameControllerDevice), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverGameControllerDevice[] = {
        { "transmit_input", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_TransmitInput), reinterpret_cast<setter>(MiracastReceiverGameControllerDevice_put_TransmitInput), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_Mode), reinterpret_cast<setter>(MiracastReceiverGameControllerDevice_put_Mode), nullptr, nullptr },
        { "is_requested_by_transmitter", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_IsRequestedByTransmitter), nullptr, nullptr, nullptr },
        { "is_transmitting_input", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_IsTransmittingInput), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverGameControllerDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverGameControllerDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverGameControllerDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverGameControllerDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverGameControllerDevice) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverGameControllerDevice = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverGameControllerDevice",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverGameControllerDevice};

    // ----- MiracastReceiverInputDevices class --------------------

    static PyObject* _new_MiracastReceiverInputDevices(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverInputDevices(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverInputDevices_get_GameController(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverInputDevices", L"GameController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GameController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverInputDevices_get_Keyboard(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverInputDevices", L"Keyboard");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Keyboard();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverInputDevices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverInputDevices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverInputDevices[] = {
        { "_assign_array_", _assign_array_MiracastReceiverInputDevices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverInputDevices), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverInputDevices[] = {
        { "game_controller", reinterpret_cast<getter>(MiracastReceiverInputDevices_get_GameController), nullptr, nullptr, nullptr },
        { "keyboard", reinterpret_cast<getter>(MiracastReceiverInputDevices_get_Keyboard), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverInputDevices[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverInputDevices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverInputDevices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverInputDevices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverInputDevices) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverInputDevices = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverInputDevices",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverInputDevices};

    // ----- MiracastReceiverKeyboardDevice class --------------------

    static PyObject* _new_MiracastReceiverKeyboardDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverKeyboardDevice(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"TransmitInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransmitInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverKeyboardDevice_put_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"TransmitInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.TransmitInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_IsRequestedByTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"IsRequestedByTransmitter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRequestedByTransmitter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_IsTransmittingInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"IsTransmittingInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTransmittingInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_add_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Changed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_remove_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Changed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverKeyboardDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverKeyboardDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverKeyboardDevice[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(MiracastReceiverKeyboardDevice_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MiracastReceiverKeyboardDevice_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverKeyboardDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverKeyboardDevice), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverKeyboardDevice[] = {
        { "transmit_input", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_TransmitInput), reinterpret_cast<setter>(MiracastReceiverKeyboardDevice_put_TransmitInput), nullptr, nullptr },
        { "is_requested_by_transmitter", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_IsRequestedByTransmitter), nullptr, nullptr, nullptr },
        { "is_transmitting_input", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_IsTransmittingInput), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverKeyboardDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverKeyboardDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverKeyboardDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverKeyboardDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverKeyboardDevice) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverKeyboardDevice = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverKeyboardDevice",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverKeyboardDevice};

    // ----- MiracastReceiverMediaSourceCreatedEventArgs class --------------------

    static PyObject* _new_MiracastReceiverMediaSourceCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverMediaSourceCreatedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_GetDeferral(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"Connection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Connection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_CursorImageChannelSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"CursorImageChannelSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CursorImageChannelSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_MediaSource(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"MediaSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MediaSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverMediaSourceCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverMediaSourceCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverMediaSourceCreatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MiracastReceiverMediaSourceCreatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverMediaSourceCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverMediaSourceCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverMediaSourceCreatedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { "cursor_image_channel_settings", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_CursorImageChannelSettings), nullptr, nullptr, nullptr },
        { "media_source", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_MediaSource), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverMediaSourceCreatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverMediaSourceCreatedEventArgs) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverMediaSourceCreatedEventArgs = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverMediaSourceCreatedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverMediaSourceCreatedEventArgs};

    // ----- MiracastReceiverSession class --------------------

    static PyObject* _new_MiracastReceiverSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSession>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSession_Close(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_Start(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Start();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_StartAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"StartAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_get_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MaxSimultaneousConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxSimultaneousConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSession_put_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MaxSimultaneousConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.MaxSimultaneousConnections(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSession_get_AllowConnectionTakeover(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"AllowConnectionTakeover");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowConnectionTakeover();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSession_put_AllowConnectionTakeover(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"AllowConnectionTakeover");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowConnectionTakeover(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSession_add_ConnectionCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"ConnectionCreated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectionCreated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_ConnectionCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"ConnectionCreated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConnectionCreated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_add_Disconnected(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Disconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Disconnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_Disconnected(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Disconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Disconnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_add_MediaSourceCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MediaSourceCreated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MediaSourceCreated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_MediaSourceCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MediaSourceCreated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MediaSourceCreated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSession[] = {
        { "close", reinterpret_cast<PyCFunction>(MiracastReceiverSession_Close), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MiracastReceiverSession_Start), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(MiracastReceiverSession_StartAsync), METH_VARARGS, nullptr },
        { "add_connection_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_ConnectionCreated), METH_O, nullptr },
        { "remove_connection_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_ConnectionCreated), METH_O, nullptr },
        { "add_disconnected", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_Disconnected), METH_O, nullptr },
        { "remove_disconnected", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_Disconnected), METH_O, nullptr },
        { "add_media_source_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_MediaSourceCreated), METH_O, nullptr },
        { "remove_media_source_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_MediaSourceCreated), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MiracastReceiverSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MiracastReceiverSession), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverSession[] = {
        { "max_simultaneous_connections", reinterpret_cast<getter>(MiracastReceiverSession_get_MaxSimultaneousConnections), reinterpret_cast<setter>(MiracastReceiverSession_put_MaxSimultaneousConnections), nullptr, nullptr },
        { "allow_connection_takeover", reinterpret_cast<getter>(MiracastReceiverSession_get_AllowConnectionTakeover), reinterpret_cast<setter>(MiracastReceiverSession_put_AllowConnectionTakeover), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSession) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverSession = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverSession",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSession};

    // ----- MiracastReceiverSessionStartResult class --------------------

    static PyObject* _new_MiracastReceiverSessionStartResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSessionStartResult(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSessionStartResult_get_ExtendedError(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSessionStartResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSessionStartResult_get_Status(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSessionStartResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSessionStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSessionStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSessionStartResult[] = {
        { "_assign_array_", _assign_array_MiracastReceiverSessionStartResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSessionStartResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverSessionStartResult[] = {
        { "extended_error", reinterpret_cast<getter>(MiracastReceiverSessionStartResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MiracastReceiverSessionStartResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverSessionStartResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSessionStartResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSessionStartResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSessionStartResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSessionStartResult) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverSessionStartResult = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverSessionStartResult",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSessionStartResult};

    // ----- MiracastReceiverSettings class --------------------

    static PyObject* _new_MiracastReceiverSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSettings_get_RequireAuthorizationFromKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"RequireAuthorizationFromKnownTransmitters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequireAuthorizationFromKnownTransmitters();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_RequireAuthorizationFromKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"RequireAuthorizationFromKnownTransmitters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequireAuthorizationFromKnownTransmitters(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_ModelNumber(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModelNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_ModelNumber(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ModelNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_ModelName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModelName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_ModelName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ModelName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_FriendlyName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"FriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FriendlyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_FriendlyName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"FriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.FriendlyName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_AuthorizationMethod(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"AuthorizationMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AuthorizationMethod();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_AuthorizationMethod(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"AuthorizationMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverAuthorizationMethod>(arg);

            {
                auto _gil = release_gil();
                self->obj.AuthorizationMethod(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverSettings[] = {
        { "require_authorization_from_known_transmitters", reinterpret_cast<getter>(MiracastReceiverSettings_get_RequireAuthorizationFromKnownTransmitters), reinterpret_cast<setter>(MiracastReceiverSettings_put_RequireAuthorizationFromKnownTransmitters), nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(MiracastReceiverSettings_get_ModelNumber), reinterpret_cast<setter>(MiracastReceiverSettings_put_ModelNumber), nullptr, nullptr },
        { "model_name", reinterpret_cast<getter>(MiracastReceiverSettings_get_ModelName), reinterpret_cast<setter>(MiracastReceiverSettings_put_ModelName), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(MiracastReceiverSettings_get_FriendlyName), reinterpret_cast<setter>(MiracastReceiverSettings_put_FriendlyName), nullptr, nullptr },
        { "authorization_method", reinterpret_cast<getter>(MiracastReceiverSettings_get_AuthorizationMethod), reinterpret_cast<setter>(MiracastReceiverSettings_put_AuthorizationMethod), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSettings) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverSettings = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSettings};

    // ----- MiracastReceiverStatus class --------------------

    static PyObject* _new_MiracastReceiverStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverStatus>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverStatus_get_IsConnectionTakeoverSupported(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"IsConnectionTakeoverSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConnectionTakeoverSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_KnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"KnownTransmitters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnownTransmitters();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_ListeningStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"ListeningStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ListeningStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"MaxSimultaneousConnections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxSimultaneousConnections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_WiFiStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"WiFiStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WiFiStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverStatus[] = {
        { "_assign_array_", _assign_array_MiracastReceiverStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverStatus), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverStatus[] = {
        { "is_connection_takeover_supported", reinterpret_cast<getter>(MiracastReceiverStatus_get_IsConnectionTakeoverSupported), nullptr, nullptr, nullptr },
        { "known_transmitters", reinterpret_cast<getter>(MiracastReceiverStatus_get_KnownTransmitters), nullptr, nullptr, nullptr },
        { "listening_status", reinterpret_cast<getter>(MiracastReceiverStatus_get_ListeningStatus), nullptr, nullptr, nullptr },
        { "max_simultaneous_connections", reinterpret_cast<getter>(MiracastReceiverStatus_get_MaxSimultaneousConnections), nullptr, nullptr, nullptr },
        { "wi_fi_status", reinterpret_cast<getter>(MiracastReceiverStatus_get_WiFiStatus), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverStatus[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverStatus) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverStatus = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverStatus",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverStatus};

    // ----- MiracastReceiverStreamControl class --------------------

    static PyObject* _new_MiracastReceiverStreamControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverStreamControl(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverStreamControl_GetVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"GetVideoStreamSettings", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetVideoStreamSettings();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_GetVideoStreamSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"GetVideoStreamSettingsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetVideoStreamSettingsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_SuggestVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"SuggestVideoStreamSettings", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SuggestVideoStreamSettings(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_SuggestVideoStreamSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"SuggestVideoStreamSettingsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SuggestVideoStreamSettingsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_get_MuteAudio(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"MuteAudio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MuteAudio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverStreamControl_put_MuteAudio(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"MuteAudio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.MuteAudio(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverStreamControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverStreamControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverStreamControl[] = {
        { "get_video_stream_settings", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_GetVideoStreamSettings), METH_VARARGS, nullptr },
        { "get_video_stream_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_GetVideoStreamSettingsAsync), METH_VARARGS, nullptr },
        { "suggest_video_stream_settings", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_SuggestVideoStreamSettings), METH_VARARGS, nullptr },
        { "suggest_video_stream_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_SuggestVideoStreamSettingsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverStreamControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverStreamControl), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverStreamControl[] = {
        { "mute_audio", reinterpret_cast<getter>(MiracastReceiverStreamControl_get_MuteAudio), reinterpret_cast<setter>(MiracastReceiverStreamControl_put_MuteAudio), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverStreamControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverStreamControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverStreamControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverStreamControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverStreamControl) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverStreamControl = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverStreamControl",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverStreamControl};

    // ----- MiracastReceiverVideoStreamSettings class --------------------

    static PyObject* _new_MiracastReceiverVideoStreamSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverVideoStreamSettings_get_Size(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverVideoStreamSettings_put_Size(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);

            {
                auto _gil = release_gil();
                self->obj.Size(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverVideoStreamSettings_get_Bitrate(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Bitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bitrate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverVideoStreamSettings_put_Bitrate(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Bitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Bitrate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverVideoStreamSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverVideoStreamSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverVideoStreamSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverVideoStreamSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverVideoStreamSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastReceiverVideoStreamSettings[] = {
        { "size", reinterpret_cast<getter>(MiracastReceiverVideoStreamSettings_get_Size), reinterpret_cast<setter>(MiracastReceiverVideoStreamSettings_put_Size), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(MiracastReceiverVideoStreamSettings_get_Bitrate), reinterpret_cast<setter>(MiracastReceiverVideoStreamSettings_put_Bitrate), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastReceiverVideoStreamSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverVideoStreamSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverVideoStreamSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverVideoStreamSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverVideoStreamSettings) },
        { }};

    static PyType_Spec type_spec_MiracastReceiverVideoStreamSettings = {
        "winrt._winrt_windows_media_miracast.MiracastReceiverVideoStreamSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverVideoStreamSettings};

    // ----- MiracastTransmitter class --------------------

    static PyObject* _new_MiracastTransmitter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastTransmitter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastTransmitter>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastTransmitter(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastTransmitter_GetConnections(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"GetConnections", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConnections();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastTransmitter_get_Name(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastTransmitter_put_Name(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastTransmitter_get_AuthorizationStatus(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"AuthorizationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AuthorizationStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastTransmitter_put_AuthorizationStatus(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"AuthorizationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastTransmitterAuthorizationStatus>(arg);

            {
                auto _gil = release_gil();
                self->obj.AuthorizationStatus(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastTransmitter_get_LastConnectionTime(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"LastConnectionTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastConnectionTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastTransmitter_get_MacAddress(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"MacAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MacAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastTransmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastTransmitter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastTransmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastTransmitter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastTransmitter[] = {
        { "get_connections", reinterpret_cast<PyCFunction>(MiracastTransmitter_GetConnections), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastTransmitter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastTransmitter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MiracastTransmitter[] = {
        { "name", reinterpret_cast<getter>(MiracastTransmitter_get_Name), reinterpret_cast<setter>(MiracastTransmitter_put_Name), nullptr, nullptr },
        { "authorization_status", reinterpret_cast<getter>(MiracastTransmitter_get_AuthorizationStatus), reinterpret_cast<setter>(MiracastTransmitter_put_AuthorizationStatus), nullptr, nullptr },
        { "last_connection_time", reinterpret_cast<getter>(MiracastTransmitter_get_LastConnectionTime), nullptr, nullptr, nullptr },
        { "mac_address", reinterpret_cast<getter>(MiracastTransmitter_get_MacAddress), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MiracastTransmitter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastTransmitter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastTransmitter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastTransmitter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastTransmitter) },
        { }};

    static PyType_Spec type_spec_MiracastTransmitter = {
        "winrt._winrt_windows_media_miracast.MiracastTransmitter",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastTransmitter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastTransmitter};

    // ----- Windows.Media.Miracast Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Miracast");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_miracast",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Miracast

PyMODINIT_FUNC PyInit__winrt_windows_media_miracast(void) noexcept
{
    using namespace py::cpp::Windows::Media::Miracast;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiver_type{py::register_python_type(module.get(), &type_spec_MiracastReceiver, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiver_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverApplySettingsResult_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverApplySettingsResult, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverApplySettingsResult_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverConnection_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverConnection, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverConnection_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverConnectionCreatedEventArgs_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverConnectionCreatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverConnectionCreatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverCursorImageChannel_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverCursorImageChannel, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverCursorImageChannel_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverCursorImageChannelSettings_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverCursorImageChannelSettings, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverCursorImageChannelSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverDisconnectedEventArgs_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverDisconnectedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverDisconnectedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverGameControllerDevice_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverGameControllerDevice, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverGameControllerDevice_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverInputDevices_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverInputDevices, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverInputDevices_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverKeyboardDevice_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverKeyboardDevice, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverKeyboardDevice_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverMediaSourceCreatedEventArgs_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverMediaSourceCreatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverMediaSourceCreatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverSession_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverSession, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverSession_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverSessionStartResult_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverSessionStartResult, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverSessionStartResult_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverSettings_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverSettings, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverStatus_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverStatus, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverStatus_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverStreamControl_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverStreamControl, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverStreamControl_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastReceiverVideoStreamSettings_type{py::register_python_type(module.get(), &type_spec_MiracastReceiverVideoStreamSettings, object_bases.get(), inspectable_meta_type)};
    if (!MiracastReceiverVideoStreamSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle MiracastTransmitter_type{py::register_python_type(module.get(), &type_spec_MiracastTransmitter, object_bases.get(), inspectable_meta_type)};
    if (!MiracastTransmitter_type)
    {
        return nullptr;
    }


    return module.detach();
}
