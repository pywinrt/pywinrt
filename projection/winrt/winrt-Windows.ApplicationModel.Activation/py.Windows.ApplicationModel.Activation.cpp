// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.Activation.h"

namespace py::cpp::Windows::ApplicationModel::Activation
{
    // ----- AppointmentsProviderAddAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderAddAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderAddAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs", L"AddAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AddAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderAddAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderAddAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "add_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderAddAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_AppointmentsProviderAddAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderAddAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderAddAppointmentActivatedEventArgs};

    // ----- AppointmentsProviderRemoveAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderRemoveAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderRemoveAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs", L"RemoveAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoveAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderRemoveAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "remove_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_AppointmentsProviderRemoveAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderRemoveAppointmentActivatedEventArgs};

    // ----- AppointmentsProviderReplaceAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderReplaceAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderReplaceAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs", L"ReplaceAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReplaceAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderReplaceAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "replace_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_AppointmentsProviderReplaceAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderReplaceAppointmentActivatedEventArgs};

    // ----- AppointmentsProviderShowAppointmentDetailsActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"InstanceStartDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InstanceStartDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"LocalId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"RoamingId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "instance_start_date", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId), nullptr, nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs};

    // ----- AppointmentsProviderShowTimeFrameActivatedEventArgs class --------------------

    static PyObject* _new_AppointmentsProviderShowTimeFrameActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderShowTimeFrameActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs", L"TimeToShow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TimeToShow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_AppointmentsProviderShowTimeFrameActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderShowTimeFrameActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { "time_to_show", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_AppointmentsProviderShowTimeFrameActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.AppointmentsProviderShowTimeFrameActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderShowTimeFrameActivatedEventArgs};

    // ----- BackgroundActivatedEventArgs class --------------------

    static PyObject* _new_BackgroundActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundActivatedEventArgs_get_TaskInstance(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BackgroundActivatedEventArgs", L"TaskInstance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TaskInstance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_BackgroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BackgroundActivatedEventArgs[] = {
        { "task_instance", reinterpret_cast<getter>(BackgroundActivatedEventArgs_get_TaskInstance), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BackgroundActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_BackgroundActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.BackgroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundActivatedEventArgs};

    // ----- BarcodeScannerPreviewActivatedEventArgs class --------------------

    static PyObject* _new_BarcodeScannerPreviewActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerPreviewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_ConnectionId(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.BarcodeScannerPreviewActivatedEventArgs", L"ConnectionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerPreviewActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerPreviewActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerPreviewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BarcodeScannerPreviewActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "connection_id", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_ConnectionId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BarcodeScannerPreviewActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerPreviewActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_BarcodeScannerPreviewActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.BarcodeScannerPreviewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerPreviewActivatedEventArgs};

    // ----- CachedFileUpdaterActivatedEventArgs class --------------------

    static PyObject* _new_CachedFileUpdaterActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs", L"CachedFileUpdaterUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CachedFileUpdaterUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_CachedFileUpdaterActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CachedFileUpdaterActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "cached_file_updater_ui", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CachedFileUpdaterActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdaterActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CachedFileUpdaterActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdaterActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdaterActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_CachedFileUpdaterActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.CachedFileUpdaterActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterActivatedEventArgs};

    // ----- CameraSettingsActivatedEventArgs class --------------------

    static PyObject* _new_CameraSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CameraSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_VideoDeviceController(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"VideoDeviceController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideoDeviceController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_VideoDeviceExtension(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs", L"VideoDeviceExtension");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideoDeviceExtension();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_CameraSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CameraSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "video_device_controller", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "video_device_extension", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_VideoDeviceExtension), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CameraSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_CameraSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.CameraSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraSettingsActivatedEventArgs};

    // ----- CommandLineActivatedEventArgs class --------------------

    static PyObject* _new_CommandLineActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandLineActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandLineActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandLineActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_CommandLineActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandLineActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CommandLineActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CommandLineActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandLineActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandLineActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandLineActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandLineActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_CommandLineActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.CommandLineActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandLineActivatedEventArgs};

    // ----- CommandLineActivationOperation class --------------------

    static PyObject* _new_CommandLineActivationOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandLineActivationOperation(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandLineActivationOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandLineActivationOperation_get_ExitCode(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"ExitCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExitCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CommandLineActivationOperation_put_ExitCode(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"ExitCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExitCode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CommandLineActivationOperation_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivationOperation_get_CurrentDirectoryPath(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.CommandLineActivationOperation", L"CurrentDirectoryPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentDirectoryPath();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandLineActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandLineActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandLineActivationOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CommandLineActivationOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CommandLineActivationOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandLineActivationOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CommandLineActivationOperation[] = {
        { "exit_code", reinterpret_cast<getter>(CommandLineActivationOperation_get_ExitCode), reinterpret_cast<setter>(CommandLineActivationOperation_put_ExitCode), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(CommandLineActivationOperation_get_Arguments), nullptr, nullptr, nullptr },
        { "current_directory_path", reinterpret_cast<getter>(CommandLineActivationOperation_get_CurrentDirectoryPath), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CommandLineActivationOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandLineActivationOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandLineActivationOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandLineActivationOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandLineActivationOperation) },
        { }};

    static PyType_Spec type_spec_CommandLineActivationOperation = {
        "winrt._winrt_windows_applicationmodel_activation.CommandLineActivationOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandLineActivationOperation};

    // ----- ContactCallActivatedEventArgs class --------------------

    static PyObject* _new_ContactCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContactCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContactCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContactCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCallActivatedEventArgs};

    // ----- ContactMapActivatedEventArgs class --------------------

    static PyObject* _new_ContactMapActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactMapActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactMapActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Address(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Address();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMapActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactMapActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactMapActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContactMapActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "address", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContactMapActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactMapActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactMapActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactMapActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactMapActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContactMapActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactMapActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMapActivatedEventArgs};

    // ----- ContactMessageActivatedEventArgs class --------------------

    static PyObject* _new_ContactMessageActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactMessageActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMessageActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactMessageActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactMessageActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContactMessageActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContactMessageActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactMessageActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactMessageActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactMessageActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactMessageActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContactMessageActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactMessageActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMessageActivatedEventArgs};

    // ----- ContactPanelActivatedEventArgs class --------------------

    static PyObject* _new_ContactPanelActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPanelActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPanelActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_ContactPanel(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPanelActivatedEventArgs", L"ContactPanel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactPanel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactPanelActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanelActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContactPanelActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "contact_panel", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_ContactPanel), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContactPanelActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPanelActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPanelActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPanelActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPanelActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContactPanelActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactPanelActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelActivatedEventArgs};

    // ----- ContactPickerActivatedEventArgs class --------------------

    static PyObject* _new_ContactPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_ContactPickerUI(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs", L"ContactPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactPickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContactPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "contact_picker_ui", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_ContactPickerUI), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContactPickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContactPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPickerActivatedEventArgs};

    // ----- ContactPostActivatedEventArgs class --------------------

    static PyObject* _new_ContactPostActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPostActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPostActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPostActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactPostActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPostActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContactPostActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContactPostActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPostActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPostActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPostActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPostActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContactPostActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactPostActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPostActivatedEventArgs};

    // ----- ContactVideoCallActivatedEventArgs class --------------------

    static PyObject* _new_ContactVideoCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactVideoCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactVideoCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactVideoCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactVideoCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContactVideoCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContactVideoCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactVideoCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactVideoCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactVideoCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactVideoCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContactVideoCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ContactVideoCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactVideoCallActivatedEventArgs};

    // ----- DeviceActivatedEventArgs class --------------------

    static PyObject* _new_DeviceActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_DeviceInformationId(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"DeviceInformationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceInformationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DeviceActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_DeviceActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DeviceActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "device_information_id", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_DeviceInformationId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DeviceActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_DeviceActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.DeviceActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceActivatedEventArgs};

    // ----- DevicePairingActivatedEventArgs class --------------------

    static PyObject* _new_DevicePairingActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DevicePairingActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePairingActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_DeviceInformation(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs", L"DeviceInformation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceInformation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_DevicePairingActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePairingActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DevicePairingActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DevicePairingActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePairingActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePairingActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePairingActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePairingActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_DevicePairingActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.DevicePairingActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingActivatedEventArgs};

    // ----- DialReceiverActivatedEventArgs class --------------------

    static PyObject* _new_DialReceiverActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DialReceiverActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DialReceiverActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_AppName(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"AppName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DialReceiverActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_DialReceiverActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DialReceiverActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DialReceiverActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "app_name", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_AppName), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DialReceiverActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DialReceiverActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DialReceiverActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DialReceiverActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DialReceiverActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_DialReceiverActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.DialReceiverActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DialReceiverActivatedEventArgs};

    // ----- FileActivatedEventArgs class --------------------

    static PyObject* _new_FileActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Files();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_NeighboringFilesQuery(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"NeighboringFilesQuery");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NeighboringFilesQuery();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_FileActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(FileActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(FileActivatedEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(FileActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "neighboring_files_query", reinterpret_cast<getter>(FileActivatedEventArgs_get_NeighboringFilesQuery), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(FileActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FileActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_FileActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileActivatedEventArgs};

    // ----- FileOpenPickerActivatedEventArgs class --------------------

    static PyObject* _new_FileOpenPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileOpenPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_FileOpenPickerUI(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"FileOpenPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileOpenPickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOpenPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_FileOpenPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileOpenPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileOpenPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_open_picker_ui", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_FileOpenPickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FileOpenPickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileOpenPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileOpenPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileOpenPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileOpenPickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_FileOpenPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileOpenPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOpenPickerActivatedEventArgs};

    // ----- FileOpenPickerContinuationEventArgs class --------------------

    static PyObject* _new_FileOpenPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileOpenPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Files();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOpenPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_FileOpenPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileOpenPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileOpenPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_Files), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FileOpenPickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileOpenPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileOpenPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileOpenPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileOpenPickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_FileOpenPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileOpenPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOpenPickerContinuationEventArgs};

    // ----- FileSavePickerActivatedEventArgs class --------------------

    static PyObject* _new_FileSavePickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileSavePickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_FileSavePickerUI(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"FileSavePickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileSavePickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs", L"EnterpriseId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EnterpriseId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileSavePickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_FileSavePickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileSavePickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileSavePickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_save_picker_ui", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_FileSavePickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_EnterpriseId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FileSavePickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileSavePickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileSavePickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileSavePickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileSavePickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_FileSavePickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileSavePickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileSavePickerActivatedEventArgs};

    // ----- FileSavePickerContinuationEventArgs class --------------------

    static PyObject* _new_FileSavePickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileSavePickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_File(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.File();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileSavePickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_FileSavePickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileSavePickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileSavePickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_File), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FileSavePickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileSavePickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileSavePickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileSavePickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileSavePickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_FileSavePickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FileSavePickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileSavePickerContinuationEventArgs};

    // ----- FolderPickerContinuationEventArgs class --------------------

    static PyObject* _new_FolderPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FolderPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FolderPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_Folder(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs", L"Folder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Folder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FolderPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_FolderPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FolderPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FolderPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "folder", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_Folder), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FolderPickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FolderPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FolderPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FolderPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FolderPickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_FolderPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.FolderPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FolderPickerContinuationEventArgs};

    // ----- LaunchActivatedEventArgs class --------------------

    static PyObject* _new_LaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"TileActivatedInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileActivatedInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_PrelaunchActivated(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"PrelaunchActivated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrelaunchActivated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LaunchActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_LaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "tile_activated_info", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_TileActivatedInfo), nullptr, nullptr, nullptr },
        { "prelaunch_activated", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_PrelaunchActivated), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_LaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_LaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.LaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LaunchActivatedEventArgs};

    // ----- LockScreenActivatedEventArgs class --------------------

    static PyObject* _new_LockScreenActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_Info(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs", L"Info");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Info();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_LockScreenActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LockScreenActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "info", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_Info), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_LockScreenActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_LockScreenActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.LockScreenActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenActivatedEventArgs};

    // ----- LockScreenCallActivatedEventArgs class --------------------

    static PyObject* _new_LockScreenCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_CallUI(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"CallUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_LockScreenCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LockScreenCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "call_ui", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_CallUI), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_LockScreenCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_LockScreenCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.LockScreenCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallActivatedEventArgs};

    // ----- LockScreenComponentActivatedEventArgs class --------------------

    static PyObject* _new_LockScreenComponentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenComponentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenComponentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenComponentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.LockScreenComponentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenComponentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_LockScreenComponentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenComponentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LockScreenComponentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_LockScreenComponentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenComponentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenComponentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenComponentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenComponentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_LockScreenComponentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.LockScreenComponentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenComponentActivatedEventArgs};

    // ----- PhoneCallActivatedEventArgs class --------------------

    static PyObject* _new_PhoneCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PhoneCallActivatedEventArgs", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_PhoneCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhoneCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhoneCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_PhoneCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.PhoneCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallActivatedEventArgs};

    // ----- PickerReturnedActivatedEventArgs class --------------------

    static PyObject* _new_PickerReturnedActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PickerReturnedActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_PickerOperationId(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs", L"PickerOperationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PickerOperationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerReturnedActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_PickerReturnedActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerReturnedActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PickerReturnedActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "picker_operation_id", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_PickerOperationId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PickerReturnedActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerReturnedActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerReturnedActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerReturnedActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerReturnedActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_PickerReturnedActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.PickerReturnedActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerReturnedActivatedEventArgs};

    // ----- Print3DWorkflowActivatedEventArgs class --------------------

    static PyObject* _new_Print3DWorkflowActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DWorkflowActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_Workflow(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs", L"Workflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Workflow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DWorkflowActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_Print3DWorkflowActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DWorkflowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Print3DWorkflowActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "workflow", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_Workflow), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Print3DWorkflowActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DWorkflowActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DWorkflowActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DWorkflowActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DWorkflowActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_Print3DWorkflowActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.Print3DWorkflowActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DWorkflowActivatedEventArgs};

    // ----- PrintTaskSettingsActivatedEventArgs class --------------------

    static PyObject* _new_PrintTaskSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintTaskSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_Configuration(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintTaskSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_PrintTaskSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintTaskSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PrintTaskSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PrintTaskSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintTaskSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintTaskSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintTaskSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintTaskSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_PrintTaskSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.PrintTaskSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintTaskSettingsActivatedEventArgs};

    // ----- ProtocolActivatedEventArgs class --------------------

    static PyObject* _new_ProtocolActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ProtocolActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProtocolActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_Data(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ProtocolActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProtocolActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProtocolActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProtocolActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProtocolActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProtocolActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProtocolActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProtocolActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ProtocolActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ProtocolActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolActivatedEventArgs};

    // ----- ProtocolForResultsActivatedEventArgs class --------------------

    static PyObject* _new_ProtocolForResultsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ProtocolForResultsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Data(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"ProtocolForResultsOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtocolForResultsOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolForResultsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ProtocolForResultsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProtocolForResultsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProtocolForResultsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "protocol_for_results_operation", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProtocolForResultsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProtocolForResultsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProtocolForResultsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProtocolForResultsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProtocolForResultsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ProtocolForResultsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ProtocolForResultsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolForResultsActivatedEventArgs};

    // ----- RestrictedLaunchActivatedEventArgs class --------------------

    static PyObject* _new_RestrictedLaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RestrictedLaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_SharedContext(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs", L"SharedContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SharedContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RestrictedLaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_RestrictedLaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RestrictedLaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RestrictedLaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "shared_context", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RestrictedLaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RestrictedLaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RestrictedLaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RestrictedLaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RestrictedLaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_RestrictedLaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.RestrictedLaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RestrictedLaunchActivatedEventArgs};

    // ----- SearchActivatedEventArgs class --------------------

    static PyObject* _new_SearchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinguisticDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SearchActivatedEventArgs", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(SearchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(SearchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(SearchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(SearchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(SearchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(SearchActivatedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchActivatedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchActivatedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(SearchActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_SearchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.SearchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchActivatedEventArgs};

    // ----- ShareTargetActivatedEventArgs class --------------------

    static PyObject* _new_ShareTargetActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ShareTargetActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareTargetActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_ShareOperation(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs", L"ShareOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShareOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareTargetActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ShareTargetActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareTargetActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ShareTargetActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "share_operation", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_ShareOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ShareTargetActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShareTargetActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShareTargetActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShareTargetActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShareTargetActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ShareTargetActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ShareTargetActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareTargetActivatedEventArgs};

    // ----- SplashScreen class --------------------

    static PyObject* _new_SplashScreen(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::SplashScreen>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::SplashScreen>::type_name);
        return nullptr;
    }

    static void _dealloc_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplashScreen_get_ImageLocation(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.SplashScreen", L"ImageLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImageLocation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplashScreen_add_Dismissed(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Activation.SplashScreen", L"Dismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Activation::SplashScreen, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Dismissed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplashScreen_remove_Dismissed(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Activation.SplashScreen", L"Dismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Dismissed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplashScreen(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::SplashScreen>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplashScreen(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::SplashScreen>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplashScreen[] = {
        { "add_dismissed", reinterpret_cast<PyCFunction>(SplashScreen_add_Dismissed), METH_O, nullptr },
        { "remove_dismissed", reinterpret_cast<PyCFunction>(SplashScreen_remove_Dismissed), METH_O, nullptr },
        { "_assign_array_", _assign_array_SplashScreen, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplashScreen), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SplashScreen[] = {
        { "image_location", reinterpret_cast<getter>(SplashScreen_get_ImageLocation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SplashScreen[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplashScreen) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplashScreen) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplashScreen) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplashScreen) },
        { }};

    static PyType_Spec type_spec_SplashScreen = {
        "winrt._winrt_windows_applicationmodel_activation.SplashScreen",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplashScreen};

    // ----- StartupTaskActivatedEventArgs class --------------------

    static PyObject* _new_StartupTaskActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_StartupTaskActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StartupTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_TaskId(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.StartupTaskActivatedEventArgs", L"TaskId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TaskId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartupTaskActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_StartupTaskActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StartupTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StartupTaskActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_TaskId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StartupTaskActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StartupTaskActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StartupTaskActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StartupTaskActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StartupTaskActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_StartupTaskActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.StartupTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartupTaskActivatedEventArgs};

    // ----- TileActivatedInfo class --------------------

    static PyObject* _new_TileActivatedInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileActivatedInfo_get_RecentlyShownNotifications(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.TileActivatedInfo", L"RecentlyShownNotifications");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RecentlyShownNotifications();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileActivatedInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileActivatedInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileActivatedInfo[] = {
        { "_assign_array_", _assign_array_TileActivatedInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileActivatedInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TileActivatedInfo[] = {
        { "recently_shown_notifications", reinterpret_cast<getter>(TileActivatedInfo_get_RecentlyShownNotifications), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TileActivatedInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileActivatedInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileActivatedInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileActivatedInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileActivatedInfo) },
        { }};

    static PyType_Spec type_spec_TileActivatedInfo = {
        "winrt._winrt_windows_applicationmodel_activation.TileActivatedInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileActivatedInfo};

    // ----- ToastNotificationActivatedEventArgs class --------------------

    static PyObject* _new_ToastNotificationActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastNotificationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_Argument(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"Argument");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Argument();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_UserInput(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs", L"UserInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ToastNotificationActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastNotificationActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "argument", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastNotificationActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ToastNotificationActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ToastNotificationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActivatedEventArgs};

    // ----- UserDataAccountProviderActivatedEventArgs class --------------------

    static PyObject* _new_UserDataAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UserDataAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.UserDataAccountProviderActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.UserDataAccountProviderActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.UserDataAccountProviderActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.UserDataAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_UserDataAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserDataAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UserDataAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_UserDataAccountProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserDataAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserDataAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserDataAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserDataAccountProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_UserDataAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.UserDataAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataAccountProviderActivatedEventArgs};

    // ----- VoiceCommandActivatedEventArgs class --------------------

    static PyObject* _new_VoiceCommandActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VoiceCommandActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_Result(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoiceCommandActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_VoiceCommandActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoiceCommandActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VoiceCommandActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_VoiceCommandActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VoiceCommandActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VoiceCommandActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VoiceCommandActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VoiceCommandActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_VoiceCommandActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.VoiceCommandActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoiceCommandActivatedEventArgs};

    // ----- WalletActionActivatedEventArgs class --------------------

    static PyObject* _new_WalletActionActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WalletActionActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletActionActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ActionId(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"ActionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ActionKind(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"ActionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ItemId(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs", L"ItemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletActionActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WalletActionActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletActionActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WalletActionActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "action_id", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ActionId), nullptr, nullptr, nullptr },
        { "action_kind", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ActionKind), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ItemId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WalletActionActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletActionActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletActionActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletActionActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletActionActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WalletActionActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.WalletActionActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletActionActivatedEventArgs};

    // ----- WebAccountProviderActivatedEventArgs class --------------------

    static PyObject* _new_WebAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebAccountProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebAccountProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.WebAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebAccountProviderActivatedEventArgs};

    // ----- WebAuthenticationBrokerContinuationEventArgs class --------------------

    static PyObject* _new_WebAuthenticationBrokerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebAuthenticationBrokerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs", L"WebAuthenticationResult");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WebAuthenticationResult();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebAuthenticationBrokerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebAuthenticationBrokerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebAuthenticationBrokerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebAuthenticationBrokerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "web_authentication_result", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebAuthenticationBrokerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebAuthenticationBrokerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_WebAuthenticationBrokerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.WebAuthenticationBrokerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebAuthenticationBrokerContinuationEventArgs};

    // ----- IActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(IActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IActivatedEventArgs};

    struct ImplementsIActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>
    {
        ImplementsIActivatedEventArgs() = delete;
        ImplementsIActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIActivatedEventArgs};

    // ----- IActivatedEventArgsWithUser interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IActivatedEventArgsWithUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IActivatedEventArgsWithUser(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IActivatedEventArgsWithUser_get_User(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgsWithUser", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IActivatedEventArgsWithUser[] = {
        { }};

    static PyGetSetDef _getset_IActivatedEventArgsWithUser[] = {
        { "user", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_User), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IActivatedEventArgsWithUser[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IActivatedEventArgsWithUser) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IActivatedEventArgsWithUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IActivatedEventArgsWithUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IActivatedEventArgsWithUser) },
        { }};

    static PyType_Spec type_spec_IActivatedEventArgsWithUser = {
        "winrt._winrt_windows_applicationmodel_activation._IActivatedEventArgsWithUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IActivatedEventArgsWithUser};

    struct ImplementsIActivatedEventArgsWithUser : py::ImplementsInterfaceT<ImplementsIActivatedEventArgsWithUser, winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>
    {
        ImplementsIActivatedEventArgsWithUser() = delete;
        ImplementsIActivatedEventArgsWithUser(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIActivatedEventArgsWithUser, winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>(py_obj, runtime_class)
        {
        }

        auto User()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "user")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::System::User>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IActivatedEventArgsWithUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IActivatedEventArgsWithUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIActivatedEventArgsWithUser(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIActivatedEventArgsWithUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIActivatedEventArgsWithUser>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIActivatedEventArgsWithUser[] = {
        { "_assign_array_", _assign_array_IActivatedEventArgsWithUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IActivatedEventArgsWithUser), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIActivatedEventArgsWithUser), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIActivatedEventArgsWithUser), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIActivatedEventArgsWithUser[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIActivatedEventArgsWithUser) },
        { }};

    static PyType_Spec type_spec_ImplementsIActivatedEventArgsWithUser = {
        "winrt._winrt_windows_applicationmodel_activation.IActivatedEventArgsWithUser",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIActivatedEventArgsWithUser};

    // ----- IApplicationViewActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IApplicationViewActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IApplicationViewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IApplicationViewActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IApplicationViewActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IApplicationViewActivatedEventArgs[] = {
        { "currently_shown_application_view_id", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IApplicationViewActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IApplicationViewActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IApplicationViewActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IApplicationViewActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IApplicationViewActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IApplicationViewActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IApplicationViewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IApplicationViewActivatedEventArgs};

    struct ImplementsIApplicationViewActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIApplicationViewActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>
    {
        ImplementsIApplicationViewActivatedEventArgs() = delete;
        ImplementsIApplicationViewActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIApplicationViewActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto CurrentlyShownApplicationViewId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "currently_shown_application_view_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IApplicationViewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IApplicationViewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIApplicationViewActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIApplicationViewActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIApplicationViewActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIApplicationViewActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IApplicationViewActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IApplicationViewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIApplicationViewActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIApplicationViewActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIApplicationViewActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIApplicationViewActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIApplicationViewActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IApplicationViewActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIApplicationViewActivatedEventArgs};

    // ----- IAppointmentsProviderActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAppointmentsProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAppointmentsProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IAppointmentsProviderActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAppointmentsProviderActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IAppointmentsProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IAppointmentsProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAppointmentsProviderActivatedEventArgs};

    struct ImplementsIAppointmentsProviderActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>
    {
        ImplementsIAppointmentsProviderActivatedEventArgs() = delete;
        ImplementsIAppointmentsProviderActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAppointmentsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAppointmentsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAppointmentsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAppointmentsProviderActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAppointmentsProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAppointmentsProviderActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAppointmentsProviderActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAppointmentsProviderActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAppointmentsProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIAppointmentsProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAppointmentsProviderActivatedEventArgs};

    // ----- IAppointmentsProviderAddAppointmentActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAppointmentsProviderAddAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAppointmentsProviderAddAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderAddAppointmentActivatedEventArgs", L"AddAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AddAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "add_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderAddAppointmentActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IAppointmentsProviderAddAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IAppointmentsProviderAddAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAppointmentsProviderAddAppointmentActivatedEventArgs};

    struct ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>
    {
        ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs() = delete;
        ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto AddAppointmentOperation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "add_appointment_operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentsProvider::AddAppointmentOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderAddAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderAddAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderAddAppointmentActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs};

    // ----- IAppointmentsProviderRemoveAppointmentActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"RemoveAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoveAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "remove_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IAppointmentsProviderRemoveAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IAppointmentsProviderRemoveAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAppointmentsProviderRemoveAppointmentActivatedEventArgs};

    struct ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>
    {
        ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs() = delete;
        ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto RemoveAppointmentOperation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "remove_appointment_operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentsProvider::RemoveAppointmentOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderRemoveAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderRemoveAppointmentActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs};

    // ----- IAppointmentsProviderReplaceAppointmentActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"ReplaceAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReplaceAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "replace_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IAppointmentsProviderReplaceAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IAppointmentsProviderReplaceAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAppointmentsProviderReplaceAppointmentActivatedEventArgs};

    struct ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>
    {
        ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs() = delete;
        ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ReplaceAppointmentOperation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "replace_appointment_operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentsProvider::ReplaceAppointmentOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderReplaceAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderReplaceAppointmentActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs};

    // ----- IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"InstanceStartDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InstanceStartDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"LocalId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"RoamingId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "instance_start_date", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId), nullptr, nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs};

    struct ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>
    {
        ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs() = delete;
        ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto InstanceStartDate()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "instance_start_date")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LocalId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "local_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RoamingId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "roaming_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs};

    // ----- IAppointmentsProviderShowTimeFrameActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAppointmentsProviderShowTimeFrameActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAppointmentsProviderShowTimeFrameActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowTimeFrameActivatedEventArgs", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderShowTimeFrameActivatedEventArgs", L"TimeToShow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TimeToShow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IAppointmentsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "duration", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { "time_to_show", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IAppointmentsProviderShowTimeFrameActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IAppointmentsProviderShowTimeFrameActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAppointmentsProviderShowTimeFrameActivatedEventArgs};

    struct ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>
    {
        ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs() = delete;
        ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Duration()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "duration")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::TimeSpan>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TimeToShow()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "time_to_show")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IAppointmentsProviderShowTimeFrameActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderShowTimeFrameActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IAppointmentsProviderShowTimeFrameActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs};

    // ----- IBackgroundActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IBackgroundActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IBackgroundActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundActivatedEventArgs_get_TaskInstance(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IBackgroundActivatedEventArgs", L"TaskInstance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TaskInstance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IBackgroundActivatedEventArgs[] = {
        { "task_instance", reinterpret_cast<getter>(IBackgroundActivatedEventArgs_get_TaskInstance), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IBackgroundActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IBackgroundActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IBackgroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IBackgroundActivatedEventArgs};

    struct ImplementsIBackgroundActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIBackgroundActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>
    {
        ImplementsIBackgroundActivatedEventArgs() = delete;
        ImplementsIBackgroundActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIBackgroundActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto TaskInstance()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "task_instance")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IBackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIBackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIBackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIBackgroundActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIBackgroundActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IBackgroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIBackgroundActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIBackgroundActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIBackgroundActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIBackgroundActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIBackgroundActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IBackgroundActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIBackgroundActivatedEventArgs};

    // ----- IBarcodeScannerPreviewActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IBarcodeScannerPreviewActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IBarcodeScannerPreviewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IBarcodeScannerPreviewActivatedEventArgs", L"ConnectionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBarcodeScannerPreviewActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IBarcodeScannerPreviewActivatedEventArgs[] = {
        { "connection_id", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IBarcodeScannerPreviewActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IBarcodeScannerPreviewActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBarcodeScannerPreviewActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IBarcodeScannerPreviewActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IBarcodeScannerPreviewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IBarcodeScannerPreviewActivatedEventArgs};

    struct ImplementsIBarcodeScannerPreviewActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIBarcodeScannerPreviewActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>
    {
        ImplementsIBarcodeScannerPreviewActivatedEventArgs() = delete;
        ImplementsIBarcodeScannerPreviewActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIBarcodeScannerPreviewActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ConnectionId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "connection_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIBarcodeScannerPreviewActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIBarcodeScannerPreviewActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IBarcodeScannerPreviewActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBarcodeScannerPreviewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIBarcodeScannerPreviewActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIBarcodeScannerPreviewActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIBarcodeScannerPreviewActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIBarcodeScannerPreviewActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIBarcodeScannerPreviewActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IBarcodeScannerPreviewActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIBarcodeScannerPreviewActivatedEventArgs};

    // ----- ICachedFileUpdaterActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICachedFileUpdaterActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICachedFileUpdaterActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ICachedFileUpdaterActivatedEventArgs", L"CachedFileUpdaterUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CachedFileUpdaterUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICachedFileUpdaterActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_ICachedFileUpdaterActivatedEventArgs[] = {
        { "cached_file_updater_ui", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ICachedFileUpdaterActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICachedFileUpdaterActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICachedFileUpdaterActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ICachedFileUpdaterActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._ICachedFileUpdaterActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICachedFileUpdaterActivatedEventArgs};

    struct ImplementsICachedFileUpdaterActivatedEventArgs : py::ImplementsInterfaceT<ImplementsICachedFileUpdaterActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>
    {
        ImplementsICachedFileUpdaterActivatedEventArgs() = delete;
        ImplementsICachedFileUpdaterActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICachedFileUpdaterActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto CachedFileUpdaterUI()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "cached_file_updater_ui")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICachedFileUpdaterActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICachedFileUpdaterActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ICachedFileUpdaterActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICachedFileUpdaterActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICachedFileUpdaterActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICachedFileUpdaterActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICachedFileUpdaterActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICachedFileUpdaterActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsICachedFileUpdaterActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ICachedFileUpdaterActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICachedFileUpdaterActivatedEventArgs};

    // ----- ICameraSettingsActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICameraSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICameraSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_VideoDeviceController(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ICameraSettingsActivatedEventArgs", L"VideoDeviceController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideoDeviceController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_VideoDeviceExtension(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ICameraSettingsActivatedEventArgs", L"VideoDeviceExtension");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideoDeviceExtension();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICameraSettingsActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_ICameraSettingsActivatedEventArgs[] = {
        { "video_device_controller", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "video_device_extension", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_VideoDeviceExtension), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ICameraSettingsActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICameraSettingsActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICameraSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICameraSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICameraSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ICameraSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._ICameraSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICameraSettingsActivatedEventArgs};

    struct ImplementsICameraSettingsActivatedEventArgs : py::ImplementsInterfaceT<ImplementsICameraSettingsActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>
    {
        ImplementsICameraSettingsActivatedEventArgs() = delete;
        ImplementsICameraSettingsActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICameraSettingsActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto VideoDeviceController()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "video_device_controller")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VideoDeviceExtension()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "video_device_extension")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICameraSettingsActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICameraSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ICameraSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICameraSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICameraSettingsActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICameraSettingsActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICameraSettingsActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICameraSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsICameraSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ICameraSettingsActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICameraSettingsActivatedEventArgs};

    // ----- ICommandLineActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICommandLineActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICommandLineActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommandLineActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ICommandLineActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommandLineActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_ICommandLineActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ICommandLineActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommandLineActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommandLineActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommandLineActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommandLineActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ICommandLineActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._ICommandLineActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICommandLineActivatedEventArgs};

    struct ImplementsICommandLineActivatedEventArgs : py::ImplementsInterfaceT<ImplementsICommandLineActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>
    {
        ImplementsICommandLineActivatedEventArgs() = delete;
        ImplementsICommandLineActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICommandLineActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Operation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICommandLineActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICommandLineActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ICommandLineActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommandLineActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICommandLineActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICommandLineActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICommandLineActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICommandLineActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsICommandLineActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ICommandLineActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICommandLineActivatedEventArgs};

    // ----- IContactActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IContactActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactActivatedEventArgs};

    struct ImplementsIContactActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>
    {
        ImplementsIContactActivatedEventArgs() = delete;
        ImplementsIContactActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactActivatedEventArgs};

    // ----- IContactCallActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactCallActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactCallActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactCallActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactCallActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactCallActivatedEventArgs};

    struct ImplementsIContactCallActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactCallActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>
    {
        ImplementsIContactCallActivatedEventArgs() = delete;
        ImplementsIContactCallActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactCallActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Contact()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "contact")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceUserId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_user_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactCallActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactCallActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactCallActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactCallActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactCallActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactCallActivatedEventArgs};

    // ----- IContactMapActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactMapActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactMapActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactMapActivatedEventArgs_get_Address(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMapActivatedEventArgs", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Address();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMapActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactMapActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactMapActivatedEventArgs[] = {
        { "address", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactMapActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactMapActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactMapActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactMapActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactMapActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactMapActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactMapActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactMapActivatedEventArgs};

    struct ImplementsIContactMapActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactMapActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>
    {
        ImplementsIContactMapActivatedEventArgs() = delete;
        ImplementsIContactMapActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactMapActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Address()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "address")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAddress>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Contact()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "contact")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactMapActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactMapActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactMapActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactMapActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactMapActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactMapActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactMapActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactMapActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactMapActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactMapActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactMapActivatedEventArgs};

    // ----- IContactMessageActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactMessageActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactMessageActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMessageActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMessageActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactMessageActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactMessageActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactMessageActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactMessageActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactMessageActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactMessageActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactMessageActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactMessageActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactMessageActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactMessageActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactMessageActivatedEventArgs};

    struct ImplementsIContactMessageActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactMessageActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>
    {
        ImplementsIContactMessageActivatedEventArgs() = delete;
        ImplementsIContactMessageActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactMessageActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Contact()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "contact")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceUserId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_user_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactMessageActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactMessageActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactMessageActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactMessageActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactMessageActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactMessageActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactMessageActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactMessageActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactMessageActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactMessageActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactMessageActivatedEventArgs};

    // ----- IContactPanelActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactPanelActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactPanelActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPanelActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPanelActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPanelActivatedEventArgs_get_ContactPanel(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPanelActivatedEventArgs", L"ContactPanel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactPanel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPanelActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactPanelActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactPanelActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "contact_panel", reinterpret_cast<getter>(IContactPanelActivatedEventArgs_get_ContactPanel), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactPanelActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactPanelActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactPanelActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactPanelActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactPanelActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactPanelActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactPanelActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactPanelActivatedEventArgs};

    struct ImplementsIContactPanelActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactPanelActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>
    {
        ImplementsIContactPanelActivatedEventArgs() = delete;
        ImplementsIContactPanelActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactPanelActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Contact()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "contact")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContactPanel()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "contact_panel")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactPanel>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactPanelActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactPanelActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactPanelActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPanelActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactPanelActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactPanelActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactPanelActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactPanelActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactPanelActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactPanelActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactPanelActivatedEventArgs};

    // ----- IContactPickerActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPickerActivatedEventArgs_get_ContactPickerUI(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPickerActivatedEventArgs", L"ContactPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactPickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPickerActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactPickerActivatedEventArgs[] = {
        { "contact_picker_ui", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_ContactPickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactPickerActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactPickerActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactPickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactPickerActivatedEventArgs};

    struct ImplementsIContactPickerActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactPickerActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>
    {
        ImplementsIContactPickerActivatedEventArgs() = delete;
        ImplementsIContactPickerActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactPickerActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ContactPickerUI()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "contact_picker_ui")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::Provider::ContactPickerUI>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactPickerActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactPickerActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactPickerActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactPickerActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactPickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactPickerActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactPickerActivatedEventArgs};

    // ----- IContactPostActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactPostActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactPostActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPostActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPostActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPostActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactPostActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPostActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactPostActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactPostActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactPostActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactPostActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactPostActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactPostActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactPostActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactPostActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactPostActivatedEventArgs};

    struct ImplementsIContactPostActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactPostActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>
    {
        ImplementsIContactPostActivatedEventArgs() = delete;
        ImplementsIContactPostActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactPostActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Contact()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "contact")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceUserId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_user_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactPostActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactPostActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactPostActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPostActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactPostActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactPostActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactPostActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactPostActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactPostActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactPostActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactPostActivatedEventArgs};

    // ----- IContactVideoCallActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactVideoCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactVideoCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactVideoCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactVideoCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactVideoCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactVideoCallActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactVideoCallActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactVideoCallActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactVideoCallActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactVideoCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactVideoCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactVideoCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactVideoCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactVideoCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactVideoCallActivatedEventArgs};

    struct ImplementsIContactVideoCallActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactVideoCallActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>
    {
        ImplementsIContactVideoCallActivatedEventArgs() = delete;
        ImplementsIContactVideoCallActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactVideoCallActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Contact()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "contact")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServiceUserId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "service_user_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactVideoCallActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactVideoCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactVideoCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactVideoCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactVideoCallActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactVideoCallActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactVideoCallActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactVideoCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactVideoCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactVideoCallActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactVideoCallActivatedEventArgs};

    // ----- IContactsProviderActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContactsProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContactsProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContactsProviderActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactsProviderActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContactsProviderActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContactsProviderActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactsProviderActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactsProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactsProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactsProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContactsProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContactsProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContactsProviderActivatedEventArgs};

    struct ImplementsIContactsProviderActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContactsProviderActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>
    {
        ImplementsIContactsProviderActivatedEventArgs() = delete;
        ImplementsIContactsProviderActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContactsProviderActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContactsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContactsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContactsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContactsProviderActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContactsProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContactsProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactsProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContactsProviderActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContactsProviderActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContactsProviderActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContactsProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContactsProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContactsProviderActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContactsProviderActivatedEventArgs};

    // ----- IContinuationActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IContinuationActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IContinuationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContinuationActivatedEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContinuationActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IContinuationActivatedEventArgs[] = {
        { "continuation_data", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContinuationActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IContinuationActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContinuationActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContinuationActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContinuationActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IContinuationActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IContinuationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IContinuationActivatedEventArgs};

    struct ImplementsIContinuationActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIContinuationActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>
    {
        ImplementsIContinuationActivatedEventArgs() = delete;
        ImplementsIContinuationActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContinuationActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ContinuationData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "continuation_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IContinuationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContinuationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIContinuationActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContinuationActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContinuationActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContinuationActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IContinuationActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContinuationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContinuationActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContinuationActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContinuationActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContinuationActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIContinuationActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IContinuationActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIContinuationActivatedEventArgs};

    // ----- IDeviceActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IDeviceActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IDeviceActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDeviceActivatedEventArgs_get_DeviceInformationId(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IDeviceActivatedEventArgs", L"DeviceInformationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceInformationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IDeviceActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDeviceActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IDeviceActivatedEventArgs[] = {
        { "device_information_id", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_DeviceInformationId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IDeviceActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IDeviceActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDeviceActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDeviceActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDeviceActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IDeviceActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IDeviceActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IDeviceActivatedEventArgs};

    struct ImplementsIDeviceActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIDeviceActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>
    {
        ImplementsIDeviceActivatedEventArgs() = delete;
        ImplementsIDeviceActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIDeviceActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto DeviceInformationId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "device_information_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIDeviceActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIDeviceActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IDeviceActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDeviceActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIDeviceActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIDeviceActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIDeviceActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIDeviceActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIDeviceActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IDeviceActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIDeviceActivatedEventArgs};

    // ----- IDevicePairingActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IDevicePairingActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IDevicePairingActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_DeviceInformation(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IDevicePairingActivatedEventArgs", L"DeviceInformation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceInformation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDevicePairingActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IDevicePairingActivatedEventArgs[] = {
        { "device_information", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IDevicePairingActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IDevicePairingActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDevicePairingActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDevicePairingActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDevicePairingActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IDevicePairingActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IDevicePairingActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IDevicePairingActivatedEventArgs};

    struct ImplementsIDevicePairingActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIDevicePairingActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>
    {
        ImplementsIDevicePairingActivatedEventArgs() = delete;
        ImplementsIDevicePairingActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIDevicePairingActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto DeviceInformation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "device_information")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIDevicePairingActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIDevicePairingActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IDevicePairingActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDevicePairingActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIDevicePairingActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIDevicePairingActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIDevicePairingActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIDevicePairingActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIDevicePairingActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IDevicePairingActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIDevicePairingActivatedEventArgs};

    // ----- IDialReceiverActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IDialReceiverActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IDialReceiverActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_AppName(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IDialReceiverActivatedEventArgs", L"AppName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDialReceiverActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IDialReceiverActivatedEventArgs[] = {
        { "app_name", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_AppName), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IDialReceiverActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IDialReceiverActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDialReceiverActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDialReceiverActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDialReceiverActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IDialReceiverActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IDialReceiverActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IDialReceiverActivatedEventArgs};

    struct ImplementsIDialReceiverActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIDialReceiverActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>
    {
        ImplementsIDialReceiverActivatedEventArgs() = delete;
        ImplementsIDialReceiverActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIDialReceiverActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto AppName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "app_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Arguments()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "arguments")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TileId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "tile_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIDialReceiverActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIDialReceiverActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IDialReceiverActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDialReceiverActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIDialReceiverActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIDialReceiverActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIDialReceiverActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIDialReceiverActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIDialReceiverActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IDialReceiverActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIDialReceiverActivatedEventArgs};

    // ----- IFileActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Files();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IFileActivatedEventArgs[] = {
        { "files", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IFileActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IFileActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileActivatedEventArgs};

    struct ImplementsIFileActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIFileActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>
    {
        ImplementsIFileActivatedEventArgs() = delete;
        ImplementsIFileActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Files()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "files")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IFileActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileActivatedEventArgs};

    // ----- IFileActivatedEventArgsWithCallerPackageFamilyName interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileActivatedEventArgsWithCallerPackageFamilyName(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileActivatedEventArgsWithCallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgsWithCallerPackageFamilyName", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { }};

    static PyGetSetDef _getset_IFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileActivatedEventArgsWithCallerPackageFamilyName) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileActivatedEventArgsWithCallerPackageFamilyName) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileActivatedEventArgsWithCallerPackageFamilyName) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileActivatedEventArgsWithCallerPackageFamilyName) },
        { }};

    static PyType_Spec type_spec_IFileActivatedEventArgsWithCallerPackageFamilyName = {
        "winrt._winrt_windows_applicationmodel_activation._IFileActivatedEventArgsWithCallerPackageFamilyName",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileActivatedEventArgsWithCallerPackageFamilyName};

    struct ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName : py::ImplementsInterfaceT<ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName, winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>
    {
        ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName() = delete;
        ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName, winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>(py_obj, runtime_class)
        {
        }

        auto CallerPackageFamilyName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "caller_package_family_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileActivatedEventArgsWithCallerPackageFamilyName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileActivatedEventArgsWithCallerPackageFamilyName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { "_assign_array_", _assign_array_IFileActivatedEventArgsWithCallerPackageFamilyName, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgsWithCallerPackageFamilyName), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName = {
        "winrt._winrt_windows_applicationmodel_activation.IFileActivatedEventArgsWithCallerPackageFamilyName",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName};

    // ----- IFileActivatedEventArgsWithNeighboringFiles interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileActivatedEventArgsWithNeighboringFiles(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileActivatedEventArgsWithNeighboringFiles(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_NeighboringFilesQuery(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgsWithNeighboringFiles", L"NeighboringFilesQuery");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NeighboringFilesQuery();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Files();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgsWithNeighboringFiles[] = {
        { }};

    static PyGetSetDef _getset_IFileActivatedEventArgsWithNeighboringFiles[] = {
        { "neighboring_files_query", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_NeighboringFilesQuery), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileActivatedEventArgsWithNeighboringFiles[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileActivatedEventArgsWithNeighboringFiles) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileActivatedEventArgsWithNeighboringFiles) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileActivatedEventArgsWithNeighboringFiles) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileActivatedEventArgsWithNeighboringFiles) },
        { }};

    static PyType_Spec type_spec_IFileActivatedEventArgsWithNeighboringFiles = {
        "winrt._winrt_windows_applicationmodel_activation._IFileActivatedEventArgsWithNeighboringFiles",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileActivatedEventArgsWithNeighboringFiles};

    struct ImplementsIFileActivatedEventArgsWithNeighboringFiles : py::ImplementsInterfaceT<ImplementsIFileActivatedEventArgsWithNeighboringFiles, winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>
    {
        ImplementsIFileActivatedEventArgsWithNeighboringFiles() = delete;
        ImplementsIFileActivatedEventArgsWithNeighboringFiles(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileActivatedEventArgsWithNeighboringFiles, winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>(py_obj, runtime_class)
        {
        }

        auto NeighboringFilesQuery()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "neighboring_files_query")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Search::StorageFileQueryResult>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Files()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "files")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Verb()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "verb")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileActivatedEventArgsWithNeighboringFiles(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileActivatedEventArgsWithNeighboringFiles(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileActivatedEventArgsWithNeighboringFiles(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileActivatedEventArgsWithNeighboringFiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileActivatedEventArgsWithNeighboringFiles>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileActivatedEventArgsWithNeighboringFiles[] = {
        { "_assign_array_", _assign_array_IFileActivatedEventArgsWithNeighboringFiles, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgsWithNeighboringFiles), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileActivatedEventArgsWithNeighboringFiles), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileActivatedEventArgsWithNeighboringFiles), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileActivatedEventArgsWithNeighboringFiles[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileActivatedEventArgsWithNeighboringFiles) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileActivatedEventArgsWithNeighboringFiles = {
        "winrt._winrt_windows_applicationmodel_activation.IFileActivatedEventArgsWithNeighboringFiles",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileActivatedEventArgsWithNeighboringFiles};

    // ----- IFileOpenPickerActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileOpenPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileOpenPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileOpenPickerActivatedEventArgs", L"FileOpenPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileOpenPickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IFileOpenPickerActivatedEventArgs[] = {
        { "file_open_picker_ui", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileOpenPickerActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileOpenPickerActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileOpenPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileOpenPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileOpenPickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IFileOpenPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IFileOpenPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileOpenPickerActivatedEventArgs};

    struct ImplementsIFileOpenPickerActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIFileOpenPickerActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>
    {
        ImplementsIFileOpenPickerActivatedEventArgs() = delete;
        ImplementsIFileOpenPickerActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileOpenPickerActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto FileOpenPickerUI()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "file_open_picker_ui")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Pickers::Provider::FileOpenPickerUI>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileOpenPickerActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileOpenPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IFileOpenPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileOpenPickerActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileOpenPickerActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileOpenPickerActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileOpenPickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileOpenPickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileOpenPickerActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileOpenPickerActivatedEventArgs};

    // ----- IFileOpenPickerActivatedEventArgs2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileOpenPickerActivatedEventArgs2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileOpenPickerActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerActivatedEventArgs2_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileOpenPickerActivatedEventArgs2", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerActivatedEventArgs2[] = {
        { }};

    static PyGetSetDef _getset_IFileOpenPickerActivatedEventArgs2[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs2_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileOpenPickerActivatedEventArgs2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileOpenPickerActivatedEventArgs2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileOpenPickerActivatedEventArgs2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileOpenPickerActivatedEventArgs2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileOpenPickerActivatedEventArgs2) },
        { }};

    static PyType_Spec type_spec_IFileOpenPickerActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation._IFileOpenPickerActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileOpenPickerActivatedEventArgs2};

    struct ImplementsIFileOpenPickerActivatedEventArgs2 : py::ImplementsInterfaceT<ImplementsIFileOpenPickerActivatedEventArgs2, winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>
    {
        ImplementsIFileOpenPickerActivatedEventArgs2() = delete;
        ImplementsIFileOpenPickerActivatedEventArgs2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileOpenPickerActivatedEventArgs2, winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>(py_obj, runtime_class)
        {
        }

        auto CallerPackageFamilyName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "caller_package_family_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileOpenPickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileOpenPickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileOpenPickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileOpenPickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileOpenPickerActivatedEventArgs2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileOpenPickerActivatedEventArgs2[] = {
        { "_assign_array_", _assign_array_IFileOpenPickerActivatedEventArgs2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileOpenPickerActivatedEventArgs2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileOpenPickerActivatedEventArgs2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileOpenPickerActivatedEventArgs2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileOpenPickerActivatedEventArgs2) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileOpenPickerActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation.IFileOpenPickerActivatedEventArgs2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileOpenPickerActivatedEventArgs2};

    // ----- IFileOpenPickerContinuationEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileOpenPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileOpenPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileOpenPickerContinuationEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Files();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerContinuationEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IFileOpenPickerContinuationEventArgs[] = {
        { "files", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileOpenPickerContinuationEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileOpenPickerContinuationEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileOpenPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileOpenPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileOpenPickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_IFileOpenPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IFileOpenPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileOpenPickerContinuationEventArgs};

    struct ImplementsIFileOpenPickerContinuationEventArgs : py::ImplementsInterfaceT<ImplementsIFileOpenPickerContinuationEventArgs, winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>
    {
        ImplementsIFileOpenPickerContinuationEventArgs() = delete;
        ImplementsIFileOpenPickerContinuationEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileOpenPickerContinuationEventArgs, winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>(py_obj, runtime_class)
        {
        }

        auto Files()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "files")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContinuationData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "continuation_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileOpenPickerContinuationEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileOpenPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_IFileOpenPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileOpenPickerContinuationEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileOpenPickerContinuationEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileOpenPickerContinuationEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileOpenPickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileOpenPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileOpenPickerContinuationEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileOpenPickerContinuationEventArgs};

    // ----- IFileSavePickerActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileSavePickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileSavePickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_FileSavePickerUI(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs", L"FileSavePickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileSavePickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IFileSavePickerActivatedEventArgs[] = {
        { "file_save_picker_ui", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_FileSavePickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileSavePickerActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileSavePickerActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileSavePickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileSavePickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileSavePickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IFileSavePickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IFileSavePickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileSavePickerActivatedEventArgs};

    struct ImplementsIFileSavePickerActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIFileSavePickerActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>
    {
        ImplementsIFileSavePickerActivatedEventArgs() = delete;
        ImplementsIFileSavePickerActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileSavePickerActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto FileSavePickerUI()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "file_save_picker_ui")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Pickers::Provider::FileSavePickerUI>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileSavePickerActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileSavePickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IFileSavePickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileSavePickerActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileSavePickerActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileSavePickerActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileSavePickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileSavePickerActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileSavePickerActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileSavePickerActivatedEventArgs};

    // ----- IFileSavePickerActivatedEventArgs2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileSavePickerActivatedEventArgs2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileSavePickerActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerActivatedEventArgs2_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs2", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs2_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs2", L"EnterpriseId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EnterpriseId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerActivatedEventArgs2[] = {
        { }};

    static PyGetSetDef _getset_IFileSavePickerActivatedEventArgs2[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs2_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs2_get_EnterpriseId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileSavePickerActivatedEventArgs2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileSavePickerActivatedEventArgs2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileSavePickerActivatedEventArgs2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileSavePickerActivatedEventArgs2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileSavePickerActivatedEventArgs2) },
        { }};

    static PyType_Spec type_spec_IFileSavePickerActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation._IFileSavePickerActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileSavePickerActivatedEventArgs2};

    struct ImplementsIFileSavePickerActivatedEventArgs2 : py::ImplementsInterfaceT<ImplementsIFileSavePickerActivatedEventArgs2, winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>
    {
        ImplementsIFileSavePickerActivatedEventArgs2() = delete;
        ImplementsIFileSavePickerActivatedEventArgs2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileSavePickerActivatedEventArgs2, winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>(py_obj, runtime_class)
        {
        }

        auto CallerPackageFamilyName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "caller_package_family_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto EnterpriseId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "enterprise_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileSavePickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileSavePickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileSavePickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileSavePickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileSavePickerActivatedEventArgs2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileSavePickerActivatedEventArgs2[] = {
        { "_assign_array_", _assign_array_IFileSavePickerActivatedEventArgs2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileSavePickerActivatedEventArgs2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileSavePickerActivatedEventArgs2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileSavePickerActivatedEventArgs2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileSavePickerActivatedEventArgs2) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileSavePickerActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation.IFileSavePickerActivatedEventArgs2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileSavePickerActivatedEventArgs2};

    // ----- IFileSavePickerContinuationEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFileSavePickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFileSavePickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_File(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFileSavePickerContinuationEventArgs", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.File();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerContinuationEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IFileSavePickerContinuationEventArgs[] = {
        { "file", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_File), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFileSavePickerContinuationEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileSavePickerContinuationEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileSavePickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileSavePickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileSavePickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_IFileSavePickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IFileSavePickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFileSavePickerContinuationEventArgs};

    struct ImplementsIFileSavePickerContinuationEventArgs : py::ImplementsInterfaceT<ImplementsIFileSavePickerContinuationEventArgs, winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>
    {
        ImplementsIFileSavePickerContinuationEventArgs() = delete;
        ImplementsIFileSavePickerContinuationEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileSavePickerContinuationEventArgs, winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>(py_obj, runtime_class)
        {
        }

        auto File()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "file")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::StorageFile>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContinuationData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "continuation_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileSavePickerContinuationEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileSavePickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_IFileSavePickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileSavePickerContinuationEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileSavePickerContinuationEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFileSavePickerContinuationEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileSavePickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIFileSavePickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFileSavePickerContinuationEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFileSavePickerContinuationEventArgs};

    // ----- IFolderPickerContinuationEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IFolderPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IFolderPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_Folder(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IFolderPickerContinuationEventArgs", L"Folder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Folder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFolderPickerContinuationEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IFolderPickerContinuationEventArgs[] = {
        { "folder", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_Folder), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IFolderPickerContinuationEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IFolderPickerContinuationEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFolderPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFolderPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFolderPickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_IFolderPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IFolderPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IFolderPickerContinuationEventArgs};

    struct ImplementsIFolderPickerContinuationEventArgs : py::ImplementsInterfaceT<ImplementsIFolderPickerContinuationEventArgs, winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>
    {
        ImplementsIFolderPickerContinuationEventArgs() = delete;
        ImplementsIFolderPickerContinuationEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFolderPickerContinuationEventArgs, winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>(py_obj, runtime_class)
        {
        }

        auto Folder()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "folder")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::StorageFolder>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContinuationData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "continuation_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFolderPickerContinuationEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFolderPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_IFolderPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFolderPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFolderPickerContinuationEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFolderPickerContinuationEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIFolderPickerContinuationEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFolderPickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIFolderPickerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IFolderPickerContinuationEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIFolderPickerContinuationEventArgs};

    // ----- ILaunchActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ILaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ILaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILaunchActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILaunchActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_ILaunchActivatedEventArgs[] = {
        { "arguments", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ILaunchActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ILaunchActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ILaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._ILaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ILaunchActivatedEventArgs};

    struct ImplementsILaunchActivatedEventArgs : py::ImplementsInterfaceT<ImplementsILaunchActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>
    {
        ImplementsILaunchActivatedEventArgs() = delete;
        ImplementsILaunchActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsILaunchActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Arguments()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "arguments")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TileId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "tile_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsILaunchActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsILaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ILaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsILaunchActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsILaunchActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsILaunchActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsILaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsILaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ILaunchActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsILaunchActivatedEventArgs};

    // ----- ILaunchActivatedEventArgs2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ILaunchActivatedEventArgs2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ILaunchActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILaunchActivatedEventArgs2_get_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs2", L"TileActivatedInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileActivatedInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILaunchActivatedEventArgs2[] = {
        { }};

    static PyGetSetDef _getset_ILaunchActivatedEventArgs2[] = {
        { "tile_activated_info", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_TileActivatedInfo), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ILaunchActivatedEventArgs2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ILaunchActivatedEventArgs2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILaunchActivatedEventArgs2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILaunchActivatedEventArgs2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILaunchActivatedEventArgs2) },
        { }};

    static PyType_Spec type_spec_ILaunchActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation._ILaunchActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ILaunchActivatedEventArgs2};

    struct ImplementsILaunchActivatedEventArgs2 : py::ImplementsInterfaceT<ImplementsILaunchActivatedEventArgs2, winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>
    {
        ImplementsILaunchActivatedEventArgs2() = delete;
        ImplementsILaunchActivatedEventArgs2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsILaunchActivatedEventArgs2, winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>(py_obj, runtime_class)
        {
        }

        auto TileActivatedInfo()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "tile_activated_info")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Arguments()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "arguments")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TileId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "tile_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ILaunchActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILaunchActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsILaunchActivatedEventArgs2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsILaunchActivatedEventArgs2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsILaunchActivatedEventArgs2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsILaunchActivatedEventArgs2[] = {
        { "_assign_array_", _assign_array_ILaunchActivatedEventArgs2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILaunchActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsILaunchActivatedEventArgs2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsILaunchActivatedEventArgs2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsILaunchActivatedEventArgs2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsILaunchActivatedEventArgs2) },
        { }};

    static PyType_Spec type_spec_ImplementsILaunchActivatedEventArgs2 = {
        "winrt._winrt_windows_applicationmodel_activation.ILaunchActivatedEventArgs2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsILaunchActivatedEventArgs2};

    // ----- ILockScreenActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ILockScreenActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ILockScreenActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILockScreenActivatedEventArgs_get_Info(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILockScreenActivatedEventArgs", L"Info");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Info();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILockScreenActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_ILockScreenActivatedEventArgs[] = {
        { "info", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_Info), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ILockScreenActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ILockScreenActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILockScreenActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILockScreenActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILockScreenActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ILockScreenActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._ILockScreenActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ILockScreenActivatedEventArgs};

    struct ImplementsILockScreenActivatedEventArgs : py::ImplementsInterfaceT<ImplementsILockScreenActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>
    {
        ImplementsILockScreenActivatedEventArgs() = delete;
        ImplementsILockScreenActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsILockScreenActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Info()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "info")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsILockScreenActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsILockScreenActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ILockScreenActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILockScreenActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsILockScreenActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsILockScreenActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsILockScreenActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsILockScreenActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsILockScreenActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ILockScreenActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsILockScreenActivatedEventArgs};

    // ----- ILockScreenCallActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ILockScreenCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ILockScreenCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_CallUI(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILockScreenCallActivatedEventArgs", L"CallUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILockScreenCallActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_ILockScreenCallActivatedEventArgs[] = {
        { "call_ui", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_CallUI), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ILockScreenCallActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ILockScreenCallActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILockScreenCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILockScreenCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILockScreenCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ILockScreenCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._ILockScreenCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ILockScreenCallActivatedEventArgs};

    struct ImplementsILockScreenCallActivatedEventArgs : py::ImplementsInterfaceT<ImplementsILockScreenCallActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>
    {
        ImplementsILockScreenCallActivatedEventArgs() = delete;
        ImplementsILockScreenCallActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsILockScreenCallActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto CallUI()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "call_ui")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Arguments()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "arguments")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TileId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "tile_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsILockScreenCallActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsILockScreenCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ILockScreenCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILockScreenCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsILockScreenCallActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsILockScreenCallActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsILockScreenCallActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsILockScreenCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsILockScreenCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ILockScreenCallActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsILockScreenCallActivatedEventArgs};

    // ----- IPhoneCallActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IPhoneCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IPhoneCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPhoneCallActivatedEventArgs", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPhoneCallActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IPhoneCallActivatedEventArgs[] = {
        { "line_id", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPhoneCallActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IPhoneCallActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPhoneCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPhoneCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPhoneCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IPhoneCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IPhoneCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IPhoneCallActivatedEventArgs};

    struct ImplementsIPhoneCallActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIPhoneCallActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>
    {
        ImplementsIPhoneCallActivatedEventArgs() = delete;
        ImplementsIPhoneCallActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPhoneCallActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto LineId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "line_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPhoneCallActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPhoneCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPhoneCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPhoneCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPhoneCallActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPhoneCallActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPhoneCallActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPhoneCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIPhoneCallActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPhoneCallActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIPhoneCallActivatedEventArgs};

    // ----- IPickerReturnedActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IPickerReturnedActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IPickerReturnedActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_PickerOperationId(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPickerReturnedActivatedEventArgs", L"PickerOperationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PickerOperationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPickerReturnedActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IPickerReturnedActivatedEventArgs[] = {
        { "picker_operation_id", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_PickerOperationId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPickerReturnedActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IPickerReturnedActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPickerReturnedActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPickerReturnedActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPickerReturnedActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IPickerReturnedActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IPickerReturnedActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IPickerReturnedActivatedEventArgs};

    struct ImplementsIPickerReturnedActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIPickerReturnedActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>
    {
        ImplementsIPickerReturnedActivatedEventArgs() = delete;
        ImplementsIPickerReturnedActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPickerReturnedActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto PickerOperationId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "picker_operation_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPickerReturnedActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPickerReturnedActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPickerReturnedActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPickerReturnedActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPickerReturnedActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPickerReturnedActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPickerReturnedActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPickerReturnedActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIPickerReturnedActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPickerReturnedActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIPickerReturnedActivatedEventArgs};

    // ----- IPrelaunchActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IPrelaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IPrelaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_PrelaunchActivated(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPrelaunchActivatedEventArgs", L"PrelaunchActivated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrelaunchActivated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrelaunchActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IPrelaunchActivatedEventArgs[] = {
        { "prelaunch_activated", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_PrelaunchActivated), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPrelaunchActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrelaunchActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrelaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrelaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrelaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IPrelaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IPrelaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IPrelaunchActivatedEventArgs};

    struct ImplementsIPrelaunchActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIPrelaunchActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>
    {
        ImplementsIPrelaunchActivatedEventArgs() = delete;
        ImplementsIPrelaunchActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPrelaunchActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto PrelaunchActivated()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "prelaunch_activated")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPrelaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrelaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPrelaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPrelaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPrelaunchActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPrelaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPrelaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrelaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPrelaunchActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPrelaunchActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPrelaunchActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPrelaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIPrelaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPrelaunchActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIPrelaunchActivatedEventArgs};

    // ----- IPrint3DWorkflowActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IPrint3DWorkflowActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IPrint3DWorkflowActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_Workflow(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPrint3DWorkflowActivatedEventArgs", L"Workflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Workflow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrint3DWorkflowActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IPrint3DWorkflowActivatedEventArgs[] = {
        { "workflow", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_Workflow), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPrint3DWorkflowActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrint3DWorkflowActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrint3DWorkflowActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IPrint3DWorkflowActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IPrint3DWorkflowActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IPrint3DWorkflowActivatedEventArgs};

    struct ImplementsIPrint3DWorkflowActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIPrint3DWorkflowActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>
    {
        ImplementsIPrint3DWorkflowActivatedEventArgs() = delete;
        ImplementsIPrint3DWorkflowActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPrint3DWorkflowActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Workflow()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "workflow")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Printers::Extensions::Print3DWorkflow>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPrint3DWorkflowActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPrint3DWorkflowActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPrint3DWorkflowActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrint3DWorkflowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPrint3DWorkflowActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPrint3DWorkflowActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPrint3DWorkflowActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPrint3DWorkflowActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIPrint3DWorkflowActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPrint3DWorkflowActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIPrint3DWorkflowActivatedEventArgs};

    // ----- IPrintTaskSettingsActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IPrintTaskSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IPrintTaskSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_Configuration(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IPrintTaskSettingsActivatedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrintTaskSettingsActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IPrintTaskSettingsActivatedEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPrintTaskSettingsActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IPrintTaskSettingsActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPrintTaskSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IPrintTaskSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IPrintTaskSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IPrintTaskSettingsActivatedEventArgs};

    struct ImplementsIPrintTaskSettingsActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIPrintTaskSettingsActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>
    {
        ImplementsIPrintTaskSettingsActivatedEventArgs() = delete;
        ImplementsIPrintTaskSettingsActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPrintTaskSettingsActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Configuration()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "configuration")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Printers::Extensions::PrintTaskConfiguration>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPrintTaskSettingsActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPrintTaskSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IPrintTaskSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrintTaskSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPrintTaskSettingsActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPrintTaskSettingsActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPrintTaskSettingsActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPrintTaskSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIPrintTaskSettingsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IPrintTaskSettingsActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIPrintTaskSettingsActivatedEventArgs};

    // ----- IProtocolActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IProtocolActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IProtocolActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IProtocolActivatedEventArgs", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IProtocolActivatedEventArgs[] = {
        { "uri", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IProtocolActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IProtocolActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IProtocolActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IProtocolActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IProtocolActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IProtocolActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IProtocolActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IProtocolActivatedEventArgs};

    struct ImplementsIProtocolActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIProtocolActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>
    {
        ImplementsIProtocolActivatedEventArgs() = delete;
        ImplementsIProtocolActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIProtocolActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Uri()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "uri")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Uri>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIProtocolActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIProtocolActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IProtocolActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIProtocolActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIProtocolActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIProtocolActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIProtocolActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIProtocolActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IProtocolActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIProtocolActivatedEventArgs};

    // ----- IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Data(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { }};

    static PyGetSetDef _getset_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Data), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        { }};

    static PyType_Spec type_spec_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData = {
        "winrt._winrt_windows_applicationmodel_activation._IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData};

    struct ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData : py::ImplementsInterfaceT<ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>
    {
        ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData() = delete;
        ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>(py_obj, runtime_class)
        {
        }

        auto CallerPackageFamilyName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "caller_package_family_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Data()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { "_assign_array_", _assign_array_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData) },
        { }};

    static PyType_Spec type_spec_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData = {
        "winrt._winrt_windows_applicationmodel_activation.IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData};

    // ----- IProtocolForResultsActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IProtocolForResultsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IProtocolForResultsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IProtocolForResultsActivatedEventArgs", L"ProtocolForResultsOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtocolForResultsOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolForResultsActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IProtocolForResultsActivatedEventArgs[] = {
        { "protocol_for_results_operation", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IProtocolForResultsActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IProtocolForResultsActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IProtocolForResultsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IProtocolForResultsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IProtocolForResultsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IProtocolForResultsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IProtocolForResultsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IProtocolForResultsActivatedEventArgs};

    struct ImplementsIProtocolForResultsActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIProtocolForResultsActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>
    {
        ImplementsIProtocolForResultsActivatedEventArgs() = delete;
        ImplementsIProtocolForResultsActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIProtocolForResultsActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ProtocolForResultsOperation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "protocol_for_results_operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::System::ProtocolForResultsOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIProtocolForResultsActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIProtocolForResultsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IProtocolForResultsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolForResultsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIProtocolForResultsActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIProtocolForResultsActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIProtocolForResultsActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIProtocolForResultsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIProtocolForResultsActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IProtocolForResultsActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIProtocolForResultsActivatedEventArgs};

    // ----- IRestrictedLaunchActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IRestrictedLaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IRestrictedLaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_SharedContext(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IRestrictedLaunchActivatedEventArgs", L"SharedContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SharedContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRestrictedLaunchActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IRestrictedLaunchActivatedEventArgs[] = {
        { "shared_context", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IRestrictedLaunchActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IRestrictedLaunchActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRestrictedLaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRestrictedLaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRestrictedLaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IRestrictedLaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IRestrictedLaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IRestrictedLaunchActivatedEventArgs};

    struct ImplementsIRestrictedLaunchActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIRestrictedLaunchActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>
    {
        ImplementsIRestrictedLaunchActivatedEventArgs() = delete;
        ImplementsIRestrictedLaunchActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIRestrictedLaunchActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto SharedContext()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "shared_context")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIRestrictedLaunchActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIRestrictedLaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IRestrictedLaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRestrictedLaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIRestrictedLaunchActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIRestrictedLaunchActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIRestrictedLaunchActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIRestrictedLaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIRestrictedLaunchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IRestrictedLaunchActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIRestrictedLaunchActivatedEventArgs};

    // ----- ISearchActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ISearchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ISearchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchActivatedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ISearchActivatedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ISearchActivatedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_ISearchActivatedEventArgs[] = {
        { "language", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISearchActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ISearchActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISearchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISearchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISearchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ISearchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._ISearchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ISearchActivatedEventArgs};

    struct ImplementsISearchActivatedEventArgs : py::ImplementsInterfaceT<ImplementsISearchActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>
    {
        ImplementsISearchActivatedEventArgs() = delete;
        ImplementsISearchActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISearchActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Language()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "language")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto QueryText()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "query_text")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISearchActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISearchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ISearchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISearchActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISearchActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISearchActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISearchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsISearchActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.ISearchActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsISearchActivatedEventArgs};

    // ----- ISearchActivatedEventArgsWithLinguisticDetails interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ISearchActivatedEventArgsWithLinguisticDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ISearchActivatedEventArgsWithLinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchActivatedEventArgsWithLinguisticDetails_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.ISearchActivatedEventArgsWithLinguisticDetails", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinguisticDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchActivatedEventArgsWithLinguisticDetails[] = {
        { }};

    static PyGetSetDef _getset_ISearchActivatedEventArgsWithLinguisticDetails[] = {
        { "linguistic_details", reinterpret_cast<getter>(ISearchActivatedEventArgsWithLinguisticDetails_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISearchActivatedEventArgsWithLinguisticDetails[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ISearchActivatedEventArgsWithLinguisticDetails) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISearchActivatedEventArgsWithLinguisticDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISearchActivatedEventArgsWithLinguisticDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISearchActivatedEventArgsWithLinguisticDetails) },
        { }};

    static PyType_Spec type_spec_ISearchActivatedEventArgsWithLinguisticDetails = {
        "winrt._winrt_windows_applicationmodel_activation._ISearchActivatedEventArgsWithLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ISearchActivatedEventArgsWithLinguisticDetails};

    struct ImplementsISearchActivatedEventArgsWithLinguisticDetails : py::ImplementsInterfaceT<ImplementsISearchActivatedEventArgsWithLinguisticDetails, winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>
    {
        ImplementsISearchActivatedEventArgsWithLinguisticDetails() = delete;
        ImplementsISearchActivatedEventArgsWithLinguisticDetails(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISearchActivatedEventArgsWithLinguisticDetails, winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>(py_obj, runtime_class)
        {
        }

        auto LinguisticDetails()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "linguistic_details")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISearchActivatedEventArgsWithLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISearchActivatedEventArgsWithLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISearchActivatedEventArgsWithLinguisticDetails(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISearchActivatedEventArgsWithLinguisticDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISearchActivatedEventArgsWithLinguisticDetails>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISearchActivatedEventArgsWithLinguisticDetails[] = {
        { "_assign_array_", _assign_array_ISearchActivatedEventArgsWithLinguisticDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchActivatedEventArgsWithLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISearchActivatedEventArgsWithLinguisticDetails), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISearchActivatedEventArgsWithLinguisticDetails), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISearchActivatedEventArgsWithLinguisticDetails[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISearchActivatedEventArgsWithLinguisticDetails) },
        { }};

    static PyType_Spec type_spec_ImplementsISearchActivatedEventArgsWithLinguisticDetails = {
        "winrt._winrt_windows_applicationmodel_activation.ISearchActivatedEventArgsWithLinguisticDetails",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsISearchActivatedEventArgsWithLinguisticDetails};

    // ----- IShareTargetActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IShareTargetActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IShareTargetActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IShareTargetActivatedEventArgs_get_ShareOperation(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IShareTargetActivatedEventArgs", L"ShareOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShareOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IShareTargetActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IShareTargetActivatedEventArgs[] = {
        { "share_operation", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_ShareOperation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IShareTargetActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IShareTargetActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IShareTargetActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IShareTargetActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IShareTargetActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IShareTargetActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IShareTargetActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IShareTargetActivatedEventArgs};

    struct ImplementsIShareTargetActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIShareTargetActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>
    {
        ImplementsIShareTargetActivatedEventArgs() = delete;
        ImplementsIShareTargetActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIShareTargetActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ShareOperation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "share_operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ShareTarget::ShareOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIShareTargetActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIShareTargetActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IShareTargetActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IShareTargetActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIShareTargetActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIShareTargetActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIShareTargetActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIShareTargetActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIShareTargetActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IShareTargetActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIShareTargetActivatedEventArgs};

    // ----- IStartupTaskActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IStartupTaskActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IStartupTaskActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_TaskId(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IStartupTaskActivatedEventArgs", L"TaskId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TaskId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStartupTaskActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IStartupTaskActivatedEventArgs[] = {
        { "task_id", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_TaskId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStartupTaskActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IStartupTaskActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStartupTaskActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStartupTaskActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStartupTaskActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IStartupTaskActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IStartupTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IStartupTaskActivatedEventArgs};

    struct ImplementsIStartupTaskActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIStartupTaskActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>
    {
        ImplementsIStartupTaskActivatedEventArgs() = delete;
        ImplementsIStartupTaskActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStartupTaskActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto TaskId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "task_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStartupTaskActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStartupTaskActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IStartupTaskActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStartupTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStartupTaskActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStartupTaskActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStartupTaskActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStartupTaskActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIStartupTaskActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IStartupTaskActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIStartupTaskActivatedEventArgs};

    // ----- IToastNotificationActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IToastNotificationActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IToastNotificationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_Argument(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IToastNotificationActivatedEventArgs", L"Argument");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Argument();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_UserInput(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IToastNotificationActivatedEventArgs", L"UserInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IToastNotificationActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IToastNotificationActivatedEventArgs[] = {
        { "argument", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IToastNotificationActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IToastNotificationActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IToastNotificationActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IToastNotificationActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IToastNotificationActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IToastNotificationActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IToastNotificationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IToastNotificationActivatedEventArgs};

    struct ImplementsIToastNotificationActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIToastNotificationActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>
    {
        ImplementsIToastNotificationActivatedEventArgs() = delete;
        ImplementsIToastNotificationActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIToastNotificationActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Argument()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "argument")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto UserInput()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "user_input")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIToastNotificationActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIToastNotificationActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IToastNotificationActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IToastNotificationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIToastNotificationActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIToastNotificationActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIToastNotificationActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIToastNotificationActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIToastNotificationActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IToastNotificationActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIToastNotificationActivatedEventArgs};

    // ----- IUserDataAccountProviderActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IUserDataAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IUserDataAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IUserDataAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IUserDataAccountProviderActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IUserDataAccountProviderActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IUserDataAccountProviderActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IUserDataAccountProviderActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IUserDataAccountProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IUserDataAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IUserDataAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IUserDataAccountProviderActivatedEventArgs};

    struct ImplementsIUserDataAccountProviderActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIUserDataAccountProviderActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>
    {
        ImplementsIUserDataAccountProviderActivatedEventArgs() = delete;
        ImplementsIUserDataAccountProviderActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIUserDataAccountProviderActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Operation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::Provider::IUserDataAccountProviderOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIUserDataAccountProviderActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIUserDataAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IUserDataAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IUserDataAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIUserDataAccountProviderActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIUserDataAccountProviderActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIUserDataAccountProviderActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIUserDataAccountProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIUserDataAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IUserDataAccountProviderActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIUserDataAccountProviderActivatedEventArgs};

    // ----- IViewSwitcherProvider interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IViewSwitcherProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IViewSwitcherProvider(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IViewSwitcherProvider_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IViewSwitcherProvider", L"ViewSwitcher");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewSwitcher();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IViewSwitcherProvider[] = {
        { }};

    static PyGetSetDef _getset_IViewSwitcherProvider[] = {
        { "view_switcher", reinterpret_cast<getter>(IViewSwitcherProvider_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IViewSwitcherProvider_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IViewSwitcherProvider_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IViewSwitcherProvider_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IViewSwitcherProvider[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IViewSwitcherProvider) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IViewSwitcherProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IViewSwitcherProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IViewSwitcherProvider) },
        { }};

    static PyType_Spec type_spec_IViewSwitcherProvider = {
        "winrt._winrt_windows_applicationmodel_activation._IViewSwitcherProvider",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IViewSwitcherProvider};

    struct ImplementsIViewSwitcherProvider : py::ImplementsInterfaceT<ImplementsIViewSwitcherProvider, winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>
    {
        ImplementsIViewSwitcherProvider() = delete;
        ImplementsIViewSwitcherProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIViewSwitcherProvider, winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>(py_obj, runtime_class)
        {
        }

        auto ViewSwitcher()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "view_switcher")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::ViewManagement::ActivationViewSwitcher>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IViewSwitcherProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IViewSwitcherProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIViewSwitcherProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIViewSwitcherProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIViewSwitcherProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIViewSwitcherProvider[] = {
        { "_assign_array_", _assign_array_IViewSwitcherProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IViewSwitcherProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIViewSwitcherProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIViewSwitcherProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIViewSwitcherProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIViewSwitcherProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIViewSwitcherProvider = {
        "winrt._winrt_windows_applicationmodel_activation.IViewSwitcherProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIViewSwitcherProvider};

    // ----- IVoiceCommandActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IVoiceCommandActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IVoiceCommandActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_Result(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IVoiceCommandActivatedEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVoiceCommandActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IVoiceCommandActivatedEventArgs[] = {
        { "result", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IVoiceCommandActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IVoiceCommandActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVoiceCommandActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVoiceCommandActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVoiceCommandActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IVoiceCommandActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IVoiceCommandActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IVoiceCommandActivatedEventArgs};

    struct ImplementsIVoiceCommandActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIVoiceCommandActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>
    {
        ImplementsIVoiceCommandActivatedEventArgs() = delete;
        ImplementsIVoiceCommandActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVoiceCommandActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Result()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "result")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVoiceCommandActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVoiceCommandActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IVoiceCommandActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVoiceCommandActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVoiceCommandActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVoiceCommandActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIVoiceCommandActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVoiceCommandActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIVoiceCommandActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IVoiceCommandActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIVoiceCommandActivatedEventArgs};

    // ----- IWalletActionActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWalletActionActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWalletActionActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ActionId(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWalletActionActivatedEventArgs", L"ActionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ActionKind(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWalletActionActivatedEventArgs", L"ActionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ItemId(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWalletActionActivatedEventArgs", L"ItemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWalletActionActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IWalletActionActivatedEventArgs[] = {
        { "action_id", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ActionId), nullptr, nullptr, nullptr },
        { "action_kind", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ActionKind), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ItemId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IWalletActionActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWalletActionActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWalletActionActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWalletActionActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWalletActionActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IWalletActionActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IWalletActionActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWalletActionActivatedEventArgs};

    struct ImplementsIWalletActionActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIWalletActionActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>
    {
        ImplementsIWalletActionActivatedEventArgs() = delete;
        ImplementsIWalletActionActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWalletActionActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto ActionId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "action_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ActionKind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "action_kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletActionKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ItemId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "item_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWalletActionActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWalletActionActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IWalletActionActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWalletActionActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWalletActionActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWalletActionActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWalletActionActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWalletActionActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIWalletActionActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IWalletActionActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWalletActionActivatedEventArgs};

    // ----- IWebAccountProviderActivatedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWebAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWebAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWebAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebAccountProviderActivatedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IWebAccountProviderActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IWebAccountProviderActivatedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebAccountProviderActivatedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebAccountProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IWebAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IWebAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWebAccountProviderActivatedEventArgs};

    struct ImplementsIWebAccountProviderActivatedEventArgs : py::ImplementsInterfaceT<ImplementsIWebAccountProviderActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>
    {
        ImplementsIWebAccountProviderActivatedEventArgs() = delete;
        ImplementsIWebAccountProviderActivatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWebAccountProviderActivatedEventArgs, winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Operation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Security::Authentication::Web::Provider::IWebAccountProviderOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWebAccountProviderActivatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWebAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_IWebAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWebAccountProviderActivatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWebAccountProviderActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWebAccountProviderActivatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWebAccountProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIWebAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IWebAccountProviderActivatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWebAccountProviderActivatedEventArgs};

    // ----- IWebAuthenticationBrokerContinuationEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWebAuthenticationBrokerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWebAuthenticationBrokerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IWebAuthenticationBrokerContinuationEventArgs", L"WebAuthenticationResult");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WebAuthenticationResult();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IContinuationActivatedEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Activation.IActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebAuthenticationBrokerContinuationEventArgs[] = {
        { }};

    static PyGetSetDef _getset_IWebAuthenticationBrokerContinuationEventArgs[] = {
        { "web_authentication_result", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IWebAuthenticationBrokerContinuationEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebAuthenticationBrokerContinuationEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebAuthenticationBrokerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_IWebAuthenticationBrokerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation._IWebAuthenticationBrokerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWebAuthenticationBrokerContinuationEventArgs};

    struct ImplementsIWebAuthenticationBrokerContinuationEventArgs : py::ImplementsInterfaceT<ImplementsIWebAuthenticationBrokerContinuationEventArgs, winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>
    {
        ImplementsIWebAuthenticationBrokerContinuationEventArgs() = delete;
        ImplementsIWebAuthenticationBrokerContinuationEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWebAuthenticationBrokerContinuationEventArgs, winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>(py_obj, runtime_class)
        {
        }

        auto WebAuthenticationResult()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "web_authentication_result")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Security::Authentication::Web::WebAuthenticationResult>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContinuationData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "continuation_data")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ActivationKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PreviousExecutionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "previous_execution_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SplashScreen()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "splash_screen")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Activation::SplashScreen>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWebAuthenticationBrokerContinuationEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWebAuthenticationBrokerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_IWebAuthenticationBrokerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebAuthenticationBrokerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWebAuthenticationBrokerContinuationEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWebAuthenticationBrokerContinuationEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWebAuthenticationBrokerContinuationEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWebAuthenticationBrokerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIWebAuthenticationBrokerContinuationEventArgs = {
        "winrt._winrt_windows_applicationmodel_activation.IWebAuthenticationBrokerContinuationEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWebAuthenticationBrokerContinuationEventArgs};

    // ----- Windows.ApplicationModel.Activation Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Activation");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_activation",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Activation

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_activation(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderAddAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderAddAppointmentActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AppointmentsProviderAddAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderRemoveAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderRemoveAppointmentActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AppointmentsProviderRemoveAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderReplaceAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderReplaceAppointmentActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AppointmentsProviderReplaceAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AppointmentsProviderShowTimeFrameActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_AppointmentsProviderShowTimeFrameActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AppointmentsProviderShowTimeFrameActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_BackgroundActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!BackgroundActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle BarcodeScannerPreviewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_BarcodeScannerPreviewActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!BarcodeScannerPreviewActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CachedFileUpdaterActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_CachedFileUpdaterActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CachedFileUpdaterActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CameraSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_CameraSettingsActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CameraSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CommandLineActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_CommandLineActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CommandLineActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CommandLineActivationOperation_type{py::register_python_type(module.get(), &type_spec_CommandLineActivationOperation, object_bases.get(), inspectable_meta_type)};
    if (!CommandLineActivationOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactCallActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ContactCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactMapActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactMapActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ContactMapActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactMessageActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactMessageActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ContactMessageActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactPanelActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactPanelActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ContactPanelActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactPickerActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ContactPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactPostActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactPostActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ContactPostActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactVideoCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContactVideoCallActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ContactVideoCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DeviceActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_DeviceActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!DeviceActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DevicePairingActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_DevicePairingActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!DevicePairingActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DialReceiverActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_DialReceiverActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!DialReceiverActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_FileActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FileActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileOpenPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_FileOpenPickerActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FileOpenPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileOpenPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_FileOpenPickerContinuationEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FileOpenPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileSavePickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_FileSavePickerActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FileSavePickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FileSavePickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_FileSavePickerContinuationEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FileSavePickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FolderPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_FolderPickerContinuationEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FolderPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_LaunchActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!LaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LockScreenActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_LockScreenActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!LockScreenActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LockScreenCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_LockScreenCallActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!LockScreenCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LockScreenComponentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_LockScreenComponentActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!LockScreenComponentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PhoneCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PhoneCallActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PhoneCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PickerReturnedActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PickerReturnedActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PickerReturnedActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle Print3DWorkflowActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_Print3DWorkflowActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!Print3DWorkflowActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintTaskSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintTaskSettingsActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PrintTaskSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ProtocolActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ProtocolActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ProtocolActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ProtocolForResultsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ProtocolForResultsActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ProtocolForResultsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RestrictedLaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_RestrictedLaunchActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RestrictedLaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_SearchActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SearchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ShareTargetActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ShareTargetActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ShareTargetActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SplashScreen_type{py::register_python_type(module.get(), &type_spec_SplashScreen, object_bases.get(), inspectable_meta_type)};
    if (!SplashScreen_type)
    {
        return nullptr;
    }

    py::pytype_handle StartupTaskActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_StartupTaskActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!StartupTaskActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TileActivatedInfo_type{py::register_python_type(module.get(), &type_spec_TileActivatedInfo, object_bases.get(), inspectable_meta_type)};
    if (!TileActivatedInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotificationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ToastNotificationActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ToastNotificationActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle UserDataAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_UserDataAccountProviderActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!UserDataAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle VoiceCommandActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_VoiceCommandActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!VoiceCommandActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WalletActionActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WalletActionActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WalletActionActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebAccountProviderActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WebAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebAuthenticationBrokerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_WebAuthenticationBrokerContinuationEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WebAuthenticationBrokerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IActivatedEventArgsWithUser_type{py::register_python_type(module.get(), &type_spec_IActivatedEventArgsWithUser, object_bases.get(), nullptr)};
    if (!IActivatedEventArgsWithUser_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIActivatedEventArgsWithUser_type{py::register_python_type(module.get(), &type_spec_ImplementsIActivatedEventArgsWithUser, nullptr, inspectable_meta_type)};
    if (!ImplementsIActivatedEventArgsWithUser_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIActivatedEventArgsWithUser_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IApplicationViewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IApplicationViewActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IApplicationViewActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIApplicationViewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIApplicationViewActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIApplicationViewActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIApplicationViewActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAppointmentsProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIAppointmentsProviderActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIAppointmentsProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAppointmentsProviderActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderAddAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderAddAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderAddAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAppointmentsProviderAddAppointmentActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderRemoveAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderRemoveAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderRemoveAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAppointmentsProviderRemoveAppointmentActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderReplaceAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderReplaceAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderReplaceAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAppointmentsProviderReplaceAppointmentActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IAppointmentsProviderShowTimeFrameActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IAppointmentsProviderShowTimeFrameActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IAppointmentsProviderShowTimeFrameActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAppointmentsProviderShowTimeFrameActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IBackgroundActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IBackgroundActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IBackgroundActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIBackgroundActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIBackgroundActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIBackgroundActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIBackgroundActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IBarcodeScannerPreviewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IBarcodeScannerPreviewActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IBarcodeScannerPreviewActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIBarcodeScannerPreviewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIBarcodeScannerPreviewActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIBarcodeScannerPreviewActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIBarcodeScannerPreviewActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ICachedFileUpdaterActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ICachedFileUpdaterActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ICachedFileUpdaterActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICachedFileUpdaterActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsICachedFileUpdaterActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsICachedFileUpdaterActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICachedFileUpdaterActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ICameraSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ICameraSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ICameraSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICameraSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsICameraSettingsActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsICameraSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICameraSettingsActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ICommandLineActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ICommandLineActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ICommandLineActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICommandLineActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsICommandLineActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsICommandLineActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICommandLineActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactCallActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactCallActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactMapActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactMapActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactMapActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactMapActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactMapActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactMapActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactMapActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactMessageActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactMessageActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactMessageActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactMessageActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactMessageActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactMessageActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactMessageActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactPanelActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactPanelActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactPanelActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactPanelActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactPanelActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactPanelActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactPanelActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactPickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactPickerActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactPickerActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactPostActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactPostActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactPostActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactPostActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactPostActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactPostActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactPostActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactVideoCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactVideoCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactVideoCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactVideoCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactVideoCallActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactVideoCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactVideoCallActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContactsProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContactsProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContactsProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContactsProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContactsProviderActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContactsProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContactsProviderActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IContinuationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IContinuationActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IContinuationActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContinuationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIContinuationActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIContinuationActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContinuationActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IDeviceActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IDeviceActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IDeviceActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIDeviceActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIDeviceActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIDeviceActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIDeviceActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IDevicePairingActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IDevicePairingActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IDevicePairingActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIDevicePairingActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIDevicePairingActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIDevicePairingActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIDevicePairingActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IDialReceiverActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IDialReceiverActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IDialReceiverActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIDialReceiverActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIDialReceiverActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIDialReceiverActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIDialReceiverActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IFileActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileActivatedEventArgsWithCallerPackageFamilyName_type{py::register_python_type(module.get(), &type_spec_IFileActivatedEventArgsWithCallerPackageFamilyName, object_bases.get(), nullptr)};
    if (!IFileActivatedEventArgsWithCallerPackageFamilyName_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileActivatedEventArgsWithCallerPackageFamilyName_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileActivatedEventArgsWithNeighboringFiles_type{py::register_python_type(module.get(), &type_spec_IFileActivatedEventArgsWithNeighboringFiles, object_bases.get(), nullptr)};
    if (!IFileActivatedEventArgsWithNeighboringFiles_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileActivatedEventArgsWithNeighboringFiles_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileActivatedEventArgsWithNeighboringFiles, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileActivatedEventArgsWithNeighboringFiles_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileActivatedEventArgsWithNeighboringFiles_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileOpenPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileOpenPickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IFileOpenPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileOpenPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileOpenPickerActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileOpenPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileOpenPickerActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileOpenPickerActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_IFileOpenPickerActivatedEventArgs2, object_bases.get(), nullptr)};
    if (!IFileOpenPickerActivatedEventArgs2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileOpenPickerActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileOpenPickerActivatedEventArgs2, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileOpenPickerActivatedEventArgs2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileOpenPickerActivatedEventArgs2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileOpenPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileOpenPickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!IFileOpenPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileOpenPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileOpenPickerContinuationEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileOpenPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileOpenPickerContinuationEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileSavePickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileSavePickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IFileSavePickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileSavePickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileSavePickerActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileSavePickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileSavePickerActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileSavePickerActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_IFileSavePickerActivatedEventArgs2, object_bases.get(), nullptr)};
    if (!IFileSavePickerActivatedEventArgs2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileSavePickerActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileSavePickerActivatedEventArgs2, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileSavePickerActivatedEventArgs2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileSavePickerActivatedEventArgs2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileSavePickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_IFileSavePickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!IFileSavePickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileSavePickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIFileSavePickerContinuationEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIFileSavePickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileSavePickerContinuationEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFolderPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_IFolderPickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!IFolderPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFolderPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIFolderPickerContinuationEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIFolderPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFolderPickerContinuationEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ILaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ILaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ILaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsILaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsILaunchActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsILaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsILaunchActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ILaunchActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_ILaunchActivatedEventArgs2, object_bases.get(), nullptr)};
    if (!ILaunchActivatedEventArgs2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsILaunchActivatedEventArgs2_type{py::register_python_type(module.get(), &type_spec_ImplementsILaunchActivatedEventArgs2, nullptr, inspectable_meta_type)};
    if (!ImplementsILaunchActivatedEventArgs2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsILaunchActivatedEventArgs2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ILockScreenActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ILockScreenActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ILockScreenActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsILockScreenActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsILockScreenActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsILockScreenActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsILockScreenActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ILockScreenCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ILockScreenCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ILockScreenCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsILockScreenCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsILockScreenCallActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsILockScreenCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsILockScreenCallActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPhoneCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPhoneCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPhoneCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPhoneCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIPhoneCallActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIPhoneCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPhoneCallActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPickerReturnedActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPickerReturnedActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPickerReturnedActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPickerReturnedActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIPickerReturnedActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIPickerReturnedActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPickerReturnedActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPrelaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPrelaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPrelaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPrelaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIPrelaunchActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIPrelaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPrelaunchActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPrint3DWorkflowActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPrint3DWorkflowActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPrint3DWorkflowActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPrint3DWorkflowActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIPrint3DWorkflowActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIPrint3DWorkflowActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPrint3DWorkflowActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IPrintTaskSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IPrintTaskSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IPrintTaskSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPrintTaskSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIPrintTaskSettingsActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIPrintTaskSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPrintTaskSettingsActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IProtocolActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IProtocolActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IProtocolActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIProtocolActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIProtocolActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIProtocolActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIProtocolActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_type{py::register_python_type(module.get(), &type_spec_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, object_bases.get(), nullptr)};
    if (!IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_type{py::register_python_type(module.get(), &type_spec_ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, nullptr, inspectable_meta_type)};
    if (!ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IProtocolForResultsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IProtocolForResultsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IProtocolForResultsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIProtocolForResultsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIProtocolForResultsActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIProtocolForResultsActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIProtocolForResultsActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IRestrictedLaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IRestrictedLaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IRestrictedLaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIRestrictedLaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIRestrictedLaunchActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIRestrictedLaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIRestrictedLaunchActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISearchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ISearchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!ISearchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISearchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsISearchActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsISearchActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISearchActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISearchActivatedEventArgsWithLinguisticDetails_type{py::register_python_type(module.get(), &type_spec_ISearchActivatedEventArgsWithLinguisticDetails, object_bases.get(), nullptr)};
    if (!ISearchActivatedEventArgsWithLinguisticDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISearchActivatedEventArgsWithLinguisticDetails_type{py::register_python_type(module.get(), &type_spec_ImplementsISearchActivatedEventArgsWithLinguisticDetails, nullptr, inspectable_meta_type)};
    if (!ImplementsISearchActivatedEventArgsWithLinguisticDetails_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISearchActivatedEventArgsWithLinguisticDetails_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IShareTargetActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IShareTargetActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IShareTargetActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIShareTargetActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIShareTargetActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIShareTargetActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIShareTargetActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStartupTaskActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IStartupTaskActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IStartupTaskActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStartupTaskActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIStartupTaskActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIStartupTaskActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStartupTaskActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IToastNotificationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IToastNotificationActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IToastNotificationActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIToastNotificationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIToastNotificationActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIToastNotificationActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIToastNotificationActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IUserDataAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IUserDataAccountProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IUserDataAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIUserDataAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIUserDataAccountProviderActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIUserDataAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIUserDataAccountProviderActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IViewSwitcherProvider_type{py::register_python_type(module.get(), &type_spec_IViewSwitcherProvider, object_bases.get(), nullptr)};
    if (!IViewSwitcherProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIViewSwitcherProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIViewSwitcherProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIViewSwitcherProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIViewSwitcherProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVoiceCommandActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IVoiceCommandActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IVoiceCommandActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVoiceCommandActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIVoiceCommandActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIVoiceCommandActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVoiceCommandActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWalletActionActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IWalletActionActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IWalletActionActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWalletActionActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIWalletActionActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIWalletActionActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWalletActionActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWebAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IWebAccountProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!IWebAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWebAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIWebAccountProviderActivatedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIWebAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWebAccountProviderActivatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWebAuthenticationBrokerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_IWebAuthenticationBrokerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!IWebAuthenticationBrokerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWebAuthenticationBrokerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsIWebAuthenticationBrokerContinuationEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsIWebAuthenticationBrokerContinuationEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWebAuthenticationBrokerContinuationEventArgs_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
