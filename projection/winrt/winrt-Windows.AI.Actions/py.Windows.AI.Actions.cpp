// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.AI.Actions.h"

namespace py::cpp::Windows::AI::Actions
{
    // ----- ActionEntity class --------------------

    static PyObject* _new_ActionEntity(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::ActionEntity>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::ActionEntity>::type_name);
        return nullptr;
    }

    static void _dealloc_ActionEntity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActionEntity_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionEntity", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Windows::AI::Actions::ActionEntity>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionEntity_get_DisplayInfo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionEntity", L"DisplayInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::AI::Actions::ActionEntity>().DisplayInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActionEntity_get_Kind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionEntity", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::AI::Actions::ActionEntity>().Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::ActionEntity>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::ActionEntity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActionEntity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ActionEntity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Windows::AI::Actions::ActionEntity>().Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActionEntity[] = {
        { "close", reinterpret_cast<PyCFunction>(ActionEntity_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActionEntity, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActionEntity), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ActionEntity), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ActionEntity), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ActionEntity[] = {
        { "display_info", reinterpret_cast<getter>(ActionEntity_get_DisplayInfo), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ActionEntity_get_Kind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ActionEntity[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActionEntity) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActionEntity) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActionEntity) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActionEntity) },
        { }};

    static PyType_Spec type_spec_ActionEntity = {
        "winrt._winrt_windows_ai_actions.ActionEntity",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ActionEntity};

    static PyGetSetDef getset_ActionEntity_Static[] = {
        { }};

    static PyMethodDef methods_ActionEntity_Static[] = {
        { }};

    static PyType_Slot type_slots_ActionEntity_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ActionEntity_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ActionEntity_Static) },
        { }
    };

    static PyType_Spec type_spec_ActionEntity_Static = {
        "winrt._winrt_windows_ai_actions.ActionEntity_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ActionEntity_Static};

    // ----- ActionEntityDisplayInfo class --------------------

    static PyObject* _new_ActionEntityDisplayInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::ActionEntityDisplayInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::ActionEntityDisplayInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_ActionEntityDisplayInfo(py::wrapper::Windows::AI::Actions::ActionEntityDisplayInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActionEntityDisplayInfo_Close(py::wrapper::Windows::AI::Actions::ActionEntityDisplayInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionEntityDisplayInfo", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionEntityDisplayInfo_get_Title(py::wrapper::Windows::AI::Actions::ActionEntityDisplayInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionEntityDisplayInfo", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActionEntityDisplayInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::ActionEntityDisplayInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActionEntityDisplayInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::ActionEntityDisplayInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActionEntityDisplayInfo(py::wrapper::Windows::AI::Actions::ActionEntityDisplayInfo* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ActionEntityDisplayInfo(py::wrapper::Windows::AI::Actions::ActionEntityDisplayInfo* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActionEntityDisplayInfo[] = {
        { "close", reinterpret_cast<PyCFunction>(ActionEntityDisplayInfo_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActionEntityDisplayInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActionEntityDisplayInfo), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ActionEntityDisplayInfo), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ActionEntityDisplayInfo), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ActionEntityDisplayInfo[] = {
        { "title", reinterpret_cast<getter>(ActionEntityDisplayInfo_get_Title), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ActionEntityDisplayInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActionEntityDisplayInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActionEntityDisplayInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActionEntityDisplayInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActionEntityDisplayInfo) },
        { }};

    static PyType_Spec type_spec_ActionEntityDisplayInfo = {
        "winrt._winrt_windows_ai_actions.ActionEntityDisplayInfo",
        sizeof(py::wrapper::Windows::AI::Actions::ActionEntityDisplayInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActionEntityDisplayInfo};

    // ----- ActionEntityFactory class --------------------

    static PyObject* _new_ActionEntityFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::ActionEntityFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::ActionEntityFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_ActionEntityFactory(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActionEntityFactory_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionEntityFactory", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Windows::AI::Actions::ActionEntityFactory>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionEntityFactory_CreateDocumentEntity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionEntityFactory", L"CreateDocumentEntity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Windows::AI::Actions::ActionEntityFactory>().CreateDocumentEntity(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionEntityFactory_CreateFileEntity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionEntityFactory", L"CreateFileEntity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Windows::AI::Actions::ActionEntityFactory>().CreateFileEntity(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionEntityFactory_CreatePhotoEntity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionEntityFactory", L"CreatePhotoEntity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Windows::AI::Actions::ActionEntityFactory>().CreatePhotoEntity(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionEntityFactory_CreateTextEntity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionEntityFactory", L"CreateTextEntity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Windows::AI::Actions::ActionEntityFactory>().CreateTextEntity(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActionEntityFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::ActionEntityFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActionEntityFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::ActionEntityFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActionEntityFactory(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ActionEntityFactory(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Windows::AI::Actions::ActionEntityFactory>().Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActionEntityFactory[] = {
        { "close", reinterpret_cast<PyCFunction>(ActionEntityFactory_Close), METH_VARARGS, nullptr },
        { "create_document_entity", reinterpret_cast<PyCFunction>(ActionEntityFactory_CreateDocumentEntity), METH_VARARGS, nullptr },
        { "create_file_entity", reinterpret_cast<PyCFunction>(ActionEntityFactory_CreateFileEntity), METH_VARARGS, nullptr },
        { "create_photo_entity", reinterpret_cast<PyCFunction>(ActionEntityFactory_CreatePhotoEntity), METH_VARARGS, nullptr },
        { "create_text_entity", reinterpret_cast<PyCFunction>(ActionEntityFactory_CreateTextEntity), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActionEntityFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActionEntityFactory), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ActionEntityFactory), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ActionEntityFactory), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ActionEntityFactory[] = {
        { }};

    static PyType_Slot _type_slots_ActionEntityFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActionEntityFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActionEntityFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActionEntityFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActionEntityFactory) },
        { }};

    static PyType_Spec type_spec_ActionEntityFactory = {
        "winrt._winrt_windows_ai_actions.ActionEntityFactory",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ActionEntityFactory};

    static PyGetSetDef getset_ActionEntityFactory_Static[] = {
        { }};

    static PyMethodDef methods_ActionEntityFactory_Static[] = {
        { }};

    static PyType_Slot type_slots_ActionEntityFactory_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ActionEntityFactory_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ActionEntityFactory_Static) },
        { }
    };

    static PyType_Spec type_spec_ActionEntityFactory_Static = {
        "winrt._winrt_windows_ai_actions.ActionEntityFactory_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ActionEntityFactory_Static};

    // ----- ActionInvocationContext class --------------------

    static PyObject* _new_ActionInvocationContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::ActionInvocationContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::ActionInvocationContext>::type_name);
        return nullptr;
    }

    static void _dealloc_ActionInvocationContext(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActionInvocationContext_Close(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionInvocationContext", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionInvocationContext_GetInputEntities(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionInvocationContext", L"GetInputEntities", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetInputEntities();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionInvocationContext_GetOutputEntities(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionInvocationContext", L"GetOutputEntities", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetOutputEntities();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionInvocationContext_SetInputEntity(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionInvocationContext", L"SetInputEntity", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::Actions::ActionEntity>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetInputEntity(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionInvocationContext_SetOutputEntity(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionInvocationContext", L"SetOutputEntity", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::Actions::ActionEntity>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetOutputEntity(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionInvocationContext_get_Result(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionInvocationContext", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ActionInvocationContext_put_Result(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionInvocationContext", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::AI::Actions::ActionInvocationResult>(arg);

            {
                auto _gil = release_gil();
                self->obj.Result(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ActionInvocationContext_get_ExtendedError(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionInvocationContext", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ActionInvocationContext_put_ExtendedError(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionInvocationContext", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hresult>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExtendedError(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ActionInvocationContext_get_ActionName(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionInvocationContext", L"ActionName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActionInvocationContext_get_EntityFactory(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionInvocationContext", L"EntityFactory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EntityFactory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActionInvocationContext_get_InvokerAumid(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionInvocationContext", L"InvokerAumid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InvokerAumid();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActionInvocationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::ActionInvocationContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActionInvocationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::ActionInvocationContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActionInvocationContext(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ActionInvocationContext(py::wrapper::Windows::AI::Actions::ActionInvocationContext* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActionInvocationContext[] = {
        { "close", reinterpret_cast<PyCFunction>(ActionInvocationContext_Close), METH_VARARGS, nullptr },
        { "get_input_entities", reinterpret_cast<PyCFunction>(ActionInvocationContext_GetInputEntities), METH_VARARGS, nullptr },
        { "get_output_entities", reinterpret_cast<PyCFunction>(ActionInvocationContext_GetOutputEntities), METH_VARARGS, nullptr },
        { "set_input_entity", reinterpret_cast<PyCFunction>(ActionInvocationContext_SetInputEntity), METH_VARARGS, nullptr },
        { "set_output_entity", reinterpret_cast<PyCFunction>(ActionInvocationContext_SetOutputEntity), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActionInvocationContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActionInvocationContext), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ActionInvocationContext), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ActionInvocationContext), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ActionInvocationContext[] = {
        { "result", reinterpret_cast<getter>(ActionInvocationContext_get_Result), reinterpret_cast<setter>(ActionInvocationContext_put_Result), nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(ActionInvocationContext_get_ExtendedError), reinterpret_cast<setter>(ActionInvocationContext_put_ExtendedError), nullptr, nullptr },
        { "action_name", reinterpret_cast<getter>(ActionInvocationContext_get_ActionName), nullptr, nullptr, nullptr },
        { "entity_factory", reinterpret_cast<getter>(ActionInvocationContext_get_EntityFactory), nullptr, nullptr, nullptr },
        { "invoker_aumid", reinterpret_cast<getter>(ActionInvocationContext_get_InvokerAumid), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ActionInvocationContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActionInvocationContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActionInvocationContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActionInvocationContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActionInvocationContext) },
        { }};

    static PyType_Spec type_spec_ActionInvocationContext = {
        "winrt._winrt_windows_ai_actions.ActionInvocationContext",
        sizeof(py::wrapper::Windows::AI::Actions::ActionInvocationContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActionInvocationContext};

    // ----- ActionRuntime class --------------------

    static PyObject* _new_ActionRuntime(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::ActionRuntime>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::ActionRuntime>::type_name);
        return nullptr;
    }

    static void _dealloc_ActionRuntime(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActionRuntime_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionRuntime", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Windows::AI::Actions::ActionRuntime>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionRuntime_CreateInvocationContext(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.ActionRuntime", L"CreateInvocationContext", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Windows::AI::Actions::ActionRuntime>().CreateInvocationContext(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActionRuntime_get_ActionCatalog(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionRuntime", L"ActionCatalog");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::AI::Actions::ActionRuntime>().ActionCatalog();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActionRuntime_get_EntityFactory(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.ActionRuntime", L"EntityFactory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::AI::Actions::ActionRuntime>().EntityFactory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActionRuntime(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::ActionRuntime>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActionRuntime(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::ActionRuntime>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActionRuntime(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ActionRuntime(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Windows::AI::Actions::ActionRuntime>().Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActionRuntime[] = {
        { "close", reinterpret_cast<PyCFunction>(ActionRuntime_Close), METH_VARARGS, nullptr },
        { "create_invocation_context", reinterpret_cast<PyCFunction>(ActionRuntime_CreateInvocationContext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActionRuntime, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActionRuntime), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ActionRuntime), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ActionRuntime), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ActionRuntime[] = {
        { "action_catalog", reinterpret_cast<getter>(ActionRuntime_get_ActionCatalog), nullptr, nullptr, nullptr },
        { "entity_factory", reinterpret_cast<getter>(ActionRuntime_get_EntityFactory), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ActionRuntime[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActionRuntime) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActionRuntime) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActionRuntime) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActionRuntime) },
        { }};

    static PyType_Spec type_spec_ActionRuntime = {
        "winrt._winrt_windows_ai_actions.ActionRuntime",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ActionRuntime};

    static PyGetSetDef getset_ActionRuntime_Static[] = {
        { }};

    static PyMethodDef methods_ActionRuntime_Static[] = {
        { }};

    static PyType_Slot type_slots_ActionRuntime_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ActionRuntime_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ActionRuntime_Static) },
        { }
    };

    static PyType_Spec type_spec_ActionRuntime_Static = {
        "winrt._winrt_windows_ai_actions.ActionRuntime_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ActionRuntime_Static};

    // ----- DocumentActionEntity class --------------------

    static PyObject* _new_DocumentActionEntity(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::DocumentActionEntity>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::DocumentActionEntity>::type_name);
        return nullptr;
    }

    static void _dealloc_DocumentActionEntity(py::wrapper::Windows::AI::Actions::DocumentActionEntity* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DocumentActionEntity_get_FullPath(py::wrapper::Windows::AI::Actions::DocumentActionEntity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.DocumentActionEntity", L"FullPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FullPath();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DocumentActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::DocumentActionEntity>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DocumentActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::DocumentActionEntity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DocumentActionEntity[] = {
        { "_assign_array_", _assign_array_DocumentActionEntity, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DocumentActionEntity), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DocumentActionEntity[] = {
        { "full_path", reinterpret_cast<getter>(DocumentActionEntity_get_FullPath), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DocumentActionEntity[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DocumentActionEntity) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DocumentActionEntity) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DocumentActionEntity) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DocumentActionEntity) },
        { }};

    static PyType_Spec type_spec_DocumentActionEntity = {
        "winrt._winrt_windows_ai_actions.DocumentActionEntity",
        sizeof(py::wrapper::Windows::AI::Actions::DocumentActionEntity),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DocumentActionEntity};

    // ----- FileActionEntity class --------------------

    static PyObject* _new_FileActionEntity(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::FileActionEntity>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::FileActionEntity>::type_name);
        return nullptr;
    }

    static void _dealloc_FileActionEntity(py::wrapper::Windows::AI::Actions::FileActionEntity* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileActionEntity_get_FullPath(py::wrapper::Windows::AI::Actions::FileActionEntity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.FileActionEntity", L"FullPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FullPath();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::FileActionEntity>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::FileActionEntity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileActionEntity[] = {
        { "_assign_array_", _assign_array_FileActionEntity, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileActionEntity), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileActionEntity[] = {
        { "full_path", reinterpret_cast<getter>(FileActionEntity_get_FullPath), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FileActionEntity[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileActionEntity) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileActionEntity) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileActionEntity) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileActionEntity) },
        { }};

    static PyType_Spec type_spec_FileActionEntity = {
        "winrt._winrt_windows_ai_actions.FileActionEntity",
        sizeof(py::wrapper::Windows::AI::Actions::FileActionEntity),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileActionEntity};

    // ----- NamedActionEntity class --------------------

    static PyObject* _new_NamedActionEntity(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::NamedActionEntity>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::NamedActionEntity>::type_name);
        return nullptr;
    }

    static void _dealloc_NamedActionEntity(py::wrapper::Windows::AI::Actions::NamedActionEntity* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NamedActionEntity_Close(py::wrapper::Windows::AI::Actions::NamedActionEntity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.Actions.NamedActionEntity", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NamedActionEntity_get_Name(py::wrapper::Windows::AI::Actions::NamedActionEntity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.NamedActionEntity", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NamedActionEntity_put_Name(py::wrapper::Windows::AI::Actions::NamedActionEntity* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.NamedActionEntity", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NamedActionEntity_get_Entity(py::wrapper::Windows::AI::Actions::NamedActionEntity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.NamedActionEntity", L"Entity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Entity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NamedActionEntity_put_Entity(py::wrapper::Windows::AI::Actions::NamedActionEntity* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.NamedActionEntity", L"Entity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::AI::Actions::ActionEntity>(arg);

            {
                auto _gil = release_gil();
                self->obj.Entity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_NamedActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::NamedActionEntity>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NamedActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::NamedActionEntity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_NamedActionEntity(py::wrapper::Windows::AI::Actions::NamedActionEntity* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_NamedActionEntity(py::wrapper::Windows::AI::Actions::NamedActionEntity* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NamedActionEntity[] = {
        { "close", reinterpret_cast<PyCFunction>(NamedActionEntity_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NamedActionEntity, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NamedActionEntity), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_NamedActionEntity), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_NamedActionEntity), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_NamedActionEntity[] = {
        { "name", reinterpret_cast<getter>(NamedActionEntity_get_Name), reinterpret_cast<setter>(NamedActionEntity_put_Name), nullptr, nullptr },
        { "entity", reinterpret_cast<getter>(NamedActionEntity_get_Entity), reinterpret_cast<setter>(NamedActionEntity_put_Entity), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NamedActionEntity[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NamedActionEntity) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NamedActionEntity) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NamedActionEntity) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NamedActionEntity) },
        { }};

    static PyType_Spec type_spec_NamedActionEntity = {
        "winrt._winrt_windows_ai_actions.NamedActionEntity",
        sizeof(py::wrapper::Windows::AI::Actions::NamedActionEntity),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NamedActionEntity};

    // ----- PhotoActionEntity class --------------------

    static PyObject* _new_PhotoActionEntity(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::PhotoActionEntity>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::PhotoActionEntity>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoActionEntity(py::wrapper::Windows::AI::Actions::PhotoActionEntity* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoActionEntity_get_FullPath(py::wrapper::Windows::AI::Actions::PhotoActionEntity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.PhotoActionEntity", L"FullPath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FullPath();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::PhotoActionEntity>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::PhotoActionEntity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoActionEntity[] = {
        { "_assign_array_", _assign_array_PhotoActionEntity, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoActionEntity), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoActionEntity[] = {
        { "full_path", reinterpret_cast<getter>(PhotoActionEntity_get_FullPath), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoActionEntity[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoActionEntity) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoActionEntity) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoActionEntity) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoActionEntity) },
        { }};

    static PyType_Spec type_spec_PhotoActionEntity = {
        "winrt._winrt_windows_ai_actions.PhotoActionEntity",
        sizeof(py::wrapper::Windows::AI::Actions::PhotoActionEntity),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoActionEntity};

    // ----- TextActionEntity class --------------------

    static PyObject* _new_TextActionEntity(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::Actions::TextActionEntity>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::Actions::TextActionEntity>::type_name);
        return nullptr;
    }

    static void _dealloc_TextActionEntity(py::wrapper::Windows::AI::Actions::TextActionEntity* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextActionEntity_get_Text(py::wrapper::Windows::AI::Actions::TextActionEntity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.Actions.TextActionEntity", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::Actions::TextActionEntity>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextActionEntity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::Actions::TextActionEntity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextActionEntity[] = {
        { "_assign_array_", _assign_array_TextActionEntity, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextActionEntity), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TextActionEntity[] = {
        { "text", reinterpret_cast<getter>(TextActionEntity_get_Text), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TextActionEntity[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextActionEntity) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextActionEntity) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextActionEntity) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextActionEntity) },
        { }};

    static PyType_Spec type_spec_TextActionEntity = {
        "winrt._winrt_windows_ai_actions.TextActionEntity",
        sizeof(py::wrapper::Windows::AI::Actions::TextActionEntity),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextActionEntity};

    // ----- Windows.AI.Actions Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.AI.Actions");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ai_actions",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::AI::Actions

PyMODINIT_FUNC PyInit__winrt_windows_ai_actions(void) noexcept
{
    using namespace py::cpp::Windows::AI::Actions;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle ActionEntity_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ActionEntity_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ActionEntity_Static{PyType_FromSpecWithBases(&type_spec_ActionEntity_Static, ActionEntity_Static_bases.get())};
    if (!type_ActionEntity_Static)
    {
        return nullptr;
    }

    py::pytype_handle ActionEntity_type{py::register_python_type(module.get(), &type_spec_ActionEntity, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ActionEntity_Static.get()))};
    if (!ActionEntity_type)
    {
        return nullptr;
    }

    py::pytype_handle ActionEntityDisplayInfo_type{py::register_python_type(module.get(), &type_spec_ActionEntityDisplayInfo, object_bases.get(), inspectable_meta_type)};
    if (!ActionEntityDisplayInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle ActionEntityFactory_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ActionEntityFactory_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ActionEntityFactory_Static{PyType_FromSpecWithBases(&type_spec_ActionEntityFactory_Static, ActionEntityFactory_Static_bases.get())};
    if (!type_ActionEntityFactory_Static)
    {
        return nullptr;
    }

    py::pytype_handle ActionEntityFactory_type{py::register_python_type(module.get(), &type_spec_ActionEntityFactory, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ActionEntityFactory_Static.get()))};
    if (!ActionEntityFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ActionInvocationContext_type{py::register_python_type(module.get(), &type_spec_ActionInvocationContext, object_bases.get(), inspectable_meta_type)};
    if (!ActionInvocationContext_type)
    {
        return nullptr;
    }

    py::pyobj_handle ActionRuntime_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ActionRuntime_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ActionRuntime_Static{PyType_FromSpecWithBases(&type_spec_ActionRuntime_Static, ActionRuntime_Static_bases.get())};
    if (!type_ActionRuntime_Static)
    {
        return nullptr;
    }

    py::pytype_handle ActionRuntime_type{py::register_python_type(module.get(), &type_spec_ActionRuntime, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ActionRuntime_Static.get()))};
    if (!ActionRuntime_type)
    {
        return nullptr;
    }

    py::pyobj_handle DocumentActionEntity_bases{PyTuple_Pack(1, ActionEntity_type.get())};
    if (!DocumentActionEntity_bases)
    {
        return nullptr;
    }

    py::pytype_handle DocumentActionEntity_type{py::register_python_type(module.get(), &type_spec_DocumentActionEntity, DocumentActionEntity_bases.get(), inspectable_meta_type)};
    if (!DocumentActionEntity_type)
    {
        return nullptr;
    }

    py::pyobj_handle FileActionEntity_bases{PyTuple_Pack(1, ActionEntity_type.get())};
    if (!FileActionEntity_bases)
    {
        return nullptr;
    }

    py::pytype_handle FileActionEntity_type{py::register_python_type(module.get(), &type_spec_FileActionEntity, FileActionEntity_bases.get(), inspectable_meta_type)};
    if (!FileActionEntity_type)
    {
        return nullptr;
    }

    py::pytype_handle NamedActionEntity_type{py::register_python_type(module.get(), &type_spec_NamedActionEntity, object_bases.get(), inspectable_meta_type)};
    if (!NamedActionEntity_type)
    {
        return nullptr;
    }

    py::pyobj_handle PhotoActionEntity_bases{PyTuple_Pack(1, ActionEntity_type.get())};
    if (!PhotoActionEntity_bases)
    {
        return nullptr;
    }

    py::pytype_handle PhotoActionEntity_type{py::register_python_type(module.get(), &type_spec_PhotoActionEntity, PhotoActionEntity_bases.get(), inspectable_meta_type)};
    if (!PhotoActionEntity_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextActionEntity_bases{PyTuple_Pack(1, ActionEntity_type.get())};
    if (!TextActionEntity_bases)
    {
        return nullptr;
    }

    py::pytype_handle TextActionEntity_type{py::register_python_type(module.get(), &type_spec_TextActionEntity, TextActionEntity_bases.get(), inspectable_meta_type)};
    if (!TextActionEntity_type)
    {
        return nullptr;
    }


    return module.detach();
}
