// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Automation.Provider.h"

namespace py::cpp::Windows::UI::Xaml::Automation::Provider
{
    // ----- IRawElementProviderSimple class --------------------

    static PyObject* _new_IRawElementProviderSimple(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>::type_name);
        return nullptr;
    }

    static void _dealloc_IRawElementProviderSimple(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IRawElementProviderSimple(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRawElementProviderSimple(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRawElementProviderSimple[] = {
        { "_assign_array_", _assign_array_IRawElementProviderSimple, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRawElementProviderSimple), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IRawElementProviderSimple[] = {
        { }};

    static PyType_Slot _type_slots_IRawElementProviderSimple[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRawElementProviderSimple) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRawElementProviderSimple) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRawElementProviderSimple) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRawElementProviderSimple) },
        { }};

    static PyType_Spec type_spec_IRawElementProviderSimple = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IRawElementProviderSimple",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRawElementProviderSimple};

    // ----- IAnnotationProvider interface --------------------

    static PyObject* _new_IAnnotationProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IAnnotationProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAnnotationProvider_get_AnnotationTypeId(py::wrapper::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IAnnotationProvider", L"AnnotationTypeId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AnnotationTypeId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnnotationProvider_get_AnnotationTypeName(py::wrapper::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IAnnotationProvider", L"AnnotationTypeName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AnnotationTypeName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnnotationProvider_get_Author(py::wrapper::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IAnnotationProvider", L"Author");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Author();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnnotationProvider_get_DateTime(py::wrapper::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IAnnotationProvider", L"DateTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnnotationProvider_get_Target(py::wrapper::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IAnnotationProvider", L"Target");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Target();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAnnotationProvider[] = {
        { }};

    static PyGetSetDef _getset_IAnnotationProvider[] = {
        { "annotation_type_id", reinterpret_cast<getter>(IAnnotationProvider_get_AnnotationTypeId), nullptr, nullptr, nullptr },
        { "annotation_type_name", reinterpret_cast<getter>(IAnnotationProvider_get_AnnotationTypeName), nullptr, nullptr, nullptr },
        { "author", reinterpret_cast<getter>(IAnnotationProvider_get_Author), nullptr, nullptr, nullptr },
        { "date_time", reinterpret_cast<getter>(IAnnotationProvider_get_DateTime), nullptr, nullptr, nullptr },
        { "target", reinterpret_cast<getter>(IAnnotationProvider_get_Target), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAnnotationProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAnnotationProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAnnotationProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAnnotationProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAnnotationProvider) },
        { }};

    static PyType_Spec type_spec_IAnnotationProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IAnnotationProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAnnotationProvider};

    struct ImplementsIAnnotationProvider : py::ImplementsInterfaceT<ImplementsIAnnotationProvider, winrt::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider>
    {
        ImplementsIAnnotationProvider() = delete;
        ImplementsIAnnotationProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAnnotationProvider, winrt::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider>(py_obj, runtime_class)
        {
        }

        auto AnnotationTypeId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "annotation_type_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AnnotationTypeName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "annotation_type_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Author()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "author")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DateTime()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "date_time")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Target()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "target")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAnnotationProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAnnotationProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAnnotationProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IAnnotationProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAnnotationProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAnnotationProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAnnotationProvider[] = {
        { "_assign_array_", _assign_array_IAnnotationProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAnnotationProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAnnotationProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAnnotationProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAnnotationProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAnnotationProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIAnnotationProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IAnnotationProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIAnnotationProvider};

    // ----- ICustomNavigationProvider interface --------------------

    static PyObject* _new_ICustomNavigationProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ICustomNavigationProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomNavigationProvider_NavigateCustom(py::wrapper::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ICustomNavigationProvider", L"NavigateCustom", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNavigationDirection>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NavigateCustom(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomNavigationProvider[] = {
        { "navigate_custom", reinterpret_cast<PyCFunction>(ICustomNavigationProvider_NavigateCustom), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ICustomNavigationProvider[] = {
        { }};

    static PyType_Slot _type_slots_ICustomNavigationProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomNavigationProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomNavigationProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomNavigationProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomNavigationProvider) },
        { }};

    static PyType_Spec type_spec_ICustomNavigationProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ICustomNavigationProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICustomNavigationProvider};

    struct ImplementsICustomNavigationProvider : py::ImplementsInterfaceT<ImplementsICustomNavigationProvider, winrt::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider>
    {
        ImplementsICustomNavigationProvider() = delete;
        ImplementsICustomNavigationProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICustomNavigationProvider, winrt::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider>(py_obj, runtime_class)
        {
        }

        auto NavigateCustom(winrt::Windows::UI::Xaml::Automation::Peers::AutomationNavigationDirection param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "navigate_custom")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICustomNavigationProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomNavigationProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICustomNavigationProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICustomNavigationProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICustomNavigationProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICustomNavigationProvider[] = {
        { "_assign_array_", _assign_array_ICustomNavigationProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomNavigationProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICustomNavigationProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICustomNavigationProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICustomNavigationProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICustomNavigationProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsICustomNavigationProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ICustomNavigationProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsICustomNavigationProvider};

    // ----- IDockProvider interface --------------------

    static PyObject* _new_IDockProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IDockProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IDockProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IDockProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDockProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDockProvider_SetDockPosition(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDockProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IDockProvider", L"SetDockPosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::DockPosition>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetDockPosition(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDockProvider_get_DockPosition(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDockProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IDockProvider", L"DockPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DockPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDockProvider[] = {
        { "set_dock_position", reinterpret_cast<PyCFunction>(IDockProvider_SetDockPosition), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IDockProvider[] = {
        { "dock_position", reinterpret_cast<getter>(IDockProvider_get_DockPosition), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IDockProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDockProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDockProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDockProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDockProvider) },
        { }};

    static PyType_Spec type_spec_IDockProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IDockProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDockProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDockProvider};

    struct ImplementsIDockProvider : py::ImplementsInterfaceT<ImplementsIDockProvider, winrt::Windows::UI::Xaml::Automation::Provider::IDockProvider>
    {
        ImplementsIDockProvider() = delete;
        ImplementsIDockProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIDockProvider, winrt::Windows::UI::Xaml::Automation::Provider::IDockProvider>(py_obj, runtime_class)
        {
        }

        auto SetDockPosition(winrt::Windows::UI::Xaml::Automation::DockPosition param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_dock_position")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DockPosition()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "dock_position")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::DockPosition>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IDockProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IDockProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDockProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IDockProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIDockProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IDockProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIDockProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIDockProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIDockProvider[] = {
        { "_assign_array_", _assign_array_IDockProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDockProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIDockProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIDockProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIDockProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIDockProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIDockProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IDockProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIDockProvider};

    // ----- IDragProvider interface --------------------

    static PyObject* _new_IDragProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IDragProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IDragProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IDragProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDragProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDragProvider_GetGrabbedItems(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDragProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IDragProvider", L"GetGrabbedItems", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetGrabbedItems();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDragProvider_get_DropEffect(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDragProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IDragProvider", L"DropEffect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropEffect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDragProvider_get_DropEffects(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDragProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IDragProvider", L"DropEffects");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropEffects();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDragProvider_get_IsGrabbed(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDragProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IDragProvider", L"IsGrabbed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGrabbed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDragProvider[] = {
        { "get_grabbed_items", reinterpret_cast<PyCFunction>(IDragProvider_GetGrabbedItems), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IDragProvider[] = {
        { "drop_effect", reinterpret_cast<getter>(IDragProvider_get_DropEffect), nullptr, nullptr, nullptr },
        { "drop_effects", reinterpret_cast<getter>(IDragProvider_get_DropEffects), nullptr, nullptr, nullptr },
        { "is_grabbed", reinterpret_cast<getter>(IDragProvider_get_IsGrabbed), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IDragProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDragProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDragProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDragProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDragProvider) },
        { }};

    static PyType_Spec type_spec_IDragProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IDragProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDragProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDragProvider};

    struct ImplementsIDragProvider : py::ImplementsInterfaceT<ImplementsIDragProvider, winrt::Windows::UI::Xaml::Automation::Provider::IDragProvider>
    {
        ImplementsIDragProvider() = delete;
        ImplementsIDragProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIDragProvider, winrt::Windows::UI::Xaml::Automation::Provider::IDragProvider>(py_obj, runtime_class)
        {
        }

        auto GetGrabbedItems()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_grabbed_items")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DropEffect()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "drop_effect")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DropEffects()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "drop_effects")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::hstring, false>>(value.get());
                return winrt::com_array<winrt::hstring>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsGrabbed()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_grabbed")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IDragProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IDragProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDragProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IDragProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIDragProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IDragProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIDragProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIDragProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIDragProvider[] = {
        { "_assign_array_", _assign_array_IDragProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDragProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIDragProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIDragProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIDragProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIDragProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIDragProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IDragProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIDragProvider};

    // ----- IDropTargetProvider interface --------------------

    static PyObject* _new_IDropTargetProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IDropTargetProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDropTargetProvider_get_DropEffect(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IDropTargetProvider", L"DropEffect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropEffect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDropTargetProvider_get_DropEffects(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IDropTargetProvider", L"DropEffects");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropEffects();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDropTargetProvider[] = {
        { }};

    static PyGetSetDef _getset_IDropTargetProvider[] = {
        { "drop_effect", reinterpret_cast<getter>(IDropTargetProvider_get_DropEffect), nullptr, nullptr, nullptr },
        { "drop_effects", reinterpret_cast<getter>(IDropTargetProvider_get_DropEffects), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IDropTargetProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDropTargetProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDropTargetProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDropTargetProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDropTargetProvider) },
        { }};

    static PyType_Spec type_spec_IDropTargetProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IDropTargetProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDropTargetProvider};

    struct ImplementsIDropTargetProvider : py::ImplementsInterfaceT<ImplementsIDropTargetProvider, winrt::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider>
    {
        ImplementsIDropTargetProvider() = delete;
        ImplementsIDropTargetProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIDropTargetProvider, winrt::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider>(py_obj, runtime_class)
        {
        }

        auto DropEffect()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "drop_effect")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DropEffects()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "drop_effects")};
                if (!value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::hstring, false>>(value.get());
                return winrt::com_array<winrt::hstring>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IDropTargetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDropTargetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIDropTargetProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IDropTargetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIDropTargetProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIDropTargetProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIDropTargetProvider[] = {
        { "_assign_array_", _assign_array_IDropTargetProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDropTargetProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIDropTargetProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIDropTargetProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIDropTargetProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIDropTargetProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIDropTargetProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IDropTargetProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIDropTargetProvider};

    // ----- IExpandCollapseProvider interface --------------------

    static PyObject* _new_IExpandCollapseProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IExpandCollapseProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IExpandCollapseProvider_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Collapse();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IExpandCollapseProvider_Expand(py::wrapper::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Expand();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IExpandCollapseProvider_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandCollapseState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IExpandCollapseProvider[] = {
        { "collapse", reinterpret_cast<PyCFunction>(IExpandCollapseProvider_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(IExpandCollapseProvider_Expand), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IExpandCollapseProvider[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(IExpandCollapseProvider_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IExpandCollapseProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IExpandCollapseProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IExpandCollapseProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IExpandCollapseProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IExpandCollapseProvider) },
        { }};

    static PyType_Spec type_spec_IExpandCollapseProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IExpandCollapseProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IExpandCollapseProvider};

    struct ImplementsIExpandCollapseProvider : py::ImplementsInterfaceT<ImplementsIExpandCollapseProvider, winrt::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider>
    {
        ImplementsIExpandCollapseProvider() = delete;
        ImplementsIExpandCollapseProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIExpandCollapseProvider, winrt::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider>(py_obj, runtime_class)
        {
        }

        auto Collapse()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "collapse")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Expand()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "expand")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ExpandCollapseState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "expand_collapse_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::ExpandCollapseState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IExpandCollapseProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IExpandCollapseProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIExpandCollapseProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIExpandCollapseProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIExpandCollapseProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIExpandCollapseProvider[] = {
        { "_assign_array_", _assign_array_IExpandCollapseProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IExpandCollapseProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIExpandCollapseProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIExpandCollapseProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIExpandCollapseProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIExpandCollapseProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIExpandCollapseProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IExpandCollapseProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIExpandCollapseProvider};

    // ----- IGridItemProvider interface --------------------

    static PyObject* _new_IGridItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IGridItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IGridItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IGridItemProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGridItemProvider_get_Column(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IGridItemProvider", L"Column");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Column();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridItemProvider_get_ColumnSpan(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IGridItemProvider", L"ColumnSpan");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ColumnSpan();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridItemProvider_get_ContainingGrid(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IGridItemProvider", L"ContainingGrid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainingGrid();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridItemProvider_get_Row(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IGridItemProvider", L"Row");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Row();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridItemProvider_get_RowSpan(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IGridItemProvider", L"RowSpan");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RowSpan();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGridItemProvider[] = {
        { }};

    static PyGetSetDef _getset_IGridItemProvider[] = {
        { "column", reinterpret_cast<getter>(IGridItemProvider_get_Column), nullptr, nullptr, nullptr },
        { "column_span", reinterpret_cast<getter>(IGridItemProvider_get_ColumnSpan), nullptr, nullptr, nullptr },
        { "containing_grid", reinterpret_cast<getter>(IGridItemProvider_get_ContainingGrid), nullptr, nullptr, nullptr },
        { "row", reinterpret_cast<getter>(IGridItemProvider_get_Row), nullptr, nullptr, nullptr },
        { "row_span", reinterpret_cast<getter>(IGridItemProvider_get_RowSpan), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IGridItemProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGridItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGridItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGridItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGridItemProvider) },
        { }};

    static PyType_Spec type_spec_IGridItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IGridItemProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGridItemProvider};

    struct ImplementsIGridItemProvider : py::ImplementsInterfaceT<ImplementsIGridItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::IGridItemProvider>
    {
        ImplementsIGridItemProvider() = delete;
        ImplementsIGridItemProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGridItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::IGridItemProvider>(py_obj, runtime_class)
        {
        }

        auto Column()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "column")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ColumnSpan()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "column_span")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContainingGrid()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "containing_grid")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Row()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "row")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RowSpan()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "row_span")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IGridItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IGridItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGridItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IGridItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIGridItemProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IGridItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGridItemProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGridItemProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGridItemProvider[] = {
        { "_assign_array_", _assign_array_IGridItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGridItemProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGridItemProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGridItemProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIGridItemProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGridItemProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIGridItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IGridItemProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIGridItemProvider};

    // ----- IGridProvider interface --------------------

    static PyObject* _new_IGridProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IGridProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IGridProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IGridProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGridProvider_GetItem(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IGridProvider", L"GetItem", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItem(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGridProvider_get_ColumnCount(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IGridProvider", L"ColumnCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ColumnCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridProvider_get_RowCount(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IGridProvider", L"RowCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RowCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGridProvider[] = {
        { "get_item", reinterpret_cast<PyCFunction>(IGridProvider_GetItem), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IGridProvider[] = {
        { "column_count", reinterpret_cast<getter>(IGridProvider_get_ColumnCount), nullptr, nullptr, nullptr },
        { "row_count", reinterpret_cast<getter>(IGridProvider_get_RowCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IGridProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGridProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGridProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGridProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGridProvider) },
        { }};

    static PyType_Spec type_spec_IGridProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IGridProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IGridProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGridProvider};

    struct ImplementsIGridProvider : py::ImplementsInterfaceT<ImplementsIGridProvider, winrt::Windows::UI::Xaml::Automation::Provider::IGridProvider>
    {
        ImplementsIGridProvider() = delete;
        ImplementsIGridProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGridProvider, winrt::Windows::UI::Xaml::Automation::Provider::IGridProvider>(py_obj, runtime_class)
        {
        }

        auto GetItem(int32_t param0, int32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_item")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ColumnCount()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "column_count")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RowCount()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "row_count")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IGridProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IGridProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGridProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IGridProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIGridProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IGridProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGridProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGridProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGridProvider[] = {
        { "_assign_array_", _assign_array_IGridProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGridProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGridProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGridProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIGridProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGridProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIGridProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IGridProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIGridProvider};

    // ----- IInvokeProvider interface --------------------

    static PyObject* _new_IInvokeProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IInvokeProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IInvokeProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IInvokeProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IInvokeProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInvokeProvider_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Provider::IInvokeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IInvokeProvider", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Invoke();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInvokeProvider[] = {
        { "invoke", reinterpret_cast<PyCFunction>(IInvokeProvider_Invoke), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IInvokeProvider[] = {
        { }};

    static PyType_Slot _type_slots_IInvokeProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInvokeProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInvokeProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInvokeProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInvokeProvider) },
        { }};

    static PyType_Spec type_spec_IInvokeProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IInvokeProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IInvokeProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInvokeProvider};

    struct ImplementsIInvokeProvider : py::ImplementsInterfaceT<ImplementsIInvokeProvider, winrt::Windows::UI::Xaml::Automation::Provider::IInvokeProvider>
    {
        ImplementsIInvokeProvider() = delete;
        ImplementsIInvokeProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIInvokeProvider, winrt::Windows::UI::Xaml::Automation::Provider::IInvokeProvider>(py_obj, runtime_class)
        {
        }

        auto Invoke()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "invoke")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IInvokeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IInvokeProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInvokeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IInvokeProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIInvokeProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IInvokeProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIInvokeProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIInvokeProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIInvokeProvider[] = {
        { "_assign_array_", _assign_array_IInvokeProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInvokeProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIInvokeProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIInvokeProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIInvokeProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIInvokeProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIInvokeProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IInvokeProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIInvokeProvider};

    // ----- IItemContainerProvider interface --------------------

    static PyObject* _new_IItemContainerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IItemContainerProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IItemContainerProvider_FindItemByProperty(py::wrapper::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IItemContainerProvider", L"FindItemByProperty", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindItemByProperty(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IItemContainerProvider[] = {
        { "find_item_by_property", reinterpret_cast<PyCFunction>(IItemContainerProvider_FindItemByProperty), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IItemContainerProvider[] = {
        { }};

    static PyType_Slot _type_slots_IItemContainerProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IItemContainerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IItemContainerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IItemContainerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IItemContainerProvider) },
        { }};

    static PyType_Spec type_spec_IItemContainerProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IItemContainerProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IItemContainerProvider};

    struct ImplementsIItemContainerProvider : py::ImplementsInterfaceT<ImplementsIItemContainerProvider, winrt::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider>
    {
        ImplementsIItemContainerProvider() = delete;
        ImplementsIItemContainerProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIItemContainerProvider, winrt::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider>(py_obj, runtime_class)
        {
        }

        auto FindItemByProperty(winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple const& param0, winrt::Windows::UI::Xaml::Automation::AutomationProperty const& param1, winrt::Windows::Foundation::IInspectable const& param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "find_item_by_property")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IItemContainerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IItemContainerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIItemContainerProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IItemContainerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIItemContainerProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIItemContainerProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIItemContainerProvider[] = {
        { "_assign_array_", _assign_array_IItemContainerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IItemContainerProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIItemContainerProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIItemContainerProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIItemContainerProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIItemContainerProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIItemContainerProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IItemContainerProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIItemContainerProvider};

    // ----- IMultipleViewProvider interface --------------------

    static PyObject* _new_IMultipleViewProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IMultipleViewProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMultipleViewProvider_GetSupportedViews(py::wrapper::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IMultipleViewProvider", L"GetSupportedViews", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSupportedViews();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMultipleViewProvider_GetViewName(py::wrapper::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IMultipleViewProvider", L"GetViewName", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetViewName(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMultipleViewProvider_SetCurrentView(py::wrapper::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IMultipleViewProvider", L"SetCurrentView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetCurrentView(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMultipleViewProvider_get_CurrentView(py::wrapper::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IMultipleViewProvider", L"CurrentView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentView();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMultipleViewProvider[] = {
        { "get_supported_views", reinterpret_cast<PyCFunction>(IMultipleViewProvider_GetSupportedViews), METH_VARARGS, nullptr },
        { "get_view_name", reinterpret_cast<PyCFunction>(IMultipleViewProvider_GetViewName), METH_VARARGS, nullptr },
        { "set_current_view", reinterpret_cast<PyCFunction>(IMultipleViewProvider_SetCurrentView), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IMultipleViewProvider[] = {
        { "current_view", reinterpret_cast<getter>(IMultipleViewProvider_get_CurrentView), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IMultipleViewProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMultipleViewProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMultipleViewProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMultipleViewProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMultipleViewProvider) },
        { }};

    static PyType_Spec type_spec_IMultipleViewProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IMultipleViewProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMultipleViewProvider};

    struct ImplementsIMultipleViewProvider : py::ImplementsInterfaceT<ImplementsIMultipleViewProvider, winrt::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider>
    {
        ImplementsIMultipleViewProvider() = delete;
        ImplementsIMultipleViewProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIMultipleViewProvider, winrt::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider>(py_obj, runtime_class)
        {
        }

        auto GetSupportedViews()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_supported_views")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<int32_t, false>>(return_value.get());
                return winrt::com_array<int32_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetViewName(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_view_name")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetCurrentView(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_current_view")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CurrentView()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "current_view")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IMultipleViewProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMultipleViewProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIMultipleViewProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIMultipleViewProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIMultipleViewProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIMultipleViewProvider[] = {
        { "_assign_array_", _assign_array_IMultipleViewProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMultipleViewProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIMultipleViewProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIMultipleViewProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIMultipleViewProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIMultipleViewProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIMultipleViewProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IMultipleViewProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIMultipleViewProvider};

    // ----- IObjectModelProvider interface --------------------

    static PyObject* _new_IObjectModelProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IObjectModelProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IObjectModelProvider_GetUnderlyingObjectModel(py::wrapper::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IObjectModelProvider", L"GetUnderlyingObjectModel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUnderlyingObjectModel();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IObjectModelProvider[] = {
        { "get_underlying_object_model", reinterpret_cast<PyCFunction>(IObjectModelProvider_GetUnderlyingObjectModel), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IObjectModelProvider[] = {
        { }};

    static PyType_Slot _type_slots_IObjectModelProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IObjectModelProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IObjectModelProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IObjectModelProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IObjectModelProvider) },
        { }};

    static PyType_Spec type_spec_IObjectModelProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IObjectModelProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IObjectModelProvider};

    struct ImplementsIObjectModelProvider : py::ImplementsInterfaceT<ImplementsIObjectModelProvider, winrt::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider>
    {
        ImplementsIObjectModelProvider() = delete;
        ImplementsIObjectModelProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIObjectModelProvider, winrt::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider>(py_obj, runtime_class)
        {
        }

        auto GetUnderlyingObjectModel()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_underlying_object_model")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IObjectModelProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IObjectModelProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIObjectModelProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IObjectModelProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIObjectModelProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIObjectModelProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIObjectModelProvider[] = {
        { "_assign_array_", _assign_array_IObjectModelProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IObjectModelProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIObjectModelProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIObjectModelProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIObjectModelProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIObjectModelProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIObjectModelProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IObjectModelProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIObjectModelProvider};

    // ----- IRangeValueProvider interface --------------------

    static PyObject* _new_IRangeValueProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IRangeValueProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRangeValueProvider_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IRangeValueProvider", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetValue(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IRangeValueProvider", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsReadOnly();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_LargeChange(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IRangeValueProvider", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LargeChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_Maximum(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IRangeValueProvider", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Maximum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_Minimum(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IRangeValueProvider", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Minimum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_SmallChange(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IRangeValueProvider", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmallChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IRangeValueProvider", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRangeValueProvider[] = {
        { "set_value", reinterpret_cast<PyCFunction>(IRangeValueProvider_SetValue), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IRangeValueProvider[] = {
        { "is_read_only", reinterpret_cast<getter>(IRangeValueProvider_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(IRangeValueProvider_get_LargeChange), nullptr, nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(IRangeValueProvider_get_Maximum), nullptr, nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(IRangeValueProvider_get_Minimum), nullptr, nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(IRangeValueProvider_get_SmallChange), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IRangeValueProvider_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IRangeValueProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRangeValueProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRangeValueProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRangeValueProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRangeValueProvider) },
        { }};

    static PyType_Spec type_spec_IRangeValueProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IRangeValueProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRangeValueProvider};

    struct ImplementsIRangeValueProvider : py::ImplementsInterfaceT<ImplementsIRangeValueProvider, winrt::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider>
    {
        ImplementsIRangeValueProvider() = delete;
        ImplementsIRangeValueProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIRangeValueProvider, winrt::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider>(py_obj, runtime_class)
        {
        }

        auto SetValue(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsReadOnly()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_read_only")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LargeChange()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "large_change")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Maximum()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "maximum")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Minimum()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "minimum")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SmallChange()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "small_change")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Value()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "value")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IRangeValueProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRangeValueProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIRangeValueProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IRangeValueProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIRangeValueProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIRangeValueProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIRangeValueProvider[] = {
        { "_assign_array_", _assign_array_IRangeValueProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRangeValueProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIRangeValueProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIRangeValueProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIRangeValueProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIRangeValueProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIRangeValueProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IRangeValueProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIRangeValueProvider};

    // ----- IScrollItemProvider interface --------------------

    static PyObject* _new_IScrollItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollItemProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollItemProvider_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollItemProvider", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ScrollIntoView();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollItemProvider[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(IScrollItemProvider_ScrollIntoView), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IScrollItemProvider[] = {
        { }};

    static PyType_Slot _type_slots_IScrollItemProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollItemProvider) },
        { }};

    static PyType_Spec type_spec_IScrollItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IScrollItemProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollItemProvider};

    struct ImplementsIScrollItemProvider : py::ImplementsInterfaceT<ImplementsIScrollItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider>
    {
        ImplementsIScrollItemProvider() = delete;
        ImplementsIScrollItemProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIScrollItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider>(py_obj, runtime_class)
        {
        }

        auto ScrollIntoView()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "scroll_into_view")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IScrollItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIScrollItemProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IScrollItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIScrollItemProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIScrollItemProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIScrollItemProvider[] = {
        { "_assign_array_", _assign_array_IScrollItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollItemProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIScrollItemProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIScrollItemProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIScrollItemProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIScrollItemProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIScrollItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IScrollItemProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIScrollItemProvider};

    // ----- IScrollProvider interface --------------------

    static PyObject* _new_IScrollProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IScrollProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IScrollProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollProvider_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollProvider", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Scroll(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollProvider", L"SetScrollPercent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetScrollPercent(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollProvider", L"HorizontalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalScrollPercent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollProvider", L"HorizontalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalViewSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollProvider", L"HorizontallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontallyScrollable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollProvider", L"VerticalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalScrollPercent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollProvider", L"VerticalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalViewSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IScrollProvider", L"VerticallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticallyScrollable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollProvider[] = {
        { "scroll", reinterpret_cast<PyCFunction>(IScrollProvider_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(IScrollProvider_SetScrollPercent), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IScrollProvider[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(IScrollProvider_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(IScrollProvider_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(IScrollProvider_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(IScrollProvider_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(IScrollProvider_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(IScrollProvider_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IScrollProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollProvider) },
        { }};

    static PyType_Spec type_spec_IScrollProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IScrollProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IScrollProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollProvider};

    struct ImplementsIScrollProvider : py::ImplementsInterfaceT<ImplementsIScrollProvider, winrt::Windows::UI::Xaml::Automation::Provider::IScrollProvider>
    {
        ImplementsIScrollProvider() = delete;
        ImplementsIScrollProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIScrollProvider, winrt::Windows::UI::Xaml::Automation::Provider::IScrollProvider>(py_obj, runtime_class)
        {
        }

        auto Scroll(winrt::Windows::UI::Xaml::Automation::ScrollAmount param0, winrt::Windows::UI::Xaml::Automation::ScrollAmount param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "scroll")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetScrollPercent(double param0, double param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_scroll_percent")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HorizontalScrollPercent()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "horizontal_scroll_percent")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HorizontalViewSize()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "horizontal_view_size")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HorizontallyScrollable()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "horizontally_scrollable")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VerticalScrollPercent()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "vertical_scroll_percent")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VerticalViewSize()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "vertical_view_size")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VerticallyScrollable()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "vertically_scrollable")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IScrollProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IScrollProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IScrollProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIScrollProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IScrollProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIScrollProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIScrollProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIScrollProvider[] = {
        { "_assign_array_", _assign_array_IScrollProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIScrollProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIScrollProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIScrollProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIScrollProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIScrollProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IScrollProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIScrollProvider};

    // ----- ISelectionItemProvider interface --------------------

    static PyObject* _new_ISelectionItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISelectionItemProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISelectionItemProvider_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.AddToSelection();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionItemProvider_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveFromSelection();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionItemProvider_Select(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Select();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionItemProvider_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSelected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISelectionItemProvider_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectionContainer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISelectionItemProvider[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(ISelectionItemProvider_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(ISelectionItemProvider_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(ISelectionItemProvider_Select), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISelectionItemProvider[] = {
        { "is_selected", reinterpret_cast<getter>(ISelectionItemProvider_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(ISelectionItemProvider_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISelectionItemProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISelectionItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISelectionItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISelectionItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISelectionItemProvider) },
        { }};

    static PyType_Spec type_spec_ISelectionItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ISelectionItemProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISelectionItemProvider};

    struct ImplementsISelectionItemProvider : py::ImplementsInterfaceT<ImplementsISelectionItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider>
    {
        ImplementsISelectionItemProvider() = delete;
        ImplementsISelectionItemProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISelectionItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider>(py_obj, runtime_class)
        {
        }

        auto AddToSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_to_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveFromSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_from_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Select()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "select")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsSelected()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_selected")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SelectionContainer()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "selection_container")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISelectionItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISelectionItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISelectionItemProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISelectionItemProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISelectionItemProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISelectionItemProvider[] = {
        { "_assign_array_", _assign_array_ISelectionItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISelectionItemProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISelectionItemProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISelectionItemProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISelectionItemProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISelectionItemProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsISelectionItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ISelectionItemProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISelectionItemProvider};

    // ----- ISelectionProvider interface --------------------

    static PyObject* _new_ISelectionProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISelectionProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISelectionProvider_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISelectionProvider", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSelection();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionProvider_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ISelectionProvider", L"CanSelectMultiple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanSelectMultiple();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISelectionProvider_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ISelectionProvider", L"IsSelectionRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSelectionRequired();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISelectionProvider[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(ISelectionProvider_GetSelection), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISelectionProvider[] = {
        { "can_select_multiple", reinterpret_cast<getter>(ISelectionProvider_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(ISelectionProvider_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISelectionProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISelectionProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISelectionProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISelectionProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISelectionProvider) },
        { }};

    static PyType_Spec type_spec_ISelectionProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ISelectionProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISelectionProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISelectionProvider};

    struct ImplementsISelectionProvider : py::ImplementsInterfaceT<ImplementsISelectionProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISelectionProvider>
    {
        ImplementsISelectionProvider() = delete;
        ImplementsISelectionProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISelectionProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISelectionProvider>(py_obj, runtime_class)
        {
        }

        auto GetSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanSelectMultiple()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_select_multiple")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsSelectionRequired()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_selection_required")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISelectionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISelectionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISelectionProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ISelectionProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISelectionProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISelectionProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISelectionProvider[] = {
        { "_assign_array_", _assign_array_ISelectionProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISelectionProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISelectionProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISelectionProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISelectionProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISelectionProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsISelectionProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ISelectionProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISelectionProvider};

    // ----- ISpreadsheetItemProvider interface --------------------

    static PyObject* _new_ISpreadsheetItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISpreadsheetItemProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISpreadsheetItemProvider_GetAnnotationObjects(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISpreadsheetItemProvider", L"GetAnnotationObjects", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAnnotationObjects();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISpreadsheetItemProvider_GetAnnotationTypes(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISpreadsheetItemProvider", L"GetAnnotationTypes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAnnotationTypes();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISpreadsheetItemProvider_get_Formula(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ISpreadsheetItemProvider", L"Formula");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Formula();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpreadsheetItemProvider[] = {
        { "get_annotation_objects", reinterpret_cast<PyCFunction>(ISpreadsheetItemProvider_GetAnnotationObjects), METH_VARARGS, nullptr },
        { "get_annotation_types", reinterpret_cast<PyCFunction>(ISpreadsheetItemProvider_GetAnnotationTypes), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISpreadsheetItemProvider[] = {
        { "formula", reinterpret_cast<getter>(ISpreadsheetItemProvider_get_Formula), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISpreadsheetItemProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISpreadsheetItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISpreadsheetItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISpreadsheetItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISpreadsheetItemProvider) },
        { }};

    static PyType_Spec type_spec_ISpreadsheetItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ISpreadsheetItemProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISpreadsheetItemProvider};

    struct ImplementsISpreadsheetItemProvider : py::ImplementsInterfaceT<ImplementsISpreadsheetItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>
    {
        ImplementsISpreadsheetItemProvider() = delete;
        ImplementsISpreadsheetItemProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISpreadsheetItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>(py_obj, runtime_class)
        {
        }

        auto GetAnnotationObjects()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_annotation_objects")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetAnnotationTypes()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_annotation_types")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::AnnotationType, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::AnnotationType>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Formula()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "formula")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISpreadsheetItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISpreadsheetItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISpreadsheetItemProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISpreadsheetItemProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISpreadsheetItemProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISpreadsheetItemProvider[] = {
        { "_assign_array_", _assign_array_ISpreadsheetItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISpreadsheetItemProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISpreadsheetItemProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISpreadsheetItemProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISpreadsheetItemProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISpreadsheetItemProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsISpreadsheetItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ISpreadsheetItemProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISpreadsheetItemProvider};

    // ----- ISpreadsheetProvider interface --------------------

    static PyObject* _new_ISpreadsheetProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISpreadsheetProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISpreadsheetProvider_GetItemByName(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISpreadsheetProvider", L"GetItemByName", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemByName(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpreadsheetProvider[] = {
        { "get_item_by_name", reinterpret_cast<PyCFunction>(ISpreadsheetProvider_GetItemByName), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISpreadsheetProvider[] = {
        { }};

    static PyType_Slot _type_slots_ISpreadsheetProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISpreadsheetProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISpreadsheetProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISpreadsheetProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISpreadsheetProvider) },
        { }};

    static PyType_Spec type_spec_ISpreadsheetProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ISpreadsheetProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISpreadsheetProvider};

    struct ImplementsISpreadsheetProvider : py::ImplementsInterfaceT<ImplementsISpreadsheetProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider>
    {
        ImplementsISpreadsheetProvider() = delete;
        ImplementsISpreadsheetProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISpreadsheetProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider>(py_obj, runtime_class)
        {
        }

        auto GetItemByName(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_item_by_name")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISpreadsheetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISpreadsheetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISpreadsheetProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISpreadsheetProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISpreadsheetProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISpreadsheetProvider[] = {
        { "_assign_array_", _assign_array_ISpreadsheetProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISpreadsheetProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISpreadsheetProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISpreadsheetProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISpreadsheetProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISpreadsheetProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsISpreadsheetProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ISpreadsheetProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISpreadsheetProvider};

    // ----- IStylesProvider interface --------------------

    static PyObject* _new_IStylesProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IStylesProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IStylesProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IStylesProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStylesProvider_get_ExtendedProperties(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IStylesProvider", L"ExtendedProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_FillColor(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IStylesProvider", L"FillColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FillColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_FillPatternColor(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IStylesProvider", L"FillPatternColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FillPatternColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_FillPatternStyle(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IStylesProvider", L"FillPatternStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FillPatternStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_Shape(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IStylesProvider", L"Shape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Shape();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_StyleId(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IStylesProvider", L"StyleId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StyleId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_StyleName(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IStylesProvider", L"StyleName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StyleName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStylesProvider[] = {
        { }};

    static PyGetSetDef _getset_IStylesProvider[] = {
        { "extended_properties", reinterpret_cast<getter>(IStylesProvider_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "fill_color", reinterpret_cast<getter>(IStylesProvider_get_FillColor), nullptr, nullptr, nullptr },
        { "fill_pattern_color", reinterpret_cast<getter>(IStylesProvider_get_FillPatternColor), nullptr, nullptr, nullptr },
        { "fill_pattern_style", reinterpret_cast<getter>(IStylesProvider_get_FillPatternStyle), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(IStylesProvider_get_Shape), nullptr, nullptr, nullptr },
        { "style_id", reinterpret_cast<getter>(IStylesProvider_get_StyleId), nullptr, nullptr, nullptr },
        { "style_name", reinterpret_cast<getter>(IStylesProvider_get_StyleName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStylesProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStylesProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStylesProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStylesProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStylesProvider) },
        { }};

    static PyType_Spec type_spec_IStylesProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IStylesProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IStylesProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStylesProvider};

    struct ImplementsIStylesProvider : py::ImplementsInterfaceT<ImplementsIStylesProvider, winrt::Windows::UI::Xaml::Automation::Provider::IStylesProvider>
    {
        ImplementsIStylesProvider() = delete;
        ImplementsIStylesProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStylesProvider, winrt::Windows::UI::Xaml::Automation::Provider::IStylesProvider>(py_obj, runtime_class)
        {
        }

        auto ExtendedProperties()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "extended_properties")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FillColor()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "fill_color")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Color>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FillPatternColor()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "fill_pattern_color")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Color>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FillPatternStyle()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "fill_pattern_style")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Shape()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "shape")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StyleId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "style_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StyleName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "style_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStylesProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IStylesProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStylesProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IStylesProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStylesProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IStylesProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStylesProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStylesProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStylesProvider[] = {
        { "_assign_array_", _assign_array_IStylesProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStylesProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStylesProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStylesProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStylesProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStylesProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIStylesProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IStylesProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStylesProvider};

    // ----- ISynchronizedInputProvider interface --------------------

    static PyObject* _new_ISynchronizedInputProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISynchronizedInputProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISynchronizedInputProvider_Cancel(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISynchronizedInputProvider", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISynchronizedInputProvider_StartListening(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ISynchronizedInputProvider", L"StartListening", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::SynchronizedInputType>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.StartListening(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISynchronizedInputProvider[] = {
        { "cancel", reinterpret_cast<PyCFunction>(ISynchronizedInputProvider_Cancel), METH_VARARGS, nullptr },
        { "start_listening", reinterpret_cast<PyCFunction>(ISynchronizedInputProvider_StartListening), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISynchronizedInputProvider[] = {
        { }};

    static PyType_Slot _type_slots_ISynchronizedInputProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISynchronizedInputProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISynchronizedInputProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISynchronizedInputProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISynchronizedInputProvider) },
        { }};

    static PyType_Spec type_spec_ISynchronizedInputProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ISynchronizedInputProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISynchronizedInputProvider};

    struct ImplementsISynchronizedInputProvider : py::ImplementsInterfaceT<ImplementsISynchronizedInputProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>
    {
        ImplementsISynchronizedInputProvider() = delete;
        ImplementsISynchronizedInputProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISynchronizedInputProvider, winrt::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>(py_obj, runtime_class)
        {
        }

        auto Cancel()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "cancel")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StartListening(winrt::Windows::UI::Xaml::Automation::SynchronizedInputType param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start_listening")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISynchronizedInputProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISynchronizedInputProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISynchronizedInputProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISynchronizedInputProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISynchronizedInputProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISynchronizedInputProvider[] = {
        { "_assign_array_", _assign_array_ISynchronizedInputProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISynchronizedInputProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISynchronizedInputProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISynchronizedInputProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISynchronizedInputProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISynchronizedInputProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsISynchronizedInputProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ISynchronizedInputProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISynchronizedInputProvider};

    // ----- ITableItemProvider interface --------------------

    static PyObject* _new_ITableItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITableItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITableItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITableItemProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITableItemProvider_GetColumnHeaderItems(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITableItemProvider", L"GetColumnHeaderItems", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetColumnHeaderItems();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITableItemProvider_GetRowHeaderItems(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITableItemProvider", L"GetRowHeaderItems", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetRowHeaderItems();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITableItemProvider[] = {
        { "get_column_header_items", reinterpret_cast<PyCFunction>(ITableItemProvider_GetColumnHeaderItems), METH_VARARGS, nullptr },
        { "get_row_header_items", reinterpret_cast<PyCFunction>(ITableItemProvider_GetRowHeaderItems), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITableItemProvider[] = {
        { }};

    static PyType_Slot _type_slots_ITableItemProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITableItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITableItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITableItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITableItemProvider) },
        { }};

    static PyType_Spec type_spec_ITableItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITableItemProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITableItemProvider};

    struct ImplementsITableItemProvider : py::ImplementsInterfaceT<ImplementsITableItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITableItemProvider>
    {
        ImplementsITableItemProvider() = delete;
        ImplementsITableItemProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITableItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITableItemProvider>(py_obj, runtime_class)
        {
        }

        auto GetColumnHeaderItems()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_column_header_items")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetRowHeaderItems()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_row_header_items")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITableItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITableItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITableItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITableItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITableItemProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITableItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITableItemProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITableItemProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITableItemProvider[] = {
        { "_assign_array_", _assign_array_ITableItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITableItemProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITableItemProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITableItemProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITableItemProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITableItemProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsITableItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITableItemProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITableItemProvider};

    // ----- ITableProvider interface --------------------

    static PyObject* _new_ITableProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITableProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITableProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITableProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITableProvider_GetColumnHeaders(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITableProvider", L"GetColumnHeaders", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetColumnHeaders();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITableProvider_GetRowHeaders(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITableProvider", L"GetRowHeaders", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetRowHeaders();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITableProvider_get_RowOrColumnMajor(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITableProvider", L"RowOrColumnMajor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RowOrColumnMajor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITableProvider[] = {
        { "get_column_headers", reinterpret_cast<PyCFunction>(ITableProvider_GetColumnHeaders), METH_VARARGS, nullptr },
        { "get_row_headers", reinterpret_cast<PyCFunction>(ITableProvider_GetRowHeaders), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITableProvider[] = {
        { "row_or_column_major", reinterpret_cast<getter>(ITableProvider_get_RowOrColumnMajor), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ITableProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITableProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITableProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITableProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITableProvider) },
        { }};

    static PyType_Spec type_spec_ITableProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITableProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITableProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITableProvider};

    struct ImplementsITableProvider : py::ImplementsInterfaceT<ImplementsITableProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITableProvider>
    {
        ImplementsITableProvider() = delete;
        ImplementsITableProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITableProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITableProvider>(py_obj, runtime_class)
        {
        }

        auto GetColumnHeaders()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_column_headers")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetRowHeaders()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_row_headers")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RowOrColumnMajor()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "row_or_column_major")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::RowOrColumnMajor>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITableProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITableProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITableProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITableProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITableProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITableProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITableProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITableProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITableProvider[] = {
        { "_assign_array_", _assign_array_ITableProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITableProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITableProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITableProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITableProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITableProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsITableProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITableProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITableProvider};

    // ----- ITextChildProvider interface --------------------

    static PyObject* _new_ITextChildProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextChildProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextChildProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextChildProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextChildProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextChildProvider_get_TextContainer(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextChildProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITextChildProvider", L"TextContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextContainer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextChildProvider_get_TextRange(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextChildProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITextChildProvider", L"TextRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextChildProvider[] = {
        { }};

    static PyGetSetDef _getset_ITextChildProvider[] = {
        { "text_container", reinterpret_cast<getter>(ITextChildProvider_get_TextContainer), nullptr, nullptr, nullptr },
        { "text_range", reinterpret_cast<getter>(ITextChildProvider_get_TextRange), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ITextChildProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextChildProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextChildProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextChildProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextChildProvider) },
        { }};

    static PyType_Spec type_spec_ITextChildProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITextChildProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextChildProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextChildProvider};

    struct ImplementsITextChildProvider : py::ImplementsInterfaceT<ImplementsITextChildProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITextChildProvider>
    {
        ImplementsITextChildProvider() = delete;
        ImplementsITextChildProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITextChildProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITextChildProvider>(py_obj, runtime_class)
        {
        }

        auto TextContainer()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "text_container")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TextRange()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "text_range")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITextChildProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITextChildProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextChildProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITextChildProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITextChildProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITextChildProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITextChildProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITextChildProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITextChildProvider[] = {
        { "_assign_array_", _assign_array_ITextChildProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextChildProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITextChildProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITextChildProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITextChildProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITextChildProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsITextChildProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITextChildProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextChildProvider};

    // ----- ITextEditProvider interface --------------------

    static PyObject* _new_ITextEditProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextEditProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextEditProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextEditProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextEditProvider_GetActiveComposition(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextEditProvider", L"GetActiveComposition", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetActiveComposition();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_GetConversionTarget(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextEditProvider", L"GetConversionTarget", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversionTarget();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSelection();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_GetVisibleRanges(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"GetVisibleRanges", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetVisibleRanges();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_RangeFromChild(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromChild", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RangeFromChild(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_RangeFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RangeFromPoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_get_DocumentRange(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"DocumentRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DocumentRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_get_SupportedTextSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"SupportedTextSelection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedTextSelection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextEditProvider[] = {
        { "get_active_composition", reinterpret_cast<PyCFunction>(ITextEditProvider_GetActiveComposition), METH_VARARGS, nullptr },
        { "get_conversion_target", reinterpret_cast<PyCFunction>(ITextEditProvider_GetConversionTarget), METH_VARARGS, nullptr },
        { "get_selection", reinterpret_cast<PyCFunction>(ITextEditProvider_GetSelection), METH_VARARGS, nullptr },
        { "get_visible_ranges", reinterpret_cast<PyCFunction>(ITextEditProvider_GetVisibleRanges), METH_VARARGS, nullptr },
        { "range_from_child", reinterpret_cast<PyCFunction>(ITextEditProvider_RangeFromChild), METH_VARARGS, nullptr },
        { "range_from_point", reinterpret_cast<PyCFunction>(ITextEditProvider_RangeFromPoint), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITextEditProvider[] = {
        { "document_range", reinterpret_cast<getter>(ITextEditProvider_get_DocumentRange), nullptr, nullptr, nullptr },
        { "supported_text_selection", reinterpret_cast<getter>(ITextEditProvider_get_SupportedTextSelection), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ITextEditProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextEditProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextEditProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextEditProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextEditProvider) },
        { }};

    static PyType_Spec type_spec_ITextEditProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITextEditProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextEditProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextEditProvider};

    struct ImplementsITextEditProvider : py::ImplementsInterfaceT<ImplementsITextEditProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITextEditProvider>
    {
        ImplementsITextEditProvider() = delete;
        ImplementsITextEditProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITextEditProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITextEditProvider>(py_obj, runtime_class)
        {
        }

        auto GetActiveComposition()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_active_composition")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetConversionTarget()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_conversion_target")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetVisibleRanges()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_visible_ranges")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RangeFromChild(winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "range_from_child")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RangeFromPoint(winrt::Windows::Foundation::Point param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "range_from_point")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DocumentRange()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "document_range")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SupportedTextSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "supported_text_selection")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::SupportedTextSelection>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITextEditProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITextEditProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextEditProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITextEditProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITextEditProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITextEditProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITextEditProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITextEditProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITextEditProvider[] = {
        { "_assign_array_", _assign_array_ITextEditProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextEditProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITextEditProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITextEditProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITextEditProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITextEditProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsITextEditProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITextEditProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextEditProvider};

    // ----- ITextProvider interface --------------------

    static PyObject* _new_ITextProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextProvider_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSelection();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider_GetVisibleRanges(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"GetVisibleRanges", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetVisibleRanges();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider_RangeFromChild(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromChild", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RangeFromChild(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider_RangeFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RangeFromPoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider_get_DocumentRange(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"DocumentRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DocumentRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextProvider_get_SupportedTextSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"SupportedTextSelection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedTextSelection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextProvider[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(ITextProvider_GetSelection), METH_VARARGS, nullptr },
        { "get_visible_ranges", reinterpret_cast<PyCFunction>(ITextProvider_GetVisibleRanges), METH_VARARGS, nullptr },
        { "range_from_child", reinterpret_cast<PyCFunction>(ITextProvider_RangeFromChild), METH_VARARGS, nullptr },
        { "range_from_point", reinterpret_cast<PyCFunction>(ITextProvider_RangeFromPoint), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITextProvider[] = {
        { "document_range", reinterpret_cast<getter>(ITextProvider_get_DocumentRange), nullptr, nullptr, nullptr },
        { "supported_text_selection", reinterpret_cast<getter>(ITextProvider_get_SupportedTextSelection), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ITextProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextProvider) },
        { }};

    static PyType_Spec type_spec_ITextProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITextProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextProvider};

    struct ImplementsITextProvider : py::ImplementsInterfaceT<ImplementsITextProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider>
    {
        ImplementsITextProvider() = delete;
        ImplementsITextProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITextProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider>(py_obj, runtime_class)
        {
        }

        auto GetSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetVisibleRanges()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_visible_ranges")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RangeFromChild(winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "range_from_child")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RangeFromPoint(winrt::Windows::Foundation::Point param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "range_from_point")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DocumentRange()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "document_range")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SupportedTextSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "supported_text_selection")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::SupportedTextSelection>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITextProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITextProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITextProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITextProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITextProvider[] = {
        { "_assign_array_", _assign_array_ITextProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITextProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITextProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITextProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITextProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsITextProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITextProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextProvider};

    // ----- ITextProvider2 interface --------------------

    static PyObject* _new_ITextProvider2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider2>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextProvider2(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextProvider2_GetCaretRange(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider2", L"GetCaretRange", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                bool param0{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCaretRange(param0);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSelection();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_GetVisibleRanges(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"GetVisibleRanges", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetVisibleRanges();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_RangeFromAnnotation(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider2", L"RangeFromAnnotation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RangeFromAnnotation(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_RangeFromChild(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromChild", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RangeFromChild(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_RangeFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RangeFromPoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_get_DocumentRange(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"DocumentRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DocumentRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_get_SupportedTextSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITextProvider", L"SupportedTextSelection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedTextSelection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextProvider2[] = {
        { "get_caret_range", reinterpret_cast<PyCFunction>(ITextProvider2_GetCaretRange), METH_VARARGS, nullptr },
        { "get_selection", reinterpret_cast<PyCFunction>(ITextProvider2_GetSelection), METH_VARARGS, nullptr },
        { "get_visible_ranges", reinterpret_cast<PyCFunction>(ITextProvider2_GetVisibleRanges), METH_VARARGS, nullptr },
        { "range_from_annotation", reinterpret_cast<PyCFunction>(ITextProvider2_RangeFromAnnotation), METH_VARARGS, nullptr },
        { "range_from_child", reinterpret_cast<PyCFunction>(ITextProvider2_RangeFromChild), METH_VARARGS, nullptr },
        { "range_from_point", reinterpret_cast<PyCFunction>(ITextProvider2_RangeFromPoint), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITextProvider2[] = {
        { "document_range", reinterpret_cast<getter>(ITextProvider2_get_DocumentRange), nullptr, nullptr, nullptr },
        { "supported_text_selection", reinterpret_cast<getter>(ITextProvider2_get_SupportedTextSelection), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ITextProvider2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextProvider2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextProvider2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextProvider2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextProvider2) },
        { }};

    static PyType_Spec type_spec_ITextProvider2 = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITextProvider2",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextProvider2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextProvider2};

    struct ImplementsITextProvider2 : py::ImplementsInterfaceT<ImplementsITextProvider2, winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider2>
    {
        ImplementsITextProvider2() = delete;
        ImplementsITextProvider2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITextProvider2, winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider2>(py_obj, runtime_class)
        {
        }

        auto GetCaretRange(bool& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_caret_range")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param0 = py::convert_to<bool>(return_value.get(), 1);

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetVisibleRanges()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_visible_ranges")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RangeFromAnnotation(winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "range_from_annotation")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RangeFromChild(winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "range_from_child")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RangeFromPoint(winrt::Windows::Foundation::Point param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "range_from_point")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DocumentRange()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "document_range")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SupportedTextSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "supported_text_selection")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::SupportedTextSelection>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITextProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITextProvider2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITextProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITextProvider2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITextProvider2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITextProvider2[] = {
        { "_assign_array_", _assign_array_ITextProvider2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextProvider2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITextProvider2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITextProvider2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITextProvider2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITextProvider2) },
        { }};

    static PyType_Spec type_spec_ImplementsITextProvider2 = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITextProvider2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextProvider2};

    // ----- ITextRangeProvider interface --------------------

    static PyObject* _new_ITextRangeProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextRangeProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextRangeProvider_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.AddToSelection();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_Clone(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Clone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Clone();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_Compare(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Compare", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Compare(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_CompareEndpoints(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"CompareEndpoints", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CompareEndpoints(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_ExpandToEnclosingUnit(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"ExpandToEnclosingUnit", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextUnit>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ExpandToEnclosingUnit(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_FindAttribute(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"FindAttribute", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindAttribute(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_FindText(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"FindText", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindText(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetAttributeValue(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetAttributeValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAttributeValue(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetBoundingRectangles(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetBoundingRectangles", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<double> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetBoundingRectangles(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetChildren(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetChildren", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetChildren();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetEnclosingElement(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetEnclosingElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetEnclosingElement();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetText(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetText(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_Move(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Move", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Move(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_MoveEndpointByRange(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"MoveEndpointByRange", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.MoveEndpointByRange(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_MoveEndpointByUnit(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"MoveEndpointByUnit", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextUnit>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveEndpointByUnit(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveFromSelection();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ScrollIntoView(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_Select(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Select();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextRangeProvider[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(ITextRangeProvider_AddToSelection), METH_VARARGS, nullptr },
        { "clone", reinterpret_cast<PyCFunction>(ITextRangeProvider_Clone), METH_VARARGS, nullptr },
        { "compare", reinterpret_cast<PyCFunction>(ITextRangeProvider_Compare), METH_VARARGS, nullptr },
        { "compare_endpoints", reinterpret_cast<PyCFunction>(ITextRangeProvider_CompareEndpoints), METH_VARARGS, nullptr },
        { "expand_to_enclosing_unit", reinterpret_cast<PyCFunction>(ITextRangeProvider_ExpandToEnclosingUnit), METH_VARARGS, nullptr },
        { "find_attribute", reinterpret_cast<PyCFunction>(ITextRangeProvider_FindAttribute), METH_VARARGS, nullptr },
        { "find_text", reinterpret_cast<PyCFunction>(ITextRangeProvider_FindText), METH_VARARGS, nullptr },
        { "get_attribute_value", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetAttributeValue), METH_VARARGS, nullptr },
        { "get_bounding_rectangles", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetBoundingRectangles), METH_VARARGS, nullptr },
        { "get_children", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetChildren), METH_VARARGS, nullptr },
        { "get_enclosing_element", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetEnclosingElement), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetText), METH_VARARGS, nullptr },
        { "move", reinterpret_cast<PyCFunction>(ITextRangeProvider_Move), METH_VARARGS, nullptr },
        { "move_endpoint_by_range", reinterpret_cast<PyCFunction>(ITextRangeProvider_MoveEndpointByRange), METH_VARARGS, nullptr },
        { "move_endpoint_by_unit", reinterpret_cast<PyCFunction>(ITextRangeProvider_MoveEndpointByUnit), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(ITextRangeProvider_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ITextRangeProvider_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(ITextRangeProvider_Select), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITextRangeProvider[] = {
        { }};

    static PyType_Slot _type_slots_ITextRangeProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextRangeProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextRangeProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextRangeProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextRangeProvider) },
        { }};

    static PyType_Spec type_spec_ITextRangeProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITextRangeProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextRangeProvider};

    struct ImplementsITextRangeProvider : py::ImplementsInterfaceT<ImplementsITextRangeProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>
    {
        ImplementsITextRangeProvider() = delete;
        ImplementsITextRangeProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITextRangeProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(py_obj, runtime_class)
        {
        }

        auto AddToSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_to_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Clone()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "clone")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Compare(winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "compare")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CompareEndpoints(winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param0, winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider const& param1, winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "compare_endpoints")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ExpandToEnclosingUnit(winrt::Windows::UI::Xaml::Automation::Text::TextUnit param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "expand_to_enclosing_unit")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FindAttribute(int32_t param0, winrt::Windows::Foundation::IInspectable const& param1, bool param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "find_attribute")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FindText(winrt::hstring const& param0, bool param1, bool param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "find_text")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetAttributeValue(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_attribute_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetBoundingRectangles(winrt::com_array<double>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_bounding_rectangles")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<double, false>>(return_value.get(), 0);
                param0 = winrt::com_array<double>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetChildren()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_children")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetEnclosingElement()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_enclosing_element")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetText(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_text")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Move(winrt::Windows::UI::Xaml::Automation::Text::TextUnit param0, int32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveEndpointByRange(winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param0, winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider const& param1, winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_endpoint_by_range")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveEndpointByUnit(winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param0, winrt::Windows::UI::Xaml::Automation::Text::TextUnit param1, int32_t param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_endpoint_by_unit")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveFromSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_from_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ScrollIntoView(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "scroll_into_view")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Select()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "select")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITextRangeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextRangeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITextRangeProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITextRangeProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITextRangeProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITextRangeProvider[] = {
        { "_assign_array_", _assign_array_ITextRangeProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextRangeProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITextRangeProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITextRangeProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITextRangeProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITextRangeProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsITextRangeProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITextRangeProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextRangeProvider};

    // ----- ITextRangeProvider2 interface --------------------

    static PyObject* _new_ITextRangeProvider2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextRangeProvider2(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextRangeProvider2_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.AddToSelection();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_Clone(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Clone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Clone();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_Compare(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Compare", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Compare(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_CompareEndpoints(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"CompareEndpoints", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CompareEndpoints(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_ExpandToEnclosingUnit(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"ExpandToEnclosingUnit", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextUnit>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ExpandToEnclosingUnit(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_FindAttribute(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"FindAttribute", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindAttribute(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_FindText(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"FindText", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindText(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetAttributeValue(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetAttributeValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAttributeValue(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetBoundingRectangles(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetBoundingRectangles", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<double> param0{};

                {
                    auto _gil = release_gil();
                    self->obj.GetBoundingRectangles(param0);
                }

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }

                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetChildren(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetChildren", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetChildren();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetEnclosingElement(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetEnclosingElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetEnclosingElement();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetText(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetText(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_Move(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Move", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Move(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_MoveEndpointByRange(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"MoveEndpointByRange", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.MoveEndpointByRange(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_MoveEndpointByUnit(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"MoveEndpointByUnit", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Text::TextUnit>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MoveEndpointByUnit(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveFromSelection();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ScrollIntoView(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_Select(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Select();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_ShowContextMenu(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITextRangeProvider2", L"ShowContextMenu", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ShowContextMenu();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextRangeProvider2[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(ITextRangeProvider2_AddToSelection), METH_VARARGS, nullptr },
        { "clone", reinterpret_cast<PyCFunction>(ITextRangeProvider2_Clone), METH_VARARGS, nullptr },
        { "compare", reinterpret_cast<PyCFunction>(ITextRangeProvider2_Compare), METH_VARARGS, nullptr },
        { "compare_endpoints", reinterpret_cast<PyCFunction>(ITextRangeProvider2_CompareEndpoints), METH_VARARGS, nullptr },
        { "expand_to_enclosing_unit", reinterpret_cast<PyCFunction>(ITextRangeProvider2_ExpandToEnclosingUnit), METH_VARARGS, nullptr },
        { "find_attribute", reinterpret_cast<PyCFunction>(ITextRangeProvider2_FindAttribute), METH_VARARGS, nullptr },
        { "find_text", reinterpret_cast<PyCFunction>(ITextRangeProvider2_FindText), METH_VARARGS, nullptr },
        { "get_attribute_value", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetAttributeValue), METH_VARARGS, nullptr },
        { "get_bounding_rectangles", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetBoundingRectangles), METH_VARARGS, nullptr },
        { "get_children", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetChildren), METH_VARARGS, nullptr },
        { "get_enclosing_element", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetEnclosingElement), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetText), METH_VARARGS, nullptr },
        { "move", reinterpret_cast<PyCFunction>(ITextRangeProvider2_Move), METH_VARARGS, nullptr },
        { "move_endpoint_by_range", reinterpret_cast<PyCFunction>(ITextRangeProvider2_MoveEndpointByRange), METH_VARARGS, nullptr },
        { "move_endpoint_by_unit", reinterpret_cast<PyCFunction>(ITextRangeProvider2_MoveEndpointByUnit), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(ITextRangeProvider2_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ITextRangeProvider2_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(ITextRangeProvider2_Select), METH_VARARGS, nullptr },
        { "show_context_menu", reinterpret_cast<PyCFunction>(ITextRangeProvider2_ShowContextMenu), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITextRangeProvider2[] = {
        { }};

    static PyType_Slot _type_slots_ITextRangeProvider2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextRangeProvider2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextRangeProvider2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextRangeProvider2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextRangeProvider2) },
        { }};

    static PyType_Spec type_spec_ITextRangeProvider2 = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITextRangeProvider2",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextRangeProvider2};

    struct ImplementsITextRangeProvider2 : py::ImplementsInterfaceT<ImplementsITextRangeProvider2, winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2>
    {
        ImplementsITextRangeProvider2() = delete;
        ImplementsITextRangeProvider2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITextRangeProvider2, winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2>(py_obj, runtime_class)
        {
        }

        auto AddToSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_to_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Clone()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "clone")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Compare(winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "compare")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CompareEndpoints(winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param0, winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider const& param1, winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "compare_endpoints")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ExpandToEnclosingUnit(winrt::Windows::UI::Xaml::Automation::Text::TextUnit param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "expand_to_enclosing_unit")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FindAttribute(int32_t param0, winrt::Windows::Foundation::IInspectable const& param1, bool param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "find_attribute")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FindText(winrt::hstring const& param0, bool param1, bool param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "find_text")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetAttributeValue(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_attribute_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetBoundingRectangles(winrt::com_array<double>& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_bounding_rectangles")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto param0_buf = py::convert_to<py::pybuf_view<double, false>>(return_value.get(), 0);
                param0 = winrt::com_array<double>{param0_buf.begin(), param0_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetChildren()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_children")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple, false>>(return_value.get());
                return winrt::com_array<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetEnclosingElement()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_enclosing_element")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetText(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_text")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Move(winrt::Windows::UI::Xaml::Automation::Text::TextUnit param0, int32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveEndpointByRange(winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param0, winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider const& param1, winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_endpoint_by_range")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MoveEndpointByUnit(winrt::Windows::UI::Xaml::Automation::Text::TextPatternRangeEndpoint param0, winrt::Windows::UI::Xaml::Automation::Text::TextUnit param1, int32_t param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move_endpoint_by_unit")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<int32_t>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveFromSelection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_from_selection")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ScrollIntoView(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "scroll_into_view")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Select()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "select")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ShowContextMenu()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "show_context_menu")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITextRangeProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextRangeProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITextRangeProvider2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITextRangeProvider2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITextRangeProvider2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITextRangeProvider2[] = {
        { "_assign_array_", _assign_array_ITextRangeProvider2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextRangeProvider2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITextRangeProvider2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITextRangeProvider2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITextRangeProvider2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITextRangeProvider2) },
        { }};

    static PyType_Spec type_spec_ImplementsITextRangeProvider2 = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITextRangeProvider2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextRangeProvider2};

    // ----- IToggleProvider interface --------------------

    static PyObject* _new_IToggleProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IToggleProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IToggleProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IToggleProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IToggleProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IToggleProvider_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Provider::IToggleProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IToggleProvider", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Toggle();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IToggleProvider_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Provider::IToggleProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IToggleProvider", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ToggleState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IToggleProvider[] = {
        { "toggle", reinterpret_cast<PyCFunction>(IToggleProvider_Toggle), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IToggleProvider[] = {
        { "toggle_state", reinterpret_cast<getter>(IToggleProvider_get_ToggleState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IToggleProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IToggleProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IToggleProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IToggleProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IToggleProvider) },
        { }};

    static PyType_Spec type_spec_IToggleProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IToggleProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IToggleProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IToggleProvider};

    struct ImplementsIToggleProvider : py::ImplementsInterfaceT<ImplementsIToggleProvider, winrt::Windows::UI::Xaml::Automation::Provider::IToggleProvider>
    {
        ImplementsIToggleProvider() = delete;
        ImplementsIToggleProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIToggleProvider, winrt::Windows::UI::Xaml::Automation::Provider::IToggleProvider>(py_obj, runtime_class)
        {
        }

        auto Toggle()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "toggle")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ToggleState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "toggle_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::ToggleState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IToggleProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IToggleProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IToggleProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IToggleProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIToggleProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IToggleProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIToggleProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIToggleProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIToggleProvider[] = {
        { "_assign_array_", _assign_array_IToggleProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IToggleProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIToggleProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIToggleProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIToggleProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIToggleProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIToggleProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IToggleProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIToggleProvider};

    // ----- ITransformProvider interface --------------------

    static PyObject* _new_ITransformProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITransformProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITransformProvider_Move(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"Move", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Move(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_Resize(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"Resize", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Resize(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_Rotate(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"Rotate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Rotate(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_get_CanMove(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"CanMove");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanMove();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_get_CanResize(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"CanResize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanResize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_get_CanRotate(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"CanRotate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanRotate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITransformProvider[] = {
        { "move", reinterpret_cast<PyCFunction>(ITransformProvider_Move), METH_VARARGS, nullptr },
        { "resize", reinterpret_cast<PyCFunction>(ITransformProvider_Resize), METH_VARARGS, nullptr },
        { "rotate", reinterpret_cast<PyCFunction>(ITransformProvider_Rotate), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITransformProvider[] = {
        { "can_move", reinterpret_cast<getter>(ITransformProvider_get_CanMove), nullptr, nullptr, nullptr },
        { "can_resize", reinterpret_cast<getter>(ITransformProvider_get_CanResize), nullptr, nullptr, nullptr },
        { "can_rotate", reinterpret_cast<getter>(ITransformProvider_get_CanRotate), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ITransformProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITransformProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITransformProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITransformProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITransformProvider) },
        { }};

    static PyType_Spec type_spec_ITransformProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITransformProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITransformProvider};

    struct ImplementsITransformProvider : py::ImplementsInterfaceT<ImplementsITransformProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider>
    {
        ImplementsITransformProvider() = delete;
        ImplementsITransformProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITransformProvider, winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider>(py_obj, runtime_class)
        {
        }

        auto Move(double param0, double param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Resize(double param0, double param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "resize")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Rotate(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rotate")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanMove()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_move")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanResize()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_resize")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanRotate()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_rotate")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITransformProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITransformProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITransformProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITransformProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITransformProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITransformProvider[] = {
        { "_assign_array_", _assign_array_ITransformProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITransformProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITransformProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITransformProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITransformProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITransformProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsITransformProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITransformProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITransformProvider};

    // ----- ITransformProvider2 interface --------------------

    static PyObject* _new_ITransformProvider2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider2>::type_name);
        return nullptr;
    }

    static void _dealloc_ITransformProvider2(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITransformProvider2_Move(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"Move", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Move(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_Resize(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"Resize", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Resize(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_Rotate(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"Rotate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Rotate(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_Zoom(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider2", L"Zoom", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Zoom(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_ZoomByUnit(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider2", L"ZoomByUnit", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ZoomUnit>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ZoomByUnit(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_CanZoom(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider2", L"CanZoom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanZoom();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_MaxZoom(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider2", L"MaxZoom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxZoom();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_MinZoom(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider2", L"MinZoom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinZoom();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider2", L"ZoomLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ZoomLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_CanMove(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"CanMove");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanMove();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_CanResize(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"CanResize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanResize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_CanRotate(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.ITransformProvider", L"CanRotate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanRotate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITransformProvider2[] = {
        { "move", reinterpret_cast<PyCFunction>(ITransformProvider2_Move), METH_VARARGS, nullptr },
        { "resize", reinterpret_cast<PyCFunction>(ITransformProvider2_Resize), METH_VARARGS, nullptr },
        { "rotate", reinterpret_cast<PyCFunction>(ITransformProvider2_Rotate), METH_VARARGS, nullptr },
        { "zoom", reinterpret_cast<PyCFunction>(ITransformProvider2_Zoom), METH_VARARGS, nullptr },
        { "zoom_by_unit", reinterpret_cast<PyCFunction>(ITransformProvider2_ZoomByUnit), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ITransformProvider2[] = {
        { "can_zoom", reinterpret_cast<getter>(ITransformProvider2_get_CanZoom), nullptr, nullptr, nullptr },
        { "max_zoom", reinterpret_cast<getter>(ITransformProvider2_get_MaxZoom), nullptr, nullptr, nullptr },
        { "min_zoom", reinterpret_cast<getter>(ITransformProvider2_get_MinZoom), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(ITransformProvider2_get_ZoomLevel), nullptr, nullptr, nullptr },
        { "can_move", reinterpret_cast<getter>(ITransformProvider2_get_CanMove), nullptr, nullptr, nullptr },
        { "can_resize", reinterpret_cast<getter>(ITransformProvider2_get_CanResize), nullptr, nullptr, nullptr },
        { "can_rotate", reinterpret_cast<getter>(ITransformProvider2_get_CanRotate), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ITransformProvider2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITransformProvider2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITransformProvider2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITransformProvider2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITransformProvider2) },
        { }};

    static PyType_Spec type_spec_ITransformProvider2 = {
        "winrt._winrt_windows_ui_xaml_automation_provider._ITransformProvider2",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::ITransformProvider2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITransformProvider2};

    struct ImplementsITransformProvider2 : py::ImplementsInterfaceT<ImplementsITransformProvider2, winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider2>
    {
        ImplementsITransformProvider2() = delete;
        ImplementsITransformProvider2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsITransformProvider2, winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider2>(py_obj, runtime_class)
        {
        }

        auto Move(double param0, double param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "move")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Resize(double param0, double param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "resize")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Rotate(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "rotate")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Zoom(double param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "zoom")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ZoomByUnit(winrt::Windows::UI::Xaml::Automation::ZoomUnit param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "zoom_by_unit")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanZoom()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_zoom")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MaxZoom()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "max_zoom")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MinZoom()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "min_zoom")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ZoomLevel()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "zoom_level")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<double>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanMove()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_move")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanResize()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_resize")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanRotate()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_rotate")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ITransformProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITransformProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsITransformProvider2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::ITransformProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsITransformProvider2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsITransformProvider2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsITransformProvider2[] = {
        { "_assign_array_", _assign_array_ITransformProvider2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITransformProvider2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsITransformProvider2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsITransformProvider2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsITransformProvider2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsITransformProvider2) },
        { }};

    static PyType_Spec type_spec_ImplementsITransformProvider2 = {
        "winrt._winrt_windows_ui_xaml_automation_provider.ITransformProvider2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITransformProvider2};

    // ----- IValueProvider interface --------------------

    static PyObject* _new_IValueProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IValueProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IValueProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IValueProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IValueProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IValueProvider_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Provider::IValueProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IValueProvider", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetValue(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IValueProvider_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Provider::IValueProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IValueProvider", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsReadOnly();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IValueProvider_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Provider::IValueProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IValueProvider", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IValueProvider[] = {
        { "set_value", reinterpret_cast<PyCFunction>(IValueProvider_SetValue), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IValueProvider[] = {
        { "is_read_only", reinterpret_cast<getter>(IValueProvider_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IValueProvider_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IValueProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IValueProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IValueProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IValueProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IValueProvider) },
        { }};

    static PyType_Spec type_spec_IValueProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IValueProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IValueProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IValueProvider};

    struct ImplementsIValueProvider : py::ImplementsInterfaceT<ImplementsIValueProvider, winrt::Windows::UI::Xaml::Automation::Provider::IValueProvider>
    {
        ImplementsIValueProvider() = delete;
        ImplementsIValueProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIValueProvider, winrt::Windows::UI::Xaml::Automation::Provider::IValueProvider>(py_obj, runtime_class)
        {
        }

        auto SetValue(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsReadOnly()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_read_only")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Value()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "value")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IValueProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IValueProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IValueProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IValueProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIValueProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IValueProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIValueProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIValueProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIValueProvider[] = {
        { "_assign_array_", _assign_array_IValueProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IValueProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIValueProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIValueProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIValueProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIValueProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIValueProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IValueProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIValueProvider};

    // ----- IVirtualizedItemProvider interface --------------------

    static PyObject* _new_IVirtualizedItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IVirtualizedItemProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVirtualizedItemProvider_Realize(py::wrapper::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IVirtualizedItemProvider", L"Realize", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Realize();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVirtualizedItemProvider[] = {
        { "realize", reinterpret_cast<PyCFunction>(IVirtualizedItemProvider_Realize), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IVirtualizedItemProvider[] = {
        { }};

    static PyType_Slot _type_slots_IVirtualizedItemProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVirtualizedItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVirtualizedItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVirtualizedItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVirtualizedItemProvider) },
        { }};

    static PyType_Spec type_spec_IVirtualizedItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IVirtualizedItemProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVirtualizedItemProvider};

    struct ImplementsIVirtualizedItemProvider : py::ImplementsInterfaceT<ImplementsIVirtualizedItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>
    {
        ImplementsIVirtualizedItemProvider() = delete;
        ImplementsIVirtualizedItemProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVirtualizedItemProvider, winrt::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>(py_obj, runtime_class)
        {
        }

        auto Realize()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "realize")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IVirtualizedItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVirtualizedItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIVirtualizedItemProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVirtualizedItemProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVirtualizedItemProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVirtualizedItemProvider[] = {
        { "_assign_array_", _assign_array_IVirtualizedItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVirtualizedItemProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVirtualizedItemProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVirtualizedItemProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIVirtualizedItemProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVirtualizedItemProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIVirtualizedItemProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IVirtualizedItemProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVirtualizedItemProvider};

    // ----- IWindowProvider interface --------------------

    static PyObject* _new_IWindowProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IWindowProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Automation::Provider::IWindowProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IWindowProvider(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWindowProvider_Close(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_SetVisualState(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"SetVisualState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowVisualState>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetVisualState(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_WaitForInputIdle(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"WaitForInputIdle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.WaitForInputIdle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_InteractionState(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"InteractionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InteractionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_IsModal(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"IsModal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsModal();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_IsTopmost(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"IsTopmost");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTopmost();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_Maximizable(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"Maximizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Maximizable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_Minimizable(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"Minimizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Minimizable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_VisualState(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Provider.IWindowProvider", L"VisualState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VisualState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWindowProvider[] = {
        { "close", reinterpret_cast<PyCFunction>(IWindowProvider_Close), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(IWindowProvider_SetVisualState), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(IWindowProvider_WaitForInputIdle), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWindowProvider[] = {
        { "interaction_state", reinterpret_cast<getter>(IWindowProvider_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(IWindowProvider_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(IWindowProvider_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(IWindowProvider_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(IWindowProvider_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(IWindowProvider_get_VisualState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IWindowProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWindowProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWindowProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWindowProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWindowProvider) },
        { }};

    static PyType_Spec type_spec_IWindowProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider._IWindowProvider",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Provider::IWindowProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWindowProvider};

    struct ImplementsIWindowProvider : py::ImplementsInterfaceT<ImplementsIWindowProvider, winrt::Windows::UI::Xaml::Automation::Provider::IWindowProvider>
    {
        ImplementsIWindowProvider() = delete;
        ImplementsIWindowProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWindowProvider, winrt::Windows::UI::Xaml::Automation::Provider::IWindowProvider>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetVisualState(winrt::Windows::UI::Xaml::Automation::WindowVisualState param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_visual_state")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto WaitForInputIdle(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "wait_for_input_idle")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto InteractionState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "interaction_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowInteractionState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsModal()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_modal")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsTopmost()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_topmost")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Maximizable()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "maximizable")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Minimizable()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "minimizable")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VisualState()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "visual_state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowVisualState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWindowProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Provider::IWindowProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWindowProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Provider::IWindowProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWindowProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Automation::Provider::IWindowProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWindowProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWindowProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWindowProvider[] = {
        { "_assign_array_", _assign_array_IWindowProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWindowProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWindowProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWindowProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWindowProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWindowProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIWindowProvider = {
        "winrt._winrt_windows_ui_xaml_automation_provider.IWindowProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIWindowProvider};

    // ----- Windows.UI.Xaml.Automation.Provider Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Automation.Provider");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_automation_provider",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Automation::Provider

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_automation_provider(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Automation::Provider;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml")};
    if (!windows_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_DependencyObject_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "DependencyObject")};
    if (!windows_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle IRawElementProviderSimple_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!IRawElementProviderSimple_bases)
    {
        return nullptr;
    }

    py::pytype_handle IRawElementProviderSimple_type{py::register_python_type(module.get(), &type_spec_IRawElementProviderSimple, IRawElementProviderSimple_bases.get(), inspectable_meta_type)};
    if (!IRawElementProviderSimple_type)
    {
        return nullptr;
    }

    py::pytype_handle IAnnotationProvider_type{py::register_python_type(module.get(), &type_spec_IAnnotationProvider, object_bases.get(), nullptr)};
    if (!IAnnotationProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAnnotationProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIAnnotationProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIAnnotationProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAnnotationProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ICustomNavigationProvider_type{py::register_python_type(module.get(), &type_spec_ICustomNavigationProvider, object_bases.get(), nullptr)};
    if (!ICustomNavigationProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICustomNavigationProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsICustomNavigationProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsICustomNavigationProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICustomNavigationProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IDockProvider_type{py::register_python_type(module.get(), &type_spec_IDockProvider, object_bases.get(), nullptr)};
    if (!IDockProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIDockProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIDockProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIDockProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIDockProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IDragProvider_type{py::register_python_type(module.get(), &type_spec_IDragProvider, object_bases.get(), nullptr)};
    if (!IDragProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIDragProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIDragProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIDragProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIDragProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IDropTargetProvider_type{py::register_python_type(module.get(), &type_spec_IDropTargetProvider, object_bases.get(), nullptr)};
    if (!IDropTargetProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIDropTargetProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIDropTargetProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIDropTargetProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIDropTargetProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IExpandCollapseProvider_type{py::register_python_type(module.get(), &type_spec_IExpandCollapseProvider, object_bases.get(), nullptr)};
    if (!IExpandCollapseProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIExpandCollapseProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIExpandCollapseProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIExpandCollapseProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIExpandCollapseProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IGridItemProvider_type{py::register_python_type(module.get(), &type_spec_IGridItemProvider, object_bases.get(), nullptr)};
    if (!IGridItemProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGridItemProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIGridItemProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIGridItemProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGridItemProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IGridProvider_type{py::register_python_type(module.get(), &type_spec_IGridProvider, object_bases.get(), nullptr)};
    if (!IGridProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGridProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIGridProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIGridProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGridProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IInvokeProvider_type{py::register_python_type(module.get(), &type_spec_IInvokeProvider, object_bases.get(), nullptr)};
    if (!IInvokeProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIInvokeProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIInvokeProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIInvokeProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIInvokeProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IItemContainerProvider_type{py::register_python_type(module.get(), &type_spec_IItemContainerProvider, object_bases.get(), nullptr)};
    if (!IItemContainerProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIItemContainerProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIItemContainerProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIItemContainerProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIItemContainerProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IMultipleViewProvider_type{py::register_python_type(module.get(), &type_spec_IMultipleViewProvider, object_bases.get(), nullptr)};
    if (!IMultipleViewProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIMultipleViewProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIMultipleViewProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIMultipleViewProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIMultipleViewProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IObjectModelProvider_type{py::register_python_type(module.get(), &type_spec_IObjectModelProvider, object_bases.get(), nullptr)};
    if (!IObjectModelProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIObjectModelProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIObjectModelProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIObjectModelProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIObjectModelProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IRangeValueProvider_type{py::register_python_type(module.get(), &type_spec_IRangeValueProvider, object_bases.get(), nullptr)};
    if (!IRangeValueProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIRangeValueProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIRangeValueProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIRangeValueProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIRangeValueProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IScrollItemProvider_type{py::register_python_type(module.get(), &type_spec_IScrollItemProvider, object_bases.get(), nullptr)};
    if (!IScrollItemProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIScrollItemProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIScrollItemProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIScrollItemProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIScrollItemProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IScrollProvider_type{py::register_python_type(module.get(), &type_spec_IScrollProvider, object_bases.get(), nullptr)};
    if (!IScrollProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIScrollProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIScrollProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIScrollProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIScrollProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISelectionItemProvider_type{py::register_python_type(module.get(), &type_spec_ISelectionItemProvider, object_bases.get(), nullptr)};
    if (!ISelectionItemProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISelectionItemProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsISelectionItemProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsISelectionItemProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISelectionItemProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISelectionProvider_type{py::register_python_type(module.get(), &type_spec_ISelectionProvider, object_bases.get(), nullptr)};
    if (!ISelectionProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISelectionProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsISelectionProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsISelectionProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISelectionProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISpreadsheetItemProvider_type{py::register_python_type(module.get(), &type_spec_ISpreadsheetItemProvider, object_bases.get(), nullptr)};
    if (!ISpreadsheetItemProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISpreadsheetItemProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsISpreadsheetItemProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsISpreadsheetItemProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISpreadsheetItemProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISpreadsheetProvider_type{py::register_python_type(module.get(), &type_spec_ISpreadsheetProvider, object_bases.get(), nullptr)};
    if (!ISpreadsheetProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISpreadsheetProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsISpreadsheetProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsISpreadsheetProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISpreadsheetProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStylesProvider_type{py::register_python_type(module.get(), &type_spec_IStylesProvider, object_bases.get(), nullptr)};
    if (!IStylesProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStylesProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIStylesProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIStylesProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStylesProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISynchronizedInputProvider_type{py::register_python_type(module.get(), &type_spec_ISynchronizedInputProvider, object_bases.get(), nullptr)};
    if (!ISynchronizedInputProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISynchronizedInputProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsISynchronizedInputProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsISynchronizedInputProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISynchronizedInputProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITableItemProvider_type{py::register_python_type(module.get(), &type_spec_ITableItemProvider, object_bases.get(), nullptr)};
    if (!ITableItemProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITableItemProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsITableItemProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsITableItemProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITableItemProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITableProvider_type{py::register_python_type(module.get(), &type_spec_ITableProvider, object_bases.get(), nullptr)};
    if (!ITableProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITableProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsITableProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsITableProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITableProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextChildProvider_type{py::register_python_type(module.get(), &type_spec_ITextChildProvider, object_bases.get(), nullptr)};
    if (!ITextChildProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextChildProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsITextChildProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsITextChildProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextChildProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextEditProvider_type{py::register_python_type(module.get(), &type_spec_ITextEditProvider, object_bases.get(), nullptr)};
    if (!ITextEditProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextEditProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsITextEditProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsITextEditProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextEditProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextProvider_type{py::register_python_type(module.get(), &type_spec_ITextProvider, object_bases.get(), nullptr)};
    if (!ITextProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsITextProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsITextProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextProvider2_type{py::register_python_type(module.get(), &type_spec_ITextProvider2, object_bases.get(), nullptr)};
    if (!ITextProvider2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextProvider2_type{py::register_python_type(module.get(), &type_spec_ImplementsITextProvider2, nullptr, inspectable_meta_type)};
    if (!ImplementsITextProvider2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextProvider2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextRangeProvider_type{py::register_python_type(module.get(), &type_spec_ITextRangeProvider, object_bases.get(), nullptr)};
    if (!ITextRangeProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextRangeProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsITextRangeProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsITextRangeProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextRangeProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextRangeProvider2_type{py::register_python_type(module.get(), &type_spec_ITextRangeProvider2, object_bases.get(), nullptr)};
    if (!ITextRangeProvider2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextRangeProvider2_type{py::register_python_type(module.get(), &type_spec_ImplementsITextRangeProvider2, nullptr, inspectable_meta_type)};
    if (!ImplementsITextRangeProvider2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextRangeProvider2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IToggleProvider_type{py::register_python_type(module.get(), &type_spec_IToggleProvider, object_bases.get(), nullptr)};
    if (!IToggleProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIToggleProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIToggleProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIToggleProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIToggleProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITransformProvider_type{py::register_python_type(module.get(), &type_spec_ITransformProvider, object_bases.get(), nullptr)};
    if (!ITransformProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITransformProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsITransformProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsITransformProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITransformProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITransformProvider2_type{py::register_python_type(module.get(), &type_spec_ITransformProvider2, object_bases.get(), nullptr)};
    if (!ITransformProvider2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITransformProvider2_type{py::register_python_type(module.get(), &type_spec_ImplementsITransformProvider2, nullptr, inspectable_meta_type)};
    if (!ImplementsITransformProvider2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITransformProvider2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IValueProvider_type{py::register_python_type(module.get(), &type_spec_IValueProvider, object_bases.get(), nullptr)};
    if (!IValueProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIValueProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIValueProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIValueProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIValueProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVirtualizedItemProvider_type{py::register_python_type(module.get(), &type_spec_IVirtualizedItemProvider, object_bases.get(), nullptr)};
    if (!IVirtualizedItemProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVirtualizedItemProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIVirtualizedItemProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIVirtualizedItemProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVirtualizedItemProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWindowProvider_type{py::register_python_type(module.get(), &type_spec_IWindowProvider, object_bases.get(), nullptr)};
    if (!IWindowProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWindowProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIWindowProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIWindowProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWindowProvider_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
