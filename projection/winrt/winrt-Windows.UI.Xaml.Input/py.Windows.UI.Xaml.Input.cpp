// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Input.h"

namespace py::cpp::Windows::UI::Xaml::Input
{
    // ----- AccessKeyDisplayDismissedEventArgs class --------------------

    static PyObject* _new_AccessKeyDisplayDismissedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AccessKeyDisplayDismissedEventArgs(py::wrapper::Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AccessKeyDisplayDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessKeyDisplayDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessKeyDisplayDismissedEventArgs[] = {
        { "_assign_array_", _assign_array_AccessKeyDisplayDismissedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessKeyDisplayDismissedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AccessKeyDisplayDismissedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_AccessKeyDisplayDismissedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessKeyDisplayDismissedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessKeyDisplayDismissedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessKeyDisplayDismissedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessKeyDisplayDismissedEventArgs) },
        { }};

    static PyType_Spec type_spec_AccessKeyDisplayDismissedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.AccessKeyDisplayDismissedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessKeyDisplayDismissedEventArgs};

    // ----- AccessKeyDisplayRequestedEventArgs class --------------------

    static PyObject* _new_AccessKeyDisplayRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AccessKeyDisplayRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccessKeyDisplayRequestedEventArgs_get_PressedKeys(py::wrapper::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.AccessKeyDisplayRequestedEventArgs", L"PressedKeys");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PressedKeys();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccessKeyDisplayRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessKeyDisplayRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessKeyDisplayRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_AccessKeyDisplayRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessKeyDisplayRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AccessKeyDisplayRequestedEventArgs[] = {
        { "pressed_keys", reinterpret_cast<getter>(AccessKeyDisplayRequestedEventArgs_get_PressedKeys), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AccessKeyDisplayRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessKeyDisplayRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessKeyDisplayRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessKeyDisplayRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessKeyDisplayRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_AccessKeyDisplayRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.AccessKeyDisplayRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessKeyDisplayRequestedEventArgs};

    // ----- AccessKeyInvokedEventArgs class --------------------

    static PyObject* _new_AccessKeyInvokedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AccessKeyInvokedEventArgs(py::wrapper::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccessKeyInvokedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.AccessKeyInvokedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccessKeyInvokedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.AccessKeyInvokedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AccessKeyInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessKeyInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessKeyInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_AccessKeyInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessKeyInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AccessKeyInvokedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(AccessKeyInvokedEventArgs_get_Handled), reinterpret_cast<setter>(AccessKeyInvokedEventArgs_put_Handled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AccessKeyInvokedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessKeyInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessKeyInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessKeyInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessKeyInvokedEventArgs) },
        { }};

    static PyType_Spec type_spec_AccessKeyInvokedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.AccessKeyInvokedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessKeyInvokedEventArgs};

    // ----- AccessKeyManager class --------------------

    static PyObject* _new_AccessKeyManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::AccessKeyManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::AccessKeyManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AccessKeyManager(py::wrapper::Windows::UI::Xaml::Input::AccessKeyManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccessKeyManager_ExitDisplayMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.AccessKeyManager", L"ExitDisplayMode", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    winrt::Windows::UI::Xaml::Input::AccessKeyManager::ExitDisplayMode();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessKeyManager_get_IsDisplayModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.AccessKeyManager", L"IsDisplayModeEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::AccessKeyManager::IsDisplayModeEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessKeyManager_get_AreKeyTipsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.AccessKeyManager", L"AreKeyTipsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::AccessKeyManager::AreKeyTipsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccessKeyManager_put_AreKeyTipsEnabled(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.AccessKeyManager", L"AreKeyTipsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::Xaml::Input::AccessKeyManager::AreKeyTipsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccessKeyManager_add_IsDisplayModeEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.AccessKeyManager", L"IsDisplayModeEnabledChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::AccessKeyManager::IsDisplayModeEnabledChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessKeyManager_remove_IsDisplayModeEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.AccessKeyManager", L"IsDisplayModeEnabledChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::Xaml::Input::AccessKeyManager::IsDisplayModeEnabledChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccessKeyManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::AccessKeyManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessKeyManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::AccessKeyManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessKeyManager[] = {
        { "_assign_array_", _assign_array_AccessKeyManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessKeyManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AccessKeyManager[] = {
        { }};

    static PyType_Slot _type_slots_AccessKeyManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessKeyManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessKeyManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessKeyManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessKeyManager) },
        { }};

    static PyType_Spec type_spec_AccessKeyManager = {
        "winrt._winrt_windows_ui_xaml_input.AccessKeyManager",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::AccessKeyManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessKeyManager};

    static PyGetSetDef getset_AccessKeyManager_Static[] = {
        { "is_display_mode_enabled", reinterpret_cast<getter>(AccessKeyManager_get_IsDisplayModeEnabled), nullptr, nullptr, nullptr },
        { "are_key_tips_enabled", reinterpret_cast<getter>(AccessKeyManager_get_AreKeyTipsEnabled), reinterpret_cast<setter>(AccessKeyManager_put_AreKeyTipsEnabled), nullptr, nullptr },
        { }};

    static PyMethodDef methods_AccessKeyManager_Static[] = {
        { "exit_display_mode", reinterpret_cast<PyCFunction>(AccessKeyManager_ExitDisplayMode), METH_VARARGS, nullptr },
        { "add_is_display_mode_enabled_changed", reinterpret_cast<PyCFunction>(AccessKeyManager_add_IsDisplayModeEnabledChanged), METH_O, nullptr },
        { "remove_is_display_mode_enabled_changed", reinterpret_cast<PyCFunction>(AccessKeyManager_remove_IsDisplayModeEnabledChanged), METH_O, nullptr },
        { }};

    static PyType_Slot type_slots_AccessKeyManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AccessKeyManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AccessKeyManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AccessKeyManager_Static = {
        "winrt._winrt_windows_ui_xaml_input.AccessKeyManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AccessKeyManager_Static};

    // ----- CanExecuteRequestedEventArgs class --------------------

    static PyObject* _new_CanExecuteRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CanExecuteRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CanExecuteRequestedEventArgs_get_CanExecute(py::wrapper::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.CanExecuteRequestedEventArgs", L"CanExecute");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanExecute();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CanExecuteRequestedEventArgs_put_CanExecute(py::wrapper::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.CanExecuteRequestedEventArgs", L"CanExecute");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanExecute(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CanExecuteRequestedEventArgs_get_Parameter(py::wrapper::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.CanExecuteRequestedEventArgs", L"Parameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Parameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CanExecuteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CanExecuteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CanExecuteRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CanExecuteRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CanExecuteRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CanExecuteRequestedEventArgs[] = {
        { "can_execute", reinterpret_cast<getter>(CanExecuteRequestedEventArgs_get_CanExecute), reinterpret_cast<setter>(CanExecuteRequestedEventArgs_put_CanExecute), nullptr, nullptr },
        { "parameter", reinterpret_cast<getter>(CanExecuteRequestedEventArgs_get_Parameter), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CanExecuteRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CanExecuteRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CanExecuteRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CanExecuteRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CanExecuteRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_CanExecuteRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.CanExecuteRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CanExecuteRequestedEventArgs};

    // ----- CharacterReceivedRoutedEventArgs class --------------------

    static PyObject* _new_CharacterReceivedRoutedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CharacterReceivedRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CharacterReceivedRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.CharacterReceivedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CharacterReceivedRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.CharacterReceivedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CharacterReceivedRoutedEventArgs_get_Character(py::wrapper::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.CharacterReceivedRoutedEventArgs", L"Character");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Character();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CharacterReceivedRoutedEventArgs_get_KeyStatus(py::wrapper::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.CharacterReceivedRoutedEventArgs", L"KeyStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CharacterReceivedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CharacterReceivedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CharacterReceivedRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_CharacterReceivedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CharacterReceivedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CharacterReceivedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CharacterReceivedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(CharacterReceivedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "character", reinterpret_cast<getter>(CharacterReceivedRoutedEventArgs_get_Character), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(CharacterReceivedRoutedEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CharacterReceivedRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CharacterReceivedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CharacterReceivedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CharacterReceivedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CharacterReceivedRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_CharacterReceivedRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.CharacterReceivedRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CharacterReceivedRoutedEventArgs};

    // ----- ContextRequestedEventArgs class --------------------

    static PyObject* _new_ContextRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::ContextRequestedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContextRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Input::ContextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContextRequestedEventArgs_TryGetPosition(py::wrapper::Windows::UI::Xaml::Input::ContextRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.ContextRequestedEventArgs", L"TryGetPosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                winrt::Windows::Foundation::Point param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetPosition(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContextRequestedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::ContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ContextRequestedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContextRequestedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::ContextRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ContextRequestedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ContextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ContextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContextRequestedEventArgs[] = {
        { "try_get_position", reinterpret_cast<PyCFunction>(ContextRequestedEventArgs_TryGetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContextRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ContextRequestedEventArgs_get_Handled), reinterpret_cast<setter>(ContextRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContextRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContextRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContextRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.ContextRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ContextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContextRequestedEventArgs};

    // ----- DoubleTappedRoutedEventArgs class --------------------

    static PyObject* _new_DoubleTappedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DoubleTappedRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DoubleTappedRoutedEventArgs_GetPosition(py::wrapper::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.DoubleTappedRoutedEventArgs", L"GetPosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPosition(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleTappedRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.DoubleTappedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleTappedRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.DoubleTappedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleTappedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.DoubleTappedRoutedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DoubleTappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DoubleTappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DoubleTappedRoutedEventArgs[] = {
        { "get_position", reinterpret_cast<PyCFunction>(DoubleTappedRoutedEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DoubleTappedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DoubleTappedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DoubleTappedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DoubleTappedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(DoubleTappedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(DoubleTappedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DoubleTappedRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DoubleTappedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DoubleTappedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DoubleTappedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DoubleTappedRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_DoubleTappedRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.DoubleTappedRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DoubleTappedRoutedEventArgs};

    // ----- ExecuteRequestedEventArgs class --------------------

    static PyObject* _new_ExecuteRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::ExecuteRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::ExecuteRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ExecuteRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Input::ExecuteRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExecuteRequestedEventArgs_get_Parameter(py::wrapper::Windows::UI::Xaml::Input::ExecuteRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ExecuteRequestedEventArgs", L"Parameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Parameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExecuteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ExecuteRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExecuteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ExecuteRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExecuteRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ExecuteRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExecuteRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ExecuteRequestedEventArgs[] = {
        { "parameter", reinterpret_cast<getter>(ExecuteRequestedEventArgs_get_Parameter), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ExecuteRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExecuteRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExecuteRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExecuteRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExecuteRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_ExecuteRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.ExecuteRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ExecuteRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExecuteRequestedEventArgs};

    // ----- FindNextElementOptions class --------------------

    static PyObject* _new_FindNextElementOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::FindNextElementOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FindNextElementOptions(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FindNextElementOptions_get_XYFocusNavigationStrategyOverride(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FindNextElementOptions", L"XYFocusNavigationStrategyOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusNavigationStrategyOverride();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindNextElementOptions_put_XYFocusNavigationStrategyOverride(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FindNextElementOptions", L"XYFocusNavigationStrategyOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategyOverride>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusNavigationStrategyOverride(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindNextElementOptions_get_SearchRoot(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FindNextElementOptions", L"SearchRoot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SearchRoot();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindNextElementOptions_put_SearchRoot(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FindNextElementOptions", L"SearchRoot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.SearchRoot(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindNextElementOptions_get_HintRect(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FindNextElementOptions", L"HintRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HintRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindNextElementOptions_put_HintRect(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FindNextElementOptions", L"HintRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            {
                auto _gil = release_gil();
                self->obj.HintRect(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindNextElementOptions_get_ExclusionRect(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FindNextElementOptions", L"ExclusionRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExclusionRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindNextElementOptions_put_ExclusionRect(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FindNextElementOptions", L"ExclusionRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExclusionRect(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FindNextElementOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::FindNextElementOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FindNextElementOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::FindNextElementOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FindNextElementOptions[] = {
        { "_assign_array_", _assign_array_FindNextElementOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FindNextElementOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FindNextElementOptions[] = {
        { "x_y_focus_navigation_strategy_override", reinterpret_cast<getter>(FindNextElementOptions_get_XYFocusNavigationStrategyOverride), reinterpret_cast<setter>(FindNextElementOptions_put_XYFocusNavigationStrategyOverride), nullptr, nullptr },
        { "search_root", reinterpret_cast<getter>(FindNextElementOptions_get_SearchRoot), reinterpret_cast<setter>(FindNextElementOptions_put_SearchRoot), nullptr, nullptr },
        { "hint_rect", reinterpret_cast<getter>(FindNextElementOptions_get_HintRect), reinterpret_cast<setter>(FindNextElementOptions_put_HintRect), nullptr, nullptr },
        { "exclusion_rect", reinterpret_cast<getter>(FindNextElementOptions_get_ExclusionRect), reinterpret_cast<setter>(FindNextElementOptions_put_ExclusionRect), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FindNextElementOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FindNextElementOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FindNextElementOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FindNextElementOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FindNextElementOptions) },
        { }};

    static PyType_Spec type_spec_FindNextElementOptions = {
        "winrt._winrt_windows_ui_xaml_input.FindNextElementOptions",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::FindNextElementOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FindNextElementOptions};

    // ----- FocusManager class --------------------

    static PyObject* _new_FocusManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::FocusManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::FocusManager>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusManager(py::wrapper::Windows::UI::Xaml::Input::FocusManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusManager_FindFirstFocusableElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"FindFirstFocusableElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::FindFirstFocusableElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_FindLastFocusableElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"FindLastFocusableElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::FindLastFocusableElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_FindNextElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"FindNextElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::FocusNavigationDirection>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::FindNextElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_FindNextElementWithOptions(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"FindNextElement", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::FocusNavigationDirection>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Input::FindNextElementOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::FindNextElement(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_FindNextFocusableElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"FindNextFocusableElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::FocusNavigationDirection>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::FindNextFocusableElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_FindNextFocusableElementWithHint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"FindNextFocusableElement", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::FocusNavigationDirection>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::FindNextFocusableElement(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_GetFocusedElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"GetFocusedElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::GetFocusedElement();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"GetFocusedElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::XamlRoot>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::GetFocusedElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_TryFocusAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"TryFocusAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::FocusState>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::TryFocusAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_TryMoveFocus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"TryMoveFocus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::FocusNavigationDirection>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::TryMoveFocus(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_TryMoveFocusAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"TryMoveFocusAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::FocusNavigationDirection>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::TryMoveFocusAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_TryMoveFocusWithOptions(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"TryMoveFocus", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::FocusNavigationDirection>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Input::FindNextElementOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::TryMoveFocus(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_TryMoveFocusWithOptionsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.FocusManager", L"TryMoveFocusAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::FocusNavigationDirection>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Input::FindNextElementOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Xaml::Input::FocusManager::TryMoveFocusAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusManager_add_GettingFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.FocusManager", L"GettingFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::Xaml::Input::GettingFocusEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::FocusManager::GettingFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_remove_GettingFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.FocusManager", L"GettingFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::Xaml::Input::FocusManager::GettingFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_add_GotFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.FocusManager", L"GotFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::FocusManager::GotFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_remove_GotFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.FocusManager", L"GotFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::Xaml::Input::FocusManager::GotFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_add_LosingFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.FocusManager", L"LosingFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::Xaml::Input::LosingFocusEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::FocusManager::LosingFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_remove_LosingFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.FocusManager", L"LosingFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::Xaml::Input::FocusManager::LosingFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_add_LostFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.FocusManager", L"LostFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::FocusManager::LostFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManager_remove_LostFocus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.FocusManager", L"LostFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::Xaml::Input::FocusManager::LostFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::FocusManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::FocusManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusManager[] = {
        { "_assign_array_", _assign_array_FocusManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusManager[] = {
        { }};

    static PyType_Slot _type_slots_FocusManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusManager) },
        { }};

    static PyType_Spec type_spec_FocusManager = {
        "winrt._winrt_windows_ui_xaml_input.FocusManager",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::FocusManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusManager};

    static PyGetSetDef getset_FocusManager_Static[] = {
        { }};

    static PyMethodDef methods_FocusManager_Static[] = {
        { "find_first_focusable_element", reinterpret_cast<PyCFunction>(FocusManager_FindFirstFocusableElement), METH_VARARGS, nullptr },
        { "find_last_focusable_element", reinterpret_cast<PyCFunction>(FocusManager_FindLastFocusableElement), METH_VARARGS, nullptr },
        { "find_next_element", reinterpret_cast<PyCFunction>(FocusManager_FindNextElement), METH_VARARGS, nullptr },
        { "find_next_element_with_options", reinterpret_cast<PyCFunction>(FocusManager_FindNextElementWithOptions), METH_VARARGS, nullptr },
        { "find_next_focusable_element", reinterpret_cast<PyCFunction>(FocusManager_FindNextFocusableElement), METH_VARARGS, nullptr },
        { "find_next_focusable_element_with_hint", reinterpret_cast<PyCFunction>(FocusManager_FindNextFocusableElementWithHint), METH_VARARGS, nullptr },
        { "get_focused_element", reinterpret_cast<PyCFunction>(FocusManager_GetFocusedElement), METH_VARARGS, nullptr },
        { "try_focus_async", reinterpret_cast<PyCFunction>(FocusManager_TryFocusAsync), METH_VARARGS, nullptr },
        { "try_move_focus", reinterpret_cast<PyCFunction>(FocusManager_TryMoveFocus), METH_VARARGS, nullptr },
        { "try_move_focus_async", reinterpret_cast<PyCFunction>(FocusManager_TryMoveFocusAsync), METH_VARARGS, nullptr },
        { "try_move_focus_with_options", reinterpret_cast<PyCFunction>(FocusManager_TryMoveFocusWithOptions), METH_VARARGS, nullptr },
        { "try_move_focus_with_options_async", reinterpret_cast<PyCFunction>(FocusManager_TryMoveFocusWithOptionsAsync), METH_VARARGS, nullptr },
        { "add_getting_focus", reinterpret_cast<PyCFunction>(FocusManager_add_GettingFocus), METH_O, nullptr },
        { "remove_getting_focus", reinterpret_cast<PyCFunction>(FocusManager_remove_GettingFocus), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(FocusManager_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(FocusManager_remove_GotFocus), METH_O, nullptr },
        { "add_losing_focus", reinterpret_cast<PyCFunction>(FocusManager_add_LosingFocus), METH_O, nullptr },
        { "remove_losing_focus", reinterpret_cast<PyCFunction>(FocusManager_remove_LosingFocus), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(FocusManager_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(FocusManager_remove_LostFocus), METH_O, nullptr },
        { }};

    static PyType_Slot type_slots_FocusManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FocusManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FocusManager_Static) },
        { }
    };

    static PyType_Spec type_spec_FocusManager_Static = {
        "winrt._winrt_windows_ui_xaml_input.FocusManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FocusManager_Static};

    // ----- FocusManagerGotFocusEventArgs class --------------------

    static PyObject* _new_FocusManagerGotFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusManagerGotFocusEventArgs(py::wrapper::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusManagerGotFocusEventArgs_get_CorrelationId(py::wrapper::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FocusManagerGotFocusEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CorrelationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManagerGotFocusEventArgs_get_NewFocusedElement(py::wrapper::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FocusManagerGotFocusEventArgs", L"NewFocusedElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewFocusedElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusManagerGotFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusManagerGotFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusManagerGotFocusEventArgs[] = {
        { "_assign_array_", _assign_array_FocusManagerGotFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusManagerGotFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusManagerGotFocusEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(FocusManagerGotFocusEventArgs_get_CorrelationId), nullptr, nullptr, nullptr },
        { "new_focused_element", reinterpret_cast<getter>(FocusManagerGotFocusEventArgs_get_NewFocusedElement), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FocusManagerGotFocusEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusManagerGotFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusManagerGotFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusManagerGotFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusManagerGotFocusEventArgs) },
        { }};

    static PyType_Spec type_spec_FocusManagerGotFocusEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.FocusManagerGotFocusEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::FocusManagerGotFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusManagerGotFocusEventArgs};

    // ----- FocusManagerLostFocusEventArgs class --------------------

    static PyObject* _new_FocusManagerLostFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusManagerLostFocusEventArgs(py::wrapper::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusManagerLostFocusEventArgs_get_CorrelationId(py::wrapper::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FocusManagerLostFocusEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CorrelationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusManagerLostFocusEventArgs_get_OldFocusedElement(py::wrapper::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FocusManagerLostFocusEventArgs", L"OldFocusedElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldFocusedElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusManagerLostFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusManagerLostFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusManagerLostFocusEventArgs[] = {
        { "_assign_array_", _assign_array_FocusManagerLostFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusManagerLostFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusManagerLostFocusEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(FocusManagerLostFocusEventArgs_get_CorrelationId), nullptr, nullptr, nullptr },
        { "old_focused_element", reinterpret_cast<getter>(FocusManagerLostFocusEventArgs_get_OldFocusedElement), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FocusManagerLostFocusEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusManagerLostFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusManagerLostFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusManagerLostFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusManagerLostFocusEventArgs) },
        { }};

    static PyType_Spec type_spec_FocusManagerLostFocusEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.FocusManagerLostFocusEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::FocusManagerLostFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusManagerLostFocusEventArgs};

    // ----- FocusMovementResult class --------------------

    static PyObject* _new_FocusMovementResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::FocusMovementResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::FocusMovementResult>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusMovementResult(py::wrapper::Windows::UI::Xaml::Input::FocusMovementResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusMovementResult_get_Succeeded(py::wrapper::Windows::UI::Xaml::Input::FocusMovementResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.FocusMovementResult", L"Succeeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Succeeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusMovementResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::FocusMovementResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusMovementResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::FocusMovementResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusMovementResult[] = {
        { "_assign_array_", _assign_array_FocusMovementResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusMovementResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusMovementResult[] = {
        { "succeeded", reinterpret_cast<getter>(FocusMovementResult_get_Succeeded), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FocusMovementResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusMovementResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusMovementResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusMovementResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusMovementResult) },
        { }};

    static PyType_Spec type_spec_FocusMovementResult = {
        "winrt._winrt_windows_ui_xaml_input.FocusMovementResult",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::FocusMovementResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusMovementResult};

    // ----- GettingFocusEventArgs class --------------------

    static PyObject* _new_GettingFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::GettingFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::GettingFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GettingFocusEventArgs(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GettingFocusEventArgs_TryCancel(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"TryCancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCancel();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_TrySetNewFocusedElement(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"TrySetNewFocusedElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySetNewFocusedElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_NewFocusedElement(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"NewFocusedElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewFocusedElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GettingFocusEventArgs_put_NewFocusedElement(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"NewFocusedElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.NewFocusedElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GettingFocusEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GettingFocusEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GettingFocusEventArgs_get_Cancel(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GettingFocusEventArgs_put_Cancel(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GettingFocusEventArgs_get_Direction(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Direction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_FocusState(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"FocusState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FocusState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_InputDevice(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"InputDevice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputDevice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_OldFocusedElement(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"OldFocusedElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldFocusedElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GettingFocusEventArgs_get_CorrelationId(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.GettingFocusEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CorrelationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GettingFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::GettingFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GettingFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::GettingFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GettingFocusEventArgs[] = {
        { "try_cancel", reinterpret_cast<PyCFunction>(GettingFocusEventArgs_TryCancel), METH_VARARGS, nullptr },
        { "try_set_new_focused_element", reinterpret_cast<PyCFunction>(GettingFocusEventArgs_TrySetNewFocusedElement), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GettingFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GettingFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GettingFocusEventArgs[] = {
        { "new_focused_element", reinterpret_cast<getter>(GettingFocusEventArgs_get_NewFocusedElement), reinterpret_cast<setter>(GettingFocusEventArgs_put_NewFocusedElement), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(GettingFocusEventArgs_get_Handled), reinterpret_cast<setter>(GettingFocusEventArgs_put_Handled), nullptr, nullptr },
        { "cancel", reinterpret_cast<getter>(GettingFocusEventArgs_get_Cancel), reinterpret_cast<setter>(GettingFocusEventArgs_put_Cancel), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(GettingFocusEventArgs_get_Direction), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(GettingFocusEventArgs_get_FocusState), nullptr, nullptr, nullptr },
        { "input_device", reinterpret_cast<getter>(GettingFocusEventArgs_get_InputDevice), nullptr, nullptr, nullptr },
        { "old_focused_element", reinterpret_cast<getter>(GettingFocusEventArgs_get_OldFocusedElement), nullptr, nullptr, nullptr },
        { "correlation_id", reinterpret_cast<getter>(GettingFocusEventArgs_get_CorrelationId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GettingFocusEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GettingFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GettingFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GettingFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GettingFocusEventArgs) },
        { }};

    static PyType_Spec type_spec_GettingFocusEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.GettingFocusEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::GettingFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GettingFocusEventArgs};

    // ----- HoldingRoutedEventArgs class --------------------

    static PyObject* _new_HoldingRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::HoldingRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HoldingRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::HoldingRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HoldingRoutedEventArgs_GetPosition(py::wrapper::Windows::UI::Xaml::Input::HoldingRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.HoldingRoutedEventArgs", L"GetPosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPosition(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HoldingRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::HoldingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.HoldingRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HoldingRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::HoldingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.HoldingRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HoldingRoutedEventArgs_get_HoldingState(py::wrapper::Windows::UI::Xaml::Input::HoldingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.HoldingRoutedEventArgs", L"HoldingState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldingState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingRoutedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Xaml::Input::HoldingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.HoldingRoutedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HoldingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::HoldingRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HoldingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::HoldingRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HoldingRoutedEventArgs[] = {
        { "get_position", reinterpret_cast<PyCFunction>(HoldingRoutedEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HoldingRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HoldingRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HoldingRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(HoldingRoutedEventArgs_get_Handled), reinterpret_cast<setter>(HoldingRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "holding_state", reinterpret_cast<getter>(HoldingRoutedEventArgs_get_HoldingState), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(HoldingRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HoldingRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HoldingRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HoldingRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HoldingRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HoldingRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_HoldingRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.HoldingRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::HoldingRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HoldingRoutedEventArgs};

    // ----- InertiaExpansionBehavior class --------------------

    static PyObject* _new_InertiaExpansionBehavior(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::InertiaExpansionBehavior>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::InertiaExpansionBehavior>::type_name);
        return nullptr;
    }

    static void _dealloc_InertiaExpansionBehavior(py::wrapper::Windows::UI::Xaml::Input::InertiaExpansionBehavior* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InertiaExpansionBehavior_get_DesiredExpansion(py::wrapper::Windows::UI::Xaml::Input::InertiaExpansionBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaExpansionBehavior", L"DesiredExpansion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredExpansion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaExpansionBehavior_put_DesiredExpansion(py::wrapper::Windows::UI::Xaml::Input::InertiaExpansionBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaExpansionBehavior", L"DesiredExpansion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredExpansion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InertiaExpansionBehavior_get_DesiredDeceleration(py::wrapper::Windows::UI::Xaml::Input::InertiaExpansionBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaExpansionBehavior", L"DesiredDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaExpansionBehavior_put_DesiredDeceleration(py::wrapper::Windows::UI::Xaml::Input::InertiaExpansionBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaExpansionBehavior", L"DesiredDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InertiaExpansionBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::InertiaExpansionBehavior>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InertiaExpansionBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::InertiaExpansionBehavior>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InertiaExpansionBehavior[] = {
        { "_assign_array_", _assign_array_InertiaExpansionBehavior, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InertiaExpansionBehavior), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InertiaExpansionBehavior[] = {
        { "desired_expansion", reinterpret_cast<getter>(InertiaExpansionBehavior_get_DesiredExpansion), reinterpret_cast<setter>(InertiaExpansionBehavior_put_DesiredExpansion), nullptr, nullptr },
        { "desired_deceleration", reinterpret_cast<getter>(InertiaExpansionBehavior_get_DesiredDeceleration), reinterpret_cast<setter>(InertiaExpansionBehavior_put_DesiredDeceleration), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InertiaExpansionBehavior[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InertiaExpansionBehavior) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InertiaExpansionBehavior) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InertiaExpansionBehavior) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InertiaExpansionBehavior) },
        { }};

    static PyType_Spec type_spec_InertiaExpansionBehavior = {
        "winrt._winrt_windows_ui_xaml_input.InertiaExpansionBehavior",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::InertiaExpansionBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InertiaExpansionBehavior};

    // ----- InertiaRotationBehavior class --------------------

    static PyObject* _new_InertiaRotationBehavior(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::InertiaRotationBehavior>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::InertiaRotationBehavior>::type_name);
        return nullptr;
    }

    static void _dealloc_InertiaRotationBehavior(py::wrapper::Windows::UI::Xaml::Input::InertiaRotationBehavior* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InertiaRotationBehavior_get_DesiredRotation(py::wrapper::Windows::UI::Xaml::Input::InertiaRotationBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaRotationBehavior", L"DesiredRotation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredRotation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaRotationBehavior_put_DesiredRotation(py::wrapper::Windows::UI::Xaml::Input::InertiaRotationBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaRotationBehavior", L"DesiredRotation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredRotation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InertiaRotationBehavior_get_DesiredDeceleration(py::wrapper::Windows::UI::Xaml::Input::InertiaRotationBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaRotationBehavior", L"DesiredDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaRotationBehavior_put_DesiredDeceleration(py::wrapper::Windows::UI::Xaml::Input::InertiaRotationBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaRotationBehavior", L"DesiredDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InertiaRotationBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::InertiaRotationBehavior>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InertiaRotationBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::InertiaRotationBehavior>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InertiaRotationBehavior[] = {
        { "_assign_array_", _assign_array_InertiaRotationBehavior, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InertiaRotationBehavior), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InertiaRotationBehavior[] = {
        { "desired_rotation", reinterpret_cast<getter>(InertiaRotationBehavior_get_DesiredRotation), reinterpret_cast<setter>(InertiaRotationBehavior_put_DesiredRotation), nullptr, nullptr },
        { "desired_deceleration", reinterpret_cast<getter>(InertiaRotationBehavior_get_DesiredDeceleration), reinterpret_cast<setter>(InertiaRotationBehavior_put_DesiredDeceleration), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InertiaRotationBehavior[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InertiaRotationBehavior) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InertiaRotationBehavior) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InertiaRotationBehavior) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InertiaRotationBehavior) },
        { }};

    static PyType_Spec type_spec_InertiaRotationBehavior = {
        "winrt._winrt_windows_ui_xaml_input.InertiaRotationBehavior",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::InertiaRotationBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InertiaRotationBehavior};

    // ----- InertiaTranslationBehavior class --------------------

    static PyObject* _new_InertiaTranslationBehavior(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::InertiaTranslationBehavior>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::InertiaTranslationBehavior>::type_name);
        return nullptr;
    }

    static void _dealloc_InertiaTranslationBehavior(py::wrapper::Windows::UI::Xaml::Input::InertiaTranslationBehavior* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InertiaTranslationBehavior_get_DesiredDisplacement(py::wrapper::Windows::UI::Xaml::Input::InertiaTranslationBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaTranslationBehavior", L"DesiredDisplacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredDisplacement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaTranslationBehavior_put_DesiredDisplacement(py::wrapper::Windows::UI::Xaml::Input::InertiaTranslationBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaTranslationBehavior", L"DesiredDisplacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredDisplacement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InertiaTranslationBehavior_get_DesiredDeceleration(py::wrapper::Windows::UI::Xaml::Input::InertiaTranslationBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaTranslationBehavior", L"DesiredDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InertiaTranslationBehavior_put_DesiredDeceleration(py::wrapper::Windows::UI::Xaml::Input::InertiaTranslationBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InertiaTranslationBehavior", L"DesiredDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InertiaTranslationBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::InertiaTranslationBehavior>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InertiaTranslationBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::InertiaTranslationBehavior>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InertiaTranslationBehavior[] = {
        { "_assign_array_", _assign_array_InertiaTranslationBehavior, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InertiaTranslationBehavior), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InertiaTranslationBehavior[] = {
        { "desired_displacement", reinterpret_cast<getter>(InertiaTranslationBehavior_get_DesiredDisplacement), reinterpret_cast<setter>(InertiaTranslationBehavior_put_DesiredDisplacement), nullptr, nullptr },
        { "desired_deceleration", reinterpret_cast<getter>(InertiaTranslationBehavior_get_DesiredDeceleration), reinterpret_cast<setter>(InertiaTranslationBehavior_put_DesiredDeceleration), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InertiaTranslationBehavior[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InertiaTranslationBehavior) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InertiaTranslationBehavior) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InertiaTranslationBehavior) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InertiaTranslationBehavior) },
        { }};

    static PyType_Spec type_spec_InertiaTranslationBehavior = {
        "winrt._winrt_windows_ui_xaml_input.InertiaTranslationBehavior",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::InertiaTranslationBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InertiaTranslationBehavior};

    // ----- InputScope class --------------------

    static PyObject* _new_InputScope(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::InputScope instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InputScope(py::wrapper::Windows::UI::Xaml::Input::InputScope* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputScope_get_Names(py::wrapper::Windows::UI::Xaml::Input::InputScope* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InputScope", L"Names");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Names();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputScope(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::InputScope>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputScope(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::InputScope>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputScope[] = {
        { "_assign_array_", _assign_array_InputScope, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputScope), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputScope[] = {
        { "names", reinterpret_cast<getter>(InputScope_get_Names), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputScope[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputScope) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputScope) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputScope) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputScope) },
        { }};

    static PyType_Spec type_spec_InputScope = {
        "winrt._winrt_windows_ui_xaml_input.InputScope",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::InputScope),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputScope};

    // ----- InputScopeName class --------------------

    static PyObject* _new_InputScopeName(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::InputScopeNameValue>(args, 0);

                winrt::Windows::UI::Xaml::Input::InputScopeName instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::InputScopeName instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InputScopeName(py::wrapper::Windows::UI::Xaml::Input::InputScopeName* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputScopeName_get_NameValue(py::wrapper::Windows::UI::Xaml::Input::InputScopeName* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InputScopeName", L"NameValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NameValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputScopeName_put_NameValue(py::wrapper::Windows::UI::Xaml::Input::InputScopeName* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.InputScopeName", L"NameValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::InputScopeNameValue>(arg);

            {
                auto _gil = release_gil();
                self->obj.NameValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InputScopeName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::InputScopeName>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputScopeName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::InputScopeName>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputScopeName[] = {
        { "_assign_array_", _assign_array_InputScopeName, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputScopeName), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputScopeName[] = {
        { "name_value", reinterpret_cast<getter>(InputScopeName_get_NameValue), reinterpret_cast<setter>(InputScopeName_put_NameValue), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputScopeName[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputScopeName) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputScopeName) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputScopeName) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputScopeName) },
        { }};

    static PyType_Spec type_spec_InputScopeName = {
        "winrt._winrt_windows_ui_xaml_input.InputScopeName",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::InputScopeName),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputScopeName};

    // ----- KeyRoutedEventArgs class --------------------

    static PyObject* _new_KeyRoutedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::KeyRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::KeyRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyRoutedEventArgs_get_Key(py::wrapper::Windows::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyRoutedEventArgs", L"Key");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Key();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyRoutedEventArgs_get_KeyStatus(py::wrapper::Windows::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyRoutedEventArgs", L"KeyStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyRoutedEventArgs_get_OriginalKey(py::wrapper::Windows::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyRoutedEventArgs", L"OriginalKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OriginalKey();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyRoutedEventArgs_get_DeviceId(py::wrapper::Windows::UI::Xaml::Input::KeyRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyRoutedEventArgs", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_KeyRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_KeyRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(KeyRoutedEventArgs_get_Handled), reinterpret_cast<setter>(KeyRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "key", reinterpret_cast<getter>(KeyRoutedEventArgs_get_Key), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(KeyRoutedEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "original_key", reinterpret_cast<getter>(KeyRoutedEventArgs_get_OriginalKey), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(KeyRoutedEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_KeyRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_KeyRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.KeyRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::KeyRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyRoutedEventArgs};

    // ----- KeyboardAccelerator class --------------------

    struct PyWinrtKeyboardAccelerator;
    using BasePyWinrtKeyboardAccelerator = winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorT<PyWinrtKeyboardAccelerator, py::IPywinrtObject>;

    struct PyWinrtKeyboardAccelerator : py::py_obj_ref, BasePyWinrtKeyboardAccelerator
    {
        PyWinrtKeyboardAccelerator(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtKeyboardAccelerator() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtKeyboardAccelerator* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_KeyboardAccelerator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtKeyboardAccelerator>(self.get());

                    auto obj = py::make_py_obj<PyWinrtKeyboardAccelerator>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Input::KeyboardAccelerator instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_KeyboardAccelerator(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyboardAccelerator_get_ScopeOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"ScopeOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().ScopeOwner();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAccelerator_put_ScopeOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"ScopeOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().ScopeOwner(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAccelerator_get_Modifiers(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"Modifiers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().Modifiers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAccelerator_put_Modifiers(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"Modifiers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKeyModifiers>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().Modifiers(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAccelerator_get_Key(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"Key");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().Key();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAccelerator_put_Key(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"Key");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().Key(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAccelerator_get_IsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAccelerator_put_IsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAccelerator_get_IsEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"IsEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::KeyboardAccelerator::IsEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_get_KeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"KeyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::KeyboardAccelerator::KeyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_get_ModifiersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"ModifiersProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::KeyboardAccelerator::ModifiersProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_get_ScopeOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"ScopeOwnerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::KeyboardAccelerator::ScopeOwnerProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_add_Invoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"Invoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator, winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().Invoked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAccelerator_remove_Invoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.KeyboardAccelerator", L"Invoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>().Invoked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyboardAccelerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyboardAccelerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardAccelerator[] = {
        { "add_invoked", reinterpret_cast<PyCFunction>(KeyboardAccelerator_add_Invoked), METH_O, nullptr },
        { "remove_invoked", reinterpret_cast<PyCFunction>(KeyboardAccelerator_remove_Invoked), METH_O, nullptr },
        { "_assign_array_", _assign_array_KeyboardAccelerator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyboardAccelerator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_KeyboardAccelerator[] = {
        { "scope_owner", reinterpret_cast<getter>(KeyboardAccelerator_get_ScopeOwner), reinterpret_cast<setter>(KeyboardAccelerator_put_ScopeOwner), nullptr, nullptr },
        { "modifiers", reinterpret_cast<getter>(KeyboardAccelerator_get_Modifiers), reinterpret_cast<setter>(KeyboardAccelerator_put_Modifiers), nullptr, nullptr },
        { "key", reinterpret_cast<getter>(KeyboardAccelerator_get_Key), reinterpret_cast<setter>(KeyboardAccelerator_put_Key), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(KeyboardAccelerator_get_IsEnabled), reinterpret_cast<setter>(KeyboardAccelerator_put_IsEnabled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_KeyboardAccelerator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyboardAccelerator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyboardAccelerator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyboardAccelerator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyboardAccelerator) },
        { }};

    static PyType_Spec type_spec_KeyboardAccelerator = {
        "winrt._winrt_windows_ui_xaml_input.KeyboardAccelerator",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_KeyboardAccelerator};

    static PyGetSetDef getset_KeyboardAccelerator_Static[] = {
        { "is_enabled_property", reinterpret_cast<getter>(KeyboardAccelerator_get_IsEnabledProperty), nullptr, nullptr, nullptr },
        { "key_property", reinterpret_cast<getter>(KeyboardAccelerator_get_KeyProperty), nullptr, nullptr, nullptr },
        { "modifiers_property", reinterpret_cast<getter>(KeyboardAccelerator_get_ModifiersProperty), nullptr, nullptr, nullptr },
        { "scope_owner_property", reinterpret_cast<getter>(KeyboardAccelerator_get_ScopeOwnerProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_KeyboardAccelerator_Static[] = {
        { }};

    static PyType_Slot type_slots_KeyboardAccelerator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyboardAccelerator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyboardAccelerator_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyboardAccelerator_Static = {
        "winrt._winrt_windows_ui_xaml_input.KeyboardAccelerator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_KeyboardAccelerator_Static};

    // ----- KeyboardAcceleratorInvokedEventArgs class --------------------

    static PyObject* _new_KeyboardAcceleratorInvokedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyboardAcceleratorInvokedEventArgs(py::wrapper::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyboardAcceleratorInvokedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardAcceleratorInvokedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardAcceleratorInvokedEventArgs_get_Element(py::wrapper::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs", L"Element");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Element();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardAcceleratorInvokedEventArgs_get_KeyboardAccelerator(py::wrapper::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs", L"KeyboardAccelerator");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyboardAccelerator();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyboardAcceleratorInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyboardAcceleratorInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardAcceleratorInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_KeyboardAcceleratorInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyboardAcceleratorInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_KeyboardAcceleratorInvokedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(KeyboardAcceleratorInvokedEventArgs_get_Handled), reinterpret_cast<setter>(KeyboardAcceleratorInvokedEventArgs_put_Handled), nullptr, nullptr },
        { "element", reinterpret_cast<getter>(KeyboardAcceleratorInvokedEventArgs_get_Element), nullptr, nullptr, nullptr },
        { "keyboard_accelerator", reinterpret_cast<getter>(KeyboardAcceleratorInvokedEventArgs_get_KeyboardAccelerator), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_KeyboardAcceleratorInvokedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyboardAcceleratorInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyboardAcceleratorInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyboardAcceleratorInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyboardAcceleratorInvokedEventArgs) },
        { }};

    static PyType_Spec type_spec_KeyboardAcceleratorInvokedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.KeyboardAcceleratorInvokedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardAcceleratorInvokedEventArgs};

    // ----- LosingFocusEventArgs class --------------------

    static PyObject* _new_LosingFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::LosingFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::LosingFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LosingFocusEventArgs(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LosingFocusEventArgs_TryCancel(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"TryCancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCancel();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_TrySetNewFocusedElement(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"TrySetNewFocusedElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySetNewFocusedElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_NewFocusedElement(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"NewFocusedElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewFocusedElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LosingFocusEventArgs_put_NewFocusedElement(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"NewFocusedElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.NewFocusedElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LosingFocusEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LosingFocusEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LosingFocusEventArgs_get_Cancel(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LosingFocusEventArgs_put_Cancel(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LosingFocusEventArgs_get_Direction(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Direction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_FocusState(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"FocusState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FocusState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_InputDevice(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"InputDevice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputDevice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_OldFocusedElement(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"OldFocusedElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldFocusedElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LosingFocusEventArgs_get_CorrelationId(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.LosingFocusEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CorrelationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LosingFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::LosingFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LosingFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::LosingFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LosingFocusEventArgs[] = {
        { "try_cancel", reinterpret_cast<PyCFunction>(LosingFocusEventArgs_TryCancel), METH_VARARGS, nullptr },
        { "try_set_new_focused_element", reinterpret_cast<PyCFunction>(LosingFocusEventArgs_TrySetNewFocusedElement), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LosingFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LosingFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LosingFocusEventArgs[] = {
        { "new_focused_element", reinterpret_cast<getter>(LosingFocusEventArgs_get_NewFocusedElement), reinterpret_cast<setter>(LosingFocusEventArgs_put_NewFocusedElement), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(LosingFocusEventArgs_get_Handled), reinterpret_cast<setter>(LosingFocusEventArgs_put_Handled), nullptr, nullptr },
        { "cancel", reinterpret_cast<getter>(LosingFocusEventArgs_get_Cancel), reinterpret_cast<setter>(LosingFocusEventArgs_put_Cancel), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(LosingFocusEventArgs_get_Direction), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(LosingFocusEventArgs_get_FocusState), nullptr, nullptr, nullptr },
        { "input_device", reinterpret_cast<getter>(LosingFocusEventArgs_get_InputDevice), nullptr, nullptr, nullptr },
        { "old_focused_element", reinterpret_cast<getter>(LosingFocusEventArgs_get_OldFocusedElement), nullptr, nullptr, nullptr },
        { "correlation_id", reinterpret_cast<getter>(LosingFocusEventArgs_get_CorrelationId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_LosingFocusEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LosingFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LosingFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LosingFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LosingFocusEventArgs) },
        { }};

    static PyType_Spec type_spec_LosingFocusEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.LosingFocusEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::LosingFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LosingFocusEventArgs};

    // ----- ManipulationCompletedRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationCompletedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationCompletedRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationCompletedRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Container(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Container");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Container();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_IsInertial(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"IsInertial");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInertial();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedRoutedEventArgs_get_Velocities(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationCompletedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationCompletedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationCompletedRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationCompletedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationCompletedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationCompletedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationCompletedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Container), nullptr, nullptr, nullptr },
        { "cumulative", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "is_inertial", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_IsInertial), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationCompletedRoutedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationCompletedRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationCompletedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationCompletedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationCompletedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationCompletedRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationCompletedRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.ManipulationCompletedRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationCompletedRoutedEventArgs};

    // ----- ManipulationDeltaRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationDeltaRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationDeltaRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_Complete(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationDeltaRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Container(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Container");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Container();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Delta(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Delta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Delta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_IsInertial(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"IsInertial");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInertial();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDeltaRoutedEventArgs_get_Velocities(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationDeltaRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationDeltaRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationDeltaRoutedEventArgs[] = {
        { "complete", reinterpret_cast<PyCFunction>(ManipulationDeltaRoutedEventArgs_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ManipulationDeltaRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationDeltaRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationDeltaRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationDeltaRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Container), nullptr, nullptr, nullptr },
        { "cumulative", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Delta), nullptr, nullptr, nullptr },
        { "is_inertial", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_IsInertial), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationDeltaRoutedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationDeltaRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationDeltaRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationDeltaRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationDeltaRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationDeltaRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationDeltaRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.ManipulationDeltaRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationDeltaRoutedEventArgs};

    // ----- ManipulationInertiaStartingRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationInertiaStartingRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationInertiaStartingRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_TranslationBehavior(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"TranslationBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TranslationBehavior();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationInertiaStartingRoutedEventArgs_put_TranslationBehavior(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"TranslationBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::InertiaTranslationBehavior>(arg);

            {
                auto _gil = release_gil();
                self->obj.TranslationBehavior(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_RotationBehavior(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"RotationBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RotationBehavior();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationInertiaStartingRoutedEventArgs_put_RotationBehavior(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"RotationBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::InertiaRotationBehavior>(arg);

            {
                auto _gil = release_gil();
                self->obj.RotationBehavior(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationInertiaStartingRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_ExpansionBehavior(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"ExpansionBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpansionBehavior();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationInertiaStartingRoutedEventArgs_put_ExpansionBehavior(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"ExpansionBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::InertiaExpansionBehavior>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpansionBehavior(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Container(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Container");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Container();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Delta(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Delta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Delta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingRoutedEventArgs_get_Velocities(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationInertiaStartingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationInertiaStartingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationInertiaStartingRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationInertiaStartingRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationInertiaStartingRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationInertiaStartingRoutedEventArgs[] = {
        { "translation_behavior", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_TranslationBehavior), reinterpret_cast<setter>(ManipulationInertiaStartingRoutedEventArgs_put_TranslationBehavior), nullptr, nullptr },
        { "rotation_behavior", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_RotationBehavior), reinterpret_cast<setter>(ManipulationInertiaStartingRoutedEventArgs_put_RotationBehavior), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationInertiaStartingRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "expansion_behavior", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_ExpansionBehavior), reinterpret_cast<setter>(ManipulationInertiaStartingRoutedEventArgs_put_ExpansionBehavior), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Container), nullptr, nullptr, nullptr },
        { "cumulative", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Delta), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationInertiaStartingRoutedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationInertiaStartingRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationInertiaStartingRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationInertiaStartingRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationInertiaStartingRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationInertiaStartingRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationInertiaStartingRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.ManipulationInertiaStartingRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationInertiaStartingRoutedEventArgs};

    // ----- ManipulationPivot class --------------------

    static PyObject* _new_ManipulationPivot(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::UI::Xaml::Input::ManipulationPivot instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::ManipulationPivot instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationPivot(py::wrapper::Windows::UI::Xaml::Input::ManipulationPivot* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationPivot_get_Radius(py::wrapper::Windows::UI::Xaml::Input::ManipulationPivot* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationPivot", L"Radius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Radius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationPivot_put_Radius(py::wrapper::Windows::UI::Xaml::Input::ManipulationPivot* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationPivot", L"Radius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Radius(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationPivot_get_Center(py::wrapper::Windows::UI::Xaml::Input::ManipulationPivot* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationPivot", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Center();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationPivot_put_Center(py::wrapper::Windows::UI::Xaml::Input::ManipulationPivot* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationPivot", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            {
                auto _gil = release_gil();
                self->obj.Center(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ManipulationPivot(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ManipulationPivot>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationPivot(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ManipulationPivot>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationPivot[] = {
        { "_assign_array_", _assign_array_ManipulationPivot, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationPivot), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationPivot[] = {
        { "radius", reinterpret_cast<getter>(ManipulationPivot_get_Radius), reinterpret_cast<setter>(ManipulationPivot_put_Radius), nullptr, nullptr },
        { "center", reinterpret_cast<getter>(ManipulationPivot_get_Center), reinterpret_cast<setter>(ManipulationPivot_put_Center), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationPivot[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationPivot) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationPivot) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationPivot) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationPivot) },
        { }};

    static PyType_Spec type_spec_ManipulationPivot = {
        "winrt._winrt_windows_ui_xaml_input.ManipulationPivot",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ManipulationPivot),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationPivot};

    // ----- ManipulationStartedRoutedEventArgs class --------------------

    struct PyWinrtManipulationStartedRoutedEventArgs;
    using BasePyWinrtManipulationStartedRoutedEventArgs = winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgsT<PyWinrtManipulationStartedRoutedEventArgs, py::IPywinrtObject>;

    struct PyWinrtManipulationStartedRoutedEventArgs : py::py_obj_ref, BasePyWinrtManipulationStartedRoutedEventArgs
    {
        PyWinrtManipulationStartedRoutedEventArgs(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtManipulationStartedRoutedEventArgs() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtManipulationStartedRoutedEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_ManipulationStartedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtManipulationStartedRoutedEventArgs>(self.get());

                    auto obj = py::make_py_obj<PyWinrtManipulationStartedRoutedEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationStartedRoutedEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationStartedRoutedEventArgs_Complete(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>().Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_Handled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>().Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartedRoutedEventArgs_put_Handled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>().Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_Container(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Container");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>().Container();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_Cumulative(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>().Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_PointerDeviceType(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>().PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedRoutedEventArgs_get_Position(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>().Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationStartedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationStartedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationStartedRoutedEventArgs[] = {
        { "complete", reinterpret_cast<PyCFunction>(ManipulationStartedRoutedEventArgs_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ManipulationStartedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationStartedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationStartedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationStartedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_Container), nullptr, nullptr, nullptr },
        { "cumulative", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationStartedRoutedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationStartedRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationStartedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationStartedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationStartedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationStartedRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationStartedRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.ManipulationStartedRoutedEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ManipulationStartedRoutedEventArgs};

    static PyGetSetDef getset_ManipulationStartedRoutedEventArgs_Static[] = {
        { }};

    static PyMethodDef methods_ManipulationStartedRoutedEventArgs_Static[] = {
        { }};

    static PyType_Slot type_slots_ManipulationStartedRoutedEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ManipulationStartedRoutedEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ManipulationStartedRoutedEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_ManipulationStartedRoutedEventArgs_Static = {
        "winrt._winrt_windows_ui_xaml_input.ManipulationStartedRoutedEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ManipulationStartedRoutedEventArgs_Static};

    // ----- ManipulationStartingRoutedEventArgs class --------------------

    static PyObject* _new_ManipulationStartingRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ManipulationStartingRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationStartingRoutedEventArgs_get_Pivot(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Pivot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Pivot();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartingRoutedEventArgs_put_Pivot(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Pivot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationPivot>(arg);

            {
                auto _gil = release_gil();
                self->obj.Pivot(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationStartingRoutedEventArgs_get_Mode(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Mode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartingRoutedEventArgs_put_Mode(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationModes>(arg);

            {
                auto _gil = release_gil();
                self->obj.Mode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationStartingRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartingRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationStartingRoutedEventArgs_get_Container(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Container");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Container();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationStartingRoutedEventArgs_put_Container(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs", L"Container");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.Container(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ManipulationStartingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationStartingRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationStartingRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationStartingRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationStartingRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationStartingRoutedEventArgs[] = {
        { "pivot", reinterpret_cast<getter>(ManipulationStartingRoutedEventArgs_get_Pivot), reinterpret_cast<setter>(ManipulationStartingRoutedEventArgs_put_Pivot), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(ManipulationStartingRoutedEventArgs_get_Mode), reinterpret_cast<setter>(ManipulationStartingRoutedEventArgs_put_Mode), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(ManipulationStartingRoutedEventArgs_get_Handled), reinterpret_cast<setter>(ManipulationStartingRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(ManipulationStartingRoutedEventArgs_get_Container), reinterpret_cast<setter>(ManipulationStartingRoutedEventArgs_put_Container), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationStartingRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationStartingRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationStartingRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationStartingRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationStartingRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationStartingRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.ManipulationStartingRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationStartingRoutedEventArgs};

    // ----- NoFocusCandidateFoundEventArgs class --------------------

    static PyObject* _new_NoFocusCandidateFoundEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NoFocusCandidateFoundEventArgs(py::wrapper::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NoFocusCandidateFoundEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.NoFocusCandidateFoundEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NoFocusCandidateFoundEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.NoFocusCandidateFoundEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NoFocusCandidateFoundEventArgs_get_Direction(py::wrapper::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.NoFocusCandidateFoundEventArgs", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Direction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NoFocusCandidateFoundEventArgs_get_InputDevice(py::wrapper::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.NoFocusCandidateFoundEventArgs", L"InputDevice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputDevice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NoFocusCandidateFoundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NoFocusCandidateFoundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NoFocusCandidateFoundEventArgs[] = {
        { "_assign_array_", _assign_array_NoFocusCandidateFoundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NoFocusCandidateFoundEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NoFocusCandidateFoundEventArgs[] = {
        { "handled", reinterpret_cast<getter>(NoFocusCandidateFoundEventArgs_get_Handled), reinterpret_cast<setter>(NoFocusCandidateFoundEventArgs_put_Handled), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(NoFocusCandidateFoundEventArgs_get_Direction), nullptr, nullptr, nullptr },
        { "input_device", reinterpret_cast<getter>(NoFocusCandidateFoundEventArgs_get_InputDevice), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NoFocusCandidateFoundEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NoFocusCandidateFoundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NoFocusCandidateFoundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NoFocusCandidateFoundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NoFocusCandidateFoundEventArgs) },
        { }};

    static PyType_Spec type_spec_NoFocusCandidateFoundEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.NoFocusCandidateFoundEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NoFocusCandidateFoundEventArgs};

    // ----- Pointer class --------------------

    static PyObject* _new_Pointer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::Pointer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::Pointer>::type_name);
        return nullptr;
    }

    static void _dealloc_Pointer(py::wrapper::Windows::UI::Xaml::Input::Pointer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Pointer_get_IsInContact(py::wrapper::Windows::UI::Xaml::Input::Pointer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.Pointer", L"IsInContact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInContact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pointer_get_IsInRange(py::wrapper::Windows::UI::Xaml::Input::Pointer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.Pointer", L"IsInRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pointer_get_PointerDeviceType(py::wrapper::Windows::UI::Xaml::Input::Pointer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.Pointer", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pointer_get_PointerId(py::wrapper::Windows::UI::Xaml::Input::Pointer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.Pointer", L"PointerId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Pointer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::Pointer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Pointer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::Pointer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Pointer[] = {
        { "_assign_array_", _assign_array_Pointer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Pointer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Pointer[] = {
        { "is_in_contact", reinterpret_cast<getter>(Pointer_get_IsInContact), nullptr, nullptr, nullptr },
        { "is_in_range", reinterpret_cast<getter>(Pointer_get_IsInRange), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(Pointer_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "pointer_id", reinterpret_cast<getter>(Pointer_get_PointerId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Pointer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Pointer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Pointer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Pointer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Pointer) },
        { }};

    static PyType_Spec type_spec_Pointer = {
        "winrt._winrt_windows_ui_xaml_input.Pointer",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::Pointer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Pointer};

    // ----- PointerRoutedEventArgs class --------------------

    static PyObject* _new_PointerRoutedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::PointerRoutedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::PointerRoutedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerRoutedEventArgs_GetCurrentPoint(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.PointerRoutedEventArgs", L"GetCurrentPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentPoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerRoutedEventArgs_GetIntermediatePoints(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.PointerRoutedEventArgs", L"GetIntermediatePoints", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIntermediatePoints(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.PointerRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.PointerRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerRoutedEventArgs_get_KeyModifiers(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.PointerRoutedEventArgs", L"KeyModifiers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyModifiers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerRoutedEventArgs_get_Pointer(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.PointerRoutedEventArgs", L"Pointer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Pointer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerRoutedEventArgs_get_IsGenerated(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.PointerRoutedEventArgs", L"IsGenerated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGenerated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::PointerRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::PointerRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerRoutedEventArgs[] = {
        { "get_current_point", reinterpret_cast<PyCFunction>(PointerRoutedEventArgs_GetCurrentPoint), METH_VARARGS, nullptr },
        { "get_intermediate_points", reinterpret_cast<PyCFunction>(PointerRoutedEventArgs_GetIntermediatePoints), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointerRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PointerRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(PointerRoutedEventArgs_get_Handled), reinterpret_cast<setter>(PointerRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "key_modifiers", reinterpret_cast<getter>(PointerRoutedEventArgs_get_KeyModifiers), nullptr, nullptr, nullptr },
        { "pointer", reinterpret_cast<getter>(PointerRoutedEventArgs_get_Pointer), nullptr, nullptr, nullptr },
        { "is_generated", reinterpret_cast<getter>(PointerRoutedEventArgs_get_IsGenerated), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_PointerRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.PointerRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::PointerRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerRoutedEventArgs};

    // ----- ProcessKeyboardAcceleratorEventArgs class --------------------

    static PyObject* _new_ProcessKeyboardAcceleratorEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessKeyboardAcceleratorEventArgs(py::wrapper::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessKeyboardAcceleratorEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessKeyboardAcceleratorEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessKeyboardAcceleratorEventArgs_get_Key(py::wrapper::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs", L"Key");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Key();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessKeyboardAcceleratorEventArgs_get_Modifiers(py::wrapper::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs", L"Modifiers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Modifiers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessKeyboardAcceleratorEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessKeyboardAcceleratorEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessKeyboardAcceleratorEventArgs[] = {
        { "_assign_array_", _assign_array_ProcessKeyboardAcceleratorEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessKeyboardAcceleratorEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProcessKeyboardAcceleratorEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ProcessKeyboardAcceleratorEventArgs_get_Handled), reinterpret_cast<setter>(ProcessKeyboardAcceleratorEventArgs_put_Handled), nullptr, nullptr },
        { "key", reinterpret_cast<getter>(ProcessKeyboardAcceleratorEventArgs_get_Key), nullptr, nullptr, nullptr },
        { "modifiers", reinterpret_cast<getter>(ProcessKeyboardAcceleratorEventArgs_get_Modifiers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProcessKeyboardAcceleratorEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessKeyboardAcceleratorEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessKeyboardAcceleratorEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessKeyboardAcceleratorEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessKeyboardAcceleratorEventArgs) },
        { }};

    static PyType_Spec type_spec_ProcessKeyboardAcceleratorEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.ProcessKeyboardAcceleratorEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessKeyboardAcceleratorEventArgs};

    // ----- RightTappedRoutedEventArgs class --------------------

    static PyObject* _new_RightTappedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RightTappedRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RightTappedRoutedEventArgs_GetPosition(py::wrapper::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.RightTappedRoutedEventArgs", L"GetPosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPosition(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RightTappedRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.RightTappedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RightTappedRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.RightTappedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RightTappedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.RightTappedRoutedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RightTappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RightTappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RightTappedRoutedEventArgs[] = {
        { "get_position", reinterpret_cast<PyCFunction>(RightTappedRoutedEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RightTappedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RightTappedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RightTappedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(RightTappedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(RightTappedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(RightTappedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RightTappedRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RightTappedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RightTappedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RightTappedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RightTappedRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_RightTappedRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.RightTappedRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RightTappedRoutedEventArgs};

    // ----- StandardUICommand class --------------------

    struct PyWinrtStandardUICommand;
    using BasePyWinrtStandardUICommand = winrt::Windows::UI::Xaml::Input::StandardUICommandT<PyWinrtStandardUICommand, py::IPywinrtObject>;

    struct PyWinrtStandardUICommand : py::py_obj_ref, BasePyWinrtStandardUICommand
    {
        PyWinrtStandardUICommand(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtStandardUICommand() {}
        PyWinrtStandardUICommand(PyObject* py_obj, winrt::Windows::UI::Xaml::Input::StandardUICommandKind kind) : py::py_obj_ref(py_obj), BasePyWinrtStandardUICommand(kind) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtStandardUICommand* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_StandardUICommand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Input::StandardUICommand>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtStandardUICommand>(self.get());

                    auto obj = py::make_py_obj<PyWinrtStandardUICommand>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Input::StandardUICommand instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::StandardUICommandKind>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtStandardUICommand>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtStandardUICommand>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Input::StandardUICommand instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StandardUICommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StandardUICommand_get_Kind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.StandardUICommand", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::StandardUICommand>().Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StandardUICommand_put_Kind(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.StandardUICommand", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::StandardUICommandKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::StandardUICommand>().Kind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StandardUICommand_get_KindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.StandardUICommand", L"KindProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::StandardUICommand::KindProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StandardUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::StandardUICommand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StandardUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::StandardUICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StandardUICommand[] = {
        { "_assign_array_", _assign_array_StandardUICommand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StandardUICommand), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StandardUICommand[] = {
        { "kind", reinterpret_cast<getter>(StandardUICommand_get_Kind), reinterpret_cast<setter>(StandardUICommand_put_Kind), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StandardUICommand[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StandardUICommand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StandardUICommand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StandardUICommand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StandardUICommand) },
        { }};

    static PyType_Spec type_spec_StandardUICommand = {
        "winrt._winrt_windows_ui_xaml_input.StandardUICommand",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_StandardUICommand};

    static PyGetSetDef getset_StandardUICommand_Static[] = {
        { "kind_property", reinterpret_cast<getter>(StandardUICommand_get_KindProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_StandardUICommand_Static[] = {
        { }};

    static PyType_Slot type_slots_StandardUICommand_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StandardUICommand_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StandardUICommand_Static) },
        { }
    };

    static PyType_Spec type_spec_StandardUICommand_Static = {
        "winrt._winrt_windows_ui_xaml_input.StandardUICommand_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_StandardUICommand_Static};

    // ----- TappedRoutedEventArgs class --------------------

    static PyObject* _new_TappedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Input::TappedRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TappedRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Input::TappedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TappedRoutedEventArgs_GetPosition(py::wrapper::Windows::UI::Xaml::Input::TappedRoutedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.TappedRoutedEventArgs", L"GetPosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPosition(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TappedRoutedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::Input::TappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.TappedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TappedRoutedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::Input::TappedRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.TappedRoutedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TappedRoutedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Xaml::Input::TappedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.TappedRoutedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::TappedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TappedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::TappedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TappedRoutedEventArgs[] = {
        { "get_position", reinterpret_cast<PyCFunction>(TappedRoutedEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TappedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TappedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TappedRoutedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(TappedRoutedEventArgs_get_Handled), reinterpret_cast<setter>(TappedRoutedEventArgs_put_Handled), nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(TappedRoutedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TappedRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TappedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TappedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TappedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TappedRoutedEventArgs) },
        { }};

    static PyType_Spec type_spec_TappedRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_input.TappedRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::TappedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TappedRoutedEventArgs};

    // ----- XamlUICommand class --------------------

    struct PyWinrtXamlUICommand;
    using BasePyWinrtXamlUICommand = winrt::Windows::UI::Xaml::Input::XamlUICommandT<PyWinrtXamlUICommand, py::IPywinrtObject>;

    struct PyWinrtXamlUICommand : py::py_obj_ref, BasePyWinrtXamlUICommand
    {
        PyWinrtXamlUICommand(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtXamlUICommand() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtXamlUICommand* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_XamlUICommand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Input::XamlUICommand>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtXamlUICommand>(self.get());

                    auto obj = py::make_py_obj<PyWinrtXamlUICommand>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Input::XamlUICommand instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_XamlUICommand(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlUICommand_CanExecute(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"CanExecute", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().CanExecute(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_Execute(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"Execute", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().Execute(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_NotifyCanExecuteChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"NotifyCanExecuteChanged", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().NotifyCanExecuteChanged();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_Label(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().Label();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_Label(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().Label(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().IconSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_IconSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconSource>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().IconSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_Description(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_Description(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().Description(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().Command();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().Command(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_AccessKey(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"AccessKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().AccessKey();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlUICommand_put_AccessKey(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"AccessKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().AccessKey(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlUICommand_get_KeyboardAccelerators(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"KeyboardAccelerators");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().KeyboardAccelerators();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_AccessKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"AccessKeyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::XamlUICommand::AccessKeyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_CommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"CommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::XamlUICommand::CommandProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_DescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"DescriptionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::XamlUICommand::DescriptionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_IconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"IconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::XamlUICommand::IconSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_KeyboardAcceleratorsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"KeyboardAcceleratorsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::XamlUICommand::KeyboardAcceleratorsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"LabelProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Xaml::Input::XamlUICommand::LabelProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_add_CanExecuteRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"CanExecuteRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Input::XamlUICommand, winrt::Windows::UI::Xaml::Input::CanExecuteRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().CanExecuteRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_remove_CanExecuteRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"CanExecuteRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().CanExecuteRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_add_ExecuteRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"ExecuteRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Input::XamlUICommand, winrt::Windows::UI::Xaml::Input::ExecuteRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().ExecuteRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_remove_ExecuteRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"ExecuteRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().ExecuteRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_add_CanExecuteChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"CanExecuteChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().CanExecuteChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlUICommand_remove_CanExecuteChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.XamlUICommand", L"CanExecuteChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Xaml::Input::XamlUICommand>().CanExecuteChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::XamlUICommand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::XamlUICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlUICommand[] = {
        { "can_execute", reinterpret_cast<PyCFunction>(XamlUICommand_CanExecute), METH_VARARGS, nullptr },
        { "execute", reinterpret_cast<PyCFunction>(XamlUICommand_Execute), METH_VARARGS, nullptr },
        { "notify_can_execute_changed", reinterpret_cast<PyCFunction>(XamlUICommand_NotifyCanExecuteChanged), METH_VARARGS, nullptr },
        { "add_can_execute_requested", reinterpret_cast<PyCFunction>(XamlUICommand_add_CanExecuteRequested), METH_O, nullptr },
        { "remove_can_execute_requested", reinterpret_cast<PyCFunction>(XamlUICommand_remove_CanExecuteRequested), METH_O, nullptr },
        { "add_execute_requested", reinterpret_cast<PyCFunction>(XamlUICommand_add_ExecuteRequested), METH_O, nullptr },
        { "remove_execute_requested", reinterpret_cast<PyCFunction>(XamlUICommand_remove_ExecuteRequested), METH_O, nullptr },
        { "add_can_execute_changed", reinterpret_cast<PyCFunction>(XamlUICommand_add_CanExecuteChanged), METH_O, nullptr },
        { "remove_can_execute_changed", reinterpret_cast<PyCFunction>(XamlUICommand_remove_CanExecuteChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_XamlUICommand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlUICommand), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XamlUICommand[] = {
        { "label", reinterpret_cast<getter>(XamlUICommand_get_Label), reinterpret_cast<setter>(XamlUICommand_put_Label), nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(XamlUICommand_get_IconSource), reinterpret_cast<setter>(XamlUICommand_put_IconSource), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(XamlUICommand_get_Description), reinterpret_cast<setter>(XamlUICommand_put_Description), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(XamlUICommand_get_Command), reinterpret_cast<setter>(XamlUICommand_put_Command), nullptr, nullptr },
        { "access_key", reinterpret_cast<getter>(XamlUICommand_get_AccessKey), reinterpret_cast<setter>(XamlUICommand_put_AccessKey), nullptr, nullptr },
        { "keyboard_accelerators", reinterpret_cast<getter>(XamlUICommand_get_KeyboardAccelerators), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XamlUICommand[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlUICommand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlUICommand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlUICommand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlUICommand) },
        { }};

    static PyType_Spec type_spec_XamlUICommand = {
        "winrt._winrt_windows_ui_xaml_input.XamlUICommand",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_XamlUICommand};

    static PyGetSetDef getset_XamlUICommand_Static[] = {
        { "access_key_property", reinterpret_cast<getter>(XamlUICommand_get_AccessKeyProperty), nullptr, nullptr, nullptr },
        { "command_property", reinterpret_cast<getter>(XamlUICommand_get_CommandProperty), nullptr, nullptr, nullptr },
        { "description_property", reinterpret_cast<getter>(XamlUICommand_get_DescriptionProperty), nullptr, nullptr, nullptr },
        { "icon_source_property", reinterpret_cast<getter>(XamlUICommand_get_IconSourceProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerators_property", reinterpret_cast<getter>(XamlUICommand_get_KeyboardAcceleratorsProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(XamlUICommand_get_LabelProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_XamlUICommand_Static[] = {
        { }};

    static PyType_Slot type_slots_XamlUICommand_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlUICommand_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlUICommand_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlUICommand_Static = {
        "winrt._winrt_windows_ui_xaml_input.XamlUICommand_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_XamlUICommand_Static};

    // ----- ICommand interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICommand(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Input::ICommand>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Input::ICommand>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICommand(py::wrapper::Windows::UI::Xaml::Input::ICommand* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommand_CanExecute(py::wrapper::Windows::UI::Xaml::Input::ICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.ICommand", L"CanExecute", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CanExecute(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICommand_Execute(py::wrapper::Windows::UI::Xaml::Input::ICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Input.ICommand", L"Execute", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Execute(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICommand_add_CanExecuteChanged(py::wrapper::Windows::UI::Xaml::Input::ICommand* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.ICommand", L"CanExecuteChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanExecuteChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommand_remove_CanExecuteChanged(py::wrapper::Windows::UI::Xaml::Input::ICommand* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Input.ICommand", L"CanExecuteChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanExecuteChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommand[] = {
        { "can_execute", reinterpret_cast<PyCFunction>(ICommand_CanExecute), METH_VARARGS, nullptr },
        { "execute", reinterpret_cast<PyCFunction>(ICommand_Execute), METH_VARARGS, nullptr },
        { "add_can_execute_changed", reinterpret_cast<PyCFunction>(ICommand_add_CanExecuteChanged), METH_O, nullptr },
        { "remove_can_execute_changed", reinterpret_cast<PyCFunction>(ICommand_remove_CanExecuteChanged), METH_O, nullptr },
        { }};

    static PyGetSetDef _getset_ICommand[] = {
        { }};

    static PyType_Slot _type_slots_ICommand[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommand) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommand) },
        { }};

    static PyType_Spec type_spec_ICommand = {
        "winrt._winrt_windows_ui_xaml_input._ICommand",
        sizeof(py::wrapper::Windows::UI::Xaml::Input::ICommand),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICommand};

    struct ImplementsICommand : py::ImplementsInterfaceT<ImplementsICommand, winrt::Windows::UI::Xaml::Input::ICommand>
    {
        ImplementsICommand() = delete;
        ImplementsICommand(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICommand, winrt::Windows::UI::Xaml::Input::ICommand>(py_obj, runtime_class)
        {
        }

        auto CanExecute(winrt::Windows::Foundation::IInspectable const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "can_execute")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Execute(winrt::Windows::Foundation::IInspectable const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "execute")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanExecuteChanged(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_can_execute_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanExecuteChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_can_execute_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Input::ICommand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Input::ICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICommand(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Input::ICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICommand(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICommand>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICommand[] = {
        { "_assign_array_", _assign_array_ICommand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommand), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICommand), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICommand), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICommand[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICommand) },
        { }};

    static PyType_Spec type_spec_ImplementsICommand = {
        "winrt._winrt_windows_ui_xaml_input.ICommand",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICommand};

    // ----- Windows.UI.Xaml.Input Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Input");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_input",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Input

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_input(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Input;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml")};
    if (!windows_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_RoutedEventArgs_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "RoutedEventArgs")};
    if (!windows_ui_xaml_RoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_DependencyObject_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "DependencyObject")};
    if (!windows_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_input_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_input")};
    if (!windows_ui_xaml_input_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_input_XamlUICommand_type{PyObject_GetAttrString(windows_ui_xaml_input_module.get(), "XamlUICommand")};
    if (!windows_ui_xaml_input_XamlUICommand_type)
    {
        return nullptr;
    }

    py::pytype_handle AccessKeyDisplayDismissedEventArgs_type{py::register_python_type(module.get(), &type_spec_AccessKeyDisplayDismissedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AccessKeyDisplayDismissedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AccessKeyDisplayRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_AccessKeyDisplayRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AccessKeyDisplayRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AccessKeyInvokedEventArgs_type{py::register_python_type(module.get(), &type_spec_AccessKeyInvokedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!AccessKeyInvokedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle AccessKeyManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AccessKeyManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AccessKeyManager_Static{PyType_FromSpecWithBases(&type_spec_AccessKeyManager_Static, AccessKeyManager_Static_bases.get())};
    if (!type_AccessKeyManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle AccessKeyManager_type{py::register_python_type(module.get(), &type_spec_AccessKeyManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AccessKeyManager_Static.get()))};
    if (!AccessKeyManager_type)
    {
        return nullptr;
    }

    py::pytype_handle CanExecuteRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_CanExecuteRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CanExecuteRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle CharacterReceivedRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!CharacterReceivedRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle CharacterReceivedRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_CharacterReceivedRoutedEventArgs, CharacterReceivedRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!CharacterReceivedRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ContextRequestedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!ContextRequestedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle ContextRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContextRequestedEventArgs, ContextRequestedEventArgs_bases.get(), inspectable_meta_type)};
    if (!ContextRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle DoubleTappedRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!DoubleTappedRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle DoubleTappedRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_DoubleTappedRoutedEventArgs, DoubleTappedRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!DoubleTappedRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ExecuteRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_ExecuteRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ExecuteRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FindNextElementOptions_type{py::register_python_type(module.get(), &type_spec_FindNextElementOptions, object_bases.get(), inspectable_meta_type)};
    if (!FindNextElementOptions_type)
    {
        return nullptr;
    }

    py::pyobj_handle FocusManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!FocusManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FocusManager_Static{PyType_FromSpecWithBases(&type_spec_FocusManager_Static, FocusManager_Static_bases.get())};
    if (!type_FocusManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle FocusManager_type{py::register_python_type(module.get(), &type_spec_FocusManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FocusManager_Static.get()))};
    if (!FocusManager_type)
    {
        return nullptr;
    }

    py::pytype_handle FocusManagerGotFocusEventArgs_type{py::register_python_type(module.get(), &type_spec_FocusManagerGotFocusEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FocusManagerGotFocusEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FocusManagerLostFocusEventArgs_type{py::register_python_type(module.get(), &type_spec_FocusManagerLostFocusEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FocusManagerLostFocusEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FocusMovementResult_type{py::register_python_type(module.get(), &type_spec_FocusMovementResult, object_bases.get(), inspectable_meta_type)};
    if (!FocusMovementResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle GettingFocusEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!GettingFocusEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle GettingFocusEventArgs_type{py::register_python_type(module.get(), &type_spec_GettingFocusEventArgs, GettingFocusEventArgs_bases.get(), inspectable_meta_type)};
    if (!GettingFocusEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle HoldingRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!HoldingRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle HoldingRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_HoldingRoutedEventArgs, HoldingRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!HoldingRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle InertiaExpansionBehavior_type{py::register_python_type(module.get(), &type_spec_InertiaExpansionBehavior, object_bases.get(), inspectable_meta_type)};
    if (!InertiaExpansionBehavior_type)
    {
        return nullptr;
    }

    py::pytype_handle InertiaRotationBehavior_type{py::register_python_type(module.get(), &type_spec_InertiaRotationBehavior, object_bases.get(), inspectable_meta_type)};
    if (!InertiaRotationBehavior_type)
    {
        return nullptr;
    }

    py::pytype_handle InertiaTranslationBehavior_type{py::register_python_type(module.get(), &type_spec_InertiaTranslationBehavior, object_bases.get(), inspectable_meta_type)};
    if (!InertiaTranslationBehavior_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputScope_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!InputScope_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputScope_type{py::register_python_type(module.get(), &type_spec_InputScope, InputScope_bases.get(), inspectable_meta_type)};
    if (!InputScope_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputScopeName_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!InputScopeName_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputScopeName_type{py::register_python_type(module.get(), &type_spec_InputScopeName, InputScopeName_bases.get(), inspectable_meta_type)};
    if (!InputScopeName_type)
    {
        return nullptr;
    }

    py::pyobj_handle KeyRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!KeyRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle KeyRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_KeyRoutedEventArgs, KeyRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!KeyRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle KeyboardAccelerator_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!KeyboardAccelerator_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyboardAccelerator_Static{PyType_FromSpecWithBases(&type_spec_KeyboardAccelerator_Static, KeyboardAccelerator_Static_bases.get())};
    if (!type_KeyboardAccelerator_Static)
    {
        return nullptr;
    }

    py::pyobj_handle KeyboardAccelerator_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!KeyboardAccelerator_bases)
    {
        return nullptr;
    }

    py::pytype_handle KeyboardAccelerator_type{py::register_python_type(module.get(), &type_spec_KeyboardAccelerator, KeyboardAccelerator_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyboardAccelerator_Static.get()))};
    if (!KeyboardAccelerator_type)
    {
        return nullptr;
    }

    py::pytype_handle KeyboardAcceleratorInvokedEventArgs_type{py::register_python_type(module.get(), &type_spec_KeyboardAcceleratorInvokedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!KeyboardAcceleratorInvokedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle LosingFocusEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!LosingFocusEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle LosingFocusEventArgs_type{py::register_python_type(module.get(), &type_spec_LosingFocusEventArgs, LosingFocusEventArgs_bases.get(), inspectable_meta_type)};
    if (!LosingFocusEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ManipulationCompletedRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!ManipulationCompletedRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationCompletedRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationCompletedRoutedEventArgs, ManipulationCompletedRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!ManipulationCompletedRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ManipulationDeltaRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!ManipulationDeltaRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationDeltaRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationDeltaRoutedEventArgs, ManipulationDeltaRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!ManipulationDeltaRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ManipulationInertiaStartingRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!ManipulationInertiaStartingRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationInertiaStartingRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationInertiaStartingRoutedEventArgs, ManipulationInertiaStartingRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!ManipulationInertiaStartingRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationPivot_type{py::register_python_type(module.get(), &type_spec_ManipulationPivot, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationPivot_type)
    {
        return nullptr;
    }

    py::pyobj_handle ManipulationStartedRoutedEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_RoutedEventArgs_type.get())))};
    if (!ManipulationStartedRoutedEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ManipulationStartedRoutedEventArgs_Static{PyType_FromSpecWithBases(&type_spec_ManipulationStartedRoutedEventArgs_Static, ManipulationStartedRoutedEventArgs_Static_bases.get())};
    if (!type_ManipulationStartedRoutedEventArgs_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ManipulationStartedRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!ManipulationStartedRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationStartedRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationStartedRoutedEventArgs, ManipulationStartedRoutedEventArgs_bases.get(), reinterpret_cast<PyTypeObject*>(type_ManipulationStartedRoutedEventArgs_Static.get()))};
    if (!ManipulationStartedRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ManipulationStartingRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!ManipulationStartingRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationStartingRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationStartingRoutedEventArgs, ManipulationStartingRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!ManipulationStartingRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle NoFocusCandidateFoundEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!NoFocusCandidateFoundEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle NoFocusCandidateFoundEventArgs_type{py::register_python_type(module.get(), &type_spec_NoFocusCandidateFoundEventArgs, NoFocusCandidateFoundEventArgs_bases.get(), inspectable_meta_type)};
    if (!NoFocusCandidateFoundEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle Pointer_type{py::register_python_type(module.get(), &type_spec_Pointer, object_bases.get(), inspectable_meta_type)};
    if (!Pointer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PointerRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!PointerRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle PointerRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_PointerRoutedEventArgs, PointerRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!PointerRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ProcessKeyboardAcceleratorEventArgs_type{py::register_python_type(module.get(), &type_spec_ProcessKeyboardAcceleratorEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ProcessKeyboardAcceleratorEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RightTappedRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!RightTappedRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle RightTappedRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_RightTappedRoutedEventArgs, RightTappedRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!RightTappedRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlUICommand_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!XamlUICommand_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlUICommand_Static{PyType_FromSpecWithBases(&type_spec_XamlUICommand_Static, XamlUICommand_Static_bases.get())};
    if (!type_XamlUICommand_Static)
    {
        return nullptr;
    }

    py::pyobj_handle XamlUICommand_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!XamlUICommand_bases)
    {
        return nullptr;
    }

    py::pytype_handle XamlUICommand_type{py::register_python_type(module.get(), &type_spec_XamlUICommand, XamlUICommand_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlUICommand_Static.get()))};
    if (!XamlUICommand_type)
    {
        return nullptr;
    }

    py::pyobj_handle StandardUICommand_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(XamlUICommand_type.get())))};
    if (!StandardUICommand_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StandardUICommand_Static{PyType_FromSpecWithBases(&type_spec_StandardUICommand_Static, StandardUICommand_Static_bases.get())};
    if (!type_StandardUICommand_Static)
    {
        return nullptr;
    }

    py::pyobj_handle StandardUICommand_bases{PyTuple_Pack(1, XamlUICommand_type.get())};
    if (!StandardUICommand_bases)
    {
        return nullptr;
    }

    py::pytype_handle StandardUICommand_type{py::register_python_type(module.get(), &type_spec_StandardUICommand, StandardUICommand_bases.get(), reinterpret_cast<PyTypeObject*>(type_StandardUICommand_Static.get()))};
    if (!StandardUICommand_type)
    {
        return nullptr;
    }

    py::pyobj_handle TappedRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!TappedRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle TappedRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_TappedRoutedEventArgs, TappedRoutedEventArgs_bases.get(), inspectable_meta_type)};
    if (!TappedRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ICommand_type{py::register_python_type(module.get(), &type_spec_ICommand, object_bases.get(), nullptr)};
    if (!ICommand_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICommand_type{py::register_python_type(module.get(), &type_spec_ImplementsICommand, nullptr, inspectable_meta_type)};
    if (!ImplementsICommand_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICommand_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
