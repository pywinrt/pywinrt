// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Devices.Input.h"

namespace py::cpp::Windows::Devices::Input
{
    // ----- KeyboardCapabilities class --------------------

    static PyObject* _new_KeyboardCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::KeyboardCapabilities instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_KeyboardCapabilities(py::wrapper::Windows::Devices::Input::KeyboardCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyboardCapabilities_get_KeyboardPresent(py::wrapper::Windows::Devices::Input::KeyboardCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.KeyboardCapabilities", L"KeyboardPresent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyboardPresent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyboardCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::KeyboardCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyboardCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::KeyboardCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardCapabilities[] = {
        { "_assign_array_", _assign_array_KeyboardCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyboardCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_KeyboardCapabilities[] = {
        { "keyboard_present", reinterpret_cast<getter>(KeyboardCapabilities_get_KeyboardPresent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_KeyboardCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyboardCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyboardCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyboardCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyboardCapabilities) },
        { }};

    static PyType_Spec type_spec_KeyboardCapabilities = {
        "winrt._winrt_windows_devices_input.KeyboardCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::KeyboardCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardCapabilities};

    // ----- MouseCapabilities class --------------------

    static PyObject* _new_MouseCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::MouseCapabilities instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MouseCapabilities(py::wrapper::Windows::Devices::Input::MouseCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseCapabilities_get_HorizontalWheelPresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"HorizontalWheelPresent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalWheelPresent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_MousePresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"MousePresent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MousePresent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_NumberOfButtons(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"NumberOfButtons");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NumberOfButtons();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_SwapButtons(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"SwapButtons");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SwapButtons();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_VerticalWheelPresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"VerticalWheelPresent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalWheelPresent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseCapabilities[] = {
        { "_assign_array_", _assign_array_MouseCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MouseCapabilities[] = {
        { "horizontal_wheel_present", reinterpret_cast<getter>(MouseCapabilities_get_HorizontalWheelPresent), nullptr, nullptr, nullptr },
        { "mouse_present", reinterpret_cast<getter>(MouseCapabilities_get_MousePresent), nullptr, nullptr, nullptr },
        { "number_of_buttons", reinterpret_cast<getter>(MouseCapabilities_get_NumberOfButtons), nullptr, nullptr, nullptr },
        { "swap_buttons", reinterpret_cast<getter>(MouseCapabilities_get_SwapButtons), nullptr, nullptr, nullptr },
        { "vertical_wheel_present", reinterpret_cast<getter>(MouseCapabilities_get_VerticalWheelPresent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MouseCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseCapabilities) },
        { }};

    static PyType_Spec type_spec_MouseCapabilities = {
        "winrt._winrt_windows_devices_input.MouseCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::MouseCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseCapabilities};

    // ----- MouseDevice class --------------------

    static PyObject* _new_MouseDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::MouseDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::MouseDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_MouseDevice(py::wrapper::Windows::Devices::Input::MouseDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseDevice_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.MouseDevice", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Input::MouseDevice::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MouseDevice_add_MouseMoved(py::wrapper::Windows::Devices::Input::MouseDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.MouseDevice", L"MouseMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::MouseDevice, winrt::Windows::Devices::Input::MouseEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MouseMoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseDevice_remove_MouseMoved(py::wrapper::Windows::Devices::Input::MouseDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.MouseDevice", L"MouseMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MouseMoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseDevice[] = {
        { "add_mouse_moved", reinterpret_cast<PyCFunction>(MouseDevice_add_MouseMoved), METH_O, nullptr },
        { "remove_mouse_moved", reinterpret_cast<PyCFunction>(MouseDevice_remove_MouseMoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_MouseDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseDevice), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MouseDevice[] = {
        { }};

    static PyType_Slot _type_slots_MouseDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseDevice) },
        { }};

    static PyType_Spec type_spec_MouseDevice = {
        "winrt._winrt_windows_devices_input.MouseDevice",
        sizeof(py::wrapper::Windows::Devices::Input::MouseDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseDevice};

    static PyGetSetDef getset_MouseDevice_Static[] = {
        { }};

    static PyMethodDef methods_MouseDevice_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(MouseDevice_GetForCurrentView), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_MouseDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MouseDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MouseDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_MouseDevice_Static = {
        "winrt._winrt_windows_devices_input.MouseDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MouseDevice_Static};

    // ----- MouseEventArgs class --------------------

    static PyObject* _new_MouseEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::MouseEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::MouseEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MouseEventArgs(py::wrapper::Windows::Devices::Input::MouseEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseEventArgs_get_MouseDelta(py::wrapper::Windows::Devices::Input::MouseEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseEventArgs", L"MouseDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MouseDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseEventArgs[] = {
        { "_assign_array_", _assign_array_MouseEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MouseEventArgs[] = {
        { "mouse_delta", reinterpret_cast<getter>(MouseEventArgs_get_MouseDelta), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MouseEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseEventArgs) },
        { }};

    static PyType_Spec type_spec_MouseEventArgs = {
        "winrt._winrt_windows_devices_input.MouseEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::MouseEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseEventArgs};

    // ----- PenButtonListener class --------------------

    static PyObject* _new_PenButtonListener(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenButtonListener>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenButtonListener>::type_name);
        return nullptr;
    }

    static void _dealloc_PenButtonListener(py::wrapper::Windows::Devices::Input::PenButtonListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenButtonListener_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenButtonListener", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Input::PenButtonListener::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_IsSupported(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupportedChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSupportedChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupportedChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSupportedChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonClicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TailButtonClicked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonClicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TailButtonClicked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonDoubleClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonDoubleClicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TailButtonDoubleClicked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonDoubleClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonDoubleClicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TailButtonDoubleClicked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonLongPressed(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonLongPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TailButtonLongPressed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonLongPressed(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonLongPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TailButtonLongPressed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenButtonListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenButtonListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenButtonListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenButtonListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenButtonListener[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(PenButtonListener_IsSupported), METH_VARARGS, nullptr },
        { "add_is_supported_changed", reinterpret_cast<PyCFunction>(PenButtonListener_add_IsSupportedChanged), METH_O, nullptr },
        { "remove_is_supported_changed", reinterpret_cast<PyCFunction>(PenButtonListener_remove_IsSupportedChanged), METH_O, nullptr },
        { "add_tail_button_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonClicked), METH_O, nullptr },
        { "remove_tail_button_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonClicked), METH_O, nullptr },
        { "add_tail_button_double_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonDoubleClicked), METH_O, nullptr },
        { "remove_tail_button_double_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonDoubleClicked), METH_O, nullptr },
        { "add_tail_button_long_pressed", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonLongPressed), METH_O, nullptr },
        { "remove_tail_button_long_pressed", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonLongPressed), METH_O, nullptr },
        { "_assign_array_", _assign_array_PenButtonListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenButtonListener), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PenButtonListener[] = {
        { }};

    static PyType_Slot _type_slots_PenButtonListener[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenButtonListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenButtonListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenButtonListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenButtonListener) },
        { }};

    static PyType_Spec type_spec_PenButtonListener = {
        "winrt._winrt_windows_devices_input.PenButtonListener",
        sizeof(py::wrapper::Windows::Devices::Input::PenButtonListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenButtonListener};

    static PyGetSetDef getset_PenButtonListener_Static[] = {
        { }};

    static PyMethodDef methods_PenButtonListener_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PenButtonListener_GetDefault), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PenButtonListener_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PenButtonListener_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PenButtonListener_Static) },
        { }
    };

    static PyType_Spec type_spec_PenButtonListener_Static = {
        "winrt._winrt_windows_devices_input.PenButtonListener_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PenButtonListener_Static};

    // ----- PenDevice class --------------------

    static PyObject* _new_PenDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_PenDevice(py::wrapper::Windows::Devices::Input::PenDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenDevice_GetFromPointerId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDevice", L"GetFromPointerId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Input::PenDevice::GetFromPointerId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDevice_get_PenId(py::wrapper::Windows::Devices::Input::PenDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PenDevice", L"PenId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PenId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDevice_get_SimpleHapticsController(py::wrapper::Windows::Devices::Input::PenDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PenDevice", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDevice[] = {
        { "_assign_array_", _assign_array_PenDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDevice), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PenDevice[] = {
        { "pen_id", reinterpret_cast<getter>(PenDevice_get_PenId), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(PenDevice_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PenDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDevice) },
        { }};

    static PyType_Spec type_spec_PenDevice = {
        "winrt._winrt_windows_devices_input.PenDevice",
        sizeof(py::wrapper::Windows::Devices::Input::PenDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDevice};

    static PyGetSetDef getset_PenDevice_Static[] = {
        { }};

    static PyMethodDef methods_PenDevice_Static[] = {
        { "get_from_pointer_id", reinterpret_cast<PyCFunction>(PenDevice_GetFromPointerId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PenDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PenDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PenDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_PenDevice_Static = {
        "winrt._winrt_windows_devices_input.PenDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PenDevice_Static};

    // ----- PenDockListener class --------------------

    static PyObject* _new_PenDockListener(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenDockListener>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenDockListener>::type_name);
        return nullptr;
    }

    static void _dealloc_PenDockListener(py::wrapper::Windows::Devices::Input::PenDockListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenDockListener_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDockListener", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Input::PenDockListener::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDockListener_IsSupported(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_Docked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Docked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Devices::Input::PenDockedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Docked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_Docked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Docked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Docked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupportedChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSupportedChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupportedChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSupportedChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_Undocked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Undocked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Devices::Input::PenUndockedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Undocked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_Undocked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Undocked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Undocked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenDockListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDockListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDockListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDockListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDockListener[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(PenDockListener_IsSupported), METH_VARARGS, nullptr },
        { "add_docked", reinterpret_cast<PyCFunction>(PenDockListener_add_Docked), METH_O, nullptr },
        { "remove_docked", reinterpret_cast<PyCFunction>(PenDockListener_remove_Docked), METH_O, nullptr },
        { "add_is_supported_changed", reinterpret_cast<PyCFunction>(PenDockListener_add_IsSupportedChanged), METH_O, nullptr },
        { "remove_is_supported_changed", reinterpret_cast<PyCFunction>(PenDockListener_remove_IsSupportedChanged), METH_O, nullptr },
        { "add_undocked", reinterpret_cast<PyCFunction>(PenDockListener_add_Undocked), METH_O, nullptr },
        { "remove_undocked", reinterpret_cast<PyCFunction>(PenDockListener_remove_Undocked), METH_O, nullptr },
        { "_assign_array_", _assign_array_PenDockListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDockListener), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PenDockListener[] = {
        { }};

    static PyType_Slot _type_slots_PenDockListener[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDockListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDockListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDockListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDockListener) },
        { }};

    static PyType_Spec type_spec_PenDockListener = {
        "winrt._winrt_windows_devices_input.PenDockListener",
        sizeof(py::wrapper::Windows::Devices::Input::PenDockListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDockListener};

    static PyGetSetDef getset_PenDockListener_Static[] = {
        { }};

    static PyMethodDef methods_PenDockListener_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PenDockListener_GetDefault), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PenDockListener_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PenDockListener_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PenDockListener_Static) },
        { }
    };

    static PyType_Spec type_spec_PenDockListener_Static = {
        "winrt._winrt_windows_devices_input.PenDockListener_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PenDockListener_Static};

    // ----- PenDockedEventArgs class --------------------

    static PyObject* _new_PenDockedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenDockedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenDockedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenDockedEventArgs(py::wrapper::Windows::Devices::Input::PenDockedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenDockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDockedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDockedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDockedEventArgs[] = {
        { "_assign_array_", _assign_array_PenDockedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDockedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PenDockedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_PenDockedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDockedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDockedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDockedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDockedEventArgs) },
        { }};

    static PyType_Spec type_spec_PenDockedEventArgs = {
        "winrt._winrt_windows_devices_input.PenDockedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenDockedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDockedEventArgs};

    // ----- PenTailButtonClickedEventArgs class --------------------

    static PyObject* _new_PenTailButtonClickedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenTailButtonClickedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonClickedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PenTailButtonClickedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_PenTailButtonClickedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonClickedEventArgs) },
        { }};

    static PyType_Spec type_spec_PenTailButtonClickedEventArgs = {
        "winrt._winrt_windows_devices_input.PenTailButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonClickedEventArgs};

    // ----- PenTailButtonDoubleClickedEventArgs class --------------------

    static PyObject* _new_PenTailButtonDoubleClickedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenTailButtonDoubleClickedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonDoubleClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonDoubleClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonDoubleClickedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonDoubleClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonDoubleClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PenTailButtonDoubleClickedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_PenTailButtonDoubleClickedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonDoubleClickedEventArgs) },
        { }};

    static PyType_Spec type_spec_PenTailButtonDoubleClickedEventArgs = {
        "winrt._winrt_windows_devices_input.PenTailButtonDoubleClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonDoubleClickedEventArgs};

    // ----- PenTailButtonLongPressedEventArgs class --------------------

    static PyObject* _new_PenTailButtonLongPressedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenTailButtonLongPressedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonLongPressedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonLongPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonLongPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonLongPressedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonLongPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonLongPressedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PenTailButtonLongPressedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_PenTailButtonLongPressedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonLongPressedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonLongPressedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonLongPressedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonLongPressedEventArgs) },
        { }};

    static PyType_Spec type_spec_PenTailButtonLongPressedEventArgs = {
        "winrt._winrt_windows_devices_input.PenTailButtonLongPressedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonLongPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonLongPressedEventArgs};

    // ----- PenUndockedEventArgs class --------------------

    static PyObject* _new_PenUndockedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenUndockedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenUndockedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenUndockedEventArgs(py::wrapper::Windows::Devices::Input::PenUndockedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenUndockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenUndockedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenUndockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenUndockedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenUndockedEventArgs[] = {
        { "_assign_array_", _assign_array_PenUndockedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenUndockedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PenUndockedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_PenUndockedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenUndockedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenUndockedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenUndockedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenUndockedEventArgs) },
        { }};

    static PyType_Spec type_spec_PenUndockedEventArgs = {
        "winrt._winrt_windows_devices_input.PenUndockedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenUndockedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenUndockedEventArgs};

    // ----- PointerDevice class --------------------

    static PyObject* _new_PointerDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PointerDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PointerDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerDevice(py::wrapper::Windows::Devices::Input::PointerDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerDevice_GetPointerDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PointerDevice", L"GetPointerDevice", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Input::PointerDevice::GetPointerDevice(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerDevice_GetPointerDevices(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PointerDevice", L"GetPointerDevices", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Input::PointerDevice::GetPointerDevices();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_IsIntegrated(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"IsIntegrated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsIntegrated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_MaxContacts(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"MaxContacts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxContacts();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_PhysicalDeviceRect(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"PhysicalDeviceRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhysicalDeviceRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_PointerDeviceType(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_ScreenRect(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"ScreenRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScreenRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_SupportedUsages(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"SupportedUsages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedUsages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_MaxPointersWithZDistance(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"MaxPointersWithZDistance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxPointersWithZDistance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PointerDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PointerDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerDevice[] = {
        { "_assign_array_", _assign_array_PointerDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerDevice), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PointerDevice[] = {
        { "is_integrated", reinterpret_cast<getter>(PointerDevice_get_IsIntegrated), nullptr, nullptr, nullptr },
        { "max_contacts", reinterpret_cast<getter>(PointerDevice_get_MaxContacts), nullptr, nullptr, nullptr },
        { "physical_device_rect", reinterpret_cast<getter>(PointerDevice_get_PhysicalDeviceRect), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(PointerDevice_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "screen_rect", reinterpret_cast<getter>(PointerDevice_get_ScreenRect), nullptr, nullptr, nullptr },
        { "supported_usages", reinterpret_cast<getter>(PointerDevice_get_SupportedUsages), nullptr, nullptr, nullptr },
        { "max_pointers_with_z_distance", reinterpret_cast<getter>(PointerDevice_get_MaxPointersWithZDistance), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerDevice) },
        { }};

    static PyType_Spec type_spec_PointerDevice = {
        "winrt._winrt_windows_devices_input.PointerDevice",
        sizeof(py::wrapper::Windows::Devices::Input::PointerDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDevice};

    static PyGetSetDef getset_PointerDevice_Static[] = {
        { }};

    static PyMethodDef methods_PointerDevice_Static[] = {
        { "get_pointer_device", reinterpret_cast<PyCFunction>(PointerDevice_GetPointerDevice), METH_VARARGS, nullptr },
        { "get_pointer_devices", reinterpret_cast<PyCFunction>(PointerDevice_GetPointerDevices), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PointerDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointerDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PointerDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_PointerDevice_Static = {
        "winrt._winrt_windows_devices_input.PointerDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointerDevice_Static};

    // ----- TouchCapabilities class --------------------

    static PyObject* _new_TouchCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::TouchCapabilities instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TouchCapabilities(py::wrapper::Windows::Devices::Input::TouchCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TouchCapabilities_get_Contacts(py::wrapper::Windows::Devices::Input::TouchCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.TouchCapabilities", L"Contacts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contacts();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchCapabilities_get_TouchPresent(py::wrapper::Windows::Devices::Input::TouchCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.TouchCapabilities", L"TouchPresent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TouchPresent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TouchCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::TouchCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TouchCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::TouchCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TouchCapabilities[] = {
        { "_assign_array_", _assign_array_TouchCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TouchCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TouchCapabilities[] = {
        { "contacts", reinterpret_cast<getter>(TouchCapabilities_get_Contacts), nullptr, nullptr, nullptr },
        { "touch_present", reinterpret_cast<getter>(TouchCapabilities_get_TouchPresent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TouchCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TouchCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TouchCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TouchCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TouchCapabilities) },
        { }};

    static PyType_Spec type_spec_TouchCapabilities = {
        "winrt._winrt_windows_devices_input.TouchCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::TouchCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TouchCapabilities};

    // ----- MouseDelta struct --------------------

    winrt::Windows::Devices::Input::MouseDelta MouseDelta_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Devices::Input::MouseDelta result{};

        result.X = py::convert_to<int32_t>(tuple, 0);
        result.Y = py::convert_to<int32_t>(tuple, 1);

        return result;
    }

    PyObject* _new_MouseDelta(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Input::MouseDelta>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int32_t _X{};
        int32_t _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ii", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            self->obj.X = _X;
            self->obj.Y = _Y;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MouseDelta(py::wrapper::Windows::Devices::Input::MouseDelta* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MouseDelta(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseDelta>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_MouseDelta(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int32_t _X{self->obj.X};
            int32_t _Y{self->obj.Y};

            static const char* kwlist[] = {"x", "y", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ii", const_cast<char**>(kwlist), &_X, &_Y))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.X = _X;
            copy.Y = _Y;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_MouseDelta(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.X)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.Y)};
        if (!Y)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_MouseDelta[] = {
        { "_assign_array_", _assign_array_MouseDelta, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_MouseDelta)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_MouseDelta), METH_NOARGS, nullptr },
        { }};

    static PyObject* MouseDelta_get_X(py::wrapper::Windows::Devices::Input::MouseDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseDelta_get_Y(py::wrapper::Windows::Devices::Input::MouseDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_MouseDelta[] = {
        { "x", reinterpret_cast<getter>(MouseDelta_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(MouseDelta_get_Y), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_MouseDelta(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Devices::Input::MouseDelta>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_MouseDelta(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("MouseDelta(x=%R, y=%R)", X.get(), Y.get());
    }

    static PyType_Slot _type_slots_MouseDelta[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseDelta) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseDelta) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseDelta) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseDelta) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_MouseDelta) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_MouseDelta) },
        { }};

    static PyType_Spec type_spec_MouseDelta = {
        "winrt._winrt_windows_devices_input.MouseDelta",
        sizeof(py::wrapper::Windows::Devices::Input::MouseDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseDelta};

    // ----- PointerDeviceUsage struct --------------------

    winrt::Windows::Devices::Input::PointerDeviceUsage PointerDeviceUsage_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 8)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Devices::Input::PointerDeviceUsage result{};

        result.UsagePage = py::convert_to<uint32_t>(tuple, 0);
        result.Usage = py::convert_to<uint32_t>(tuple, 1);
        result.MinLogical = py::convert_to<int32_t>(tuple, 2);
        result.MaxLogical = py::convert_to<int32_t>(tuple, 3);
        result.MinPhysical = py::convert_to<int32_t>(tuple, 4);
        result.MaxPhysical = py::convert_to<int32_t>(tuple, 5);
        result.Unit = py::convert_to<uint32_t>(tuple, 6);
        result.PhysicalMultiplier = py::convert_to<float>(tuple, 7);

        return result;
    }

    PyObject* _new_PointerDeviceUsage(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Input::PointerDeviceUsage>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint32_t _UsagePage{};
        uint32_t _Usage{};
        int32_t _MinLogical{};
        int32_t _MaxLogical{};
        int32_t _MinPhysical{};
        int32_t _MaxPhysical{};
        uint32_t _Unit{};
        float _PhysicalMultiplier{};

        static const char* kwlist[] = {"usage_page", "usage", "min_logical", "max_logical", "min_physical", "max_physical", "unit", "physical_multiplier", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|IIiiiiIf", const_cast<char**>(kwlist), &_UsagePage, &_Usage, &_MinLogical, &_MaxLogical, &_MinPhysical, &_MaxPhysical, &_Unit, &_PhysicalMultiplier))
        {
            return nullptr;
        }

        try
        {
            self->obj.UsagePage = _UsagePage;
            self->obj.Usage = _Usage;
            self->obj.MinLogical = _MinLogical;
            self->obj.MaxLogical = _MaxLogical;
            self->obj.MinPhysical = _MinPhysical;
            self->obj.MaxPhysical = _MaxPhysical;
            self->obj.Unit = _Unit;
            self->obj.PhysicalMultiplier = _PhysicalMultiplier;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PointerDeviceUsage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PointerDeviceUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PointerDeviceUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_PointerDeviceUsage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint32_t _UsagePage{self->obj.UsagePage};
            uint32_t _Usage{self->obj.Usage};
            int32_t _MinLogical{self->obj.MinLogical};
            int32_t _MaxLogical{self->obj.MaxLogical};
            int32_t _MinPhysical{self->obj.MinPhysical};
            int32_t _MaxPhysical{self->obj.MaxPhysical};
            uint32_t _Unit{self->obj.Unit};
            float _PhysicalMultiplier{self->obj.PhysicalMultiplier};

            static const char* kwlist[] = {"usage_page", "usage", "min_logical", "max_logical", "min_physical", "max_physical", "unit", "physical_multiplier", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$IIiiiiIf", const_cast<char**>(kwlist), &_UsagePage, &_Usage, &_MinLogical, &_MaxLogical, &_MinPhysical, &_MaxPhysical, &_Unit, &_PhysicalMultiplier))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.UsagePage = _UsagePage;
            copy.Usage = _Usage;
            copy.MinLogical = _MinLogical;
            copy.MaxLogical = _MaxLogical;
            copy.MinPhysical = _MinPhysical;
            copy.MaxPhysical = _MaxPhysical;
            copy.Unit = _Unit;
            copy.PhysicalMultiplier = _PhysicalMultiplier;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_PointerDeviceUsage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle UsagePage{convert(self->obj.UsagePage)};
        if (!UsagePage)
        {
            return nullptr;
        }

        py::pyobj_handle Usage{convert(self->obj.Usage)};
        if (!Usage)
        {
            return nullptr;
        }

        py::pyobj_handle MinLogical{convert(self->obj.MinLogical)};
        if (!MinLogical)
        {
            return nullptr;
        }

        py::pyobj_handle MaxLogical{convert(self->obj.MaxLogical)};
        if (!MaxLogical)
        {
            return nullptr;
        }

        py::pyobj_handle MinPhysical{convert(self->obj.MinPhysical)};
        if (!MinPhysical)
        {
            return nullptr;
        }

        py::pyobj_handle MaxPhysical{convert(self->obj.MaxPhysical)};
        if (!MaxPhysical)
        {
            return nullptr;
        }

        py::pyobj_handle Unit{convert(self->obj.Unit)};
        if (!Unit)
        {
            return nullptr;
        }

        py::pyobj_handle PhysicalMultiplier{convert(self->obj.PhysicalMultiplier)};
        if (!PhysicalMultiplier)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(8)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, UsagePage.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Usage.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, MinLogical.detach());
        PyTuple_SET_ITEM(tuple.get(), 3, MaxLogical.detach());
        PyTuple_SET_ITEM(tuple.get(), 4, MinPhysical.detach());
        PyTuple_SET_ITEM(tuple.get(), 5, MaxPhysical.detach());
        PyTuple_SET_ITEM(tuple.get(), 6, Unit.detach());
        PyTuple_SET_ITEM(tuple.get(), 7, PhysicalMultiplier.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_PointerDeviceUsage[] = {
        { "_assign_array_", _assign_array_PointerDeviceUsage, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_PointerDeviceUsage)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_PointerDeviceUsage), METH_NOARGS, nullptr },
        { }};

    static PyObject* PointerDeviceUsage_get_UsagePage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsagePage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDeviceUsage_get_Usage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Usage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDeviceUsage_get_MinLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinLogical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDeviceUsage_get_MaxLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxLogical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDeviceUsage_get_MinPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinPhysical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDeviceUsage_get_MaxPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPhysical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDeviceUsage_get_Unit(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDeviceUsage_get_PhysicalMultiplier(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalMultiplier);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_PointerDeviceUsage[] = {
        { "usage_page", reinterpret_cast<getter>(PointerDeviceUsage_get_UsagePage), nullptr, nullptr, nullptr },
        { "usage", reinterpret_cast<getter>(PointerDeviceUsage_get_Usage), nullptr, nullptr, nullptr },
        { "min_logical", reinterpret_cast<getter>(PointerDeviceUsage_get_MinLogical), nullptr, nullptr, nullptr },
        { "max_logical", reinterpret_cast<getter>(PointerDeviceUsage_get_MaxLogical), nullptr, nullptr, nullptr },
        { "min_physical", reinterpret_cast<getter>(PointerDeviceUsage_get_MinPhysical), nullptr, nullptr, nullptr },
        { "max_physical", reinterpret_cast<getter>(PointerDeviceUsage_get_MaxPhysical), nullptr, nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(PointerDeviceUsage_get_Unit), nullptr, nullptr, nullptr },
        { "physical_multiplier", reinterpret_cast<getter>(PointerDeviceUsage_get_PhysicalMultiplier), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_PointerDeviceUsage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Devices::Input::PointerDeviceUsage>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_PointerDeviceUsage(PyObject* self) noexcept
    {
        py::pyobj_handle UsagePage{PyObject_GetAttrString(self, "usage_page")};
        if (!UsagePage)
        {
            return nullptr;
        }

        py::pyobj_handle Usage{PyObject_GetAttrString(self, "usage")};
        if (!Usage)
        {
            return nullptr;
        }

        py::pyobj_handle MinLogical{PyObject_GetAttrString(self, "min_logical")};
        if (!MinLogical)
        {
            return nullptr;
        }

        py::pyobj_handle MaxLogical{PyObject_GetAttrString(self, "max_logical")};
        if (!MaxLogical)
        {
            return nullptr;
        }

        py::pyobj_handle MinPhysical{PyObject_GetAttrString(self, "min_physical")};
        if (!MinPhysical)
        {
            return nullptr;
        }

        py::pyobj_handle MaxPhysical{PyObject_GetAttrString(self, "max_physical")};
        if (!MaxPhysical)
        {
            return nullptr;
        }

        py::pyobj_handle Unit{PyObject_GetAttrString(self, "unit")};
        if (!Unit)
        {
            return nullptr;
        }

        py::pyobj_handle PhysicalMultiplier{PyObject_GetAttrString(self, "physical_multiplier")};
        if (!PhysicalMultiplier)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("PointerDeviceUsage(usage_page=%R, usage=%R, min_logical=%R, max_logical=%R, min_physical=%R, max_physical=%R, unit=%R, physical_multiplier=%R)", UsagePage.get(), Usage.get(), MinLogical.get(), MaxLogical.get(), MinPhysical.get(), MaxPhysical.get(), Unit.get(), PhysicalMultiplier.get());
    }

    static PyType_Slot _type_slots_PointerDeviceUsage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerDeviceUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerDeviceUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerDeviceUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerDeviceUsage) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_PointerDeviceUsage) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_PointerDeviceUsage) },
        { }};

    static PyType_Spec type_spec_PointerDeviceUsage = {
        "winrt._winrt_windows_devices_input.PointerDeviceUsage",
        sizeof(py::wrapper::Windows::Devices::Input::PointerDeviceUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDeviceUsage};

    // ----- Windows.Devices.Input Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.Input");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_input",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::Input

PyMODINIT_FUNC PyInit__winrt_windows_devices_input(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Input;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle KeyboardCapabilities_type{py::register_python_type(module.get(), &type_spec_KeyboardCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!KeyboardCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle MouseCapabilities_type{py::register_python_type(module.get(), &type_spec_MouseCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!MouseCapabilities_type)
    {
        return nullptr;
    }

    py::pyobj_handle MouseDevice_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!MouseDevice_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MouseDevice_Static{PyType_FromSpecWithBases(&type_spec_MouseDevice_Static, MouseDevice_Static_bases.get())};
    if (!type_MouseDevice_Static)
    {
        return nullptr;
    }

    py::pytype_handle MouseDevice_type{py::register_python_type(module.get(), &type_spec_MouseDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MouseDevice_Static.get()))};
    if (!MouseDevice_type)
    {
        return nullptr;
    }

    py::pytype_handle MouseEventArgs_type{py::register_python_type(module.get(), &type_spec_MouseEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!MouseEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle PenButtonListener_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PenButtonListener_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PenButtonListener_Static{PyType_FromSpecWithBases(&type_spec_PenButtonListener_Static, PenButtonListener_Static_bases.get())};
    if (!type_PenButtonListener_Static)
    {
        return nullptr;
    }

    py::pytype_handle PenButtonListener_type{py::register_python_type(module.get(), &type_spec_PenButtonListener, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PenButtonListener_Static.get()))};
    if (!PenButtonListener_type)
    {
        return nullptr;
    }

    py::pyobj_handle PenDevice_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PenDevice_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PenDevice_Static{PyType_FromSpecWithBases(&type_spec_PenDevice_Static, PenDevice_Static_bases.get())};
    if (!type_PenDevice_Static)
    {
        return nullptr;
    }

    py::pytype_handle PenDevice_type{py::register_python_type(module.get(), &type_spec_PenDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PenDevice_Static.get()))};
    if (!PenDevice_type)
    {
        return nullptr;
    }

    py::pyobj_handle PenDockListener_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PenDockListener_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PenDockListener_Static{PyType_FromSpecWithBases(&type_spec_PenDockListener_Static, PenDockListener_Static_bases.get())};
    if (!type_PenDockListener_Static)
    {
        return nullptr;
    }

    py::pytype_handle PenDockListener_type{py::register_python_type(module.get(), &type_spec_PenDockListener, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PenDockListener_Static.get()))};
    if (!PenDockListener_type)
    {
        return nullptr;
    }

    py::pytype_handle PenDockedEventArgs_type{py::register_python_type(module.get(), &type_spec_PenDockedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PenDockedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PenTailButtonClickedEventArgs_type{py::register_python_type(module.get(), &type_spec_PenTailButtonClickedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PenTailButtonClickedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PenTailButtonDoubleClickedEventArgs_type{py::register_python_type(module.get(), &type_spec_PenTailButtonDoubleClickedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PenTailButtonDoubleClickedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PenTailButtonLongPressedEventArgs_type{py::register_python_type(module.get(), &type_spec_PenTailButtonLongPressedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PenTailButtonLongPressedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PenUndockedEventArgs_type{py::register_python_type(module.get(), &type_spec_PenUndockedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PenUndockedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle PointerDevice_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PointerDevice_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PointerDevice_Static{PyType_FromSpecWithBases(&type_spec_PointerDevice_Static, PointerDevice_Static_bases.get())};
    if (!type_PointerDevice_Static)
    {
        return nullptr;
    }

    py::pytype_handle PointerDevice_type{py::register_python_type(module.get(), &type_spec_PointerDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerDevice_Static.get()))};
    if (!PointerDevice_type)
    {
        return nullptr;
    }

    py::pytype_handle TouchCapabilities_type{py::register_python_type(module.get(), &type_spec_TouchCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!TouchCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle MouseDelta_type{py::register_python_type(module.get(), &type_spec_MouseDelta, nullptr, nullptr)};
    if (!MouseDelta_type)
    {
        return nullptr;
    }

    py::pyobj_handle MouseDelta_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(MouseDelta_from_tuple),"winrt._winrt_windows_devices_input.MouseDelta_from_tuple", nullptr)};
    if (!MouseDelta_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "MouseDelta_from_tuple", MouseDelta_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle PointerDeviceUsage_type{py::register_python_type(module.get(), &type_spec_PointerDeviceUsage, nullptr, nullptr)};
    if (!PointerDeviceUsage_type)
    {
        return nullptr;
    }

    py::pyobj_handle PointerDeviceUsage_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(PointerDeviceUsage_from_tuple),"winrt._winrt_windows_devices_input.PointerDeviceUsage_from_tuple", nullptr)};
    if (!PointerDeviceUsage_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "PointerDeviceUsage_from_tuple", PointerDeviceUsage_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
